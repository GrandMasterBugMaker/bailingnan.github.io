<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>白凌南</title>
<meta name="description" content="DM/DL/RecSys/Python/XJTU/INTJ" />
<link rel="shortcut icon" href="https://bailingnan.github.io//favicon.ico?v=1588754695386">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://bailingnan.github.io//styles/main.css">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-157390001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-157390001-1');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://bailingnan.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://bailingnan.github.io//images/avatar.png?v=1588754695386" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">白凌南</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97">有序序列</a>
<ul>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97">不可变序列</a>
<ul>
<li><a href="#str"><code>str</code></a></li>
<li><a href="#tuple"><code>tuple</code></a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97">可变序列</a>
<ul>
<li><a href="#list"><code>list</code></a></li>
<li><a href="#deque"><code>deque</code></a></li>
<li><a href="#bisect"><code>bisect</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%A0%E5%BA%8F%E5%AF%B9%E8%B1%A1">无序对象</a>
<ul>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a>
<ul>
<li><a href="#dict"><code>dict</code></a></li>
<li><a href="#defaultdict"><code>defaultdict</code></a></li>
<li><a href="#counter"><code>Counter</code></a></li>
<li><a href="#ordereddict"><code>OrderedDict</code></a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
</ul>
</li>
<li><a href="#%E5%A0%86%E9%98%9F%E5%88%97">堆队列</a></li>
<li><a href="#%E6%89%A9%E5%B1%95">扩展</a>
<ul>
<li><a href="#nametuple"><code>nametuple</code></a></li>
<li><a href="#chainmap"><code>ChainMap</code></a></li>
<li><a href="#queue"><code>queue</code></a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://bailingnan.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">LeetCode常用数据结构Python实现</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-23 / 9 min read
        </div>
        
        <div class="post-content yue">
          <!-- TOC -->
<ul>
<li><a href="#%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97">有序序列</a>
<ul>
<li><a href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97">不可变序列</a>
<ul>
<li><a href="#str"><code>str</code></a></li>
<li><a href="#tuple"><code>tuple</code></a></li>
</ul>
</li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%BA%8F%E5%88%97">可变序列</a>
<ul>
<li><a href="#list"><code>list</code></a></li>
<li><a href="#deque"><code>deque</code></a></li>
<li><a href="#bisect"><code>bisect</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%A0%E5%BA%8F%E5%AF%B9%E8%B1%A1">无序对象</a>
<ul>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a>
<ul>
<li><a href="#dict"><code>dict</code></a></li>
<li><a href="#defaultdict"><code>defaultdict</code></a></li>
<li><a href="#counter"><code>Counter</code></a></li>
<li><a href="#ordereddict"><code>OrderedDict</code></a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
</ul>
</li>
<li><a href="#%E5%A0%86%E9%98%9F%E5%88%97">堆队列</a></li>
<li><a href="#%E6%89%A9%E5%B1%95">扩展</a>
<ul>
<li><a href="#nametuple"><code>nametuple</code></a></li>
<li><a href="#chainmap"><code>ChainMap</code></a></li>
<li><a href="#queue"><code>queue</code></a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="有序序列">有序序列</h1>
<h2 id="不可变序列">不可变序列</h2>
<h3 id="str"><code>str</code></h3>
<p>内置的数据结构, 可以直接使用, 不需要导入</p>
<p>常用函数：</p>
<pre><code class="language-python">format(*args, **kwargs)  # 用法丰富多样, 算法中可用于字符串形式的进制转换
split(sep=None, maxsplit=-1)  # 以sep来分割字符串
strip([chars])  # 去除首末两端的字符, 默认是 \r,\n,&quot; &quot;
join(iterable)  # 将iterable内的元素拼接成字符串,如','.join(['leet', 'code']) #=&quot;leet,code&quot;
replace(old, new[, count])  # 字符串替换, old to new
count(sub[, start[, end]])  # 统计子字符串sub的个数
startswith(prefix[, start[, end]])  # 以prefix开始的字符串
endswith(suffix[, start[, end]])  # 以suffix结束的字符串
</code></pre>
<p>常用的功能:</p>
<ul>
<li>拼接(加), <code>s1 + s2</code></li>
<li>切片, <code>s[start: end: space]</code></li>
<li>重复(乘), <code>s * 10</code></li>
</ul>
<h3 id="tuple"><code>tuple</code></h3>
<p>元组, 也叫静态列表. 内置的数据结构, 可以直接使用, 无须导入.</p>
<ul>
<li>元组常用于多变量赋值和多值返回, 只是一般在使用的时候没有加上小括号</li>
<li>需要注意的是, 当<code>tuple</code>里只有一个元素时, 需要在该元素之后加上,, 如 <code>t=(1,)</code>, 否则它就不是<code>tuple</code>, 而是该元素的类型.</li>
<li>同样支持拼接, 切片, 重复等操作</li>
<li>提供的函数仅有<code>index</code>和<code>count</code></li>
</ul>
<h2 id="可变序列">可变序列</h2>
<h3 id="list"><code>list</code></h3>
<p>经常使用的数据结构, 可以实现简单的队列, 栈等.</p>
<p>常用功能: 拼接, 重复, 切片</p>
<p>强大的切片功能, 可用于取值, 替换, 删除等</p>
<ul>
<li><code>lst[i:j] = t</code>,:其中<code>t</code>是可迭代序列</li>
<li><code>del lst[i:j]</code>, 相当于 <code>lst[i:j] = []</code></li>
</ul>
<p>常用函数：</p>
<pre><code class="language-python">lst.sort(*, key=None, reverse=False)#对 list 进行排序，在 list 长度小的时候使用插入排序，在长度大的时候使用快排，所以其时间复杂度可以视为 O(nlgn)。
lst.append(val)  # 在 list 的结尾追加一个元素,也可以 lst = lst + [val]
lst.clear()  # 清空列表
lst.count(val)  # val个数
lst.extend(t)  # or s += t  # += 其实调用的是 __iadd__ 方法
lst.pop(val=lst[-1])  # (默认)从末端移除一个值
lst.remove(val)  # 移除 val
lst.reverse()  # 反转
lst.insert(i, val)  # 在 i 处插入 val
</code></pre>
<h3 id="deque"><code>deque</code></h3>
<p>一种链表的双向队列数据结构, 从该队列的头部或尾部插入或者删除一个元素, 时间复杂度是<code>O(1)</code>. 可以用来表示先进先出的队列 (<code>FIFO</code>).</p>
<p>常用函数</p>
<pre><code class="language-python">from collections import deque
queue = deque([iterable[, maxlen]])
queue.append(val)  # 往右边添加一个元素
queue.appendleft(val)  # 往左边添加一个元素
queue.clear()  # 清空队列
queue.count(val)  # 返回指定元素的出现次数
queue.extend(iterable)  # 从队列右边扩展一个序列的元素
queue.extendleft(iterable)  #  从队列左边扩展一个列表的元素
queue.insert(val[, start[, stop]])  # 在指定位置插入元素
queue.pop()  # 获取最右边一个元素，并在队列中删除
queue.popleft()  # 获取最左边一个元素，并在队列中删除
queue.reverse()  # 队列反转
queue.remove(val)  # 删除指定元素
queue.rotate(n=1)  # 把右边元素放到左边
</code></pre>
<h3 id="bisect"><code>bisect</code></h3>
<p>一种高效的折半搜索算法的类. 在<code>list</code>上用<code>index</code>来查找某个元素, 所消耗的时间会与列表长度呈线性比例. 而<code>bisect</code>提供的<code>bisect_left</code>等函数, 使用了二分折半搜索算法, 能够在排序之后的元素中查找某个值, 由<code>bisect_left</code>函数所返回的索引, 表示待搜索的值在序列中的插入点.</p>
<pre><code class="language-python">import bisect
lst = list(range(10**6))
index1 = lst.index(654321)
index2 = bisect.bisect_left(lst, 987654)
</code></pre>
<p>二分查找法的复杂度是对数级别的. 也就是说, 用<code>bisect</code>搜索100,000个元素的列表, 与用<code>index</code>搜索14个元素的列表用的时间差不多.</p>
<p>常用函数：</p>
<p>和折半查找一样, 使用这个模块的函数前先确保操作的列表是已排序的。</p>
<pre><code class="language-python">import bisect
bisect.bisect_left(a, x, lo=0, hi=len(a))  # 返回将x插入a后的位置index(如果a中存在与x等值的元素，则插入到左侧), 默认从 0到-1
bisect.bisect_right(a, x, lo=0, hi=len(a))  # 返回将x插入a后的位置index(如果a中存在与x等值的元素，则插入到右侧)
bisect.bisect(a, x, lo=0, hi=len(a))  # 与 bisect_right 相同
bisect.insort_left(a, x, lo=0, hi=len(a))  # 将x插入a(如果a中存在与x等值的元素，则插入到左侧)
bisect.insort_right(a, x, lo=0, hi=len(a))  # 将x插入a(如果a中存在与x等值的元素，则插入到右侧)
bisect.insort(a, x, lo=0, hi=len(a))  # 与insort_left 相同, 将变量x插入到a中,并保持a升序
</code></pre>
<h1 id="无序对象">无序对象</h1>
<h2 id="字典">字典</h2>
<p>一般的字典是: 无序的(也有有序的字典<code>OrderedDict</code>), 键不可变, 值可变.</p>
<h3 id="dict"><code>dict</code></h3>
<p>字典, 或映射, 以键值对形式存储. 想必不用过多介绍了吧.</p>
<p>常用函数</p>
<pre><code class="language-python">pop(key[, default])  # 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))
setdefault(key[, default])  # 设置默认值
update([other])  # 批量添加
get(key[, default])  # 通过键获取值(若没有该键可设置默认值, 预防报错)
pop(key[, default])  # 通过键删除值(若没有该键可设置默认值, 预防报错)
clear()  # 清空字典
keys()  # 将字典的键组成新的可迭代对象
values()  # 将字典中的值组成新的可迭代对象
items()  # 将字典的键值对凑成一个个元组, 组成新的可迭代对象
</code></pre>
<h3 id="defaultdict"><code>defaultdict</code></h3>
<p>在<code>dict</code>中取值时, 如果<code>key</code>不存在, 那么会报<code>KeyError</code>这样的错, 这时候可以使用<code>get</code>方法来解决, 或者捕获异常. 但是这样会感觉很麻烦, 易错, 而且没有体现出<code>python</code>的简洁风格.</p>
<p>这时候就该<code>defaultdict</code>登场了, 当试着去取不存在的值时, 就不会报错.</p>
<pre><code class="language-python">from collections import defaultdict
d = defaultdict(lambda : value)
#当取一个不存在的 key 时, 会返回 value.
</code></pre>
<p>继承于<code>dict</code>, 所以它拥有<code>dict</code>一样的方法.</p>
<h3 id="counter"><code>Counter</code></h3>
<p>用于统计值的个数</p>
<p><code>Counter</code>类继承<code>dict</code>, 所以它能使用<code>dict</code>里的方法.</p>
<p><code>Counter</code> 特有方法:</p>
<pre><code class="language-python">from collections import Counter
cnt = Counter([iterable-or-mapping])
cnt.elements()  # 所有元素
cnt.most_common([n])  # 指定一个参数n，列出前n个元素，不指定参数，则列出所有
cnt.subtract([iterable-or-mapping])  # 原来的元素减去新传入的元素
cnt.update([iterable-or-mapping])  # 增加元素
</code></pre>
<h3 id="ordereddict"><code>OrderedDict</code></h3>
<p>有序字典, 使得插入的顺序有序. (官方解释: Dictionary that remembers insertion order)</p>
<p>同样也继承于 <code>dict</code>, 所以可以使用 <code>dict</code> 所拥有的方法.</p>
<p>添加的方法:</p>
<pre><code class="language-python">popitem(last=True)  # (默认)从末尾去除一个元素
move_to_end(key, last=True)  # 将key移到(默认)末尾
</code></pre>
<h2 id="集合">集合</h2>
<p><code>set</code>, 主要用于去重的操作.</p>
<p>需要注意的是</p>
<ul>
<li>它的定义. 只能使用实例的方式定义, 如<code>s= set();s={1,2,4,8}</code>, 而不能这样定义<code>s={}</code>. 因为这样定义的是一个字典, 不能使用集合的方法.</li>
<li>无序特性. 有时候你会在 <code>N</code> 次输出同一个集合的时候, 发现它是有序的, 但是请你也一定不要相信集合是有序的.</li>
</ul>
<p>常用函数</p>
<pre><code class="language-python">add(elem)  # 向集合中添加数据
update(*others)  # 迭代着增加
clear()  # 清空集合
discard(elem)  # 删除集合中指定的值(不存在则不删除)
</code></pre>
<h1 id="堆队列">堆队列</h1>
<p>可实现优先级队列的数据结构. 可以解决 <code>top n</code> 问题, 如从1亿个数里面找出最大或最小的100个数</p>
<pre><code class="language-python">import heapq
nums = [randint(1, 1000) for x in range(100)]
print(heapq.nlargest(3, nums))
print(heapq.nsmallest(3, nums))
</code></pre>
<p>常用函数</p>
<pre><code class="language-python">import heapq
​
heap = []  # 建堆
heapq.heappush(heap,item)  # 往堆中插入新值
item = heapq.heappop(heap)  # 弹出最小的值
item = heap[0]  # 查看堆中最小的值, 不弹出
heapq.heapify(x)  # 以线性时间将一个列表转为堆
item = heapq.heapreplace(heap,item)  # 弹出一个最小的值, 然后将 item 插入到堆当中. 堆的整体的结构不会发生改变.
heapq.heappoppush(heap, item)  # 弹出最小的值.并且将新的值插入其中.
heapq.merge(*iterables, key=None, reverse=False)  # 将多个堆进行合并
heapq.nlargest(n, iterable, key=None)  # 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字
heapq.nsmallest(n, iterable, key=None)  # 从堆中找出最小的 n 个数, 与 nlargest 相反
</code></pre>
<h1 id="扩展">扩展</h1>
<h2 id="nametuple"><code>nametuple</code></h2>
<pre><code>from collections import namedtuple
namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)
</code></pre>
<h2 id="chainmap"><code>ChainMap</code></h2>
<p>将多个字典连接在一起</p>
<h2 id="queue"><code>queue</code></h2>
<p>队列</p>
<pre><code class="language-python">from Queue import queue
</code></pre>

        </div>

        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://bailingnan.github.io/post/m5-forecasting-accuracy/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  M5 Forecasting - Accuracy
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://bailingnan.github.io/post/joyful-pandas/">
                <h3 class="post-title">
                   Joyful-Pandas
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'f4bd8cbd743b58235644',
    clientSecret: 'df6eff6e7836378726d917c527c47e86f1c30f8b',
    repo: 'bailingnan.github.io',
    owner: 'bailingnan',
    admin: ['bailingnan'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://bailingnan.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
