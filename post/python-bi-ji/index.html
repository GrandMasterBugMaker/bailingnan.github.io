<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>白凌南</title>
<meta name="description" content="DL/RecSys/Python/Java/INTJ" />
<link rel="shortcut icon" href="https://bailingnan.github.io//favicon.ico?v=1584861888834">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.remixicon.com/releases/v1.3.1/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://bailingnan.github.io//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="白凌南 - Atom Feed" href="https://bailingnan.github.io//atom.xml">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-157390001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-157390001-1');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="remixicon-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://bailingnan.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://bailingnan.github.io//images/avatar.png?v=1584861888834" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">白凌南</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#python%E7%AC%94%E8%AE%B0"><code>Python</code>笔记</a>
<ul>
<li><a href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">编码规范</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a>
<ul>
<li><a href="#%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">可变与不可变对象</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a>
<ul>
<li><a href="#%E6%8B%86%E5%88%86%E5%85%83%E7%BB%84">拆分元组</a></li>
<li><a href="#tuple%E6%96%B9%E6%B3%95"><code>tuple</code>方法</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a></li>
</ul>
</li>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">添加和删除元素</a></li>
<li><a href="#%E4%B8%B2%E8%81%94%E5%92%8C%E7%BB%84%E5%90%88%E5%88%97%E8%A1%A8">串联和组合列表</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E5%92%8C%E7%BB%B4%E6%8A%A4%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8">二分搜索和维护已排序的列表</a></li>
<li><a href="#zip%E5%87%BD%E6%95%B0">zip函数</a></li>
<li><a href="#reversed%E5%87%BD%E6%95%B0">reversed函数</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-2">常用函数</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a>
<ul>
<li><a href="#%E5%88%A0%E9%99%A4%E5%80%BC">删除值</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E5%85%B8">更新字典</a></li>
<li><a href="#%E7%94%A8%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8">用序列创建字典</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC">默认值</a></li>
<li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E9%94%AE%E7%B1%BB%E5%9E%8B">有效的键类型</a></li>
<li><a href="#%E6%8C%89%E9%94%AE%E5%80%BC%E6%8E%92%E5%BA%8F">按键值排序</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
<li><a href="#%E5%88%97%E8%A1%A8-%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表、集合和字典推导式</a>
<ul>
<li><a href="#%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">嵌套列表推导式</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">默认参数</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">关键字参数</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">命名关键字参数</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">强制位置参数</a></li>
<li><a href="#%E5%8F%82%E6%95%B0%E7%BB%84%E5%90%88">参数组合</a></li>
<li><a href="#%E5%8C%BF%E5%90%8Dlambda%E5%87%BD%E6%95%B0">匿名(lambda)函数</a></li>
<li><a href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8">柯里化：部分参数应用</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">生成器表达式</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E7%B1%BB%E4%BD%9C%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">类作为迭代器</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>
<ul>
<li><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>
<ul>
<li><a href="#map%E5%87%BD%E6%95%B0"><code>map</code>函数</a></li>
<li><a href="#reduce%E5%87%BD%E6%95%B0"><code>reduce</code>函数</a></li>
<li><a href="#filter%E5%87%BD%E6%95%B0"><code>filter</code>函数</a></li>
<li><a href="#sorted%E5%87%BD%E6%95%B0"><code>sorted</code>函数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0">返回函数</a>
<ul>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8">装饰器</a>
<ul>
<li><a href="#property"><code>@property</code></a></li>
<li><a href="#classmethod"><code>@classmethod</code></a></li>
<li><a href="#staticmethod"><code>@staticmethod</code></a></li>
<li><a href="#dataclass"><code>@dataclass</code></a></li>
</ul>
</li>
<li><a href="#%E5%81%8F%E5%87%BD%E6%95%B0">偏函数</a></li>
</ul>
</li>
<li><a href="#itertools%E6%A8%A1%E5%9D%97"><code>itertools</code>模块</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>
<ul>
<li><a href="#%E5%88%86%E5%89%B2">分割</a></li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E5%8C%96%E6%88%96%E6%A0%BC%E5%BC%8F%E5%8C%96">模板化或格式化</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">常用操作</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>
<ul>
<li><a href="#%E5%92%8Cis"><code>==</code>和<code>is</code></a></li>
<li><a href="#any%E5%92%8Call"><code>any()</code>和<code>all()</code></a></li>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6">十进制转二进制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a>
<ul>
<li><a href="#name%E5%B1%9E%E6%80%A7"><code>name</code>属性</a>
<ul>
<li><a href="#%E5%8C%85">包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oop">OOP</a>
<ul>
<li><a href="#%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6">访问限制</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81">继承和多态</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF">获取对象信息</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8type">使用<code>type()</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8isinstance">使用<code>isinstance()</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8dir">使用dir()</a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7">实例属性和类属性</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8__slots__">使用<code>__slots__</code></a></li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">多重继承</a></li>
<li><a href="#%E5%AE%9A%E5%88%B6%E7%B1%BB">定制类</a>
<ul>
<li><a href="#__str__"><code>__str__</code></a></li>
<li><a href="#__iter__"><code>__iter__</code></a></li>
<li><a href="#__getitem__"><code>__getitem__</code></a></li>
<li><a href="#__getattr__"><code>__getattr__</code></a></li>
<li><a href="#__call__"><code>__call__</code></a></li>
</ul>
</li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举类</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB">使用元类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F">命名空间和作用域</a>
<ul>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">三种命名空间：</a>
<ul>
<li><a href="#%E5%9B%9B%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F">四种作用域：</a></li>
<li><a href="#global-%E5%92%8C-nonlocal%E5%85%B3%E9%94%AE%E5%AD%97"><code>global</code> 和 <code>nonlocal</code>关键字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">错误和异常处理</a>
<ul>
<li><a href="#%E8%B0%83%E8%AF%95">调试</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">文件和操作系统</a>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95">操作文件和目录</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E5%87%86%E5%BA%93">标准库</a>
<ul>
<li><a href="#collections"><code>collections</code></a>
<ul>
<li><a href="#namedtuple"><code>namedtuple</code></a></li>
<li><a href="#deque"><code>deque</code></a></li>
<li><a href="#ordereddict"><code>OrderedDict</code></a></li>
<li><a href="#chainmap"><code>ChainMap</code></a></li>
<li><a href="#counter"><code>Counter</code></a></li>
</ul>
</li>
<li><a href="#bisect"><code>bisect</code></a></li>
<li><a href="#itertools"><code>itertools</code></a></li>
<li><a href="#math"><code>math</code></a></li>
<li><a href="#time"><code>time</code></a></li>
<li><a href="#datetime"><code>datetime</code></a></li>
</ul>
</li>
<li><a href="#os"><code>os</code></a></li>
<li><a href="#path"><code>Path</code></a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">第三方库</a>
<ul>
<li><a href="#h5py"><code>h5py</code></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA">创建</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96">读取</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86">创建数据集：</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC">赋值</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B1">综合示例1</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAgroup%E9%9C%80%E8%A6%81%E9%A6%96%E5%85%88%E4%BB%A5append%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6">创建<code>group</code>,需要首先以<code>append</code>模式打开文件</a></li>
<li><a href="#pandas%E5%AF%B9h5py%E7%9A%84%E6%93%8D%E4%BD%9C"><code>Pandas</code>对<code>h5py</code>的操作</a>
<ul>
<li><a href="#%E5%86%99%E5%87%BA">写出</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96-2">读取</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="remixicon-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://bailingnan.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Python笔记</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-22 / 134 min read
        </div>
        
        <div class="post-content yue">
          <h1 id="python笔记"><code>Python</code>笔记</h1>
<h2 id="编码规范">编码规范</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318181309.png" alt="" loading="lazy"></figure>
<h2 id="对象">对象</h2>
<h3 id="可变与不可变对象">可变与不可变对象</h3>
<ul>
<li><code>Python</code>中的大多数对象，比如列表、字典、<code>NumPy</code>数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改。</li>
<li>字符串和元组，是不可变的。</li>
</ul>
<pre><code class="language-python">a= 'abc'
b = a.replace('a', 'A')
print(b)
'Abc'
</code></pre>
<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象，有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：<br>
当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了。<br>
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<ul>
<li>变量可以连续赋值:</li>
</ul>
<pre><code class="language-python">a=b=c=1
</code></pre>
<h3 id="元组">元组</h3>
<ul>
<li>如果要定义一个空的tuple，可以写成()：</li>
</ul>
<pre><code class="language-python">t = ()
print(t)
()
</code></pre>
<ul>
<li>但是，要定义一个只有1个元素的<code>tuple</code>，如果这么定义：</li>
</ul>
<pre><code class="language-python">t = (1)
print(t)
1
</code></pre>
<p>定义的不是<code>tuple</code>，是<code>1</code>这个数！这是因为括号()既可以表示<code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>
所以，只有1个元素的<code>tuple</code>定义时必须加一个逗号,，来消除歧义：</p>
<pre><code class="language-python">t = (1,)
print(t）
(1,)
</code></pre>
<p><code>Python</code>在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<ul>
<li>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</li>
</ul>
<pre><code class="language-python">tup = tuple(['foo', [1, 2], True])
tup[1].append(3)
print(tup)
('foo', [1, 2, 3], True)
</code></pre>
<h4 id="拆分元组">拆分元组</h4>
<ul>
<li>使用特殊的语法<code>*rest</code>，函数签名中以抓取任意长度列表的位置参数：</li>
</ul>
<pre><code class="language-python">values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a, b)
(1, 2)
print(rest)
[3, 4, 5]
</code></pre>
<ul>
<li><code>rest</code>的部分是想要舍弃的部分:</li>
</ul>
<pre><code class="language-python">a, b, *_ = values
</code></pre>
<h4 id="tuple方法"><code>tuple</code>方法</h4>
<ul>
<li>统计值出现频率：</li>
</ul>
<pre><code class="language-python">a = (1, 2, 2, 2, 3, 4, 2)
print(a.count(2))
4
</code></pre>
<h4 id="常用函数">常用函数</h4>
<ul>
<li><code>len(tuple)</code>:计算元组元素个数。</li>
<li><code>max(tuple)</code>:返回元组中元素最大值。</li>
<li><code>min(tuple)</code>:返回元组中元素最小值。</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="添加和删除元素">添加和删除元素</h4>
<ul>
<li><code>insert</code>在特定的位置插入元素：</li>
</ul>
<pre><code class="language-python">b_list=['foo', 'bar', 'baz']
b_list.insert(1, 'red')
print(b_list)
['foo', 'red', 'peekaboo', 'baz', 'dwarf']
</code></pre>
<p>与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，使用<code>collections.deque</code>，一个双尾部队列。</p>
<ul>
<li><code>insert</code>的逆运算是<code>pop</code>，它移除并返回指定位置的元素,<code>pop()</code>默认删除最后一个元素：</li>
</ul>
<pre><code class="language-python">print(b_list.pop(2))
'peekaboo'
print(b_list)
['foo', 'red', 'baz', 'dwarf']
</code></pre>
<ul>
<li><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</li>
</ul>
<pre><code class="language-python">b_list.append('foo')
print(b_list)
['foo', 'red', 'baz', 'dwarf', 'foo']
b_list.remove('foo')
print(b_list)
['red', 'baz', 'dwarf', 'foo']
</code></pre>
<h4 id="串联和组合列表">串联和组合列表</h4>
<ul>
<li>可以用加号将两个列表串联起来,如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</li>
</ul>
<pre><code class="language-python">x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>
<ul>
<li>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</li>
</ul>
<pre><code class="language-python">#快
everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
#慢
everything = []
for chunk in list_of_lists:
    everything = everything + chunk
</code></pre>
<p>考虑下列代码片段：</p>
<pre><code class="language-python">list = [ [ ] ] * 5
list  # output?
list[0].append(10)
list  # output?
list[1].append(20)
list  # output?
list.append(30)
list  # output?
</code></pre>
<p>2,4,6,8行将输出什么结果？试解释。<br>
输出的结果如下：</p>
<pre><code class="language-python">[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>
<p>解释如下：<br>
第一行的输出结果直觉上很容易理解，例如 <code>list = [ [ ] ] * 5</code> 就是简单的创造了5个空列表。然而，理解表达式<code>list=[ [ ] ] * 5</code>的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个创建了包含对同一个列表五次引用的列表。只有了解了这一点，我们才能更好的理解接下来的输出结果。<br>
<code>list[0].append(10)</code> 将10附加在第一个列表上。<br>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：</p>
<pre><code class="language-python">[[10], [10], [10], [10], [10]]
</code></pre>
<p>同理，<code>list[1].append(20)</code>将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：</p>
<pre><code class="language-python">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
</code></pre>
<p>作为对比， <code>list.append(30)</code>是将整个新的元素附加在外列表上，因此产生的结果是： <code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</code>。</p>
<h4 id="排序">排序</h4>
<ul>
<li><code>sort</code>函数将一个列表原地排序（不创建新的对象）</li>
</ul>
<pre><code class="language-python">a = [7, 2, 5, 1, 3]
a.sort()
print(a)
[1, 2, 3, 5, 7]
</code></pre>
<ul>
<li><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序<code>key</code>，可以用这个<code>key</code>进行排序。例如，我们可以按长度对字符串进行排序：</li>
</ul>
<pre><code class="language-python">b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)
print(b)
['He', 'saw', 'six', 'small', 'foxes']
</code></pre>
<h4 id="二分搜索和维护已排序的列表">二分搜索和维护已排序的列表</h4>
<ul>
<li><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值:</li>
</ul>
<pre><code class="language-python">import bisect
c = [1, 2, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 2))
4
print(bisect.bisect(c, 5))
6
print(bisect.insort(c, 6))
print(c)
[1, 2, 2, 2, 3, 4, 6, 7]
</code></pre>
<h4 id="zip函数">zip函数</h4>
<ul>
<li><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</li>
</ul>
<pre><code class="language-python">seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
print(list(zipped))
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</code></pre>
<ul>
<li><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</li>
</ul>
<pre><code class="language-python">seq3 = [False, True]
print(list(zip(seq1, seq2, seq3)))
[('foo', 'one', False), ('bar', 'two', True)]
</code></pre>
<ul>
<li><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</li>
</ul>
<pre><code class="language-python">for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
0: foo, one
1: bar, two
2: baz, three
</code></pre>
<ul>
<li>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。</li>
</ul>
<pre><code class="language-python">pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'),('Schilling', 'Curt')]
first_names, last_names = zip(*pitchers)
print(first_names)
('Nolan', 'Roger', 'Schilling')
print(last_names)
('Ryan', 'Clemens', 'Curt')
</code></pre>
<h4 id="reversed函数">reversed函数</h4>
<p><code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或<code>for</code>循环）之后才能创建翻转的序列。</p>
<pre><code class="language-python">print(list(reversed(range(10))))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<h4 id="常用函数-2">常用函数</h4>
<ul>
<li><code>max(list)</code>:返回列表元素最大值</li>
<li><code>min(list)</code>:返回列表元素最小值</li>
<li><code>list.count(obj)</code>:统计某个元素在列表中出现的次数</li>
<li><code>list.extend(seq)</code>:在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li><code>list.index(obj)</code>:从列表中找出某个值第一个匹配项的索引位置</li>
<li><code>list.reverse()</code>:反向列表中元素</li>
</ul>
<h3 id="字典">字典</h3>
<pre><code class="language-python">d = dict(name='Bob', age=20, score=88)
```python
`pickle.dumps()`方法把任意对象序列化成一个`bytes`，然后，就可以把这个`bytes`写入文件。或者用另一个方法`pickle.dump()`直接把对象序列化后写入一个`file-like Object`：
```python
f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个<code>Python</code>命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
print(d)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。<br>
要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<h4 id="删除值">删除值</h4>
<ul>
<li>用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</li>
</ul>
<pre><code class="language-python">d1={'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer',5: 'some value','dummy': 'another value'}
del d1[5]
print(d1)
{'a': 'some value',
 'b': [1, 2, 3, 4],
 7: 'an integer',
 'dummy': 'another value'}
ret = d1.pop('dummy')
print(ret)
'another value'
print(d1)
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
</code></pre>
<ul>
<li>`popitem():返回并删除字典中的最后一对键和值。</li>
</ul>
<h4 id="更新字典">更新字典</h4>
<ul>
<li>用<code>update</code>方法可以将一个字典与另一个融合,<code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</li>
</ul>
<pre><code class="language-python">d1.update({'b' : 'foo', 'c' : 12})
print(d1)
{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}
</code></pre>
<h4 id="用序列创建字典">用序列创建字典</h4>
<pre><code class="language-python">mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value
</code></pre>
<ul>
<li>因为字典本质上是2元元组的集合，<code>dict</code>可以接受2元元组的列表：</li>
</ul>
<pre><code class="language-python">mapping = dict(zip(range(5), reversed(range(5))))
print(mapping)
{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre>
<h4 id="默认值">默认值</h4>
<pre><code class="language-python">if key in some_dict:
    value = some_dict[key]
else:
    value = default_value
</code></pre>
<ul>
<li><code>dict</code>的方法<code>get</code>和<code>pop</code>可以取默认值进行返回，上面的<code>if-else</code>语句可以简写成下面：</li>
</ul>
<pre><code class="language-python">value = some_dict.get(key, default_value)
</code></pre>
<ul>
<li><code>get</code>默认会返回<code>None</code>，如果不存在键，<code>pop</code>会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</li>
</ul>
<pre><code class="language-python">words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)
print(by_letter)
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
</code></pre>
<ul>
<li>使用<code>setdefault</code>方法：</li>
</ul>
<pre><code class="language-python">for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
</code></pre>
<ul>
<li><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</li>
</ul>
<pre><code class="language-python">from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
</code></pre>
<p>给定以下字典的子类，下面的代码能够运行么？为什么？</p>
<pre><code class="language-python">class DefaultDict(dict):
  def __missing__(self, key):
    return []
d = DefaultDict()
d['florp'] = 127
</code></pre>
<p>能够运行。<br>
当<code>key</code>缺失时，执行<code>DefaultDict</code>类，字典的实例将自动实例化这个数列。</p>
<h4 id="有效的键类型">有效的键类型</h4>
<ul>
<li>字典的值可以是任意<code>Python</code>对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</li>
</ul>
<pre><code class="language-python">print(hash('string'))
5023931463650008331
print(hash((1, 2, (2, 3))))
1097636502276347782
print(hash((1, 2, [2, 3]))) # fails because lists are mutable
---------------------------------------------------------------------------
TypeError                                 
Traceback (most recent call last)
&lt;ipython-input-129-800cd14ba8be&gt; in &lt;module&gt;()
----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable
TypeError: unhashable type: 'list'
</code></pre>
<h4 id="按键值排序">按键值排序</h4>
<ul>
<li>键：</li>
</ul>
<pre><code class="language-python">sorted(dict.keys())
</code></pre>
<ul>
<li>值：</li>
</ul>
<pre><code class="language-python">sorted(dict.items(),key=lamda:item:item[1])
</code></pre>
<h3 id="集合">集合</h3>
<ul>
<li>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过<code>set</code>函数或使用尖括号<code>set</code>语句：</li>
</ul>
<pre><code class="language-python">print(set([2, 2, 2, 1, 3, 3]))
{1, 2, 3}
print({2, 2, 2, 1, 3, 3})
{1, 2, 3}
</code></pre>
<ul>
<li>通过<code>add(key)</code>方法可以添加元素到set中</li>
<li>通过<code>remove(key)</code>方法可以删除元素：</li>
<li>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</li>
</ul>
<pre><code class="language-python">a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a.union(b))
{1, 2, 3, 4, 5, 6, 7, 8}
print(a | b)
{1, 2, 3, 4, 5, 6, 7, 8}
</code></pre>
<ul>
<li>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</li>
</ul>
<pre><code class="language-python">print(a.intersection(b))
{3, 4, 5}
print(a &amp; b)
{3, 4, 5}
</code></pre>
<ul>
<li>
<p>常用集合方法</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317202703.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
</li>
</ul>
<pre><code class="language-python">c = a.copy()
c |= b
print(c)
{1, 2, 3, 4, 5, 6, 7, 8}
d = a.copy()
d &amp;= b
print(d)
{3, 4, 5}
</code></pre>
<ul>
<li>检测一个集合是否是另一个集合的子集或父集：</li>
</ul>
<pre><code class="language-python">a_set = {1, 2, 3, 4, 5}
print({1, 2, 3}.issubset(a_set))
True
print(a_set.issuperset({1, 2, 3}))
True
</code></pre>
<h3 id="列表-集合和字典推导式">列表、集合和字典推导式</h3>
<pre><code class="language-python">[expr for val in collection if condition]
</code></pre>
<p>等同于：</p>
<pre><code class="language-python">result = []
for val in collection:
    if condition:
        result.append(expr)
</code></pre>
<ul>
<li>字典:</li>
</ul>
<pre><code class="language-python">dict_comp = {key-expr : value-expr for value in collection if condition}
</code></pre>
<ul>
<li>集合</li>
</ul>
<pre><code class="language-python">set_comp = {expr for value in collection if condition}
</code></pre>
<ul>
<li><code>map</code>函数可以进一步简化：</li>
</ul>
<pre><code class="language-python">print(set(map(len, strings)))
{1, 2, 3, 4, 6}
</code></pre>
<h4 id="嵌套列表推导式">嵌套列表推导式</h4>
<pre><code class="language-python">all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'],['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]
names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') &gt;= 2]
    names_of_interest.extend(enough_es)
</code></pre>
<p>嵌套列表推导式：</p>
<pre><code class="language-python">result = [name for names in all_data for name in names if name.count('e') &gt;= 2]
print(result)
result=['Steven']
</code></pre>
<p>以下代码正常输出偶数：</p>
<pre><code class="language-python">[x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
</code></pre>
<p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p>
<pre><code class="language-python">[x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？<br>
另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p>
<pre><code class="language-python">[x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>:</p>
<pre><code class="language-python">[x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。<br>
可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<pre><code class="language-python">print([[x for x in tup] for tup in some_tuples])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<h3 id="函数">函数</h3>
<h4 id="参数">参数</h4>
<ul>
<li>对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容:</li>
</ul>
<pre><code class="language-python">def append_element(some_list, element):
    some_list.append(element)
data = [1, 2, 3]
append_element(data, 4)
print(data)
[1, 2, 3, 4]
</code></pre>
<ul>
<li>函数可以有一些位置参数(<code>positional</code>)和一些关键字参数(<code>keyword</code>)。关键字参数通常用于指定默认值或可选参数</li>
</ul>
<h4 id="默认参数">默认参数</h4>
<pre><code class="language-python">def add_end(L=[]):
    L.append('END')
    return L
print(add_end())
['END']
print(add_end())
['END', 'END']
</code></pre>
<ul>
<li>Python函数在定义的时候，默认参数L的值就被计算出来了，即<code>[]</code>，因为默认参数L也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。<br>
<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></li>
<li>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</li>
</ul>
<pre><code class="language-python">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>举例：</p>
<pre><code class="language-python">def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')

print &quot;list1 = %s&quot; % list1
print &quot;list2 = %s&quot; % list2
print &quot;list3 = %s&quot; % list3

list1 = [10, 'a']
list2 = [123]
list3 = [10, 'a']
</code></pre>
<p>很多人都会误认为<code>list1=[10]</code>，<code>list3=[‘a’]</code>,因为他们以为每次<code>extendList</code>被调用时，列表参数的默认值都将被设置为<code>[]</code>.但实际上的情况是，新的默认列表只在函数被定义的那一刻创建一次。<br>
当<code>extendList</code>被没有指定特定参数<code>list</code>调用时，这组<code>list</code>的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。因此<code>list1</code>和<code>list3</code>是在同一个默认列表上进行操作（计算）的。而<code>list2</code>是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。<br>
<code>extendList</code>的定义可以作如下修改。<br>
尽管，创建一个新的列表，没有特定的列表参数。<br>
下面这段代码可能能够产生想要的结果。</p>
<pre><code class="language-python">def extendList(val, list=None):
  if list is None:
    list = []
  list.append(val)
  return list
</code></pre>
<p>通过上面的修改，输出结果将变成：</p>
<pre><code class="language-python">list1 = [10]
list2 = [123]
list3 = ['a']
</code></pre>
<ul>
<li>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</li>
</ul>
<h4 id="可变参数">可变参数</h4>
<pre><code class="language-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括<code>0</code>个参数。<br>
如果已经有一个<code>list</code>或者<code>tuple</code>：</p>
<pre><code class="language-python">nums = [1, 2, 3]
print(calc(*nums))
14
</code></pre>
<h4 id="关键字参数">关键字参数</h4>
<ul>
<li>关键字参数允许你传入<code>0</code>个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</li>
</ul>
<pre><code class="language-python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</li>
</ul>
<pre><code class="language-python">person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<ul>
<li>也可以传入任意个数的关键字参数：</li>
</ul>
<pre><code class="language-python">person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p>关键字参数可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<br>
和可变参数类似，也可以先组装出一个<code>dict</code>，然后，把该<code>dict</code>转换为关键字参数传进去：</p>
<pre><code class="language-python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>上面复杂的调用可以用简化的写法：</p>
<pre><code>extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把<code>extra</code>这个<code>dict</code>的所有<code>key-value</code>用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个<code>dict</code>，注意``kw<code>获得的</code>dict<code>是</code>extra<code>的一份拷贝，对</code>kw<code>的改动不会影响到函数外的</code>extra`。</p>
<h4 id="命名关键字参数">命名关键字参数</h4>
<ul>
<li>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。<br>
仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</li>
</ul>
<pre><code class="language-python">def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</li>
</ul>
<pre><code class="language-python">def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>和关键字参数<code>**kw不同</code>，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>
调用方式如下：</li>
</ul>
<pre><code class="language-python">person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</li>
</ul>
<pre><code class="language-python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<ul>
<li>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</li>
</ul>
<pre><code class="language-python">person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<ul>
<li>由于调用时缺少参数名<code>city</code>和<code>job</code>，<code>Python</code>解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。<br>
命名关键字参数可以有缺省值，从而简化调用：</li>
</ul>
<pre><code class="language-python">def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</li>
</ul>
<pre><code class="language-python">person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，<code>Python</code>解释器将无法识别位置参数和命名关键字参数：</li>
</ul>
<pre><code class="language-python">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h4 id="强制位置参数">强制位置参数</h4>
<p><code>Python3.8</code> 新增了一个函数形参语法<code>/</code>用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。<br>
在以下的例子中，形参 <code>a</code> 和 <code>b</code> 必须使用指定位置参数，<code>c</code> 或 <code>d</code> 可以是位置形参或关键字形参，而 <code>e</code> 或 <code>f</code> 要求为关键字形参:</p>
<pre><code class="language-python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>
<p>以下使用方法是正确的:</p>
<pre><code class="language-python">f(10, 20, 30, d=40, e=50, f=60)
</code></pre>
<p>以下使用方法会发生错误:</p>
<pre><code class="language-python">f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
</code></pre>
<h4 id="参数组合">参数组合</h4>
<ul>
<li>在<code>Python</code>中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</li>
</ul>
<pre><code class="language-python">def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<ul>
<li>在函数调用的时候，<code>Python</code>解释器自动按照参数位置和参数名把对应的参数传进去。</li>
</ul>
<pre><code class="language-python">f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<ul>
<li>通过一个<code>tuple</code>和<code>dict</code>，你也可以调用上述函数：</li>
</ul>
<pre><code class="language-python">args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<ul>
<li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。<br>
<strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
</ul>
<h4 id="匿名lambda函数">匿名(lambda)函数</h4>
<ul>
<li><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然<code>lambda</code>函数看起来只能写一行，却不等同于<code>C</code>或<code>C++</code>的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<pre><code class="language-python">strings = ['foo', 'card', 'bar', 'aaaa', 'abab']
strings.sort(key=lambda x: len(set(list(x))))
print(strings)
['aaaa', 'foo', 'abab', 'bar', 'card']
</code></pre>
<h4 id="柯里化部分参数应用">柯里化：部分参数应用</h4>
<ul>
<li>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数:</li>
</ul>
<pre><code class="language-python">def add_numbers(x, y):
    return x + y
add_five = lambda y: add_numbers(5, y)
</code></pre>
<p><code>add_numbers</code>的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的<code>functools</code>模块可以用<code>partial</code>函数将此过程简化：</p>
<pre><code class="language-python">from functools import partial
add_five = partial(add_numbers, 5)
</code></pre>
<h4 id="生成器">生成器</h4>
<ul>
<li>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是<code>Python</code>的一个重要特点。这是通过一种叫做迭代器协议(<code>iterator protocol</code>，它是一种使对象可迭代的通用方式)的方式实现的，一个原生的使对象可迭代的方法。</li>
<li>生成器(<code>generator</code>)是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的<code>return</code>替换为<code>yeild</code>即可：</li>
</ul>
<pre><code class="language-python">def squares(n=10):
    print('Generating squares from 1 to {0}'.format(n ** 2))
    for i in range(1, n + 1):
        yield i ** 2
</code></pre>
<ul>
<li>调用该生成器时，没有任何代码会被立即执行：</li>
</ul>
<pre><code class="language-python">gen = squares()
print(gen)
&lt;generator object squares at 0x7fbbd5ab4570&gt;
</code></pre>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<pre><code class="language-python">for x in gen:
    print(x, end=' ')
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100
</code></pre>
<h4 id="生成器表达式">生成器表达式</h4>
<pre><code class="language-python">另一种更简洁的构造生成器的方法是使用生成器表达式(`generator expression`)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：
```python
gen = (x ** 2 for x in range(100))
print(gen)
&lt;generator object &lt;genexpr&gt; at 0x7fbbd5ab29e8&gt;
</code></pre>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<pre><code class="language-python">def _make_gen():
    for x in range(100):
        yield x ** 2
gen = _make_gen()
</code></pre>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<pre><code class="language-python">print(sum(x ** 2 for x in range(100)))
328350
print(dict((i, i **2) for i in range(5)))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>
<h4 id="迭代器">迭代器</h4>
<ul>
<li>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。<br>
可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</li>
</ul>
<pre><code class="language-python">from collections.abc import Iterator
isinstance((x for x in range(10)), Iterator)
True
isinstance([], Iterator)
False
isinstance({}, Iterator)
False
isinstance('abc', Iterator)
False
</code></pre>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<pre><code class="language-python">isinstance(iter([]), Iterator)
True
isinstance(iter('abc'), Iterator)
True
</code></pre>
<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>
<p>这是因为<code>Python</code>的<code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>
<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用<code>list</code>是永远不可能存储全体自然数的。</p>
<h5 id="类作为迭代器">类作为迭代器</h5>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。<br>
如果你已经了解的面向对象编程，就知道类都有一个构造函数，<code>Python</code> 的构造函数为 <code>__init__()</code>, 它会在对象初始化的时候执行。<br>
<code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。<br>
<code>__next__()</code> 方法（Python 2 里是 <code>next()</code>）会返回下一个迭代器对象。<br>
创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
1
2
3
4
5
</code></pre>
<p><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。<br>
在 20 次迭代后停止执行：</p>
<pre><code>class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
  print(x)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre>
<h4 id="函数式编程">函数式编程</h4>
<h5 id="高阶函数">高阶函数</h5>
<h6 id="map函数"><code>map</code>函数</h6>
<ul>
<li><code>map()</code> 会根据提供的函数对指定序列做映射。第一个参数 <code>function</code> 以参数序列中的每一个元素调用 <code>function</code> 函数，返回包含每次 <code>function</code> 函数返回值的新列表。</li>
</ul>
<pre><code class="language-python">map(function, iterable, ...)
</code></pre>
<ul>
<li><code>function</code>:函数</li>
<li><code>iterable</code>:一个或多个序列</li>
</ul>
<pre><code class="language-python">def square(x) :            # 计算平方数
    return x ** 2
print(map(square, [1,2,3,4,5]))   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
# 提供了两个列表，对相同位置的列表数据进行相加
print(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
</code></pre>
<h6 id="reduce函数"><code>reduce</code>函数</h6>
<ul>
<li><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是:</li>
</ul>
<pre><code class="language-python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数13579，reduce就可以派上用场：</p>
<pre><code class="language-python">from functools import reduce
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))
13579
</code></pre>
<p>考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<pre><code class="language-python">from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<h6 id="filter函数"><code>filter</code>函数</h6>
<ul>
<li><code>Python</code>内建的<code>filter()</code>函数用于过滤序列。<br>
和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。<br>
注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回<code>list</code>。<br>
筛法求素数：</li>
</ul>
<pre><code>def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
def _not_divisible(n):
    return lambda x: x % n &gt; 0
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<h6 id="sorted函数"><code>sorted</code>函数</h6>
<ul>
<li><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</li>
</ul>
<pre><code class="language-python">print(sorted([7, 1, 2, 6, 0, 3, 2]))
[0, 1, 2, 2, 3, 6, 7]
print(sorted('horse race'))
[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']
</code></pre>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<pre><code class="language-python">sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>进行反向排序，不必改动<code>key</code>函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-python">sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h5 id="返回函数">返回函数</h5>
<pre><code class="language-python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="language-python">f = lazy_sum(1, 3, 5, 7, 9)
f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code class="language-python">f()
25
</code></pre>
<p>函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p>
<h6 id="闭包">闭包</h6>
<ul>
<li>返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</li>
</ul>
<pre><code class="language-python">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>
你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是1，4，9，但实际结果是：</p>
<pre><code class="language-python">f1()
9
f2()
9
f3()
9
</code></pre>
<p>全部都是9！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了3，因此最终结果为9。<br>
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>
<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<pre><code class="language-python"> f1, f2, f3 = count()
f1()
1
f2()
4
f3()
9
</code></pre>
<pre><code class="language-python">下面这段代码的输出结果将是什么？请解释。
```python
def multipliers():
  return [lambda x : i * x for i in range(4)]
print [m(2) for m in multipliers()]
</code></pre>
<p>你如何修改上面的<code>multipliers</code>的定义产生想要的结果？<br>
上面代码输出的结果是<code>[6, 6, 6, 6]</code>(不是我们想的<code>[0, 2, 4, 6]</code>)。<br>
上述问题产生的原因是<code>Python</code>闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。因此，当任何由<code>multipliers()</code>返回的函数被调用时，<code>i</code>的值将在附近的范围进行查找。那时，不管返回的函数是否被调用，for循环已经完成，<code>i</code>被赋予了最终的值3。<br>
因此，每次返回的函数乘以传递过来的值3，因为上段代码传过来的值是2，它们最终返回的都是6(3*2)。碰巧的是，《The Hitchhiker’s Guide to Python》也指出，在与<code>lambdas</code>函数相关也有一个被广泛被误解的知识点，不过跟这个<code>case</code>不一样。由<code>lambda</code>表达式创造的函数没有什么特殊的地方，它其实是和def创造的函数式一样的。<br>
下面是解决这一问题的一些方法。<br>
一种解决方法就是用<code>Python</code>生成器。</p>
<pre><code class="language-python">def multipliers():
  for i in range(4): yield lambda x : i * x
</code></pre>
<p>另外一个解决方案就是创造一个闭包，利用默认函数立即绑定。</p>
<pre><code class="language-python">def multipliers():
  return [lambda x, i=i : i * x for i in range(4)]
</code></pre>
<p>还有种替代的方案是，使用偏函数：</p>
<pre><code class="language-python">from functools import partial
from operator import mul
def multipliers():
  return [partial(mul, i) for i in range(4)]
</code></pre>
<h5 id="装饰器">装饰器</h5>
<ul>
<li>在代码运行期间动态增加功能的方式，称之为“装饰器”(<code>Decorator</code>)。<br>
本质上，<code>decorator</code>就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的<code>decorator</code>，可以定义如下：</li>
</ul>
<pre><code class="language-python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
now()
call now():
2015-3-25
</code></pre>
<p>由于<code>log()</code>是一个<code>decorator</code>，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。<br>
<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。<br>
如果<code>decorator</code>本身需要传入参数，那就需要编写一个返回<code>decorator</code>的高阶函数，写出来会更复杂。比如，要自定义<code>log</code>的文本：</p>
<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
@log('execute')
def now():
    print('2015-3-25')
now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="language-python">now = log('execute')(now)
</code></pre>
<p>首先执行<code>log('execute')</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p>
<p>以上两种<code>decorator</code>的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过<code>decorator</code>装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>：</p>
<pre><code class="language-python">now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个<code>wrapper()</code>函数名字就是<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，<code>Python</code>内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的<code>decorator</code>的写法如下：</p>
<pre><code class="language-pythoh">import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的<code>decorator</code>：</p>
<pre><code>import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>在面向对象(OOP)的设计模式中，<code>decorator</code>被称为装饰模式。<code>OOP</code>的装饰模式需要通过继承和组合来实现，而<code>Python</code>除了能支持<code>OOP</code>的<code>decorator</code>外，直接从语法层次支持<code>decorator</code>。<code>Python</code>的<code>decorator</code>可以用函数实现，也可以用类实现。<br>
<code>decorator</code>可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h6 id="property"><code>@property</code></h6>
<p><code>Python</code>内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<pre><code class="language-python">class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="language-python">s = Student()
s.score = 60 # OK，实际转化为s.set_score(60)
s.score # OK，实际转化为s.get_score()
60
s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过<code>getter</code>和<code>setter</code>方法来实现的。</p>
<p>还可以定义只读属性，只定义<code>getter</code>方法，不定义<code>setter</code>方法就是一个只读属性：</p>
<pre><code class="language-python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<h6 id="classmethod"><code>@classmethod</code></h6>
<p><code>@classmethod</code>对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。<br>
<code>@classmethod</code>因为持有<code>cls</code>参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>
<pre><code class="language-python">class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 foo 方法
 
A.func2()               # 不需要实例化
</code></pre>
<h6 id="staticmethod"><code>@staticmethod</code></h6>
<p>将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。<br>
<code>@staticmethod</code>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。<br>
如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接<code>类名.属性名</code>或<code>类名.方法名</code>。</p>
<pre><code class="language-python">class TestClass:
    name = &quot;test&quot;
    def __init__(self, name):
        self.name = name
    @staticmethod
    def fun(self, x, y):
        return  x + y
cls = TestClass(&quot;felix&quot;)
print &quot;通过实例引用方法&quot;
print cls.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
print &quot;类名直接引用静态方法&quot;
print TestClass.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
</code></pre>
<h6 id="dataclass"><code>@dataclass</code></h6>
<pre><code class="language-python">class MyClass:
    def __init__(self, var_a, var_b):
        self.var_a = var_a
        self.var_b = var_b
@dataclass
class MyClass:
    var_a: str
    var_b: str
@dataclass
class Number:
    val:int = 0
</code></pre>
<h5 id="偏函数">偏函数</h5>
<ul>
<li><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换。<br>
但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入<code>base</code>参数，就可以做N进制的转换：<br>
<code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</li>
</ul>
<pre><code>import functools
int2 = functools.partial(int, base=2)
int2('1000000')
64
int2('1010101')
85
</code></pre>
<ul>
<li>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>
注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为2，但也可以在函数调用时传入其他值：</li>
</ul>
<pre><code class="language-python">int2('1000000', base=10)
1000000
</code></pre>
<ul>
<li>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</li>
</ul>
<pre><code class="language-python">int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了<code>int()</code>函数的关键字参数<code>base</code>，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code class="language-python">max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>
<pre><code class="language-python">max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code class="language-python">args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。<br>
当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
<h4 id="itertools模块"><code>itertools</code>模块</h4>
<ul>
<li>标准库<code>itertools</code>模块中有一组用于许多常见数据算法的生成器。例如，<code>groupby</code>可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</li>
</ul>
<pre><code class="language-python">import itertools
first_letter = lambda x: x[0]
names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
for letter, names in itertools.groupby(names, first_letter):
    print(letter, list(names)) # names is a generator
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']
</code></pre>
<ul>
<li>常用<code>itertools</code>函数:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373137383639312d313131383233643837363761313034642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f77.png" alt="" loading="lazy"></li>
</ul>
<h3 id="字符串">字符串</h3>
<pre><code class="language-python"> a= 'ABC'
</code></pre>
<p>在内存中创建了一个<code>'ABC'</code>的字符串；<br>
在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。<br>
也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p>
<pre><code class="language-python">a = 'ABC'
b = a
a = 'XYZ'
print(b)
'ABC`
</code></pre>
<h4 id="分割">分割</h4>
<pre><code class="language-python">s = 'python'
list(s)
['p', 'y', 't', 'h', 'o', 'n']
</code></pre>
<h4 id="模板化或格式化">模板化或格式化</h4>
<pre><code class="language-python">template = '{0:.2f} {1:s} are worth US${2:d}'
</code></pre>
<ul>
<li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>{1:s}</code>表示格式化第二个参数为字符串。</li>
<li><code>{2:d}</code>表示格式化第三个参数为一个整数。<br>
在括号中的数字用于指向传入对象在 <code>format()</code> 中的位置，如下所示：</li>
</ul>
<pre><code class="language-python">print('{0} 和 {1}'.format('Google', 'Runoob'))
Google 和 Runoob
print('{1} 和 {0}'.format('Google', 'Runoob'))
Runoob 和 Google
</code></pre>
<p>如果在<code>format()</code> 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code class="language-python">print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
菜鸟教程网址： www.runoob.com
</code></pre>
<p>位置及关键字参数可以任意的结合:</p>
<pre><code class="language-python">print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
站点列表 Google, Runoob, 和 Taobao。
</code></pre>
<p>可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 <code>Pi</code> 保留到小数点后三位：</p>
<pre><code class="language-python">import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre>
<p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。<br>
最简单的就是传入一个字典, 然后使用方括号 <code>[]</code> 来访问键值 :</p>
<pre><code class="language-python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<p>也可以通过在 <code>table</code> 变量前使用 <code>**</code> 来实现相同的功能：</p>
<pre><code class="language-python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<h4 id="常用操作">常用操作</h4>
<ul>
<li><code>str.join(iterable)</code>:返回一个由 <code>iterable</code> 中的字符串拼接而成的字符串。比<code>+</code>效率要高。</li>
<li><code>eval(str)</code>:用来计算在字符串中的有效<code>Python</code>表达式,并返回一个对象</li>
<li><code>str.center(width[, fillchar])</code>:返回长度为 <code>width</code> 的字符串，原字符串在其正中。 使用指定的 <code>fillchar</code> 填充两边的空位（默认使用 <code>ASCII</code> 空格符）。 如果 <code>width</code> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</li>
<li><code>str.count(str, beg= 0,end=len(string))</code>:返回 <code>str</code> 在 <code>string</code> 里面出现的次数，如果 <code>beg</code> 或者 <code>end</code>指定则返回指定范围内 <code>str</code> 出现的次数</li>
<li><code>str.find(str, beg=0, end=len(string))</code>:检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code> ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回<code>-1</code></li>
<li><code>str.upper()</code>:转换字符串中的小写字母为大写</li>
<li><code>str.lower()</code>:转换字符串中所有大写字符为小写</li>
<li><code>str.replace(old, new [, max])</code>:将字符串中的 <code>str1</code> 替换成 <code>str2</code>,如果<code>max</code>指定，则替换不超过<code>max</code>次。</li>
<li><code>str.split(str=&quot;&quot;, num=string.count(str))</code>:<code>num=string.count(str))</code> 以<code>str</code>为分隔符截取字符串，如果<code>num</code>有指定值，则仅截取<code>num+1</code>个子字符串</li>
<li><code>str.strip([chars])</code>:截掉字符串两边的空格或指定字符。</li>
</ul>
<h3 id="运算符">运算符</h3>
<h4 id="和is"><code>==</code>和<code>is</code></h4>
<ul>
<li>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法:</li>
</ul>
<pre><code class="language-python">a = [1, 2, 3]
b = a
c = list(a)
print(a is b)
True
# 因为list总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。
print(a is not c)
True
print(a == c)
True
</code></pre>
<h4 id="any和all"><code>any()</code>和<code>all()</code></h4>
<p><code>any()</code>, <code>all()</code>很好理解，就是字面意思，即参数中任何一个为 <code>true</code> 或者全部为 <code>true</code> 则返回 <code>true</code>。</p>
<h4 id="十进制转二进制">十进制转二进制</h4>
<pre><code class="language-python">bin(10)
'0b1010'
</code></pre>
<h2 id="模块">模块</h2>
<ul>
<li>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，<code>Python</code>就把这个目录当成普通目录，而不是一个包。</li>
<li>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</li>
<li>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。<br>
<code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该``.py文件的名称，例如：<br>
运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；<br>
运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael]</code>。<br>
注意当使用 <code>from package import item</code> 这种形式的时候，对应的 <code>item</code> 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。<br>
<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。<br>
反之，如果使用形如 <code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</li>
<li>内置的函数 <code>dir()</code> 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</li>
<li><code>sys.argv</code> 是一个包含命令行参数的列表。<code>sys.path</code> 包含了一个 <code>Python</code> 解释器自动查找所需模块的路径的列表。</li>
<li>搜索路径是由一系列目录名组成的，<code>Python</code>解释器就依次从这些目录中去寻找所引入的模块。<br>
搜索路径是在<code>Python</code>编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在<code>sys</code>模块中的<code>path</code>变量，做一个简单的实验，在交互式解释器中，输入以下代码：</li>
</ul>
<pre><code class="language-python">import sys
sys.path
['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']
</code></pre>
<p><code>sys.path</code> 输出是一个列表，其中第一项是空串<code>''</code>，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行<code>python</code>解释器的目录（对于脚本的话就是运行的脚本所在的目录）。<br>
因此若在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。<br>
了解了搜索路径的概念，就可以在脚本中修改<code>sys.path</code>来引入一些不在搜索路径中的模块。<br>
如果我们要添加自己的搜索目录，有两种方法：<br>
一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<pre><code class="language-python">import sys
sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是在运行时修改，运行结束后失效。<br>
第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，<code>Python</code>自己本身的搜索路径不受影响。<br>
现在，在解释器的当前目录或者 <code>sys.path</code>中的一个目录里面来创建一个<code>fibo.py</code>的文件，代码如下：</p>
<pre><code class="language-python"># 斐波那契(fibonacci)数列模块
def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre>
<p>然后进入<code>Python</code>解释器，使用下面的命令导入这个模块：</p>
<pre><code class="language-python">import fibo
</code></pre>
<p>这样做并没有把直接定义在<code>fibo</code>中的函数名称写入到当前符号表里，只是把模块<code>fibo</code>的名字写到了那里。</p>
<h3 id="name属性"><code>name</code>属性</h3>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code class="language-python3"># Filename: using_name.py
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<pre><code class="language-shell">$ python using_name.py
程序自身在运行
$ python
&gt;&gt;&gt; import using_name
我来自另一模块
</code></pre>
<p>说明： 每个模块都有一个<code>__name_</code>_属性，当其值是<code>'__main__'</code>时，表明该模块自身在运行，否则是被引入。</p>
<h4 id="包">包</h4>
<ul>
<li>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</li>
</ul>
<pre><code class="language-python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<p>如果 <code>__all__</code>真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 <code>sound.effects</code> 里的任何子模块。他只是把包<code>sound.effects</code>和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。<br>
这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code class="language-python">import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre>
<p>这个例子中，在执行 <code>from...import</code> 前，包 <code>sound.effects</code> 中的 <code>echo</code> 和 <code>surround</code> 模块都被导入到当前的命名空间中了。（当然如果定义了 <code>__all__</code> 就更没问题了）</p>
<h2 id="oop">OOP</h2>
<h3 id="访问限制">访问限制</h3>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在<code>Python</code>中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量(<code>private</code>)，只有内部可以访问，外部不能访问:</p>
<pre><code class="language-python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
<pre><code class="language-python">bart = Student('Bart Simpson', 59)
bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>外部代码要获取<code>name</code>和<code>score</code>,修改属性,可以给<code>Student</code>类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<pre><code class="language-python">class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
    def set_score(self, score):
        self.__score = score
</code></pre>
<p>那种直接通过<code>bart.score = 99</code>也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code class="language-python">class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>在<code>Python</code>中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是<code>private</code>变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。<br>
下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为<code>Python</code>解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name来访问__name</code>变量：</p>
<pre><code class="language-python">bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的<code>Python</code>解释器可能会把<code>__name</code>改成不同的变量名。<br>
总的来说就是，<code>Python</code>本身没有任何机制阻止你干坏事，一切全靠自觉。<br>
最后注意下面的这种错误写法：</p>
<pre><code class="language-python">bart = Student('Bart Simpson', 59)
bart.get_name()
'Bart Simpson'
bart.__name = 'New Name' # 设置__name变量！
bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和<code>class</code>内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被<code>Python</code>解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<pre><code class="language-python">bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<h3 id="继承和多态">继承和多态</h3>
<pre><code class="language-python">#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
</code></pre>
<pre><code class="language-python">class Animal(object):
    def run(self):
        print('Animal is running...')
class Dog(Animal):
    def run(self):
        print('Dog is running...')
</code></pre>
<p>子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。]</p>
<pre><code class="language-python">a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
isinstance(a, list)
True
isinstance(b, Animal)
True
isinstance(c, Dog)
True
</code></pre>
<p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p>
<pre><code class="language-python">isinstance(c, Animal)
True
</code></pre>
<p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！<br>
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p>
<pre><code class="language-python">def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<pre><code class="language-python">run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>多态的好处就是，当我们需要传入<code>Dog</code>时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>还是<code>Dog</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>
对扩展开放：允许新增<code>Animal</code>子类；<br>
对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>
对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>
对于<code>Python</code>这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<pre><code class="language-python">class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>
<code>Python</code>的<code>“file-like object“</code>就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为<code>“file-like object“</code>。许多函数接收的参数就是<code>“file-like object“</code>，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。<br>
下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-python">class Parent(object):
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass
print Parent.x, Child1.x, Child2.x
Child1.x = 2
print Parent.x, Child1.x, Child2.x
Parent.x = 3
print Parent.x, Child1.x, Child2.x
1 1 1
1 2 1
3 2 3
</code></pre>
<p>让很多人困惑或惊讶的是最后一行输出为什么是3 2 3 而不是 3 2 1.为什么在改变<code>parent.x</code>的同时也改变了<code>child2.x</code>的值？但与此同时没有改变<code>Child1.x</code>的值？<br>
此答案的关键是，在<code>Python</code>中，类变量在内部是以字典的形式进行传递。<br>
如果一个变量名没有在当前类下的字典中发现。则在更高级的类（如它的父类）中尽心搜索直到引用的变量名被找到。（如果引用变量名在自身类和更高级类中没有找到，将会引发一个属性错误。）<br>
因此,在父类中设定<code>x = 1</code>,让变量<code>x</code>类(带有值1)能够在其类和其子类中被引用到。这就是为什么第一个打印语句输出结果是1 1 1<br>
因此，如果它的任何一个子类被覆写了值（例如说，当我们执行语句<code>Child1.x = 2</code>）,这个值只在子类中进行了修改。这就是为什么第二个打印语句输出结果是1 2 1<br>
最终，如果这个值在父类中进行了修改，（例如说，当我们执行语句<code>Parent.x = 3</code>）,这个改变将会影响那些还没有覆写子类的值（在这个例子中就是<code>Child2</code>）这就是为什么第三打印语句输出结果是3 2 3</p>
<h3 id="获取对象信息">获取对象信息</h3>
<h4 id="使用type">使用<code>type()</code></h4>
<p>判断对象类型，使用<code>type()</code>函数：</p>
<pre><code class="language-python">type(123)
&lt;class 'int'&gt;
type('str')
&lt;class 'str'&gt;
type(None)
&lt;type(None) 'NoneType'&gt;
type(abs)
&lt;class 'builtin_function_or_method'&gt;
type(a)
&lt;class '__main__.Animal'&gt;
&gt;&gt;&gt; import types
def fn():
    pass
type(fn)==types.FunctionType
True
type(abs)==types.BuiltinFunctionType
True
type(lambda x: x)==types.LambdaType
True
type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h4 id="使用isinstance">使用<code>isinstance()</code></h4>
<p>判断<code>class</code>的类型，可以使用<code>isinstance()</code>函数。</p>
<pre><code class="language-python">isinstance([1, 2, 3], (list, tuple))
True
isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</strong></p>
<h4 id="使用dir">使用dir()</h4>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个<code>str</code>对象的所有属性和方法：</p>
<pre><code class="language-python">dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p>类似<code>__xxx__</code>的属性和方法在<code>Python</code>中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在<code>Python</code>中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<pre><code class="language-python">len('ABC')
3
'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<pre><code class="language-python">class MyDog(object):
    def __len__(self):
        return 100
dog = MyDog()
len(dog)
100
</code></pre>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p>
<pre><code class="language-python">'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<pre><code class="language-python">class MyObject(object):
    def __init__(self):
        self.x = 9
    def power(self):
        return self.x * self.x
obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code class="language-python">hasattr(obj, 'x') # 有属性'x'吗？
True
obj.x
9
hasattr(obj, 'y') # 有属性'y'吗？
False
setattr(obj, 'y', 19) # 设置一个属性'y'
hasattr(obj, 'y') # 有属性'y'吗？
True
getattr(obj, 'y') # 获取属性'y'
19
obj.y # 获取属性'y'
19
</code></pre>
<p>如果试图获取不存在的属性，会抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-python">getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个<code>default</code>参数，如果属性不存在，就返回默认值：</p>
<pre><code>getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code class="language-python">hasattr(obj, 'power') # 有属性'power'吗？
True
getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<h4 id="实例属性和类属性">实例属性和类属性</h4>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>直接在<code>class</code>中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<pre><code class="language-python">class Student(object):
    name = 'Student'
</code></pre>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<pre><code class="language-python">class Student(object):
    name = 'Student'
s = Student() # 创建实例s
print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
print(Student.name) # 打印类的name属性
Student
s.name = 'Michael' # 给实例绑定name属性
print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
del s.name # 如果删除实例的name属性
print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>
实例属性属于各个实例所有，互不干扰；<br>
类属性属于类所有，所有实例共享一个属性；<br>
不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h4 id="使用__slots__">使用<code>__slots__</code></h4>
<p>给实例绑定一个方法：</p>
<pre><code class="language-python">def set_age(self, age): # 定义一个函数作为实例方法
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25) # 调用实例方法
s.age # 测试结果
25
</code></pre>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<pre><code class="language-python">s2 = Student() # 创建新的实例
s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p>为了给所有实例都绑定方法，可以给class绑定方法：</p>
<pre><code class="language-python">def set_score(self, score):
    self.score = score
Student.set_score = set_score
</code></pre>
<p>给class绑定方法后，所有实例均可调用.<br>
通常情况下，上面的<code>set_score</code>方法可以直接定义在<code>class</code>中，但动态绑定允许我们在程序运行的过程中动态给<code>class</code>加上功能，这在静态语言中很难实现。<br>
限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。<br>
为了达到限制的目的，<code>Python</code>允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>
<pre><code class="language-python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```python
s = Student() # 创建新的实例
s.name = 'Michael' # 绑定属性'name'
s.age = 25 # 绑定属性'age'
s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>由于<code>'score'</code>没有被放到_<code>_slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<pre><code class="language-python">class GraduateStudent(Student):
    pass
g = GraduateStudent()
g.score = 9999
</code></pre>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h4 id="多重继承">多重继承</h4>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318023741.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">class Animal(object):
    pass
# 大类:
class Mammal(Animal):
    pass
class Bird(Animal):
    pass
# 各种动物:
class Dog(Mammal):
    pass
class Bat(Mammal):
    pass
class Parrot(Bird):
    pass
class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上<code>Runnable</code>和<code>Flyable</code>的功能，只需要先定义好<code>Runnable</code>和<code>Flyable</code>的类：</p>
<pre><code class="language-python">class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要<code>Runnable</code>功能的动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p>
<pre><code class="language-python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要<code>Flyable</code>功能的动物，就多继承一个<code>Flyable</code>，例如<code>Bat</code>：</p>
<pre><code class="language-python">class Bat(Mammal, Flyable):
    pass
</code></pre>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。<br>
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>为了更好地看出继承关系，我们把<code>Runnable</code>和<code>Flyable</code>改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让某个动物同时拥有好几个<code>MixIn</code>：</p>
<pre><code class="language-python">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><code>MixIn</code>的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个<code>MixIn</code>的功能，而不是设计多层次的复杂的继承关系。</p>
<p><code>Python</code>自带的很多库也使用了<code>MixIn</code>。举个例子，<code>Python</code>自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的<code>TCP</code>服务，定义如下：</p>
<pre><code class="language-python">class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的<code>UDP</code>服务，定义如下：</p>
<pre><code class="language-python">class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个<code>CoroutineMixIn</code>：</p>
<pre><code class="language-python">class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br>
由于<code>Python</code>允许使用多重继承，因此，<code>MixIn</code>就是一种常见的设计。<br>
只允许单一继承的语言（如<code>Java</code>）不能使用<code>MixIn</code>的设计。</p>
<ul>
<li>若是父类中有相同的方法名，而在子类使用时未指定，<code>python</code>从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
</ul>
<pre><code class="language-python">#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
 
#另一个类，多重继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
 
#多重继承
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<ul>
<li><code>super()</code><br>
如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</li>
</ul>
<pre><code class="language-python">class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
调用子类方法
调用父类方法
</code></pre>
<p>如果重写了<code>__init__</code>时，要继承父类的构造方法，可以使用 <code>super</code> 关键字：</p>
<pre><code class="language-python">super(子类，self).__init__(参数1，参数2，....)
</code></pre>
<h4 id="定制类">定制类</h4>
<h5 id="__str__"><code>__str__</code></h5>
<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。<br>
怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name: %s)' % self.name
print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>
但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p>
<pre><code class="language-python">s = Student('Michael')
s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h5 id="__iter__"><code>__iter__</code></h5>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，<code>Python</code>的<code>for</code>循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br>
我们以斐波那契数列为例，写一个<code>Fib</code>类，可以作用于<code>for</code>循环：</p>
<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把<code>Fib</code>实例作用于<code>for</code>循环：</p>
<pre><code class="language-python">for n in Fib():
    print(n)
1
1
2
3
5
...
46368
75025
</code></pre>
<h5 id="__getitem__"><code>__getitem__</code></h5>
<p><code>Fib</code>实例虽然能作用于<code>for</code>循环，看起来和<code>list</code>有点像，但是，把它当成<code>list</code>来使用还是不行,要表现得像<code>list</code>那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<pre><code class="language-python">class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
f = Fib()
f[0]
1
f[1]
1
f[2]
2
f[3]
3
f[10]
89
f[100]
573147844013817084101
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
f = Fib()
f[0:5]
[1, 1, 2, 3, 5]
f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作<code>key</code>的<code>object</code>，例如<code>str</code>。<br>
与之对应的是<code>__setitem__()</code>方法，把对象视作<code>list</code>或<code>dict</code>来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。<br>
总之，通过上面的方法，我们自己定义的类表现得和<code>Python</code>自带的<code>list</code>、<code>tuple</code>、<code>dict</code>没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h5 id="__getattr__"><code>__getattr__</code></h5>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p>
<pre><code class="language-python">s = Student()
print(s.name)
Michael
print(s.score)
Traceback (most recent call last):
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个<code>attribute</code>。</p>
<p>要避免这个错误，除了可以加上一个<code>score</code>属性外，<code>Python</code>还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p>
<pre><code class="language-python">class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如<code>score</code>，<code>Python</code>解释器会试图调用<code>__getattr__(self, 'score')</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值。<br>
返回函数也是完全可以的：</p>
<pre><code class="language-oython">class Student(object):
    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="language-python">s.age()
25
</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在_<code>_getattr__</code>中查找。<br>
此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让<code>class</code>只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-python">class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<h5 id="__call__"><code>__call__</code></h5>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在<code>Python</code>中，答案是肯定的。<br>
任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
调用方式如下：
```python
s = Student('Michael')
s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。<br>
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。<br>
那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例。<br>
通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h4 id="枚举类">枚举类</h4>
<pre><code class="language-python">from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="language-python">for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从1开始计数。<br>
如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<pre><code class="language-python">from enum import Enum, unique
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。<br>
访问这些枚举类型可以有若干种方法：</p>
<pre><code class="language-python">day1 = Weekday.Mon
print(day1)
Weekday.Mon
print(Weekday.Tue)
Weekday.Tue
print(Weekday['Tue'])
Weekday.Tue
print(Weekday.Tue.value)
2
rint(day1 == Weekday.Mon)
True
print(day1 == Weekday.Tue)
False
rint(Weekday(1))
Weekday.Mon
print(day1 == Weekday(1))
True
Weekday(7)
Traceback (most recent call last):
ValueError: 7 is not a valid Weekday
for name, member in Weekday.__members__.items():
    print(name, '=&gt;', member)
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据<code>value</code>的值获得枚举常量。<br>
<code>Enum</code>可以把一组相关常量定义在一个<code>class</code>中，且<code>class</code>不可变，而且成员可以直接比较。</p>
<h4 id="使用元类">使用元类</h4>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。<br>
比方说我们要定义一个<code>Hello</code>的<code>class</code>，就写一个<code>hello.py</code>模块：</p>
<pre><code class="language-python">class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当<code>Python</code>解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的<code>class</code>对象，测试如下：</p>
<pre><code class="language-python">from hello import Hello
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个<code>class</code>，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</p>
<p>我们说<code>class</code>的定义是运行时动态创建的，而创建<code>class</code>的方法就是使用<code>type()</code>函数。</p>
<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)</code>...的定义：</p>
<pre><code class="language-python">def fn(self, name='world'): # 先定义函数
    print('Hello, %s.' % name)
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个<code>class</code>对象，<code>type()</code>函数依次传入3个参数：<br>
<code>class</code>的名称；<br>
继承的父类集合，注意<code>Python</code>支持多重继承，如果只有一个父类，别忘了<code>tuple</code>的单元素写法；<br>
class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。<br>
通过<code>type()</code>函数创建的类和直接写<code>class</code>是完全一样的，因为<code>Python</code>解释器遇到<code>class</code>定义时，仅仅是扫描一下<code>class</code>定义的语法，然后调用<code>type()</code>函数创建出<code>class</code>。<br>
正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。<br>
<code>metaclass</code><br>
除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用<code>metaclass</code>。<br>
<code>metaclass</code>，直译为元类，简单的解释就是：<br>
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>
但是如果我们想创建出类呢？那就必须根据<code>metaclass</code>创建出类，所以：先定义<code>metaclass</code>，然后创建类。<br>
连接起来就是：先定义<code>metaclass</code>，就可以创建类，最后创建实例。<br>
所以，<code>metaclass</code>允许你创建类或者修改类。换句话说，你可以把类看成是<code>metaclass</code>创建出来的“实例”。</p>
<p><code>metaclass</code>是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用<code>metaclass</code>的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。<br>
我们先看一个简单的例子，这个<code>metaclass</code>可以给我们自定义的<code>MyList</code>增加一个<code>add</code>方法：</p>
<p>定义<code>ListMetaclass</code>，按照默认习惯，<code>metaclass</code>的类名总是以<code>Metaclass</code>结尾，以便清楚地表示这是一个<code>metaclass</code>：</p>
<pre><code class="language-python"># metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
有了`ListMetaclass`，我们在定义类的时候还要指示使用`ListMetaclass`来定制类，传入关键字参数`metaclass`：
```python
class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示<code>Python</code>解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<br>
<code>__new__()</code>方法接收到的参数依次是：<br>
当前准备创建的类的对象；<br>
类的名字；<br>
类继承的父类集合；<br>
类的方法集合。<br>
测试一下MyList是否可以调用add()方法：</p>
<pre><code class="language-python">L = MyList()
L.add(1)
L
[1]
</code></pre>
<p>而普通的list没有<code>add()</code>方法：</p>
<pre><code class="language-python">L2 = list()
L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过<code>metaclass</code>修改纯属变态。</p>
<h2 id="命名空间和作用域">命名空间和作用域</h2>
<h3 id="三种命名空间">三种命名空间：</h3>
<ul>
<li>内置名称(<code>built-in names</code>)， <code>Python</code> 语言内置的名称，比如函数名 <code>abs</code>、<code>char</code> 和异常名称 <code>BaseException</code>、<code>Exception</code> 等等。</li>
<li>全局名称(<code>global names</code>)，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li>
<li>局部名称(<code>local names</code>)，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）<br>
<code>Python</code> 的查找顺序为：<strong>局部的命名空间</strong> -&gt; <strong>全局命名空间</strong> -&gt; <strong>内置命名空间</strong>。</li>
</ul>
<h4 id="四种作用域">四种作用域：</h4>
<ul>
<li>L(Local)：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li>E(Enclosing)：包含了非局部(<code>non-local</code>)也非全局(<code>non-global</code>)的变量。比如两个嵌套函数，一个函数（或类） <code>A</code> 里面又包含了一个函数 <code>B</code> ，那么对于<code>B</code> 中的名称来说 <code>A</code> 中的作用域就为 <code>nonlocal</code>。</li>
<li>G(<code>Global</code>)：当前脚本的最外层，比如当前模块的全局变量。</li>
<li>B(<code>Built-in</code>)： 包含了内建的变量/关键字等。最后被搜索。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200320015425.png" alt="" loading="lazy"><br>
<code>Python</code> 中只有模块(<code>module</code>)，类(<code>class</code>)以及函数(<code>def</code>、<code>lambda</code>)才会引入新的作用域，其它的代码块(如 <code>if</code>/<code>elif</code>/<code>else</code>/、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</li>
</ul>
<pre><code class="language-python">if True:
    msg = 'I am from Runoob'
msg
'I am from Runoob'
</code></pre>
<p>实例中 <code>msg</code> 变量定义在 <code>if</code> 语句块中，但外部还是可以访问的。<br>
如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<pre><code class="language-python">def test():
    msg_inner = 'I am from Runoob'
msg_inner
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'msg_inner' is not defined
</code></pre>
<p>从报错的信息上看，说明了 <code>msg_inner</code> 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="global-和-nonlocal关键字"><code>global</code> 和 <code>nonlocal</code>关键字</h4>
<pre><code class="language-python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
fun1()
print(num)
1
123
123
</code></pre>
<p>如果要修改嵌套作用域(<code>enclosing</code> 作用域，外层非全局作用域)中的变量则需要 <code>nonlocal</code> 关键字了，如下实例：</p>
<pre><code class="language-python">def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
100
100
</code></pre>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<pre><code class="language-python">a = 10
def test():
    a = a + 1
    print(a)
test()
Traceback (most recent call last):
  File &quot;test.py&quot;, line 7, in &lt;module&gt;
    test()
  File &quot;test.py&quot;, line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>错误信息为局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。<br>
修改 <code>a</code> 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<pre><code class="language-python">a = 10
def test(a):
    a = a + 1
    print(a)
test(a)
11
</code></pre>
<h2 id="错误和异常处理">错误和异常处理</h2>
<pre><code class="language-python">def attempt_float(x):
    try:
        return float(x)
    except ValueError:
        return x
</code></pre>
<p>某些情况下，你可能不想抑制异常，你想无论<code>try</code>部分的代码是否成功，都执行一段代码。可以使用<code>finally</code>：</p>
<pre><code class="language-python">f = open(path, 'w')

try:
    write_to_file(f)
finally:
    f.close()
</code></pre>
<p>这里，文件处理<code>f</code>总会被关闭。相似的，你可以用<code>else</code>让只在<code>try</code>部分成功的情况下，才执行代码：</p>
<pre><code class="language-python">f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
</code></pre>
<ul>
<li>可以有多个<code>except</code>来捕获不同类型的错误：</li>
</ul>
<pre><code class="language-python">try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<ul>
<li>Python的错误其实也是<code>class</code>，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</li>
</ul>
<pre><code class="language-python">try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
第二个`except`永远也捕获不到`UnicodeError`，因为`UnicodeError`是`ValueError`的子类，如果有，也被第一个`except`给捕获了。
</code></pre>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>
<pre><code class="language-python">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
</code></pre>
<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>
<pre><code class="language-python">def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise
bar()
</code></pre>
<p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去。<br>
这种错误处理方式相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个<code>Error</code>，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="language-python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p>
<ul>
<li><code>Python</code> 使用 <code>raise</code> 语句抛出一个指定的异常。<br>
<code>raise</code>语法格式如下：</li>
</ul>
<pre><code class="language-python">raise [Exception [, args [, traceback]]]
</code></pre>
<p>以下实例如果 x 大于 5 就触发异常:</p>
<pre><code>x = 10
if x &gt; 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
</code></pre>
<p>执行以上代码会触发异常：</p>
<pre><code class="language-python">Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre>
<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<br>
如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <code>raise</code> 语句就可以再次把它抛出。</p>
<pre><code class="language-python">try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre>
<h3 id="调试">调试</h3>
<ul>
<li>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>(assert)</code>来替代：</li>
</ul>
<pre><code class="language-python">def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n
def main():
    foo('0')
</code></pre>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>
如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>
<pre><code class="language-shell">$ python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
</code></pre>
<ul>
<li><code>logging</code><br>
把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</li>
</ul>
<pre><code class="language-python">import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
</code></pre>
<pre><code class="language-shell">$ python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。<br>
<code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如<code>console</code>和文件。</p>
<h2 id="文件和操作系统">文件和操作系统</h2>
<ul>
<li>为了打开一个文件以便读写，可以使用内置的<code>open</code>函数以及一个相对或绝对的文件路径：</li>
</ul>
<pre><code class="language-python">path = 'examples/segismundo.txt'
f = open(path)
</code></pre>
<ul>
<li>默认情况下，文件是以只读模式<code>('r')</code>打开的。然后，我们就可以像处理列表那样来处理这个文件句柄<code>f</code>了，比如对行进行迭代：</li>
</ul>
<pre><code class="language-python">for line in f:
    pass
</code></pre>
<ul>
<li>如果使用<code>open</code>创建文件对象，一定要用<code>close</code>关闭它。关闭文件可以返回操作系统资源：</li>
</ul>
<pre><code class="language-python">f.close()
</code></pre>
<ul>
<li>用<code>with</code>语句可以可以更容易地清理打开的文件,这样可以在退出代码块时，自动关闭文件：</li>
</ul>
<pre><code>with open(path) as f:
    lines = [x.rstrip() for x in f]
</code></pre>
<ul>
<li>读写模式：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211525.png" alt="" loading="lazy"></li>
<li>向文件写入，可以使用文件的<code>write</code>或<code>writelines</code>方法。例如，我们可以创建一个无空行版的<code>prof_mod.py</code>：</li>
</ul>
<pre><code class="language-python">with open('tmp.txt', 'w') as handle:
    handle.writelines(x for x in open(path) if len(x) &gt; 1)
with open('tmp.txt') as f:
    lines = f.readlines()
</code></pre>
<pre><code class="language-python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。<br>
以<code>'w'</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>'a'</code>以追加<code>(append)</code>模式写入。</p>
<ul>
<li>调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。</li>
<li>常用文件方法<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211726.png" alt="" loading="lazy"></li>
</ul>
<h3 id="操作文件和目录">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<ul>
<li>查看当前目录的绝对路径:</li>
</ul>
<pre><code class="language-python">os.path.abspath('.')
'/Users/michael'
- 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
````python
os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
</code></pre>
<ul>
<li>创建一个目录:</li>
</ul>
<pre><code class="language-python">os.mkdir('/Users/michael/testdir')
</code></pre>
<ul>
<li>删掉一个目录:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>os.rmdir('/Users/michael/testdir')<br>
把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符.<br>
同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-python">os.path.split('/Users/michael/testdir/file.txt')

('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<pre><code class="language-python">os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。<br>
文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<ul>
<li>对文件重命名:</li>
</ul>
<pre><code>os.rename('test.txt', 'test.py')
</code></pre>
<ul>
<li>删掉文件:</li>
</ul>
<pre><code class="language-python">os.remove('test.py')
</code></pre>
<p><code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<h3 id="序列化">序列化</h3>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。</p>
<p>要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-python"> json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><code>Python</code>的<code>dict</code>对象可以直接序列化为<code>JSON</code>的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>
<pre><code class="language-python">import json
class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p>
<pre><code class="language-python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<code>Student</code>对象不是一个可序列化为<code>JSON</code>的对象。<br>
前面的代码之所以无法把<code>Student</code>类实例序列化为<code>JSON</code>，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个<code>JSON</code>的<code>{}</code>对象。<br>
可选参数<code>default</code>就是把任意一个对象变成一个可序列为<code>JSON</code>的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="language-python">def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>：</p>
<pre><code class="language-python">print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p>
<pre><code class="language-python">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的<code>class</code>。<br>
同样的道理，如果我们要把<code>JSON</code>反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="language-python">def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的<code>Student</code>实例对象。</p>
<h2 id="标准库">标准库</h2>
<h3 id="collections"><code>collections</code></h3>
<h4 id="namedtuple"><code>namedtuple</code></h4>
<pre><code class="language-python">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
p.x
1
p.y
2
</code></pre>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>
这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<h4 id="deque"><code>deque</code></h4>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<pre><code class="language-python">from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
# 清除所有元素
q.clear()
# 计算x的个数
q.count(x)
#移除找到的第一个 value。
q.remove(value)
#逆序排列
q.reverse()
`deque`除了实现`list`的`append()`和`pop()`外，还支持`appendleft()`和`popleft()`，这样就可以非常高效地往头部添加或删除元素。
#### `defaultdict`
使用`dict`时，如果引用的`Key`不存在，就会抛出`KeyError`。如果希望`key`不存在时，返回一个默认值，就可以用`defaultdict`：
```python
from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
dd['key1'] # key1存在
'abc'
dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<p>默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="ordereddict"><code>OrderedDict</code></h4>
<p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。<br>
如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>：</p>
<pre><code class="language-python">from collections import OrderedDict
d = dict([('a', 1), ('b', 2), ('c', 3)])
d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，<code>OrderedDict的Key</code>会按照插入的顺序排列，不是<code>Key</code>本身排序：</p>
<pre><code class="language-python">od = OrderedDict()
od['z'] = 1
od['y'] = 2
od['x'] = 3
list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p><code>OrderedDict</code>可以实现一个<code>FIFO</code>（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的<code>Key</code>：</p>
<pre><code class="language-python">from collections import OrderedDict
class LastUpdatedOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity
    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h4 id="chainmap"><code>ChainMap</code></h4>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。<br>
什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。<br>
下面的代码演示了如何查找user和color这两个参数：</p>
<pre><code class="language-python">from collections import ChainMap
import os, argparse
# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}
# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }
# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)
# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
</code></pre>
<p>没有任何参数时，打印出默认参数：</p>
<pre><code class="language-shell">$ python3 use_chainmap.py 
color=red
user=guest
</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code class="language-shell">$ python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<pre><code class="language-shell">$ user=admin color=green python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<h4 id="counter"><code>Counter</code></h4>
<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code class="language-python">from collections import Counter
c = Counter()
for ch in 'programming':
c[ch] = c[ch] + 1
c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
c.update('hello') # 也可以一次性update
c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<ul>
<li><code>elements()</code>:返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，<code>elements()</code> 将会忽略它。</li>
</ul>
<pre><code class="language-python">c = Counter(a=4, b=2, c=0, d=-2)
sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']
</code></pre>
<ul>
<li><code>most_common([n])</code>:返回一个列表，其中包含<code>n</code> 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 <code>n</code> 被省略或为 <code>None</code>，<code>most_common()</code> 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序：</li>
</ul>
<pre><code class="language-python">Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
</code></pre>
<pre><code class="language-python">c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
c &amp; d                       # intersection:  min(c[x], d[x]) 
Counter({'a': 1, 'b': 1})
c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
</code></pre>
<ul>
<li><code>heap</code><br>
这个模块提供了堆队列算法的实现，也称为优先队列算法。<br>
堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <code>k</code> ，都有 <code>heap[k]</code> &lt;= <code>heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。<br>
这个<code>API</code>与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 <code>Python</code> 使用从零开始的索引。 （b）我们的 <code>pop</code> 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。但是可以通过取反来实现最大堆。<br>
要创建一个堆，可以使用<code>list</code>来初始化为 <code>[]</code> ，或者你可以通过一个函数 <code>heapify()</code> ，来把一个<code>list</code>转换成堆。</li>
<li><code>heapq.heappush(heap, item)</code>:将 <code>item</code> 的值加入 <code>heap</code> 中，保持堆的不变性。</li>
<li><code>heapq.heappop(heap)</code>:弹出并返回 <code>heap</code> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <code>IndexError</code> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</li>
<li><code>heapq.heappushpop(heap, item)</code>:将 <code>item</code> 放入堆中，然后弹出并返回 <code>heap</code> 的最小元素。该组合操作比先调用  <code>heappush()</code> 再调用 <code>heappop()</code> 运行起来更有效率。</li>
<li><code>heapq.heapify(x)</code>:将<code>list x</code> 转换成堆，原地，线性时间内。</li>
<li><code>heapq.heapreplace(heap, item)</code>:弹出并返回 <code>heap</code> 中最小的一项，同时推入新的 <code>item</code>。 堆的大小不变。 如果堆为空则引发 <code>IndexError</code>。<br>
这个单步骤操作比 <code>heappop()</code> 加 <code>heappush()</code> 更高效，并且在使用固定大小的堆时更为适宜。 <code>pop/push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>
返回的值可能会比添加的 <code>item</code> 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。<br>
-<code>heapq.merge(*iterables, key=None, reverse=False)</code><br>
将多个已排序的输入合并为一个已排序的输出。返回已排序值的<code>iterator</code>。<br>
类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</li>
<li><code>heapq.nlargest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code>个最大元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</li>
<li><code>heapq.nsmallest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code> 个最小元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。<br>
两个函数在 <code>n</code> 值较小时性能最好。 对于更大的值，使用 <code>sorted()</code> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <code>min()</code> 和 <code>max()</code> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。<br>
堆排序:<br>
堆排序 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</li>
</ul>
<pre><code class="language-python">def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]
heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>如果我们想要<code>heapq</code>排序的是一个对象。那么heapq并不知道应该依据对象当中的哪个参数来作为排序的衡量标准，所以这个时候，需要我们自己定义一个获取关键字的函数，传递给<code>heapq</code>，这样才可以完成排序。<br>
比如说，我们现在有一批电脑，我们希望<code>heapq</code>能够根据电脑的价格排序：</p>
<pre><code class="language-python">laptops = [
    {'name': 'ThinkPad', 'amount': 100, 'price': 91.1},
    {'name': 'Mac', 'amount': 50, 'price': 543.22},
    {'name': 'Surface', 'amount': 200, 'price': 21.09},
    {'name': 'Alienware', 'amount': 35, 'price': 31.75},
    {'name': 'Lenovo', 'amount': 45, 'price': 16.35},
    {'name': 'Huawei', 'amount': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>在调用<code>nlargest</code>和<code>nsmallest</code>的时候，我们额外传递了一个参数<code>key</code>，我们传入的是一个匿名函数，它返回的结果是这个对象的<code>price</code>，也就是说我们希望<code>heapq</code>根据对象的<code>price</code>来进行排序。<br>
这类似于 <code>sorted(iterable)</code>，但与 <code>sorted()</code> 不同的是这个实现是不稳定的。</p>
<h3 id="bisect"><code>bisect</code></h3>
<ul>
<li><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code><br>
在 <code>a</code> 中找到 <code>x</code> 合适的插入点以维持有序。参数 <code>lo</code> 和 <code>hi</code> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <code>x</code> 已经在 <code>a</code> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <code>a</code> 是列表（<code>list</code>）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code>，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</li>
<li><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.bisect(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>bisect_left()</code>，但是返回的插入点是 <code>a</code> 中已存在元素 <code>x</code> 的右侧。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi]) for the right side</code>。</li>
<li><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code><br>
将 <code>x</code> 插入到一个有序序列 <code>a</code> 里，并维持其有序。如果 <code>a</code> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 <code>O(log n)</code> 的，插入却是 <code>O(n)</code> 的。</li>
<li><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.insort(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>insort_left()</code>，但是把 <code>x</code> 插入到 <code>a</code> 中已存在元素 <code>x</code>的右侧。<br>
函数 <code>bisect()</code> 还可以用于数字表查询。这个例子是使用 <code>bisect()</code> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：<code>90</code> 分及以上是 <code>'A'</code>，<code>80</code> 到 <code>89</code> 是 <code>'B'</code>，以此类推</li>
</ul>
<pre><code class="language-python">def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']
</code></pre>
<h3 id="itertools"><code>itertools</code></h3>
<ul>
<li><code>itertools.count(start=0,step=1)</code>:创建一个迭代器，生成从 <code>n</code> 开始的连续整数，如果忽略 <code>n</code>，则从 <code>0</code> 开始计算。</li>
</ul>
<pre><code class="language-python">for n in itertools.count():
    if 100000 &lt; n &lt; 100010:
        print n
    if n &gt; 1000000:
        break
100001
100002
100003
100004
100005
100006
100007
100008
100009
</code></pre>
<ul>
<li><code>itertools.cycle(iterable)</code>:把传入的一个序列无限重复下去。</li>
</ul>
<pre><code class="language-python">for c in itertools.cycle(&quot;AB&quot;):
    if count &gt; 4:
        break
    print c
   count += 1     
A
B
A
B
A
</code></pre>
<ul>
<li><code>itertools.repeat(object [,times])</code>:创建一个迭代器，重复生成 <code>object</code>，<code>times</code>（如果已提供）指定重复计数，如果未提供 <code>times</code>，将无止尽返回该对象。</li>
</ul>
<pre><code class="language-python">for x in itertools.repeat(&quot;hello world&quot;, 5):
    print x    
hello world
hello world
hello world
hello world
hello world
</code></pre>
<ul>
<li><code>itertools.chain(*iterables)</code>:把一组迭代对象串联起来，形成一个更大的迭代器。</li>
</ul>
<pre><code class="language-python">for c in itertools.chain('ABC', 'XYZ'):
    print c    
A
B
C
X
Y
Z
</code></pre>
<ul>
<li><code>itertools.permutations(iterable[, r])：返回</code>iterable<code>中任意取</code>r<code>个元素做排列的元组的迭代器，如果不指定</code>r<code>，那么序列的长度与</code>iterable` 中的项目数量相同。</li>
</ul>
<pre><code class="language-python">for elem in itertools.permutations('abc', 2):
    print elem
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
for elem in itertools.permutations('abc'):
    print elem
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
</code></pre>
<ul>
<li><code>itertools.combinations(iterable, r)</code>:组合，如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，<code>ab</code> 和 <code>ba</code> 则视为重复，此时只放回 <code>ab</code>. 示例：</li>
</ul>
<pre><code class="language-python">for elem in itertools.combinations('abc', 2):
    print elem   
('a', 'b')
('a', 'c')
('b', 'c')
</code></pre>
<ul>
<li><code>itertools.combinations_with_replacement(iterable, r)</code>:与 <code>combinations</code> 类似，但允许重复值，即如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，会多出 <code>aa</code>, <code>bb</code>, <code>cc</code>。</li>
<li><code>itertools.compress(data, selectors)</code>:<br>
相当于 <code>bool</code> 选取，只有当 <code>selectors</code> 对应位置的元素为 <code>true</code> 时，才保留 <code>data</code> 中相应位置的元素，否则去除。</li>
</ul>
<pre><code class="language-python">list(itertools.compress('abcdef', [1, 1, 0, 1, 0, 1]))
['a', 'b', 'd', 'f']
list(itertools.compress('abcdef', [True, False, True]))
['a', 'c']
</code></pre>
<ul>
<li><code>itertools.groupby(iterable[, keyfunc])</code>:对<code>iterable</code>中的元素进行分组。<code>keyfunc</code> 是分组函数，用于对 <code>iterable</code> 的连续项进行分组，如果不指定，则默认对 <code>iterable</code> 中的连续相同项进行分组，返回一个 <code>(key, sub-iterator)</code> 的迭代器。</li>
</ul>
<pre><code class="language-python">for key, value_iter in itertools.groupby('aaabbbaaccd'):
    print key, list(value_iter)  
a ['a', 'a', 'a']
b ['b', 'b', 'b']
a ['a', 'a']
c ['c', 'c']
d ['d']
data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f']
for key, value_iter in itertools.groupby(data, len):
    print key, list(value_iter)   
1 ['a']
2 ['bb', 'cc']
3 ['ddd', 'eee']
1 ['f']
</code></pre>
<p>注意，注意，注意：必须先排序后才能分组，因为<code>groupby</code>是通过比较相邻元素来分组的。可以看第二个例子，因为 <code>a</code> 和<code>f</code> 没有排在一起，所以最后没有分组到同一个列表中。</p>
<ul>
<li><code>itertools.islice(iterable, [start,] stop [, step])</code>:切片选择，<code>start</code> 是开始索引，<code>stop</code> 是结束索引，<code>step</code> 是步长，<code>start</code>和 <code>step</code> 可选。</li>
</ul>
<pre><code class="language-python">list(itertools.islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
list(itertools.islice(itertools.count(), 6))
[0, 1, 2, 3, 4, 5]
list(itertools.islice(itertools.count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
list(itertools.islice(itertools.count(), 3, 10, 2))
[3, 5, 7, 9]
</code></pre>
<ul>
<li><code>itertools.tee(iterable, n=2)</code>:从 <code>iterable</code> 创建 <code>n</code> 个独立的迭代器，以元组的形式返回。</li>
</ul>
<pre><code class="language-python">itertools.tee(&quot;abcedf&quot;)
(&lt;itertools.tee at 0x7fed7b8f59e0&gt;, &lt;itertools.tee at 0x7fed7b8f56c8&gt;)
iter1, iter2 = itertools.tee(&quot;abcedf&quot;)
list(iter1)
['a', 'b', 'c', 'e', 'd', 'f']
list(iter2)
['a', 'b', 'c', 'e', 'd', 'f']
</code></pre>
<ul>
<li><code>itertools.product(*iterables, repeat=1)</code>:<br>
大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。<br>
嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。<br>
要计算可迭代对象自身的笛卡尔积，将可选参数 <code>repeat</code> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</li>
<li><code>itertools.dropwhile</code></li>
</ul>
<pre><code class="language-python"> x = itertools.dropwhile(lambda e: e &lt; 5, range(10))
print(list(x))
[5, 6, 7, 8, 9]
</code></pre>
<ul>
<li><code>itertools.filterfalse</code>:<br>
保留对应真值为<code>False</code>的元素</li>
</ul>
<pre><code class="language-python">x = itertools.filterfalse(lambda e: e &lt; 5, (1, 5, 3, 6, 9, 4))
print(list(x))
[5, 6, 9]
</code></pre>
<h3 id="math"><code>math</code></h3>
<ul>
<li><code>math.ceil(x)</code>:返回 <code>x</code> 的上限，即大于或者等于 <code>x</code> 的最小整数。</li>
<li><code>math.comb(n, k)</code>:返回不重复且无顺序地从 <code>n</code> 项中选择 <code>k</code> 项的方式总数。</li>
<li><code>math.fabs(x)</code>:返回 <code>x</code> 的绝对值。</li>
<li><code>math.floor(x)</code>:返回 <code>x</code> 的向下取整，小于或等于 <code>x</code> 的最大整数。</li>
<li><code>math.gcd(a, b)</code>:最大公约数</li>
<li><code>math.exp(x)</code>:返回 <code>e</code> 次 <code>x</code> 幂</li>
<li><code>math.pow(x, y)</code>:将返回 <code>x</code> 的 <code>y</code> 次幂。</li>
<li><code>math.sqrt(x)</code>:返回 <code>x</code> 的平方根。</li>
<li><code>math.pi</code>:数学常数 π = 3.141592...，精确到可用精度。</li>
<li><code>math.e</code>:数学常数 e = 2.718281...，精确到可用精度。</li>
<li><code>math.inf</code>:浮点正无穷大。</li>
</ul>
<h3 id="time"><code>time</code></h3>
<p>在 <code>Python</code> 中，用三种方式来表示时间，分别是时间戳、格式化时间字符串和结构化时间</p>
<ul>
<li>时间戳（<code>timestamp</code>）：也就是 1970 年 1 月 1 日之后的秒，例如 1506388236.216345，可以通过<code>time.time()</code>获得。时间戳是一个浮点数，可以进行加减运算，但请注意不要让结果超出取值范围。</li>
<li>格式化的时间字符串（<code>string_time</code>）：也就是年月日时分秒这样的我们常见的时间字符串，例如2017-09-26 09:12:48，可以通过<code>time.strftime('%Y-%m-%d')</code>获得;<br>
结构化时间（<code>struct_time</code>）：一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code>，可以通过<code>time.localtime()</code>获得。</li>
<li>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>等方法可以获得一个格式化时间字符串。</li>
</ul>
<pre><code class="language-python">time.strftime('%Y-%m-%d %H:%M:%S')
'2017-09-26 10:04:28'
</code></pre>
<p><code>time.strptime(string[,format])</code><br>
将格式化时间字符串转化成结构化时间。该方法是<code>time.strftime()</code>方法的逆操作。<code>time.strptime()</code>方法根据指定的格式把一个时间字符串解析为时间元组。要注意的是，你提供的字符串要和 <code>format</code> 参数的格式一一对应，如果 <code>string</code> 中日期间使用<code>“-”</code>分隔，<code>format</code> 中也必须使用<code>“-”</code>分隔，时间中使用冒号<code>“:”</code>分隔，后面也必须使用冒号分隔，否则会报格式不匹配的错误。并且值也要在合法的区间范围内。</p>
<pre><code class="language-python">stime = &quot;2017-09-26 12:11:30&quot;
st = time.strptime(stime,&quot;%Y-%m-%d %H:%M:%S&quot;)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321211914.png" alt="" loading="lazy"></figure>
<ul>
<li><code>time.time()</code>:返回当前系统时间戳。时间戳可以做算术运算。</li>
</ul>
<pre><code class="language-python">time.time()
1506391907.020303
该方法经常用于计算程序运行时间：
```python
import time
def func():
    time.sleep(1.14)
    pass

t1 = time.time()
func()
t2 = time.time()
print(t2 - t1)
</code></pre>
<h3 id="datetime"><code>datetime</code></h3>
<pre><code class="language-python">from datetime import datetime, date, time
dt = datetime(2011, 10, 29, 20, 30, 21)
dt.day
29
dt.minute
30
</code></pre>
<ul>
<li>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</li>
</ul>
<pre><code class="language-python">dt.date()
datetime.date(2011, 10, 29)
dt.time()
datetime.time(20, 30, 21)
</code></pre>
<ul>
<li><code>strftime</code>方法可以将<code>datetime</code>格式化为字符串：</li>
</ul>
<pre><code class="language-python">dt.strftime('%m/%d/%Y %H:%M')
'10/29/2011 20:30'
</code></pre>
<ul>
<li><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</li>
</ul>
<pre><code class="language-python">datetime.strptime('20091031', '%Y%m%d')
datetime.datetime(2009, 10, 31, 0, 0)
</code></pre>
<ul>
<li>计算差值</li>
</ul>
<pre><code class="language-python">now = date.today()
birthday = date(1964, 7, 31)
age = now - birthday
age.days
14368
</code></pre>
<ul>
<li>格式化命令</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317190745.png" alt="" loading="lazy"></figure>
<h2 id="os"><code>os</code></h2>
<ul>
<li><code>os.path.exists(path)</code>:路径存在则返回<code>True</code>,路径损坏返回<code>False</code></li>
<li><code>os.path.join(path1[, path2[, ...]])</code>:把目录和文件名合成一个路径</li>
<li><code>os.system('mkdir today')</code>:命令行命令</li>
<li><code>os.environ</code>:<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;7&quot;</code></li>
</ul>
<h2 id="path"><code>Path</code></h2>
<p>在过去，文件的路径是纯字符串，现在它会是一个<code>pathlib.Path</code>对象:</p>
<pre><code class="language-python">from pathlib import Path
p = Path('/home/ubuntu')
PosixPath('/home/ubuntu')
str(p)
'/home/ubuntu'
</code></pre>
<p>过去路径拼接最正确的方法是用<code>os.path.join</code>:</p>
<pre><code class="language-python">os.path.join('/', 'home', 'dongwm/code')
'/home/dongwm/code'
os.path.join('/home', 'dongwm/code')
'/home/dongwm/code'
现在可以用`pathlib.Path`提供的`joinpath`来拼接:
```python
Path('/').joinpath('home', 'dongwm/code')
PosixPath('/home/dongwm/code')
但是更简单和方便的方法是用`/`运算符:
```python
Path('/') / 'home' / 'dongwm/code'
PosixPath('/home/dongwm/code')
Path('/') / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
'/' / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
</code></pre>
<p>使用<code>Path</code>对象的<code>parents</code>属性可以拿到各级目录列表(索引值越大越接近<code>root</code>)，而<code>parent</code>就表示父级目录:</p>
<pre><code class="language-python">p = Path('/Users/dongweiming/test')
p.parents[0]
PosixPath('/Users/dongweiming')
p.parents[1]
PosixPath('/Users')
p.parents[2]
PosixPath('/')
p.parent
PosixPath('/Users/dongweiming')
p.parent.parent
PosixPath('/Users')
</code></pre>
<p>获得文件后缀名:</p>
<pre><code class="language-python">p = Path('/usr/local/etc/my.cnf')
p.suffix, p.stem
('.cnf', 'my')
</code></pre>
<p>当文件有多个后缀，可以用<code>suffixes</code>返回文件所有后缀列表:</p>
<pre><code class="language-python">Path('my.tar.bz2').suffixes
['.tar', '.bz2']
Path('my.tar').suffixes
['.tar']
Path('my').suffixes
[]
</code></pre>
<p>Python语言没有内置创建文件的方法(<code>linux</code>下的<code>touch</code>命令)，过去这么做:</p>
<pre><code class="language-python">with open('new.txt', 'a') as f:
</code></pre>
<p>现在可以直接用<code>Path</code>的<code>touch</code>方法:</p>
<pre><code class="language-python">Path('new.txt').touch()
</code></pre>
<p><code>touch</code>接受<code>mode</code>参数，能够在创建时确认文件权限，还能通过<code>exist_ok</code>参数方式确认是否可以重复<code>touch</code>(默认可以重复创建，会更新文件的<code>mtime</code>)</p>
<ul>
<li><code>filename.exists()</code>；路径是否存在</li>
<li>打开文件：</li>
</ul>
<pre><code class="language-python">data_folder = Path(&quot;source_data/text_files/&quot;)
file_to_open = data_folder / &quot;raw_data.txt&quot;
print(file_to_open.read_text())
</code></pre>
<ul>
<li>与<code>os</code>模块对比<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321202526.png" alt="" loading="lazy"></li>
</ul>
<h2 id="第三方库">第三方库</h2>
<h3 id="h5py"><code>h5py</code></h3>
<p>h5py文件是存放两类对象的容器，数据集(<code>dataset</code>)和组(<code>group</code>)，<code>dataset</code>类似数组类的数据集合，和<code>numpy</code>的数组差不多。<code>group</code>是像文件夹一样的容器，它好比<code>python</code>中的字典，有键(<code>key</code>)和值(<code>value</code>)。<code>group</code>中可以存放<code>dataset</code>或者其他的<code>group</code>。”键”就是组成员的名称，”值”就是组成员对象本身(组或者数据集)</p>
<pre><code class="language-python">import h5py
</code></pre>
<h4 id="创建">创建</h4>
<pre><code class="language-python">with h5py.File('test.h5','w') as f:
</code></pre>
<h4 id="读取">读取</h4>
<pre><code class="language-python">with h5py.File('test.h5','r') as f:
</code></pre>
<p><code>h5py</code>文件就像一个 <code>Python</code> 字典，因此我们可以检查<code>key</code>,</p>
<pre><code class="language-python">list(f.keys())
['mydataset']
</code></pre>
<p>文件中有一个数据集，即<code>mydataset</code>:</p>
<pre><code class="language-python">dset = f['mydataset']
dset.shape
(100,)
dset.dtype
dtype('int32')
dset[...] = np.arange(100)
dset[0]
0
dset[10]
10
dset[0:100:10]
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
data = f['mydataset'][:]
</code></pre>
<h4 id="创建数据集">创建数据集：</h4>
<pre><code class="language-python">d1=f.create_dataset(&quot;dset1&quot;, (20,), 'i')
for key in f.keys():
    print(key)
    print(f[key].name)
    print(f[key].shape)
    print(f[key].value)
dset1
/dset1
(20,)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</code></pre>
<pre><code class="language-python">dset3 = f.create_dataset('subgroup2/dataset_three', (10,), dtype='i')
</code></pre>
<h4 id="赋值">赋值</h4>
<pre><code class="language-python">d1=f.create_dataset(&quot;dset1&quot;,(20,),'i')
d1[...]=np.arange(20)
#或者我们可以直接按照下面的方式创建数据集并赋值
f[&quot;dset2&quot;]=np.arange(15)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<p>如果我们有现成的<code>numpy</code>数组，那么可以在创建数据集的时候就赋值，这个时候就不必指定数据的类型和形状了，只需要把数组名传给参数<code>data</code>。</p>
<pre><code class="language-python">a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
</code></pre>
<h4 id="综合示例1">综合示例1</h4>
<pre><code class="language-python">#分别创建dset1,dset2,dset3这三个数据集
a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)

d2=f.create_dataset(&quot;dset2&quot;,(3,4),'i')
d2[...]=np.arange(12).reshape((3,4))

f[&quot;dset3&quot;]=np.arange(15)

for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
/dset3
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<h4 id="创建group需要首先以append模式打开文件">创建<code>group</code>,需要首先以<code>append</code>模式打开文件</h4>
<pre><code class="language-python">f = h5py.File('mydataset.hdf5', 'a')
grp = f.create_group(&quot;subgroup&quot;)
</code></pre>
<pre><code class="language-python">g1=f.create_group(&quot;bar&quot;)
#在bar这个组里面分别创建name为dset1,dset2的数据集并赋值。
g1[&quot;dset1&quot;]=np.arange(10)
g1[&quot;dset2&quot;]=np.arange(12).reshape((3,4))

for key in g1.keys():
    print(g1[key].name)
    print(g1[key].value)
/bar/dset1
[0 1 2 3 4 5 6 7 8 9]
/bar/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>
<p>注意观察数据集<code>dset1</code>和<code>dset2</code>的名字是不是有点和前面的不一样，如果是直接创建的数据集，不在任何组里面，那么它的名字就是<code>/+名字</code>，现在这两个数据集都在<code>bar</code>这个<code>group</code>(组)里面，名字就变成了<code>/bar+/</code>名字，是不是有点文件夹的感觉！继续看下面的代码，你会对<code>group</code>和<code>dataset</code>的关系进一步了解。</p>
<pre><code class="language-python">#创建组bar1,组bar2，数据集dset
g1=f.create_group(&quot;bar1&quot;)
g2=f.create_group(&quot;bar2&quot;)
d=f.create_dataset(&quot;dset&quot;,data=np.arange(10))

#在bar1组里面创建一个组car1和一个数据集dset1。
c1=g1.create_group(&quot;car1&quot;)
d1=g1.create_dataset(&quot;dset1&quot;,data=np.arange(10))

#在bar2组里面创建一个组car2和一个数据集dset2
c2=g2.create_group(&quot;car2&quot;)
d2=g2.create_dataset(&quot;dset2&quot;,data=np.arange(10))

#根目录下的组和数据集
for key in f.keys():
    print(f[key].name)
/bar1
/bar2
/dset

#bar1这个组下面的组和数据集
for key in g1.keys():
    print(g1[key].name)
/bar1/car1
/bar1/dset1
#bar2这个组下面的组和数据集
for key in g2.keys():
    print(g2[key].name)
/bar2/car2
/bar2/dset2
#顺便看下car1组和car2组下面都有什么，估计你都猜到了为空。
print(c1.keys())
print(c2.keys())
[]
[]
</code></pre>
<ul>
<li>综合示例2</li>
</ul>
<pre><code class="language-python">#遍历文件中的一级组
for group in f.keys():
    print (group)
    #根据一级组名获得其下面的组
    group_read = f[group]
    #遍历该一级组下面的子组
    for subgroup in group_read.keys():
        print subgroup     
        #根据一级组和二级组名获取其下面的dataset          
        dset_read = f[group+'/'+subgroup]                           
        #遍历该子组下所有的dataset
        for dset in dset_read.keys():
            #获取dataset数据
            dset1 = f[group+'/'+subgroup+'/'+dset]
            print dset1.name
            data = np.array(dset1)
            print data.shape
            x = data[...,0]
            y = data[...,1]        
</code></pre>
<h4 id="pandas对h5py的操作"><code>Pandas</code>对<code>h5py</code>的操作</h4>
<h5 id="写出">写出</h5>
<ul>
<li><code>path</code>：字符型输入，用于指定<code>h5</code>文件的名称（不在当前工作目录时需要带上完整路径信息）</li>
<li><code>mode</code>：用于指定<code>IO</code>操作的模式，与<code>Python</code>内建的<code>open()</code>中的参数一致，默认为<code>'a'</code>，即当指定文件已存在时不影响原有数据写入，指定文件不存在时则新建文件；<code>'r'</code>，只读模式；<code>'w'</code>，创建新文件（会覆盖同名旧文件）；<code>'r+'</code>，与<code>'a'</code>作用相似，但要求文件必须已经存在；</li>
<li><code>complevel</code>：<code>int</code>型，用于控制<code>h5</code>文件的压缩水平，取值范围在0-9之间，越大则文件的压缩程度越大，占用的空间越小，但相对应的在读取文件时需要付出更多解压缩的时间成本，默认为<code>0</code>，代表不压缩<br>
创建一个<code>HDF5 IO</code>对象<code>store</code>：</li>
</ul>
<pre><code class="language-python">store = pd.HDFStore('demo.h5')
s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
df = pd.DataFrame(np.random.randn(8, 3),
                 columns=['A', 'B', 'C'])
store['s'],store['df'] = s,df
</code></pre>
<p>从<code>pandas</code>中的数据结构直接导出到本地<code>h5</code>文件中：</p>
<pre><code class="language-python">#创建新的数据框
df_ = pd.DataFrame(np.random.randn(5,5))
#导出到已存在的h5文件中，这里需要指定key
df_.to_hdf(path_or_buf='demo.h5',key='df_')
#创建于本地demo.h5进行IO连接的store对象
store = pd.HDFStore('demo.h5')
#查看指定h5对象中的所有键
print(store.keys())
</code></pre>
<p>利用store对象的<code>put()</code>方法，其主要参数如下：</p>
<ul>
<li><code>key</code>：指定<code>h5</code>文件中待写入数据的<code>key</code></li>
<li><code>value</code>：指定与<code>key</code>对应的待写入的数据</li>
<li><code>format</code>：字符型输入，用于指定写出的模式，<code>'fixed'</code>对应的模式速度快，但是不支持追加也不支持检索；<code>'table'</code>对应的模式以表格的模式写出，速度稍慢，但是支持直接通过<code>store</code>对象进行追加和表格查询操作<br>
使用<code>put()</code>方法将数据存入<code>store</code>对象中：</li>
</ul>
<pre><code class="language-python">store.put(key='s',value=s);store.put(key='df',value=df)
</code></pre>
<p>既然是键值对的格式，那么可以查看<code>store</code>的<code>items</code>属性（注意这里<code>store</code>对象只有<code>items</code>和<code>keys</code>属性，没有<code>values</code>属性）：</p>
<pre><code class="language-python">store.items
</code></pre>
<p>调用<code>store</code>对象中的数据直接用对应的键名来索引即可：</p>
<pre><code class="language-python">store['df']
</code></pre>
<p>删除<code>store</code>对象中指定数据的方法有两种，一是使用<code>remove()</code>方法，传入要删除数据对应的键：</p>
<pre><code class="language-python">store.remove('s')
print(store.keys())
</code></pre>
<p>二是使用<code>Python</code>中的关键词<code>del</code>来删除指定数据：</p>
<pre><code class="language-python">del store['s']
</code></pre>
<h5 id="读取-2">读取</h5>
<pre><code class="language-python">store = pd.HDFStore('demo.h5')
'''方式1'''
df1 = store['df']
'''方式2'''
df2 = store.get('df')
</code></pre>
<pre><code class="language-python">df = pd.read_hdf('demo.h5',key='df')
</code></pre>
<ul>
<li>删除对象</li>
</ul>
<pre><code class="language-python">del subgroup[&quot;MyDataset&quot;]
</code></pre>

        </div>

        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/">
                <h3 class="post-title">
                  LeetCode26. 删除排序数组中的重复项
                  <i class="remixicon-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'f4bd8cbd743b58235644',
    clientSecret: 'df6eff6e7836378726d917c527c47e86f1c30f8b',
    repo: 'bailingnan.github.io',
    owner: 'bailingnan',
    admin: ['bailingnan'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://bailingnan.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()

let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
