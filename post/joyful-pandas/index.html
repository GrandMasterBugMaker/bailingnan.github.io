<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>白凌南</title>
<meta name="description" content="DM/DL/RecSys/Python/XJTU/INTJ" />
<link rel="shortcut icon" href="https://bailingnan.github.io//favicon.ico?v=1589038285688">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://bailingnan.github.io//styles/main.css">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-157390001-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-157390001-1');
</script>


  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://bailingnan.github.io/">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://bailingnan.github.io//images/avatar.png?v=1589038285688" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">白凌南</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#pandas%E5%9F%BA%E7%A1%80"><code>Pandas</code>基础</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5">文件读取与写入</a>
<ul>
<li><a href="#%E8%AF%BB%E5%8F%96">读取</a>
<ul>
<li><a href="#csv%E6%A0%BC%E5%BC%8F"><code>csv</code>格式</a></li>
<li><a href="#txt%E6%A0%BC%E5%BC%8F"><code>txt</code>格式</a></li>
</ul>
</li>
<li><a href="#%E5%86%99%E5%85%A5">写入</a>
<ul>
<li><a href="#csv%E6%A0%BC%E5%BC%8F-2"><code>csv</code>格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">基本数据结构</a>
<ul>
<li><a href="#series"><code>Series</code></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAseries">创建一个<code>Series</code></a></li>
<li><a href="#%E8%AE%BF%E9%97%AEseries%E5%B1%9E%E6%80%A7">访问<code>Series</code>属性</a></li>
<li><a href="#%E5%8F%96%E5%87%BA%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">取出某一个元素</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">调用方法</a></li>
</ul>
</li>
<li><a href="#dataframe"><code>DataFrame</code></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAdataframe">创建一个<code>DataFrame</code></a></li>
<li><a href="#%E4%BB%8Edataframe%E5%8F%96%E5%87%BA%E4%B8%80%E5%88%97%E4%B8%BAseries">从<code>DataFrame</code>取出一列为<code>Series</code></a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%A1%8C%E6%88%96%E5%88%97%E5%90%8D">修改行或列名</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">调用属性和方法</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7">索引对齐特性</a></li>
<li><a href="#%E5%88%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E6%B7%BB%E5%8A%A0">列的删除与添加</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9%E5%88%97">根据类型选择列</a></li>
<li><a href="#%E5%B0%86series%E8%BD%AC%E6%8D%A2%E4%B8%BAdataframe">将<code>Series</code>转换为<code>DataFrame</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">常用基本函数</a>
<ul>
<li><a href="#head%E5%92%8Ctail"><code>head</code>和<code>tail</code></a></li>
<li><a href="#unique%E5%92%8Cnunique"><code>unique</code>和<code>nunique</code></a></li>
<li><a href="#count%E5%92%8Cvalue_counts"><code>count</code>和<code>value_counts</code></a></li>
<li><a href="#describe%E5%92%8Cinfo"><code>describe</code>和<code>info</code></a></li>
<li><a href="#idxmax%E5%92%8Cnlargest"><code>idxmax</code>和<code>nlargest</code></a></li>
<li><a href="#clip%E5%92%8Creplace"><code>clip</code>和<code>replace</code></a></li>
<li><a href="#apply%E5%87%BD%E6%95%B0"><code>apply</code>函数</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F">索引排序</a></li>
<li><a href="#%E5%80%BC%E6%8E%92%E5%BA%8F">值排序</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a>
<ul>
<li><a href="#%E5%8D%95%E7%BA%A7%E7%B4%A2%E5%BC%95">单级索引</a>
<ul>
<li><a href="#loc%E6%96%B9%E6%B3%95-iloc%E6%96%B9%E6%B3%95-%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>loc</code>方法、<code>iloc</code>方法、<code>[]</code>操作符</a>
<ul>
<li><a href="#loc%E6%96%B9%E6%B3%95"><code>loc</code>方法</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%8C%E7%B4%A2%E5%BC%95">单行索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95">多行索引</a></li>
<li><a href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95">单列索引</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95">多列索引：</a></li>
<li><a href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95">联合索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95">函数式索引</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95">布尔索引</a></li>
</ul>
</li>
<li><a href="#iloc%E6%96%B9%E6%B3%95"><code>iloc</code>方法</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%8C%E7%B4%A2%E5%BC%95-2">单行索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95-2">多行索引</a></li>
<li><a href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95-2">单列索引</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95-2">多列索引</a></li>
<li><a href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95">混合索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95-2">函数式索引</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>[]</code>操作符</a>
<ul>
<li><a href="#series%E7%9A%84%E6%93%8D%E4%BD%9C"><code>Series</code>的<code>[]</code>操作</a>
<ul>
<li><a href="#%E5%8D%95%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95">单元素索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95-3">多行索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95-3">函数式索引</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-2">布尔索引</a></li>
</ul>
</li>
<li><a href="#dataframe%E7%9A%84%E6%93%8D%E4%BD%9C"><code>DataFrame</code>的<code>[]</code>操作</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%8C%E7%B4%A2%E5%BC%95-3">单行索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95-4">多行索引</a></li>
<li><a href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95-3">单列索引</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95-3">多列索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95-4">函数式索引</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-3">布尔索引</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-4">布尔索引</a>
<ul>
<li><a href="#%E5%B8%83%E5%B0%94%E7%AC%A6%E5%8F%B7">布尔符号</a></li>
<li><a href="#isin%E6%96%B9%E6%B3%95"><code>isin</code>方法</a></li>
</ul>
</li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%A0%87%E9%87%8F%E7%B4%A2%E5%BC%95">快速标量索引</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E7%B4%A2%E5%BC%95">区间索引</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8interval_range%E6%96%B9%E6%B3%95">利用<code>interval_range</code>方法</a></li>
<li><a href="#%E5%88%A9%E7%94%A8cut%E5%B0%86%E6%95%B0%E5%80%BC%E5%88%97%E8%BD%AC%E4%B8%BA%E5%8C%BA%E9%97%B4%E4%B8%BA%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BE%8B%E5%A6%82%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%A6%E6%88%90%E7%BB%A9%E7%9A%84%E5%8C%BA%E9%97%B4%E6%83%85%E5%86%B5">利用<code>cut</code>将数值列转为区间为元素的分类变量，例如统计数学成绩的区间情况：</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E5%8F%96">区间索引的选取</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95">多级索引</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95">创建多级索引</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87from_tuple%E6%88%96from_arrays">通过<code>from_tuple</code>或<code>from_arrays</code></a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84">直接创建元组</a></li>
<li><a href="#%E5%88%A9%E7%94%A8zip%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84">利用<code>zip</code>创建元组</a></li>
<li><a href="#%E9%80%9A%E8%BF%87array%E5%88%9B%E5%BB%BA">通过<code>Array</code>创建</a></li>
<li><a href="#%E9%80%9A%E8%BF%87from_product">通过<code>from_product</code></a></li>
<li><a href="#%E6%8C%87%E5%AE%9Adf%E4%B8%AD%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BAset_index%E6%96%B9%E6%B3%95">指定<code>df</code>中的列创建（<code>set_index</code>方法）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87">多层索引切片</a>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E5%88%87%E7%89%87">一般切片</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%94%B1%E5%85%83%E7%BB%84%E6%9E%84%E6%88%90%E5%88%97%E8%A1%A8">第一类特殊情况：由元组构成列表</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%94%B1%E5%88%97%E8%A1%A8%E6%9E%84%E6%88%90%E5%85%83%E7%BB%84">第二类特殊情况：由列表构成元组</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84slice%E5%AF%B9%E8%B1%A1">多层索引中的<code>slice</code>对象</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%B1%82%E7%9A%84%E4%BA%A4%E6%8D%A2">索引层的交换</a>
<ul>
<li><a href="#swaplevel%E6%96%B9%E6%B3%95%E4%B8%A4%E5%B1%82%E4%BA%A4%E6%8D%A2"><code>swaplevel</code>方法（两层交换）</a></li>
<li><a href="#reorder_levels%E6%96%B9%E6%B3%95%E5%A4%9A%E5%B1%82%E4%BA%A4%E6%8D%A2"><code>reorder_levels</code>方法（多层交换）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E5%AE%9A">索引设定</a>
<ul>
<li><a href="#index_col%E5%8F%82%E6%95%B0"><code>index_col</code>参数</a></li>
<li><a href="#reindex%E5%92%8Creindex_like"><code>reindex</code>和<code>reindex_like</code></a></li>
<li><a href="#set_index%E5%92%8Creset_index"><code>set_index</code>和<code>reset_index</code></a></li>
<li><a href="#rename_axis%E5%92%8Crename"><code>rename_axis</code>和<code>rename</code></a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E5%9E%8B%E5%87%BD%E6%95%B0">常用索引型函数</a>
<ul>
<li><a href="#where%E5%87%BD%E6%95%B0"><code>where</code>函数</a></li>
<li><a href="#mask%E5%87%BD%E6%95%B0"><code>mask</code>函数</a></li>
<li><a href="#query%E5%87%BD%E6%95%B0"><code>query</code>函数</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%A4%84%E7%90%86">重复元素处理</a>
<ul>
<li><a href="#duplicated%E6%96%B9%E6%B3%95"><code>duplicated</code>方法</a></li>
<li><a href="#drop_duplicates%E6%96%B9%E6%B3%95"><code>drop_duplicates</code>方法</a></li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E6%A0%B7%E5%87%BD%E6%95%B0">抽样函数</a>
<ul>
<li><a href="#n%E4%B8%BA%E6%A0%B7%E6%9C%AC%E9%87%8F"><code>n</code>为样本量</a></li>
<li><a href="#frac%E4%B8%BA%E6%8A%BD%E6%A0%B7%E6%AF%94"><code>frac</code>为抽样比</a></li>
<li><a href="#replace%E4%B8%BA%E6%98%AF%E5%90%A6%E6%94%BE%E5%9B%9E"><code>replace</code>为是否放回</a></li>
<li><a href="#axis%E4%B8%BA%E6%8A%BD%E6%A0%B7%E7%BB%B4%E5%BA%A6%E9%BB%98%E8%AE%A4%E4%B8%BA0%E5%8D%B3%E6%8A%BD%E8%A1%8C"><code>axis</code>为抽样维度，默认为<code>0</code>，即抽行</a></li>
<li><a href="#weights%E4%B8%BA%E6%A0%B7%E6%9C%AC%E6%9D%83%E9%87%8D%E8%87%AA%E5%8A%A8%E5%BD%92%E4%B8%80%E5%8C%96"><code>weights</code>为样本权重，自动归一化</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-2">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-2">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-2">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84">分组</a>
<ul>
<li><a href="#sac%E8%BF%87%E7%A8%8B">SAC过程</a>
<ul>
<li><a href="#%E5%86%85%E6%B6%B5">内涵</a></li>
<li><a href="#apply%E8%BF%87%E7%A8%8B"><code>apply</code>过程</a></li>
</ul>
</li>
<li><a href="#groupby%E5%87%BD%E6%95%B0"><code>groupby</code>函数</a>
<ul>
<li><a href="#%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9">分组函数的基本内容</a>
<ul>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%9F%90%E4%B8%80%E5%88%97%E5%88%86%E7%BB%84">根据某一列分组</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%9F%90%E5%87%A0%E5%88%97%E5%88%86%E7%BB%84">根据某几列分组</a></li>
<li><a href="#%E7%BB%84%E5%AE%B9%E9%87%8F%E4%B8%8E%E7%BB%84%E6%95%B0">组容量与组数</a></li>
<li><a href="#%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86">组的遍历</a></li>
<li><a href="#level%E5%8F%82%E6%95%B0%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%92%8Caxis%E5%8F%82%E6%95%B0"><code>level</code>参数（用于多级索引）和<code>axis</code>参数</a></li>
</ul>
</li>
<li><a href="#groupby%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><code>groupby</code>对象的特点</a>
<ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%8F%AF%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">查看所有可调用的方法</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84head%E5%92%8Cfirst">分组对象的<code>head</code>和<code>first</code></a></li>
<li><a href="#%E5%88%86%E7%BB%84%E4%BE%9D%E6%8D%AE">分组依据</a></li>
<li><a href="#groupby%E7%9A%84%E6%93%8D%E4%BD%9C"><code>groupby</code>的<code>[]</code>操作</a></li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%9E%8B%E5%8F%98%E9%87%8F%E5%88%86%E7%BB%84">连续型变量分组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%81%9A%E5%90%88-%E8%BF%87%E6%BB%A4%E5%92%8C%E5%8F%98%E6%8D%A2">聚合、过滤和变换</a>
<ul>
<li><a href="#%E8%81%9A%E5%90%88aggregation">聚合（<code>Aggregation</code>）</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">常用聚合函数</a></li>
<li><a href="#%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">同时使用多个聚合函数</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">使用自定义函数</a></li>
<li><a href="#%E5%88%A9%E7%94%A8namedagg%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%A4%9A%E4%B8%AA%E8%81%9A%E5%90%88">利用<code>NamedAgg</code>函数进行多个聚合</a></li>
<li><a href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">带参数的聚合函数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4filteration">过滤（<code>Filteration</code>）</a></li>
<li><a href="#%E5%8F%98%E6%8D%A2transformation">变换（<code>Transformation</code>）</a>
<ul>
<li><a href="#%E4%BC%A0%E5%85%A5%E5%AF%B9%E8%B1%A1">传入对象</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%86%85%E6%A0%87%E5%87%86%E5%8C%96">利用变换方法进行组内标准化</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%86%85%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E5%9D%87%E5%80%BC%E5%A1%AB%E5%85%85">利用变换方法进行组内缺失值的均值填充</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#apply%E5%87%BD%E6%95%B0-2"><code>apply</code>函数</a>
<ul>
<li><a href="#apply%E5%87%BD%E6%95%B0%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><code>apply</code>函数的灵活性</a>
<ul>
<li><a href="#%E6%A0%87%E9%87%8F%E8%BF%94%E5%9B%9E%E5%80%BC">标量返回值</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E8%BF%94%E5%9B%9E%E5%80%BC">列表返回值</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%A1%86%E8%BF%94%E5%9B%9E%E5%80%BC">数据框返回值</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8apply%E5%90%8C%E6%97%B6%E7%BB%9F%E8%AE%A1%E5%A4%9A%E4%B8%AA%E6%8C%87%E6%A0%87">用<code>apply</code>同时统计多个指标</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-3">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-3">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-3">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%98%E5%BD%A2">变形</a>
<ul>
<li><a href="#%E9%80%8F%E8%A7%86%E8%A1%A8">透视表</a>
<ul>
<li><a href="#pivot"><code>pivot</code></a></li>
<li><a href="#pivot_table"><code>pivot_table</code></a>
<ul>
<li><a href="#aggfunc%E5%AF%B9%E7%BB%84%E5%86%85%E8%BF%9B%E8%A1%8C%E8%81%9A%E5%90%88%E7%BB%9F%E8%AE%A1%E5%8F%AF%E4%BC%A0%E5%85%A5%E5%90%84%E7%B1%BB%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E4%B8%BAmean"><code>aggfunc</code>：对组内进行聚合统计，可传入各类函数，默认为<code>'mean'</code></a></li>
<li><a href="#margins%E6%B1%87%E6%80%BB%E8%BE%B9%E9%99%85%E7%8A%B6%E6%80%81"><code>margins</code>：汇总边际状态</a></li>
<li><a href="#%E8%A1%8C-%E5%88%97-%E5%80%BC%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%B8%BA%E5%A4%9A%E7%BA%A7">行、列、值都可以为多级</a></li>
</ul>
</li>
<li><a href="#crosstab%E4%BA%A4%E5%8F%89%E8%A1%A8"><code>crosstab</code>（交叉表）</a>
<ul>
<li><a href="#values%E5%92%8Caggfunc%E5%88%86%E7%BB%84%E5%AF%B9%E6%9F%90%E4%BA%9B%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0"><code>values</code>和<code>aggfunc</code>：分组对某些数据进行聚合操作，这两个参数必须成对出现</a></li>
<li><a href="#%E9%99%A4%E4%BA%86%E8%BE%B9%E9%99%85%E5%8F%82%E6%95%B0margins%E5%A4%96%E8%BF%98%E5%BC%95%E5%85%A5%E4%BA%86normalize%E5%8F%82%E6%95%B0%E5%8F%AF%E9%80%89allindexcolumns%E5%8F%82%E6%95%B0%E5%80%BC">除了边际参数<code>margins</code>外，还引入了<code>normalize</code>参数，可选<code>'all'</code>,<code>'index'</code>,<code>'columns'</code>参数值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%98%E5%BD%A2%E6%96%B9%E6%B3%95">其他变形方法</a>
<ul>
<li><a href="#melt"><code>melt</code></a></li>
<li><a href="#%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%B1%95%E5%BC%80">压缩与展开</a>
<ul>
<li><a href="#stack"><code>stack</code></a></li>
<li><a href="#unstack"><code>unstack</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%93%91%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9B%A0%E5%AD%90%E5%8C%96">哑变量与因子化</a>
<ul>
<li><a href="#dummy-variable%E5%93%91%E5%8F%98%E9%87%8F"><code>Dummy Variable</code>（哑变量）</a></li>
<li><a href="#factorize%E6%96%B9%E6%B3%95"><code>factorize</code>方法</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-4">练习</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-4">练习一</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-4">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%90%88%E5%B9%B6">合并</a>
<ul>
<li><a href="#append%E4%B8%8Eassign"><code>append</code>与<code>assign</code></a>
<ul>
<li><a href="#append%E6%96%B9%E6%B3%95"><code>append</code>方法</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E6%B7%BB%E5%8A%A0%E8%A1%8C%E5%BF%85%E9%A1%BB%E6%8C%87%E5%AE%9Aname">利用序列添加行（必须指定<code>name</code>）</a></li>
<li><a href="#%E7%94%A8dataframe%E6%B7%BB%E5%8A%A0%E8%A1%A8">用<code>DataFrame</code>添加表</a></li>
</ul>
</li>
<li><a href="#assign%E6%96%B9%E6%B3%95"><code>assign</code>方法</a></li>
</ul>
</li>
<li><a href="#combine%E4%B8%8Eupdate"><code>combine</code>与<code>update</code></a>
<ul>
<li><a href="#comine%E6%96%B9%E6%B3%95"><code>comine</code>方法</a>
<ul>
<li><a href="#%E5%A1%AB%E5%85%85%E5%AF%B9%E8%B1%A1">填充对象</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90">一些例子</a>
<ul>
<li><a href="#%E6%A0%B9%E6%8D%AE%E5%88%97%E5%9D%87%E5%80%BC%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%A1%AB%E5%85%85">根据列均值的大小填充</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7-2">索引对齐特性</a></li>
<li><a href="#%E4%BD%BF%E5%BE%97df1%E5%8E%9F%E6%9D%A5%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%80%BC%E4%B8%8D%E4%BC%9A%E8%A2%AB%E8%A6%86%E7%9B%96">使得<code>df1</code>原来符合条件的值不会被覆盖</a></li>
<li><a href="#%E5%9C%A8%E6%96%B0%E5%A2%9E%E5%8C%B9%E9%85%8Ddf2%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E5%A1%AB%E5%85%85-1">在新增匹配<code>df2</code>的元素位置填充-1</a></li>
</ul>
</li>
<li><a href="#combine_first%E6%96%B9%E6%B3%95"><code>combine_first</code>方法</a></li>
</ul>
</li>
<li><a href="#update%E6%96%B9%E6%B3%95"><code>update</code>方法</a>
<ul>
<li><a href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9">三个特点</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AE%8C%E5%85%A8%E5%AF%B9%E9%BD%90%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C">索引完全对齐情况下的操作</a></li>
<li><a href="#%E9%83%A8%E5%88%86%E5%A1%AB%E5%85%85">部分填充</a></li>
<li><a href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E4%B8%8D%E4%BC%9A%E5%A1%AB%E5%85%85">缺失值不会填充</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#concat%E6%96%B9%E6%B3%95"><code>concat</code>方法</a></li>
<li><a href="#merge%E4%B8%8Ejoin"><code>merge</code>与<code>join</code></a>
<ul>
<li><a href="#merge%E5%87%BD%E6%95%B0"><code>merge</code>函数</a></li>
<li><a href="#join%E5%87%BD%E6%95%B0"><code>join</code>函数</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-5">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-5">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-5">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">缺失数据</a>
<ul>
<li><a href="#%E7%BC%BA%E5%A4%B1%E8%A7%82%E6%B5%8B%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B">缺失观测及其类型</a>
<ul>
<li><a href="#%E4%BA%86%E8%A7%A3%E7%BC%BA%E5%A4%B1%E4%BF%A1%E6%81%AF">了解缺失信息</a>
<ul>
<li><a href="#isna%E5%92%8Cnotna%E6%96%B9%E6%B3%95"><code>isna</code>和<code>notna</code>方法</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E6%89%80%E4%BB%A5%E5%9C%A8%E8%A1%8C">查看缺失值的所以在行</a></li>
<li><a href="#%E6%8C%91%E9%80%89%E5%87%BA%E6%89%80%E6%9C%89%E9%9D%9E%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%88%97">挑选出所有非缺失值列</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E7%A7%8D%E7%BC%BA%E5%A4%B1%E7%AC%A6%E5%8F%B7">三种缺失符号</a>
<ul>
<li><a href="#npnan"><code>np.nan</code></a></li>
<li><a href="#none"><code>None</code></a></li>
<li><a href="#nat"><code>NaT</code></a></li>
</ul>
</li>
<li><a href="#nullable%E7%B1%BB%E5%9E%8B%E4%B8%8Ena%E7%AC%A6%E5%8F%B7"><code>Nullable</code>类型与<code>NA</code>符号</a>
<ul>
<li><a href="#nullable%E6%95%B4%E5%BD%A2"><code>Nullable</code>整形</a></li>
<li><a href="#nullable%E5%B8%83%E5%B0%94"><code>Nullable</code>布尔</a></li>
<li><a href="#string%E7%B1%BB%E5%9E%8B"><code>string</code>类型</a></li>
</ul>
</li>
<li><a href="#na%E7%9A%84%E7%89%B9%E6%80%A7"><code>NA</code>的特性</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">逻辑运算</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97">算术运算和比较运算</a></li>
</ul>
</li>
<li><a href="#convert_dtypes%E6%96%B9%E6%B3%95"><code>convert_dtypes</code>方法</a></li>
</ul>
</li>
<li><a href="#%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97%E4%B8%8E%E5%88%86%E7%BB%84">缺失数据的运算与分组</a>
<ul>
<li><a href="#%E5%8A%A0%E5%8F%B7%E4%B8%8E%E4%B9%98%E5%8F%B7%E8%A7%84%E5%88%99">加号与乘号规则</a></li>
<li><a href="#groupby%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%80%BC"><code>groupby</code>方法中的缺失值</a></li>
</ul>
</li>
<li><a href="#%E5%A1%AB%E5%85%85%E4%B8%8E%E5%89%94%E9%99%A4">填充与剔除</a>
<ul>
<li><a href="#fillna%E6%96%B9%E6%B3%95"><code>fillna</code>方法</a>
<ul>
<li><a href="#%E5%80%BC%E5%A1%AB%E5%85%85%E4%B8%8E%E5%89%8D%E5%90%8E%E5%90%91%E5%A1%AB%E5%85%85%E5%88%86%E5%88%AB%E4%B8%8Effill%E6%96%B9%E6%B3%95%E5%92%8Cbfill%E6%96%B9%E6%B3%95%E7%AD%89%E4%BB%B7">值填充与前后向填充（分别与<code>ffill</code>方法和<code>bfill</code>方法等价）</a></li>
<li><a href="#%E5%A1%AB%E5%85%85%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7">填充中的对齐特性</a></li>
</ul>
</li>
<li><a href="#dropna%E6%96%B9%E6%B3%95"><code>dropna</code>方法</a>
<ul>
<li><a href="#axis%E5%8F%82%E6%95%B0"><code>axis</code>参数</a></li>
<li><a href="#how%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%80%89all%E6%88%96%E8%80%85any%E8%A1%A8%E7%A4%BA%E5%85%A8%E4%B8%BA%E7%BC%BA%E5%A4%B1%E5%8E%BB%E9%99%A4%E5%92%8C%E5%AD%98%E5%9C%A8%E7%BC%BA%E5%A4%B1%E5%8E%BB%E9%99%A4"><code>how</code>参数（可以选<code>all</code>或者<code>any</code>，表示全为缺失去除和存在缺失去除）</a></li>
<li><a href="#subset%E5%8F%82%E6%95%B0%E5%8D%B3%E5%9C%A8%E6%9F%90%E4%B8%80%E7%BB%84%E5%88%97%E8%8C%83%E5%9B%B4%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%BC%BA%E5%A4%B1%E5%80%BC"><code>subset</code>参数（即在某一组列范围中搜索缺失值）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8F%92%E5%80%BCinterpolation">插值（<code>interpolation</code>）</a>
<ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">线性插值</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%97%A0%E5%85%B3%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">索引无关的线性插值</a></li>
<li><a href="#%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%89%E5%85%B3%E7%9A%84%E6%8F%92%E5%80%BC">与索引有关的插值</a></li>
</ul>
</li>
<li><a href="#interpolate%E4%B8%AD%E7%9A%84%E9%99%90%E5%88%B6%E5%8F%82%E6%95%B0"><code>interpolate</code>中的限制参数</a>
<ul>
<li><a href="#limit%E8%A1%A8%E7%A4%BA%E6%9C%80%E5%A4%9A%E6%8F%92%E5%85%A5%E5%A4%9A%E5%B0%91%E4%B8%AA"><code>limit</code>表示最多插入多少个</a></li>
<li><a href="#limit_direction%E8%A1%A8%E7%A4%BA%E6%8F%92%E5%80%BC%E6%96%B9%E5%90%91%E5%8F%AF%E9%80%89forwardbackwardboth%E9%BB%98%E8%AE%A4%E5%89%8D%E5%90%91"><code>limit_direction</code>表示插值方向，可选<code>forward</code>,<code>backward</code>,<code>both</code>，默认前向</a></li>
<li><a href="#limit_area%E8%A1%A8%E7%A4%BA%E6%8F%92%E5%80%BC%E5%8C%BA%E5%9F%9F%E5%8F%AF%E9%80%89insideoutside%E9%BB%98%E8%AE%A4none"><code>limit_area</code>表示插值区域，可选<code>inside,outside</code>，默认<code>None</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-6">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-6">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-6">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE">文本数据</a>
<ul>
<li><a href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%A7%E8%B4%A8"><code>string</code>类型的性质</a>
<ul>
<li><a href="#string%E4%B8%8Eobject%E7%9A%84%E5%8C%BA%E5%88%AB"><code>string</code>与<code>object</code>的区别</a>
<ul>
<li><a href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><code>string</code>类型的转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%86%E5%88%86%E4%B8%8E%E6%8B%BC%E6%8E%A5">拆分与拼接</a>
<ul>
<li><a href="#strsplit%E6%96%B9%E6%B3%95"><code>str.split</code>方法</a>
<ul>
<li><a href="#%E5%88%86%E5%89%B2%E7%AC%A6%E4%B8%8Estr%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0%E9%80%89%E5%8F%96">分割符与<code>str</code>的位置元素选取</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0">其他参数</a></li>
</ul>
</li>
<li><a href="#strcat%E6%96%B9%E6%B3%95"><code>str.cat</code>方法</a>
<ul>
<li><a href="#%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%BC%E6%8E%A5%E6%A8%A1%E5%BC%8F">不同对象的拼接模式</a>
<ul>
<li><a href="#%E5%AF%B9%E4%BA%8E%E5%8D%95%E4%B8%AAseries%E8%80%8C%E8%A8%80%E5%B0%B1%E6%98%AF%E6%8C%87%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2">对于单个<code>Series</code>而言，就是指所有的元素进行字符合并为一个字符串</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E4%B8%A4%E4%B8%AAseries%E5%90%88%E5%B9%B6%E8%80%8C%E8%A8%80%E6%98%AF%E5%AF%B9%E5%BA%94%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6">对于两个<code>Series</code>合并而言，是对应索引的元素进行合并</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E6%8B%BC%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E8%A1%A8%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%A4%9Aseries%E6%8B%BC%E6%8E%A5">多列拼接可以分为表的拼接和多<code>Series</code>拼接</a></li>
<li><a href="#cat%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E9%BD%90"><code>cat</code>中的索引对齐</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9B%BF%E6%8D%A2">替换</a>
<ul>
<li><a href="#strreplace%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><code>str.replace</code>的常见用法</a></li>
<li><a href="#%E5%AD%90%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2">子组与函数替换</a></li>
<li><a href="#%E5%85%B3%E4%BA%8Estrreplace%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">关于<code>str.replace</code>的注意事项</a>
<ul>
<li><a href="#strreplace%E8%B5%8B%E5%80%BC%E5%8F%82%E6%95%B0%E4%B8%8D%E5%BE%97%E4%B8%BApdna"><code>str.replace</code>赋值参数不得为<code>pd.NA</code></a></li>
<li><a href="#%E5%AF%B9%E4%BA%8Estring%E7%B1%BB%E5%9E%8Bseries%E5%9C%A8%E4%BD%BF%E7%94%A8replace%E5%87%BD%E6%95%B0%E6%97%B6%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2">对于<code>string</code>类型<code>Series</code>，在使用<code>replace</code>函数时不能使用正则表达式替换</a></li>
<li><a href="#string%E7%B1%BB%E5%9E%8B%E5%BA%8F%E5%88%97%E5%A6%82%E6%9E%9C%E5%AD%98%E5%9C%A8%E7%BC%BA%E5%A4%B1%E5%80%BC%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8replace%E6%9B%BF%E6%8D%A2"><code>string</code>类型序列如果存在缺失值，不能使用<code>replace</code>替换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8F%90%E5%8F%96">子串匹配与提取</a>
<ul>
<li><a href="#strextract%E6%96%B9%E6%B3%95"><code>str.extract</code>方法</a>
<ul>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95">常见用法</a></li>
<li><a href="#expand%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E4%B8%BAtrue"><code>expand</code>参数（默认为<code>True</code>）</a></li>
</ul>
</li>
<li><a href="#strextractall%E6%96%B9%E6%B3%95"><code>str.extractall</code>方法</a></li>
<li><a href="#strcontains%E5%92%8Cstrmatch"><code>str.contains</code>和<code>str.match</code></a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95">常用字符串方法</a>
<ul>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%9E%8B%E6%96%B9%E6%B3%95">过滤型方法</a>
<ul>
<li><a href="#strstrip"><code>str.strip</code></a></li>
<li><a href="#strlower%E5%92%8Cstrupper"><code>str.lower</code>和<code>str.upper</code></a></li>
<li><a href="#strswapcase%E5%92%8Cstrcapitalize"><code>str.swapcase</code>和<code>str.capitalize</code></a></li>
</ul>
</li>
<li><a href="#isnumeric%E6%96%B9%E6%B3%95"><code>isnumeric</code>方法</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-7">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-7">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-7">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE">分类数据</a>
<ul>
<li><a href="#category%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8">`category的创建及其性质</a>
<ul>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA">分类变量的创建</a>
<ul>
<li><a href="#%E7%94%A8series%E5%88%9B%E5%BB%BA">用<code>Series</code>创建</a></li>
<li><a href="#%E5%AF%B9dataframe%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA">对<code>DataFrame</code>指定类型创建</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%AEcategorical%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA">利用内置<code>Categorical</code>类型创建</a></li>
<li><a href="#%E5%88%A9%E7%94%A8cut%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA">利用<code>cut</code>函数创建</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84">分类变量的结构</a>
<ul>
<li><a href="#describe%E6%96%B9%E6%B3%95"><code>describe</code>方法</a></li>
<li><a href="#categories%E5%92%8Cordered%E5%B1%9E%E6%80%A7"><code>categories</code>和<code>ordered</code>属性</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%88%AB%E7%9A%84%E4%BF%AE%E6%94%B9">类别的修改</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8set_categories%E4%BF%AE%E6%94%B9">利用<code>set_categories</code>修改</a></li>
<li><a href="#%E5%88%A9%E7%94%A8rename_categories%E4%BF%AE%E6%94%B9">利用<code>rename_categories</code>修改</a></li>
<li><a href="#%E5%88%A9%E7%94%A8add_categories%E6%B7%BB%E5%8A%A0">利用<code>add_categories</code>添加</a></li>
<li><a href="#%E5%88%A9%E7%94%A8remove_categories%E7%A7%BB%E9%99%A4">利用<code>remove_categories</code>移除</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%80%BC%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E5%88%86%E7%B1%BB%E7%B1%BB%E5%9E%8B">删除元素值未出现的分类类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%8E%92%E5%BA%8F">分类变量的排序</a>
<ul>
<li><a href="#%E5%BA%8F%E7%9A%84%E5%BB%BA%E7%AB%8B">序的建立</a>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%E4%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E8%BD%AC%E4%B8%BA%E6%9C%89%E5%BA%8F%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8as_ordered%E6%96%B9%E6%B3%95">一般来说会将一个序列转为有序变量，可以利用<code>as_ordered</code>方法</a></li>
<li><a href="#%E5%88%A9%E7%94%A8set_categories%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84order%E5%8F%82%E6%95%B0">利用<code>set_categories</code>方法中的<code>order</code>参数</a></li>
<li><a href="#%E5%88%A9%E7%94%A8reorder_categories%E6%96%B9%E6%B3%95">利用<code>reorder_categories</code>方法</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F-2">排序</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C">分类变量的比较操作</a>
<ul>
<li><a href="#%E4%B8%8E%E6%A0%87%E9%87%8F%E6%88%96%E7%AD%89%E9%95%BF%E5%BA%8F%E5%88%97%E7%9A%84%E6%AF%94%E8%BE%83">与标量或等长序列的比较</a>
<ul>
<li><a href="#%E6%A0%87%E9%87%8F%E6%AF%94%E8%BE%83">标量比较</a></li>
<li><a href="#%E7%AD%89%E9%95%BF%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83">等长序列比较</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E%E5%8F%A6%E4%B8%80%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%AF%94%E8%BE%83">与另一分类变量的比较</a>
<ul>
<li><a href="#%E7%AD%89%E5%BC%8F%E5%88%A4%E5%88%AB%E5%8C%85%E5%90%AB%E7%AD%89%E5%8F%B7%E5%92%8C%E4%B8%8D%E7%AD%89%E5%8F%B7">等式判别（包含等号和不等号）</a></li>
<li><a href="#%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%88%A4%E5%88%AB%E5%8C%85%E5%90%AB">不等式判别（包含<code>&gt;=</code>,<code>&lt;=</code>,<code>&lt;</code>,<code>&gt;</code>）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-8">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-8">练习一</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE">时序数据</a>
<ul>
<li><a href="#%E6%97%B6%E5%BA%8F%E7%9A%84%E5%88%9B%E5%BB%BA">时序的创建</a>
<ul>
<li><a href="#%E5%9B%9B%E7%B1%BB%E6%97%B6%E9%97%B4%E5%8F%98%E9%87%8F">四类时间变量</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA">时间点的创建</a>
<ul>
<li><a href="#to_datetime%E6%96%B9%E6%B3%95"><code>to_datetime</code>方法</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%B2%BE%E5%BA%A6%E4%B8%8E%E8%8C%83%E5%9B%B4%E9%99%90%E5%88%B6">时间精度与范围限制</a></li>
<li><a href="#date_range%E6%96%B9%E6%B3%95"><code>date_range</code>方法</a></li>
</ul>
</li>
<li><a href="#dateoffset%E5%AF%B9%E8%B1%A1"><code>DateOffset</code>对象</a>
<ul>
<li><a href="#dataoffset%E4%B8%8Etimedelta%E7%9A%84%E5%8C%BA%E5%88%AB"><code>DataOffset</code>与<code>Timedelta</code>的区别</a></li>
<li><a href="#%E5%A2%9E%E5%87%8F%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4">增减一段时间</a></li>
<li><a href="#%E5%90%84%E7%B1%BB%E5%B8%B8%E7%94%A8offset%E5%AF%B9%E8%B1%A1">各类常用<code>offset</code>对象</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E7%9A%84offset%E6%93%8D%E4%BD%9C">序列的<code>offset</code>操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%B6%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%B1%9E%E6%80%A7">时序的索引及属性</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87">索引切片</a></li>
<li><a href="#%E5%AD%90%E9%9B%86%E7%B4%A2%E5%BC%95">子集索引</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7">时间点的属性</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E9%87%87%E6%A0%B7">重采样</a>
<ul>
<li><a href="#resample%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><code>resample</code>对象的基本操作</a></li>
<li><a href="#%E9%87%87%E6%A0%B7%E8%81%9A%E5%90%88">采样聚合</a></li>
<li><a href="#%E9%87%87%E6%A0%B7%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3">采样组的迭代</a></li>
</ul>
</li>
<li><a href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">窗口函数</a>
<ul>
<li><a href="#rolling">Rolling</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88">常用聚合</a></li>
<li><a href="#rolling%E7%9A%84apply%E8%81%9A%E5%90%88"><code>rolling</code>的<code>apply</code>聚合</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84rolling">基于时间的<code>rolling</code></a></li>
</ul>
</li>
<li><a href="#expanding"><code>Expanding</code></a>
<ul>
<li><a href="#expanding%E5%87%BD%E6%95%B0"><code>expanding</code>函数</a></li>
<li><a href="#%E5%87%A0%E4%B8%AA%E7%89%B9%E5%88%AB%E7%9A%84expanding%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0">几个特别的<code>Expanding</code>类型函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%80%9F%E6%9F%A5">速查</a>
<ul>
<li><a href="#series%E5%92%8Cdataframe%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><code>Series</code>和<code>DataFrame</code>对象的创建</a>
<ul>
<li><a href="#series-2"><code>Series</code></a>
<ul>
<li><a href="#%E9%A2%84%E8%A7%88">预览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA">创建</a>
<ul>
<li><a href="#data%E6%97%A0%E7%B4%A2%E5%BC%95"><code>data</code>无索引</a></li>
<li><a href="#data%E6%9C%89%E7%B4%A2%E5%BC%95"><code>data</code>有索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dataframe-2">DataFrame</a>
<ul>
<li><a href="#%E9%A2%84%E8%A7%88-2">预览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-2">创建</a></li>
<li><a href="#data%E6%97%A0-%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%97%A0-%E5%88%97%E7%B4%A2%E5%BC%95"><code>data</code>无 行索引，无 列索引</a></li>
<li><a href="#data%E6%97%A0-%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%9C%89-%E5%88%97%E7%B4%A2%E5%BC%95"><code>data</code>无 行索引，有 列索引</a></li>
<li><a href="#data%E6%9C%89-%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%9C%89-%E5%88%97%E7%B4%A2%E5%BC%95"><code>data</code>有 行索引，有 列索引</a></li>
</ul>
</li>
<li><a href="#%E7%94%B1%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA">由文件创建</a>
<ul>
<li><a href="#%E7%94%B1csv%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA">由<code>.csv</code>文件创建</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#series%E5%92%8Cdataframe%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9F%A5-%E6%94%B9-%E5%A2%9E-%E5%88%A0"><code>Series</code>和<code>DataFrame</code>对象的查、改、增、 删</a>
<ul>
<li><a href="#series-3"><code>Series</code></a>
<ul>
<li><a href="#%E6%9F%A5">查</a>
<ul>
<li><a href="#%E5%BF%AB%E6%8D%B7%E6%9F%A5%E7%9C%8B"><code>[]</code>，快捷查看</a></li>
<li><a href="#loc%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95"><code>.loc[]</code>，基于索引</a></li>
<li><a href="#iloc%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE"><code>.iloc[]</code>，基于位置</a></li>
</ul>
</li>
<li><a href="#%E6%94%B9">改</a>
<ul>
<li><a href="#%E6%94%B9%E5%80%BC">改值</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95">改索引</a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E">增</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%A2%9E%E4%B8%80%E8%A1%8C">直接增一行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A2%9E%E5%A4%9A%E8%A1%8C">函数增多行</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0">删</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%88%A0%E4%B8%80%E8%A1%8C">直接删一行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%A0%E5%A4%9A%E8%A1%8C">函数删多行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dataframe-3"><code>DataFrame</code></a>
<ul>
<li><a href="#%E6%9F%A5-2">查</a>
<ul>
<li><a href="#%E5%BF%AB%E6%8D%B7%E6%9F%A5%E7%9C%8B-2"><code>[]</code>，快捷查看</a></li>
<li><a href="#loc%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95-2"><code>.loc[]</code>，基于索引</a></li>
<li><a href="#iloc%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE-2"><code>.iloc[]</code>，基于位置</a></li>
</ul>
</li>
<li><a href="#%E6%94%B9-2">改</a>
<ul>
<li><a href="#%E6%94%B9%E5%80%BC-2">改值</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95-2">改索引</a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E-2">增</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%A2%9E%E4%B8%80%E8%A1%8C-2">直接增一行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A2%9E%E5%A4%9A%E8%A1%8C-2">函数增多行</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%A2%9E%E4%B8%80%E5%88%97">直接增一列</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A2%9E%E5%A4%9A%E5%88%97">函数增多列</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0-2">删</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%A0%E5%A4%9A%E8%A1%8C-2">函数删多行</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%88%A0%E4%B8%80%E5%88%97">直接删一列</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%A0%E5%A4%9A%E5%88%97">函数删多列</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#merge%E8%AF%A6%E8%A7%A3"><code>merge</code>详解</a>
<ul>
<li><a href="#on-%E7%94%A8%E6%B3%95"><code>on</code> 用法</a></li>
<li><a href="#how-%E7%94%A8%E6%B3%95"><code>how</code> 用法</a></li>
</ul>
</li>
<li><a href="#index%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9F%A5-%E6%94%B9-%E5%A2%9E-%E5%88%A0%E5%92%8C%E4%BD%BF%E7%94%A8"><code>Index</code>对象的创建,查、改、增、删和使用</a>
<ul>
<li><a href="#%E5%8D%95%E5%B1%82%E7%B4%A2%E5%BC%95">单层索引</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA-3">创建</a></li>
<li><a href="#%E6%9F%A5-3">查</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95%E5%90%8D">改索引名</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%94%B9">直接改</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%94%B9">函数改</a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E-3">增</a>
<ul>
<li><a href="#%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E8%A1%8C">按位置添加一行</a></li>
<li><a href="#%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E5%A4%9A%E8%A1%8C">尾部添加多行</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6">并</a></li>
<li><a href="#%E5%88%A0-3">删</a>
<ul>
<li><a href="#%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4%E4%B8%80%E8%A1%8C">按位置删除一行</a></li>
</ul>
</li>
<li><a href="#%E4%BA%A4">交</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95">多层索引</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA-4">创建</a></li>
<li><a href="#%E6%9F%A5-4">查</a></li>
<li><a href="#%E6%94%B9-3">改</a>
<ul>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95%E5%90%8D%E5%87%BD%E6%95%B0%E6%94%B9">改索引名（函数改）</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95%E5%B1%82%E6%AC%A1%E9%A1%BA%E5%BA%8F">改索引层次顺序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">多层索引使用方法</a>
<ul>
<li><a href="#%E5%AF%B9%E4%BA%8E%E5%A4%96%E5%B1%82%E7%B4%A2%E5%BC%95">对于外层索引</a>
<ul>
<li><a href="#"><code>[]</code></a></li>
<li><a href="#loc"><code>.loc[]</code></a></li>
<li><a href="#iloc"><code>.iloc[]</code></a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E5%86%85%E5%B1%82%E7%B4%A2%E5%BC%95">对于内层索引</a>
<ul>
<li><a href="#-2"><code>[ , ]</code></a></li>
<li><a href="#loc-2"><code>.loc[ , ]</code></a></li>
</ul>
</li>
<li><a href="#xs%E7%9B%B4%E6%8E%A5%E9%80%89%E5%8F%96%E6%B3%95"><code>xs</code>直接选取法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%99%AE%E9%80%9A%E5%88%97%E5%92%8C%E8%A1%8Cindex%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96">普通列和行index的相互转化</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E5%88%97-%E8%BD%AC%E5%8C%96%E4%B8%BA-%E8%A1%8C%E7%B4%A2%E5%BC%95">普通列 转化为 行索引</a>
<ul>
<li><a href="#dataframe%E4%B8%AD%E7%9A%84%E5%88%97"><code>DataFrame</code>中的列</a></li>
<li><a href="#%E4%BB%BB%E6%84%8F%E5%88%97">任意列</a></li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E7%B4%A2%E5%BC%95-%E8%BD%AC%E5%8C%96%E4%B8%BA-%E6%99%AE%E9%80%9A%E5%88%97">行索引 转化为 普通列</a>
<ul>
<li><a href="#%E5%8D%95%E5%B1%82-%E5%88%97%E7%B4%A2%E5%BC%95-%E6%83%85%E5%86%B5">单层 列索引 情况</a></li>
<li><a href="#%E5%A4%9A%E5%B1%82-%E5%88%97%E7%B4%A2%E5%BC%95-%E6%83%85%E5%86%B5">多层 列索引 情况</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.6000000000000001s">
          关于
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700"></div>
    <a class="rss" href="https://bailingnan.github.io//atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16"> Joyful-Pandas</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-04-11 / 169 min read
        </div>
        
        <div class="post-content yue">
          <!-- TOC -->
<ul>
<li><a href="#pandas%E5%9F%BA%E7%A1%80"><code>Pandas</code>基础</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5">文件读取与写入</a>
<ul>
<li><a href="#%E8%AF%BB%E5%8F%96">读取</a>
<ul>
<li><a href="#csv%E6%A0%BC%E5%BC%8F"><code>csv</code>格式</a></li>
<li><a href="#txt%E6%A0%BC%E5%BC%8F"><code>txt</code>格式</a></li>
</ul>
</li>
<li><a href="#%E5%86%99%E5%85%A5">写入</a>
<ul>
<li><a href="#csv%E6%A0%BC%E5%BC%8F-1"><code>csv</code>格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">基本数据结构</a>
<ul>
<li><a href="#series"><code>Series</code></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAseries">创建一个<code>Series</code></a></li>
<li><a href="#%E8%AE%BF%E9%97%AEseries%E5%B1%9E%E6%80%A7">访问<code>Series</code>属性</a></li>
<li><a href="#%E5%8F%96%E5%87%BA%E6%9F%90%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0">取出某一个元素</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95">调用方法</a></li>
</ul>
</li>
<li><a href="#dataframe"><code>DataFrame</code></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAdataframe">创建一个<code>DataFrame</code></a></li>
<li><a href="#%E4%BB%8Edataframe%E5%8F%96%E5%87%BA%E4%B8%80%E5%88%97%E4%B8%BAseries">从<code>DataFrame</code>取出一列为<code>Series</code></a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%A1%8C%E6%88%96%E5%88%97%E5%90%8D">修改行或列名</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95">调用属性和方法</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7">索引对齐特性</a></li>
<li><a href="#%E5%88%97%E7%9A%84%E5%88%A0%E9%99%A4%E4%B8%8E%E6%B7%BB%E5%8A%A0">列的删除与添加</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E7%B1%BB%E5%9E%8B%E9%80%89%E6%8B%A9%E5%88%97">根据类型选择列</a></li>
<li><a href="#%E5%B0%86series%E8%BD%AC%E6%8D%A2%E4%B8%BAdataframe">将<code>Series</code>转换为<code>DataFrame</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0">常用基本函数</a>
<ul>
<li><a href="#head%E5%92%8Ctail"><code>head</code>和<code>tail</code></a></li>
<li><a href="#unique%E5%92%8Cnunique"><code>unique</code>和<code>nunique</code></a></li>
<li><a href="#count%E5%92%8Cvalue_counts"><code>count</code>和<code>value_counts</code></a></li>
<li><a href="#describe%E5%92%8Cinfo"><code>describe</code>和<code>info</code></a></li>
<li><a href="#idxmax%E5%92%8Cnlargest"><code>idxmax</code>和<code>nlargest</code></a></li>
<li><a href="#clip%E5%92%8Creplace"><code>clip</code>和<code>replace</code></a></li>
<li><a href="#apply%E5%87%BD%E6%95%B0"><code>apply</code>函数</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F">索引排序</a></li>
<li><a href="#%E5%80%BC%E6%8E%92%E5%BA%8F">值排序</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95">索引</a>
<ul>
<li><a href="#%E5%8D%95%E7%BA%A7%E7%B4%A2%E5%BC%95">单级索引</a>
<ul>
<li><a href="#loc%E6%96%B9%E6%B3%95iloc%E6%96%B9%E6%B3%95%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>loc</code>方法、<code>iloc</code>方法、<code>[]</code>操作符</a>
<ul>
<li><a href="#loc%E6%96%B9%E6%B3%95"><code>loc</code>方法</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%8C%E7%B4%A2%E5%BC%95">单行索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95">多行索引</a></li>
<li><a href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95">单列索引</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95">多列索引：</a></li>
<li><a href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95">联合索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95">函数式索引</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95">布尔索引</a></li>
</ul>
</li>
<li><a href="#iloc%E6%96%B9%E6%B3%95"><code>iloc</code>方法</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%8C%E7%B4%A2%E5%BC%95-1">单行索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95-1">多行索引</a></li>
<li><a href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95-1">单列索引</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95-1">多列索引</a></li>
<li><a href="#%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95">混合索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95-1">函数式索引</a></li>
</ul>
</li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><code>[]</code>操作符</a>
<ul>
<li><a href="#series%E7%9A%84%E6%93%8D%E4%BD%9C"><code>Series</code>的<code>[]</code>操作</a>
<ul>
<li><a href="#%E5%8D%95%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95">单元素索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95-2">多行索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95-2">函数式索引</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-1">布尔索引</a></li>
</ul>
</li>
<li><a href="#dataframe%E7%9A%84%E6%93%8D%E4%BD%9C"><code>DataFrame</code>的<code>[]</code>操作</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%8C%E7%B4%A2%E5%BC%95-2">单行索引</a></li>
<li><a href="#%E5%A4%9A%E8%A1%8C%E7%B4%A2%E5%BC%95-3">多行索引</a></li>
<li><a href="#%E5%8D%95%E5%88%97%E7%B4%A2%E5%BC%95-2">单列索引</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95-2">多列索引</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%B4%A2%E5%BC%95-3">函数式索引</a></li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-2">布尔索引</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%B8%83%E5%B0%94%E7%B4%A2%E5%BC%95-3">布尔索引</a>
<ul>
<li><a href="#%E5%B8%83%E5%B0%94%E7%AC%A6%E5%8F%B7">布尔符号</a></li>
<li><a href="#isin%E6%96%B9%E6%B3%95"><code>isin</code>方法</a></li>
</ul>
</li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%A0%87%E9%87%8F%E7%B4%A2%E5%BC%95">快速标量索引</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E7%B4%A2%E5%BC%95">区间索引</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8interval_range%E6%96%B9%E6%B3%95">利用<code>interval_range</code>方法</a></li>
<li><a href="#%E5%88%A9%E7%94%A8cut%E5%B0%86%E6%95%B0%E5%80%BC%E5%88%97%E8%BD%AC%E4%B8%BA%E5%8C%BA%E9%97%B4%E4%B8%BA%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E4%BE%8B%E5%A6%82%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%A6%E6%88%90%E7%BB%A9%E7%9A%84%E5%8C%BA%E9%97%B4%E6%83%85%E5%86%B5">利用<code>cut</code>将数值列转为区间为元素的分类变量，例如统计数学成绩的区间情况：</a></li>
<li><a href="#%E5%8C%BA%E9%97%B4%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E5%8F%96">区间索引的选取</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95">多级索引</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95">创建多级索引</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87from_tuple%E6%88%96from_arrays">通过<code>from_tuple</code>或<code>from_arrays</code></a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84">直接创建元组</a></li>
<li><a href="#%E5%88%A9%E7%94%A8zip%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84">利用<code>zip</code>创建元组</a></li>
<li><a href="#%E9%80%9A%E8%BF%87array%E5%88%9B%E5%BB%BA">通过<code>Array</code>创建</a></li>
<li><a href="#%E9%80%9A%E8%BF%87from_product">通过<code>from_product</code></a></li>
<li><a href="#%E6%8C%87%E5%AE%9Adf%E4%B8%AD%E7%9A%84%E5%88%97%E5%88%9B%E5%BB%BAset_index%E6%96%B9%E6%B3%95">指定<code>df</code>中的列创建（<code>set_index</code>方法）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87">多层索引切片</a>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E5%88%87%E7%89%87">一般切片</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%94%B1%E5%85%83%E7%BB%84%E6%9E%84%E6%88%90%E5%88%97%E8%A1%A8">第一类特殊情况：由元组构成列表</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E7%94%B1%E5%88%97%E8%A1%A8%E6%9E%84%E6%88%90%E5%85%83%E7%BB%84">第二类特殊情况：由列表构成元组</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84slice%E5%AF%B9%E8%B1%A1">多层索引中的<code>slice</code>对象</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%B1%82%E7%9A%84%E4%BA%A4%E6%8D%A2">索引层的交换</a>
<ul>
<li><a href="#swaplevel%E6%96%B9%E6%B3%95%E4%B8%A4%E5%B1%82%E4%BA%A4%E6%8D%A2"><code>swaplevel</code>方法（两层交换）</a></li>
<li><a href="#reorder_levels%E6%96%B9%E6%B3%95%E5%A4%9A%E5%B1%82%E4%BA%A4%E6%8D%A2"><code>reorder_levels</code>方法（多层交换）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E5%AE%9A">索引设定</a>
<ul>
<li><a href="#index_col%E5%8F%82%E6%95%B0"><code>index_col</code>参数</a></li>
<li><a href="#reindex%E5%92%8Creindex_like"><code>reindex</code>和<code>reindex_like</code></a></li>
<li><a href="#set_index%E5%92%8Creset_index"><code>set_index</code>和<code>reset_index</code></a></li>
<li><a href="#rename_axis%E5%92%8Crename"><code>rename_axis</code>和<code>rename</code></a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E5%9E%8B%E5%87%BD%E6%95%B0">常用索引型函数</a>
<ul>
<li><a href="#where%E5%87%BD%E6%95%B0"><code>where</code>函数</a></li>
<li><a href="#mask%E5%87%BD%E6%95%B0"><code>mask</code>函数</a></li>
<li><a href="#query%E5%87%BD%E6%95%B0"><code>query</code>函数</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%A4%84%E7%90%86">重复元素处理</a>
<ul>
<li><a href="#duplicated%E6%96%B9%E6%B3%95"><code>duplicated</code>方法</a></li>
<li><a href="#drop_duplicates%E6%96%B9%E6%B3%95"><code>drop_duplicates</code>方法</a></li>
</ul>
</li>
<li><a href="#%E6%8A%BD%E6%A0%B7%E5%87%BD%E6%95%B0">抽样函数</a>
<ul>
<li><a href="#n%E4%B8%BA%E6%A0%B7%E6%9C%AC%E9%87%8F"><code>n</code>为样本量</a></li>
<li><a href="#frac%E4%B8%BA%E6%8A%BD%E6%A0%B7%E6%AF%94"><code>frac</code>为抽样比</a></li>
<li><a href="#replace%E4%B8%BA%E6%98%AF%E5%90%A6%E6%94%BE%E5%9B%9E"><code>replace</code>为是否放回</a></li>
<li><a href="#axis%E4%B8%BA%E6%8A%BD%E6%A0%B7%E7%BB%B4%E5%BA%A6%E9%BB%98%E8%AE%A4%E4%B8%BA0%E5%8D%B3%E6%8A%BD%E8%A1%8C"><code>axis</code>为抽样维度，默认为<code>0</code>，即抽行</a></li>
<li><a href="#weights%E4%B8%BA%E6%A0%B7%E6%9C%AC%E6%9D%83%E9%87%8D%E8%87%AA%E5%8A%A8%E5%BD%92%E4%B8%80%E5%8C%96"><code>weights</code>为样本权重，自动归一化</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-1">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-1">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-1">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%BB%84">分组</a>
<ul>
<li><a href="#sac%E8%BF%87%E7%A8%8B">SAC过程</a>
<ul>
<li><a href="#%E5%86%85%E6%B6%B5">内涵</a></li>
<li><a href="#apply%E8%BF%87%E7%A8%8B"><code>apply</code>过程</a></li>
</ul>
</li>
<li><a href="#groupby%E5%87%BD%E6%95%B0"><code>groupby</code>函数</a>
<ul>
<li><a href="#%E5%88%86%E7%BB%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9">分组函数的基本内容</a>
<ul>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%9F%90%E4%B8%80%E5%88%97%E5%88%86%E7%BB%84">根据某一列分组</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%9F%90%E5%87%A0%E5%88%97%E5%88%86%E7%BB%84">根据某几列分组</a></li>
<li><a href="#%E7%BB%84%E5%AE%B9%E9%87%8F%E4%B8%8E%E7%BB%84%E6%95%B0">组容量与组数</a></li>
<li><a href="#%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86">组的遍历</a></li>
<li><a href="#level%E5%8F%82%E6%95%B0%E7%94%A8%E4%BA%8E%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%92%8Caxis%E5%8F%82%E6%95%B0"><code>level</code>参数（用于多级索引）和<code>axis</code>参数</a></li>
</ul>
</li>
<li><a href="#groupby%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9"><code>groupby</code>对象的特点</a>
<ul>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E5%8F%AF%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">查看所有可调用的方法</a></li>
<li><a href="#%E5%88%86%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84head%E5%92%8Cfirst">分组对象的<code>head</code>和<code>first</code></a></li>
<li><a href="#%E5%88%86%E7%BB%84%E4%BE%9D%E6%8D%AE">分组依据</a></li>
<li><a href="#groupby%E7%9A%84%E6%93%8D%E4%BD%9C"><code>groupby</code>的<code>[]</code>操作</a></li>
<li><a href="#%E8%BF%9E%E7%BB%AD%E5%9E%8B%E5%8F%98%E9%87%8F%E5%88%86%E7%BB%84">连续型变量分组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%81%9A%E5%90%88%E8%BF%87%E6%BB%A4%E5%92%8C%E5%8F%98%E6%8D%A2">聚合、过滤和变换</a>
<ul>
<li><a href="#%E8%81%9A%E5%90%88aggregation">聚合（<code>Aggregation</code>）</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">常用聚合函数</a></li>
<li><a href="#%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">同时使用多个聚合函数</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0">使用自定义函数</a></li>
<li><a href="#%E5%88%A9%E7%94%A8namedagg%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%A4%9A%E4%B8%AA%E8%81%9A%E5%90%88">利用<code>NamedAgg</code>函数进行多个聚合</a></li>
<li><a href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">带参数的聚合函数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%87%E6%BB%A4filteration">过滤（<code>Filteration</code>）</a></li>
<li><a href="#%E5%8F%98%E6%8D%A2transformation">变换（<code>Transformation</code>）</a>
<ul>
<li><a href="#%E4%BC%A0%E5%85%A5%E5%AF%B9%E8%B1%A1">传入对象</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%86%85%E6%A0%87%E5%87%86%E5%8C%96">利用变换方法进行组内标准化</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%8F%98%E6%8D%A2%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%86%85%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E5%9D%87%E5%80%BC%E5%A1%AB%E5%85%85">利用变换方法进行组内缺失值的均值填充</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#apply%E5%87%BD%E6%95%B0-1"><code>apply</code>函数</a>
<ul>
<li><a href="#apply%E5%87%BD%E6%95%B0%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><code>apply</code>函数的灵活性</a>
<ul>
<li><a href="#%E6%A0%87%E9%87%8F%E8%BF%94%E5%9B%9E%E5%80%BC">标量返回值</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E8%BF%94%E5%9B%9E%E5%80%BC">列表返回值</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%A1%86%E8%BF%94%E5%9B%9E%E5%80%BC">数据框返回值</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8apply%E5%90%8C%E6%97%B6%E7%BB%9F%E8%AE%A1%E5%A4%9A%E4%B8%AA%E6%8C%87%E6%A0%87">用<code>apply</code>同时统计多个指标</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-2">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-2">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-2">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%8F%98%E5%BD%A2">变形</a>
<ul>
<li><a href="#%E9%80%8F%E8%A7%86%E8%A1%A8">透视表</a>
<ul>
<li><a href="#pivot"><code>pivot</code></a></li>
<li><a href="#pivot_table"><code>pivot_table</code></a>
<ul>
<li><a href="#aggfunc%E5%AF%B9%E7%BB%84%E5%86%85%E8%BF%9B%E8%A1%8C%E8%81%9A%E5%90%88%E7%BB%9F%E8%AE%A1%E5%8F%AF%E4%BC%A0%E5%85%A5%E5%90%84%E7%B1%BB%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E4%B8%BAmean"><code>aggfunc</code>：对组内进行聚合统计，可传入各类函数，默认为<code>'mean'</code></a></li>
<li><a href="#margins%E6%B1%87%E6%80%BB%E8%BE%B9%E9%99%85%E7%8A%B6%E6%80%81"><code>margins</code>：汇总边际状态</a></li>
<li><a href="#%E8%A1%8C%E5%88%97%E5%80%BC%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%B8%BA%E5%A4%9A%E7%BA%A7">行、列、值都可以为多级</a></li>
</ul>
</li>
<li><a href="#crosstab%E4%BA%A4%E5%8F%89%E8%A1%A8"><code>crosstab</code>（交叉表）</a>
<ul>
<li><a href="#values%E5%92%8Caggfunc%E5%88%86%E7%BB%84%E5%AF%B9%E6%9F%90%E4%BA%9B%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E5%BF%85%E9%A1%BB%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0"><code>values</code>和<code>aggfunc</code>：分组对某些数据进行聚合操作，这两个参数必须成对出现</a></li>
<li><a href="#%E9%99%A4%E4%BA%86%E8%BE%B9%E9%99%85%E5%8F%82%E6%95%B0margins%E5%A4%96%E8%BF%98%E5%BC%95%E5%85%A5%E4%BA%86normalize%E5%8F%82%E6%95%B0%E5%8F%AF%E9%80%89allindexcolumns%E5%8F%82%E6%95%B0%E5%80%BC">除了边际参数<code>margins</code>外，还引入了<code>normalize</code>参数，可选<code>'all'</code>,<code>'index'</code>,<code>'columns'</code>参数值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%98%E5%BD%A2%E6%96%B9%E6%B3%95">其他变形方法</a>
<ul>
<li><a href="#melt"><code>melt</code></a></li>
<li><a href="#%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%B1%95%E5%BC%80">压缩与展开</a>
<ul>
<li><a href="#stack"><code>stack</code></a></li>
<li><a href="#unstack"><code>unstack</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%93%91%E5%8F%98%E9%87%8F%E4%B8%8E%E5%9B%A0%E5%AD%90%E5%8C%96">哑变量与因子化</a>
<ul>
<li><a href="#dummy-variable%E5%93%91%E5%8F%98%E9%87%8F"><code>Dummy Variable</code>（哑变量）</a></li>
<li><a href="#factorize%E6%96%B9%E6%B3%95"><code>factorize</code>方法</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-3">练习</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-3">练习一</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-3">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%90%88%E5%B9%B6">合并</a>
<ul>
<li><a href="#append%E4%B8%8Eassign"><code>append</code>与<code>assign</code></a>
<ul>
<li><a href="#append%E6%96%B9%E6%B3%95"><code>append</code>方法</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E6%B7%BB%E5%8A%A0%E8%A1%8C%E5%BF%85%E9%A1%BB%E6%8C%87%E5%AE%9Aname">利用序列添加行（必须指定<code>name</code>）</a></li>
<li><a href="#%E7%94%A8dataframe%E6%B7%BB%E5%8A%A0%E8%A1%A8">用<code>DataFrame</code>添加表</a></li>
</ul>
</li>
<li><a href="#assign%E6%96%B9%E6%B3%95"><code>assign</code>方法</a></li>
</ul>
</li>
<li><a href="#combine%E4%B8%8Eupdate"><code>combine</code>与<code>update</code></a>
<ul>
<li><a href="#comine%E6%96%B9%E6%B3%95"><code>comine</code>方法</a>
<ul>
<li><a href="#%E5%A1%AB%E5%85%85%E5%AF%B9%E8%B1%A1">填充对象</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90">一些例子</a>
<ul>
<li><a href="#%E6%A0%B9%E6%8D%AE%E5%88%97%E5%9D%87%E5%80%BC%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%A1%AB%E5%85%85">根据列均值的大小填充</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7-1">索引对齐特性</a></li>
<li><a href="#%E4%BD%BF%E5%BE%97df1%E5%8E%9F%E6%9D%A5%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%80%BC%E4%B8%8D%E4%BC%9A%E8%A2%AB%E8%A6%86%E7%9B%96">使得<code>df1</code>原来符合条件的值不会被覆盖</a></li>
<li><a href="#%E5%9C%A8%E6%96%B0%E5%A2%9E%E5%8C%B9%E9%85%8Ddf2%E7%9A%84%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E5%A1%AB%E5%85%85-1">在新增匹配<code>df2</code>的元素位置填充-1</a></li>
</ul>
</li>
<li><a href="#combine_first%E6%96%B9%E6%B3%95"><code>combine_first</code>方法</a></li>
</ul>
</li>
<li><a href="#update%E6%96%B9%E6%B3%95"><code>update</code>方法</a>
<ul>
<li><a href="#%E4%B8%89%E4%B8%AA%E7%89%B9%E7%82%B9">三个特点</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AE%8C%E5%85%A8%E5%AF%B9%E9%BD%90%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E6%93%8D%E4%BD%9C">索引完全对齐情况下的操作</a></li>
<li><a href="#%E9%83%A8%E5%88%86%E5%A1%AB%E5%85%85">部分填充</a></li>
<li><a href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E4%B8%8D%E4%BC%9A%E5%A1%AB%E5%85%85">缺失值不会填充</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#concat%E6%96%B9%E6%B3%95"><code>concat</code>方法</a></li>
<li><a href="#merge%E4%B8%8Ejoin"><code>merge</code>与<code>join</code></a>
<ul>
<li><a href="#merge%E5%87%BD%E6%95%B0"><code>merge</code>函数</a></li>
<li><a href="#join%E5%87%BD%E6%95%B0"><code>join</code>函数</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-4">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-4">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-4">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">缺失数据</a>
<ul>
<li><a href="#%E7%BC%BA%E5%A4%B1%E8%A7%82%E6%B5%8B%E5%8F%8A%E5%85%B6%E7%B1%BB%E5%9E%8B">缺失观测及其类型</a>
<ul>
<li><a href="#%E4%BA%86%E8%A7%A3%E7%BC%BA%E5%A4%B1%E4%BF%A1%E6%81%AF">了解缺失信息</a>
<ul>
<li><a href="#isna%E5%92%8Cnotna%E6%96%B9%E6%B3%95"><code>isna</code>和<code>notna</code>方法</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E6%89%80%E4%BB%A5%E5%9C%A8%E8%A1%8C">查看缺失值的所以在行</a></li>
<li><a href="#%E6%8C%91%E9%80%89%E5%87%BA%E6%89%80%E6%9C%89%E9%9D%9E%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%88%97">挑选出所有非缺失值列</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E7%A7%8D%E7%BC%BA%E5%A4%B1%E7%AC%A6%E5%8F%B7">三种缺失符号</a>
<ul>
<li><a href="#npnan"><code>np.nan</code></a></li>
<li><a href="#none"><code>None</code></a></li>
<li><a href="#nat"><code>NaT</code></a></li>
</ul>
</li>
<li><a href="#nullable%E7%B1%BB%E5%9E%8B%E4%B8%8Ena%E7%AC%A6%E5%8F%B7"><code>Nullable</code>类型与<code>NA</code>符号</a>
<ul>
<li><a href="#nullable%E6%95%B4%E5%BD%A2"><code>Nullable</code>整形</a></li>
<li><a href="#nullable%E5%B8%83%E5%B0%94"><code>Nullable</code>布尔</a></li>
<li><a href="#string%E7%B1%BB%E5%9E%8B"><code>string</code>类型</a></li>
</ul>
</li>
<li><a href="#na%E7%9A%84%E7%89%B9%E6%80%A7"><code>NA</code>的特性</a>
<ul>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97">逻辑运算</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97">算术运算和比较运算</a></li>
</ul>
</li>
<li><a href="#convert_dtypes%E6%96%B9%E6%B3%95"><code>convert_dtypes</code>方法</a></li>
</ul>
</li>
<li><a href="#%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%90%E7%AE%97%E4%B8%8E%E5%88%86%E7%BB%84">缺失数据的运算与分组</a>
<ul>
<li><a href="#%E5%8A%A0%E5%8F%B7%E4%B8%8E%E4%B9%98%E5%8F%B7%E8%A7%84%E5%88%99">加号与乘号规则</a></li>
<li><a href="#groupby%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E7%BC%BA%E5%A4%B1%E5%80%BC"><code>groupby</code>方法中的缺失值</a></li>
</ul>
</li>
<li><a href="#%E5%A1%AB%E5%85%85%E4%B8%8E%E5%89%94%E9%99%A4">填充与剔除</a>
<ul>
<li><a href="#fillna%E6%96%B9%E6%B3%95"><code>fillna</code>方法</a>
<ul>
<li><a href="#%E5%80%BC%E5%A1%AB%E5%85%85%E4%B8%8E%E5%89%8D%E5%90%8E%E5%90%91%E5%A1%AB%E5%85%85%E5%88%86%E5%88%AB%E4%B8%8Effill%E6%96%B9%E6%B3%95%E5%92%8Cbfill%E6%96%B9%E6%B3%95%E7%AD%89%E4%BB%B7">值填充与前后向填充（分别与<code>ffill</code>方法和<code>bfill</code>方法等价）</a></li>
<li><a href="#%E5%A1%AB%E5%85%85%E4%B8%AD%E7%9A%84%E5%AF%B9%E9%BD%90%E7%89%B9%E6%80%A7">填充中的对齐特性</a></li>
</ul>
</li>
<li><a href="#dropna%E6%96%B9%E6%B3%95"><code>dropna</code>方法</a>
<ul>
<li><a href="#axis%E5%8F%82%E6%95%B0"><code>axis</code>参数</a></li>
<li><a href="#how%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%80%89all%E6%88%96%E8%80%85any%E8%A1%A8%E7%A4%BA%E5%85%A8%E4%B8%BA%E7%BC%BA%E5%A4%B1%E5%8E%BB%E9%99%A4%E5%92%8C%E5%AD%98%E5%9C%A8%E7%BC%BA%E5%A4%B1%E5%8E%BB%E9%99%A4"><code>how</code>参数（可以选<code>all</code>或者<code>any</code>，表示全为缺失去除和存在缺失去除）</a></li>
<li><a href="#subset%E5%8F%82%E6%95%B0%E5%8D%B3%E5%9C%A8%E6%9F%90%E4%B8%80%E7%BB%84%E5%88%97%E8%8C%83%E5%9B%B4%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%BC%BA%E5%A4%B1%E5%80%BC"><code>subset</code>参数（即在某一组列范围中搜索缺失值）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8F%92%E5%80%BCinterpolation">插值（<code>interpolation</code>）</a>
<ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">线性插值</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E6%97%A0%E5%85%B3%E7%9A%84%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC">索引无关的线性插值</a></li>
<li><a href="#%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%89%E5%85%B3%E7%9A%84%E6%8F%92%E5%80%BC">与索引有关的插值</a></li>
</ul>
</li>
<li><a href="#interpolate%E4%B8%AD%E7%9A%84%E9%99%90%E5%88%B6%E5%8F%82%E6%95%B0"><code>interpolate</code>中的限制参数</a>
<ul>
<li><a href="#limit%E8%A1%A8%E7%A4%BA%E6%9C%80%E5%A4%9A%E6%8F%92%E5%85%A5%E5%A4%9A%E5%B0%91%E4%B8%AA"><code>limit</code>表示最多插入多少个</a></li>
<li><a href="#limit_direction%E8%A1%A8%E7%A4%BA%E6%8F%92%E5%80%BC%E6%96%B9%E5%90%91%E5%8F%AF%E9%80%89forwardbackwardboth%E9%BB%98%E8%AE%A4%E5%89%8D%E5%90%91"><code>limit_direction</code>表示插值方向，可选<code>forward</code>,<code>backward</code>,<code>both</code>，默认前向</a></li>
<li><a href="#limit_area%E8%A1%A8%E7%A4%BA%E6%8F%92%E5%80%BC%E5%8C%BA%E5%9F%9F%E5%8F%AF%E9%80%89insideoutside%E9%BB%98%E8%AE%A4none"><code>limit_area</code>表示插值区域，可选<code>inside,outside</code>，默认<code>None</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-5">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-5">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-5">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE">文本数据</a>
<ul>
<li><a href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%A7%E8%B4%A8"><code>string</code>类型的性质</a>
<ul>
<li><a href="#string%E4%B8%8Eobject%E7%9A%84%E5%8C%BA%E5%88%AB"><code>string</code>与<code>object</code>的区别</a>
<ul>
<li><a href="#string%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><code>string</code>类型的转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8B%86%E5%88%86%E4%B8%8E%E6%8B%BC%E6%8E%A5">拆分与拼接</a>
<ul>
<li><a href="#strsplit%E6%96%B9%E6%B3%95"><code>str.split</code>方法</a>
<ul>
<li><a href="#%E5%88%86%E5%89%B2%E7%AC%A6%E4%B8%8Estr%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%85%83%E7%B4%A0%E9%80%89%E5%8F%96">分割符与<code>str</code>的位置元素选取</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%8F%82%E6%95%B0">其他参数</a></li>
</ul>
</li>
<li><a href="#strcat%E6%96%B9%E6%B3%95"><code>str.cat</code>方法</a>
<ul>
<li><a href="#%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8B%BC%E6%8E%A5%E6%A8%A1%E5%BC%8F">不同对象的拼接模式</a>
<ul>
<li><a href="#%E5%AF%B9%E4%BA%8E%E5%8D%95%E4%B8%AAseries%E8%80%8C%E8%A8%80%E5%B0%B1%E6%98%AF%E6%8C%87%E6%89%80%E6%9C%89%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2">对于单个<code>Series</code>而言，就是指所有的元素进行字符合并为一个字符串</a></li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E4%B8%A4%E4%B8%AAseries%E5%90%88%E5%B9%B6%E8%80%8C%E8%A8%80%E6%98%AF%E5%AF%B9%E5%BA%94%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%83%E7%B4%A0%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6">对于两个<code>Series</code>合并而言，是对应索引的元素进行合并</a></li>
<li><a href="#%E5%A4%9A%E5%88%97%E6%8B%BC%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E8%A1%A8%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E5%A4%9Aseries%E6%8B%BC%E6%8E%A5">多列拼接可以分为表的拼接和多<code>Series</code>拼接</a></li>
<li><a href="#cat%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E9%BD%90"><code>cat</code>中的索引对齐</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9B%BF%E6%8D%A2">替换</a>
<ul>
<li><a href="#strreplace%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95"><code>str.replace</code>的常见用法</a></li>
<li><a href="#%E5%AD%90%E7%BB%84%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9B%BF%E6%8D%A2">子组与函数替换</a></li>
<li><a href="#%E5%85%B3%E4%BA%8Estrreplace%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">关于<code>str.replace</code>的注意事项</a>
<ul>
<li><a href="#strreplace%E8%B5%8B%E5%80%BC%E5%8F%82%E6%95%B0%E4%B8%8D%E5%BE%97%E4%B8%BApdna"><code>str.replace</code>赋值参数不得为<code>pd.NA</code></a></li>
<li><a href="#%E5%AF%B9%E4%BA%8Estring%E7%B1%BB%E5%9E%8Bseries%E5%9C%A8%E4%BD%BF%E7%94%A8replace%E5%87%BD%E6%95%B0%E6%97%B6%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2">对于<code>string</code>类型<code>Series</code>，在使用<code>replace</code>函数时不能使用正则表达式替换</a></li>
<li><a href="#string%E7%B1%BB%E5%9E%8B%E5%BA%8F%E5%88%97%E5%A6%82%E6%9E%9C%E5%AD%98%E5%9C%A8%E7%BC%BA%E5%A4%B1%E5%80%BC%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8replace%E6%9B%BF%E6%8D%A2"><code>string</code>类型序列如果存在缺失值，不能使用<code>replace</code>替换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%8F%90%E5%8F%96">子串匹配与提取</a>
<ul>
<li><a href="#strextract%E6%96%B9%E6%B3%95"><code>str.extract</code>方法</a>
<ul>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95">常见用法</a></li>
<li><a href="#expand%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E4%B8%BAtrue"><code>expand</code>参数（默认为<code>True</code>）</a></li>
</ul>
</li>
<li><a href="#strextractall%E6%96%B9%E6%B3%95"><code>str.extractall</code>方法</a></li>
<li><a href="#strcontains%E5%92%8Cstrmatch"><code>str.contains</code>和<code>str.match</code></a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95">常用字符串方法</a>
<ul>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%9E%8B%E6%96%B9%E6%B3%95">过滤型方法</a>
<ul>
<li><a href="#strstrip"><code>str.strip</code></a></li>
<li><a href="#strlower%E5%92%8Cstrupper"><code>str.lower</code>和<code>str.upper</code></a></li>
<li><a href="#strswapcase%E5%92%8Cstrcapitalize"><code>str.swapcase</code>和<code>str.capitalize</code></a></li>
</ul>
</li>
<li><a href="#isnumeric%E6%96%B9%E6%B3%95"><code>isnumeric</code>方法</a></li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-6">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-6">练习一</a></li>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%BA%8C-6">练习二</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE">分类数据</a>
<ul>
<li><a href="#category%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%85%B6%E6%80%A7%E8%B4%A8">`category的创建及其性质</a>
<ul>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA">分类变量的创建</a>
<ul>
<li><a href="#%E7%94%A8series%E5%88%9B%E5%BB%BA">用<code>Series</code>创建</a></li>
<li><a href="#%E5%AF%B9dataframe%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA">对<code>DataFrame</code>指定类型创建</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%AEcategorical%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA">利用内置<code>Categorical</code>类型创建</a></li>
<li><a href="#%E5%88%A9%E7%94%A8cut%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA">利用<code>cut</code>函数创建</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84">分类变量的结构</a>
<ul>
<li><a href="#describe%E6%96%B9%E6%B3%95"><code>describe</code>方法</a></li>
<li><a href="#categories%E5%92%8Cordered%E5%B1%9E%E6%80%A7"><code>categories</code>和<code>ordered</code>属性</a></li>
</ul>
</li>
<li><a href="#%E7%B1%BB%E5%88%AB%E7%9A%84%E4%BF%AE%E6%94%B9">类别的修改</a>
<ul>
<li><a href="#%E5%88%A9%E7%94%A8set_categories%E4%BF%AE%E6%94%B9">利用<code>set_categories</code>修改</a></li>
<li><a href="#%E5%88%A9%E7%94%A8rename_categories%E4%BF%AE%E6%94%B9">利用<code>rename_categories</code>修改</a></li>
<li><a href="#%E5%88%A9%E7%94%A8add_categories%E6%B7%BB%E5%8A%A0">利用<code>add_categories</code>添加</a></li>
<li><a href="#%E5%88%A9%E7%94%A8remove_categories%E7%A7%BB%E9%99%A4">利用<code>remove_categories</code>移除</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%80%BC%E6%9C%AA%E5%87%BA%E7%8E%B0%E7%9A%84%E5%88%86%E7%B1%BB%E7%B1%BB%E5%9E%8B">删除元素值未出现的分类类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%8E%92%E5%BA%8F">分类变量的排序</a>
<ul>
<li><a href="#%E5%BA%8F%E7%9A%84%E5%BB%BA%E7%AB%8B">序的建立</a>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E6%9D%A5%E8%AF%B4%E4%BC%9A%E5%B0%86%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%E8%BD%AC%E4%B8%BA%E6%9C%89%E5%BA%8F%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8as_ordered%E6%96%B9%E6%B3%95">一般来说会将一个序列转为有序变量，可以利用<code>as_ordered</code>方法</a></li>
<li><a href="#%E5%88%A9%E7%94%A8set_categories%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84order%E5%8F%82%E6%95%B0">利用<code>set_categories</code>方法中的<code>order</code>参数</a></li>
<li><a href="#%E5%88%A9%E7%94%A8reorder_categories%E6%96%B9%E6%B3%95">利用<code>reorder_categories</code>方法</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F-1">排序</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C">分类变量的比较操作</a>
<ul>
<li><a href="#%E4%B8%8E%E6%A0%87%E9%87%8F%E6%88%96%E7%AD%89%E9%95%BF%E5%BA%8F%E5%88%97%E7%9A%84%E6%AF%94%E8%BE%83">与标量或等长序列的比较</a>
<ul>
<li><a href="#%E6%A0%87%E9%87%8F%E6%AF%94%E8%BE%83">标量比较</a></li>
<li><a href="#%E7%AD%89%E9%95%BF%E5%BA%8F%E5%88%97%E6%AF%94%E8%BE%83">等长序列比较</a></li>
</ul>
</li>
<li><a href="#%E4%B8%8E%E5%8F%A6%E4%B8%80%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84%E6%AF%94%E8%BE%83">与另一分类变量的比较</a>
<ul>
<li><a href="#%E7%AD%89%E5%BC%8F%E5%88%A4%E5%88%AB%E5%8C%85%E5%90%AB%E7%AD%89%E5%8F%B7%E5%92%8C%E4%B8%8D%E7%AD%89%E5%8F%B7">等式判别（包含等号和不等号）</a></li>
<li><a href="#%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%88%A4%E5%88%AB%E5%8C%85%E5%90%AB">不等式判别（包含<code>&gt;=</code>,<code>&lt;=</code>,<code>&lt;</code>,<code>&gt;</code>）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%83%E4%B9%A0-7">练习</a>
<ul>
<li><a href="#%E7%BB%83%E4%B9%A0%E4%B8%80-7">练习一</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE">时序数据</a>
<ul>
<li><a href="#%E6%97%B6%E5%BA%8F%E7%9A%84%E5%88%9B%E5%BB%BA">时序的创建</a>
<ul>
<li><a href="#%E5%9B%9B%E7%B1%BB%E6%97%B6%E9%97%B4%E5%8F%98%E9%87%8F">四类时间变量</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%82%B9%E7%9A%84%E5%88%9B%E5%BB%BA">时间点的创建</a>
<ul>
<li><a href="#to_datetime%E6%96%B9%E6%B3%95"><code>to_datetime</code>方法</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%B2%BE%E5%BA%A6%E4%B8%8E%E8%8C%83%E5%9B%B4%E9%99%90%E5%88%B6">时间精度与范围限制</a></li>
<li><a href="#date_range%E6%96%B9%E6%B3%95"><code>date_range</code>方法</a></li>
</ul>
</li>
<li><a href="#dateoffset%E5%AF%B9%E8%B1%A1"><code>DateOffset</code>对象</a>
<ul>
<li><a href="#dataoffset%E4%B8%8Etimedelta%E7%9A%84%E5%8C%BA%E5%88%AB"><code>DataOffset</code>与<code>Timedelta</code>的区别</a></li>
<li><a href="#%E5%A2%9E%E5%87%8F%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4">增减一段时间</a></li>
<li><a href="#%E5%90%84%E7%B1%BB%E5%B8%B8%E7%94%A8offset%E5%AF%B9%E8%B1%A1">各类常用<code>offset</code>对象</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E7%9A%84offset%E6%93%8D%E4%BD%9C">序列的<code>offset</code>操作</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%97%B6%E5%BA%8F%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%B1%9E%E6%80%A7">时序的索引及属性</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%88%87%E7%89%87">索引切片</a></li>
<li><a href="#%E5%AD%90%E9%9B%86%E7%B4%A2%E5%BC%95">子集索引</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E7%82%B9%E7%9A%84%E5%B1%9E%E6%80%A7">时间点的属性</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E9%87%87%E6%A0%B7">重采样</a>
<ul>
<li><a href="#resample%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><code>resample</code>对象的基本操作</a></li>
<li><a href="#%E9%87%87%E6%A0%B7%E8%81%9A%E5%90%88">采样聚合</a></li>
<li><a href="#%E9%87%87%E6%A0%B7%E7%BB%84%E7%9A%84%E8%BF%AD%E4%BB%A3">采样组的迭代</a></li>
</ul>
</li>
<li><a href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">窗口函数</a>
<ul>
<li><a href="#rolling">Rolling</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%81%9A%E5%90%88">常用聚合</a></li>
<li><a href="#rolling%E7%9A%84apply%E8%81%9A%E5%90%88"><code>rolling</code>的<code>apply</code>聚合</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84rolling">基于时间的<code>rolling</code></a></li>
</ul>
</li>
<li><a href="#expanding"><code>Expanding</code></a>
<ul>
<li><a href="#expanding%E5%87%BD%E6%95%B0"><code>expanding</code>函数</a></li>
<li><a href="#%E5%87%A0%E4%B8%AA%E7%89%B9%E5%88%AB%E7%9A%84expanding%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0">几个特别的<code>Expanding</code>类型函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%80%9F%E6%9F%A5">速查</a>
<ul>
<li><a href="#series%E5%92%8Cdataframe%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><code>Series</code>和<code>DataFrame</code>对象的创建</a>
<ul>
<li><a href="#series-1"><code>Series</code></a>
<ul>
<li><a href="#%E9%A2%84%E8%A7%88">预览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA">创建</a>
<ul>
<li><a href="#data%E6%97%A0%E7%B4%A2%E5%BC%95"><code>data</code>无索引</a></li>
<li><a href="#data%E6%9C%89%E7%B4%A2%E5%BC%95"><code>data</code>有索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dataframe-1">DataFrame</a>
<ul>
<li><a href="#%E9%A2%84%E8%A7%88-1">预览</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA-1">创建</a></li>
<li><a href="#data%E6%97%A0-%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%97%A0-%E5%88%97%E7%B4%A2%E5%BC%95"><code>data</code>无 行索引，无 列索引</a></li>
<li><a href="#data%E6%97%A0-%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%9C%89-%E5%88%97%E7%B4%A2%E5%BC%95"><code>data</code>无 行索引，有 列索引</a></li>
<li><a href="#data%E6%9C%89-%E8%A1%8C%E7%B4%A2%E5%BC%95%E6%9C%89-%E5%88%97%E7%B4%A2%E5%BC%95"><code>data</code>有 行索引，有 列索引</a></li>
</ul>
</li>
<li><a href="#%E7%94%B1%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA">由文件创建</a>
<ul>
<li><a href="#%E7%94%B1csv%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA">由<code>.csv</code>文件创建</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#series%E5%92%8Cdataframe%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9F%A5%E6%94%B9%E5%A2%9E-%E5%88%A0"><code>Series</code>和<code>DataFrame</code>对象的查、改、增、 删</a>
<ul>
<li><a href="#series-2"><code>Series</code></a>
<ul>
<li><a href="#%E6%9F%A5">查</a>
<ul>
<li><a href="#%E5%BF%AB%E6%8D%B7%E6%9F%A5%E7%9C%8B"><code>[]</code>，快捷查看</a></li>
<li><a href="#loc%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95"><code>.loc[]</code>，基于索引</a></li>
<li><a href="#iloc%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE"><code>.iloc[]</code>，基于位置</a></li>
</ul>
</li>
<li><a href="#%E6%94%B9">改</a>
<ul>
<li><a href="#%E6%94%B9%E5%80%BC">改值</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95">改索引</a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E">增</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%A2%9E%E4%B8%80%E8%A1%8C">直接增一行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A2%9E%E5%A4%9A%E8%A1%8C">函数增多行</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0">删</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%88%A0%E4%B8%80%E8%A1%8C">直接删一行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%A0%E5%A4%9A%E8%A1%8C">函数删多行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dataframe-2"><code>DataFrame</code></a>
<ul>
<li><a href="#%E6%9F%A5-1">查</a>
<ul>
<li><a href="#%E5%BF%AB%E6%8D%B7%E6%9F%A5%E7%9C%8B-1"><code>[]</code>，快捷查看</a></li>
<li><a href="#loc%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95-1"><code>.loc[]</code>，基于索引</a></li>
<li><a href="#iloc%E5%9F%BA%E4%BA%8E%E4%BD%8D%E7%BD%AE-1"><code>.iloc[]</code>，基于位置</a></li>
</ul>
</li>
<li><a href="#%E6%94%B9-1">改</a>
<ul>
<li><a href="#%E6%94%B9%E5%80%BC-1">改值</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95-1">改索引</a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E-1">增</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%A2%9E%E4%B8%80%E8%A1%8C-1">直接增一行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A2%9E%E5%A4%9A%E8%A1%8C-1">函数增多行</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%A2%9E%E4%B8%80%E5%88%97">直接增一列</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A2%9E%E5%A4%9A%E5%88%97">函数增多列</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0-1">删</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%A0%E5%A4%9A%E8%A1%8C-1">函数删多行</a></li>
<li><a href="#%E7%9B%B4%E6%8E%A5%E5%88%A0%E4%B8%80%E5%88%97">直接删一列</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%88%A0%E5%A4%9A%E5%88%97">函数删多列</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#merge%E8%AF%A6%E8%A7%A3"><code>merge</code>详解</a>
<ul>
<li><a href="#on-%E7%94%A8%E6%B3%95"><code>on</code> 用法</a></li>
<li><a href="#how-%E7%94%A8%E6%B3%95"><code>how</code> 用法</a></li>
</ul>
</li>
<li><a href="#index%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9F%A5%E6%94%B9%E5%A2%9E%E5%88%A0%E5%92%8C%E4%BD%BF%E7%94%A8"><code>Index</code>对象的创建,查、改、增、删和使用</a>
<ul>
<li><a href="#%E5%8D%95%E5%B1%82%E7%B4%A2%E5%BC%95">单层索引</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA-2">创建</a></li>
<li><a href="#%E6%9F%A5-2">查</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95%E5%90%8D">改索引名</a>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%94%B9">直接改</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%94%B9">函数改</a></li>
</ul>
</li>
<li><a href="#%E5%A2%9E-2">增</a>
<ul>
<li><a href="#%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%B7%BB%E5%8A%A0%E4%B8%80%E8%A1%8C">按位置添加一行</a></li>
<li><a href="#%E5%B0%BE%E9%83%A8%E6%B7%BB%E5%8A%A0%E5%A4%9A%E8%A1%8C">尾部添加多行</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6">并</a></li>
<li><a href="#%E5%88%A0-2">删</a>
<ul>
<li><a href="#%E6%8C%89%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4%E4%B8%80%E8%A1%8C">按位置删除一行</a></li>
</ul>
</li>
<li><a href="#%E4%BA%A4">交</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95">多层索引</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA-3">创建</a></li>
<li><a href="#%E6%9F%A5-3">查</a></li>
<li><a href="#%E6%94%B9-2">改</a>
<ul>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95%E5%90%8D%E5%87%BD%E6%95%B0%E6%94%B9">改索引名（函数改）</a></li>
<li><a href="#%E6%94%B9%E7%B4%A2%E5%BC%95%E5%B1%82%E6%AC%A1%E9%A1%BA%E5%BA%8F">改索引层次顺序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%B1%82%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">多层索引使用方法</a>
<ul>
<li><a href="#%E5%AF%B9%E4%BA%8E%E5%A4%96%E5%B1%82%E7%B4%A2%E5%BC%95">对于外层索引</a>
<ul>
<li><a href="#"><code>[]</code></a></li>
<li><a href="#loc"><code>.loc[]</code></a></li>
<li><a href="#iloc"><code>.iloc[]</code></a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E4%BA%8E%E5%86%85%E5%B1%82%E7%B4%A2%E5%BC%95">对于内层索引</a>
<ul>
<li><a href="#--"><code>[ , ]</code></a></li>
<li><a href="#loc--"><code>.loc[ , ]</code></a></li>
</ul>
</li>
<li><a href="#xs%E7%9B%B4%E6%8E%A5%E9%80%89%E5%8F%96%E6%B3%95"><code>xs</code>直接选取法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%99%AE%E9%80%9A%E5%88%97%E5%92%8C%E8%A1%8Cindex%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96">普通列和行index的相互转化</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E5%88%97-%E8%BD%AC%E5%8C%96%E4%B8%BA-%E8%A1%8C%E7%B4%A2%E5%BC%95">普通列 转化为 行索引</a>
<ul>
<li><a href="#dataframe%E4%B8%AD%E7%9A%84%E5%88%97"><code>DataFrame</code>中的列</a></li>
<li><a href="#%E4%BB%BB%E6%84%8F%E5%88%97">任意列</a></li>
</ul>
</li>
<li><a href="#%E8%A1%8C%E7%B4%A2%E5%BC%95-%E8%BD%AC%E5%8C%96%E4%B8%BA-%E6%99%AE%E9%80%9A%E5%88%97">行索引 转化为 普通列</a>
<ul>
<li><a href="#%E5%8D%95%E5%B1%82-%E5%88%97%E7%B4%A2%E5%BC%95-%E6%83%85%E5%86%B5">单层 列索引 情况</a></li>
<li><a href="#%E5%A4%9A%E5%B1%82-%E5%88%97%E7%B4%A2%E5%BC%95-%E6%83%85%E5%86%B5">多层 列索引 情况</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="pandas基础"><code>Pandas</code>基础</h1>
<pre><code class="language-python">import pandas as pd
import numpy as np
</code></pre>
<p>查看<code>Pandas</code>版本</p>
<pre><code class="language-python">pd.__version__
'1.0.1'
</code></pre>
<h2 id="文件读取与写入">文件读取与写入</h2>
<h3 id="读取">读取</h3>
<h4 id="csv格式"><code>csv</code>格式</h4>
<pre><code class="language-python">df = pd.read_csv('data/table.csv')
df.head()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410145004.png" alt="" loading="lazy"></figure>
<h4 id="txt格式"><code>txt</code>格式</h4>
<pre><code class="language-python">df_txt = pd.read_table('data/table.txt') #可设置sep分隔符参数
df_txt
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410145114.png" alt="" loading="lazy"></figure>
<h3 id="写入">写入</h3>
<h4 id="csv格式-2"><code>csv</code>格式</h4>
<pre><code class="language-python">df.to_csv('data/new_table.csv')
</code></pre>
<h2 id="基本数据结构">基本数据结构</h2>
<h3 id="series"><code>Series</code></h3>
<h4 id="创建一个series">创建一个<code>Series</code></h4>
<p>对于一个<code>Series</code>，其中最常用的属性为值（<code>values</code>），索引（<code>index</code>），名字（<code>name</code>），类型（<code>dtype</code>）</p>
<pre><code class="language-python">s
a   -0.282809
b   -0.316346
c    0.535802
d    1.802756
e    1.808229
Name: 这是一个Series, dtype: float64
</code></pre>
<h4 id="访问series属性">访问<code>Series</code>属性</h4>
<pre><code class="language-python">s.values
array([-0.28280874, -0.31634646,  0.53580237,  1.802756  ,  1.8082295 ])
s.name
'这是一个Series'
s.index
Index(['a', 'b', 'c', 'd', 'e'], dtype='object')
s.dtype
dtype('float64')
</code></pre>
<h4 id="取出某一个元素">取出某一个元素</h4>
<pre><code class="language-python">s['a']
-0.2828087433467871
</code></pre>
<h4 id="调用方法">调用方法</h4>
<pre><code class="language-python">s.mean()
0.7095265322328809
</code></pre>
<p><code>Series</code>有相当多的方法可以调用：</p>
<pre><code class="language-python">print([attr for attr in dir(s) if not attr.startswith('_')])
['T', 'a', 'abs', 'add', 'add_prefix', 'add_suffix', 'agg', 'aggregate', 'align', 'all', 'any', 'append', 'apply', 'argmax', 'argmin', 'argsort', 'array', 'asfreq', 'asof', 'astype', 'at', 'at_time', 'attrs', 'autocorr', 'axes', 'b', 'between', 'between_time', 'bfill', 'bool', 'c', 'clip', 'combine', 'combine_first', 'convert_dtypes', 'copy', 'corr', 'count', 'cov', 'cummax', 'cummin', 'cumprod', 'cumsum', 'd', 'describe', 'diff', 'div', 'divide', 'divmod', 'dot', 'drop', 'drop_duplicates', 'droplevel', 'dropna', 'dtype', 'dtypes', 'duplicated', 'e', 'empty', 'eq', 'equals', 'ewm', 'expanding', 'explode', 'factorize', 'ffill', 'fillna', 'filter', 'first', 'first_valid_index', 'floordiv', 'ge', 'get', 'groupby', 'gt', 'hasnans', 'head', 'hist', 'iat', 'idxmax', 'idxmin', 'iloc', 'index', 'infer_objects', 'interpolate', 'is_monotonic', 'is_monotonic_decreasing', 'is_monotonic_increasing', 'is_unique', 'isin', 'isna', 'isnull', 'item', 'items', 'iteritems', 'keys', 'kurt', 'kurtosis', 'last', 'last_valid_index', 'le', 'loc', 'lt', 'mad', 'map', 'mask', 'max', 'mean', 'median', 'memory_usage', 'min', 'mod', 'mode', 'mul', 'multiply', 'name', 'nbytes', 'ndim', 'ne', 'nlargest', 'notna', 'notnull', 'nsmallest', 'nunique', 'pct_change', 'pipe', 'plot', 'pop', 'pow', 'prod', 'product', 'quantile', 'radd', 'rank', 'ravel', 'rdiv', 'rdivmod', 'reindex', 'reindex_like', 'rename', 'rename_axis', 'reorder_levels', 'repeat', 'replace', 'resample', 'reset_index', 'rfloordiv', 'rmod', 'rmul', 'rolling', 'round', 'rpow', 'rsub', 'rtruediv', 'sample', 'searchsorted', 'sem', 'set_axis', 'shape', 'shift', 'size', 'skew', 'slice_shift', 'sort_index', 'sort_values', 'squeeze', 'std', 'sub', 'subtract', 'sum', 'swapaxes', 'swaplevel', 'tail', 'take', 'to_clipboard', 'to_csv', 'to_dict', 'to_excel', 'to_frame', 'to_hdf', 'to_json', 'to_latex', 'to_list', 'to_markdown', 'to_numpy', 'to_period', 'to_pickle', 'to_sql', 'to_string', 'to_timestamp', 'to_xarray', 'transform', 'transpose', 'truediv', 'truncate', 'tshift', 'tz_convert', 'tz_localize', 'unique', 'unstack', 'update', 'value_counts', 'values', 'var', 'view', 'where', 'xs']
</code></pre>
<h3 id="dataframe"><code>DataFrame</code></h3>
<h4 id="创建一个dataframe">创建一个<code>DataFrame</code></h4>
<pre><code class="language-python">df = pd.DataFrame({'col1':list('abcde'),'col2':range(5,10),'col3':[1.3,2.5,3.6,4.6,5.8]},
                 index=list('一二三四五'))
df
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410145747.png" alt="" loading="lazy"></figure>
<h4 id="从dataframe取出一列为series">从<code>DataFrame</code>取出一列为<code>Series</code></h4>
<pre><code class="language-python">df['col1']
一    a
二    b
三    c
四    d
五    e
Name: col1, dtype: object
type(df)
pandas.core.frame.DataFrame
type(df['col1'])
pandas.core.series.Series
</code></pre>
<h4 id="修改行或列名">修改行或列名</h4>
<pre><code class="language-python">df.rename(index={'一':'one'},columns={'col1':'new_col1'})
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410145747.png" alt="" loading="lazy"></figure>
<h4 id="调用属性和方法">调用属性和方法</h4>
<pre><code class="language-python">df.index
Index(['一', '二', '三', '四', '五'], dtype='object')
df.columns
Index(['col1', 'col2', 'col3'], dtype='object')
df.values
array([['a', 5, 1.3],
       ['b', 6, 2.5],
       ['c', 7, 3.6],
       ['d', 8, 4.6],
       ['e', 9, 5.8]], dtype=object)
df.shape
(5, 3)
df.mean() #本质上是一种Aggregation操作
col2    7.00
col3    3.56
dtype: float64
</code></pre>
<h4 id="索引对齐特性">索引对齐特性</h4>
<p>这是<code>Pandas</code>中非常强大的特性，不理解这一特性有时就会造成一些麻烦</p>
<pre><code class="language-python">df1 = pd.DataFrame({'A':[1,2,3]},index=[1,2,3])
df2 = pd.DataFrame({'A':[1,2,3]},index=[3,1,2])
df1-df2 #由于索引对齐，因此结果不是0
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410152035.png" alt="" loading="lazy"></figure>
<h4 id="列的删除与添加">列的删除与添加</h4>
<p>对于删除而言，可以使用<code>drop</code>函数或<code>del</code>或<code>pop</code></p>
<pre><code class="language-python">df.drop(index='五',columns='col1') #设置inplace=True后会直接在原DataFrame中改动
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410152212.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df['col1']=[1,2,3,4,5]
del df['col1']
df
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410152312.png" alt="" loading="lazy"></figure>
<p><code>pop</code>方法直接在原来的<code>DataFrame</code>上操作，且返回被删除的列，与<code>python</code>中的<code>pop</code>函数类似</p>
<pre><code class="language-python">df['col1']=[1,2,3,4,5]
df.pop('col1')
一    1
二    2
三    3
四    4
五    5
Name: col1, dtype: int64
df
	col2	col3
一	5	1.3
二	6	2.5
三	7	3.6
四	8	4.6
五	9	5.8
</code></pre>
<p>可以直接增加新的列，也可以使用<code>assign</code>方法,但<code>assign</code>方法不会对原<code>DataFrame</code>做修改</p>
<pre><code class="language-python">df1['B']=list('abc')
df1
	A	B
1	1	a
2	2	b
3	3	c
df1.assign(C=pd.Series(list('def')))
	A	B	C
1	1	a	e
2	2	b	f
3	3	c	NaN
</code></pre>
<h4 id="根据类型选择列">根据类型选择列</h4>
<pre><code class="language-python">df.select_dtypes(include=['number']).head()
	col2	col3
一	5	1.3
二	6	2.5
三	7	3.6
四	8	4.6
五	9	5.8
df.select_dtypes(include=['float']).head()
	col3
一	1.3
二	2.5
三	3.6
四	4.6
五	5.8
</code></pre>
<h4 id="将series转换为dataframe">将<code>Series</code>转换为<code>DataFrame</code></h4>
<pre><code class="language-python">s = df.mean()
s.name='to_DataFrame'
s
col2    7.00
col3    3.56
Name: to_DataFrame, dtype: float64
s.to_frame()
	to_DataFrame
col2	7.00
col3	3.56
</code></pre>
<p>使用<code>T</code>符号可以转置</p>
<pre><code class="language-python">s.to_frame().T
	            col2	col3
to_DataFrame	7.0	    3.56
</code></pre>
<h2 id="常用基本函数">常用基本函数</h2>
<p>从下面开始，包括后面所有章节，我们都会用到这份虚拟的数据集</p>
<pre><code class="language-python">df = pd.read_csv('data/table.csv')
</code></pre>
<h3 id="head和tail"><code>head</code>和<code>tail</code></h3>
<pre><code class="language-python">df.head()
	School	Class	ID	Gender	Address	    Height	Weight	Math	Physics
0	S_1	    C_1	    1101	M	street_1	173	    63	    34.0	A+
1	S_1	    C_1	    1102	F	street_2	192	    73	    32.5	B+
2	S_1	    C_1	    1103	M	street_2	186	    82	    87.2	B+
3	S_1	    C_1	    1104	F	street_2	167	    81	    80.4	B-
4	S_1	    C_1	    1105	F	street_4	159	    64	    84.8	B+
df.tail()
	School	Class	ID	Gender	Address	    Height	Weight	Math	Physics
30	S_2	    C_4	    2401	F	street_2	192	    62	    45.3	A
31	S_2	    C_4	    2402	M	street_7	166	    82	    48.7	B
32	S_2	    C_4	    2403	F	street_6	158	    60	    59.7	B+
33	S_2	    C_4	    2404	F	street_2	160	    84	    67.7	B
34	S_2	    C_4	    2405	F	street_6	193	    54	    47.6	B
</code></pre>
<p>可以指定<code>n</code>参数显示多少行</p>
<pre><code class="language-python">df.head(3)
	School	Class	ID	Gender	Address	    Height	Weight	Math	Physics
0	S_1	    C_1	    1101	M	street_1	173	    63	    34.0	A+
1	S_1	    C_1	    1102	F	street_2	192	    73	    32.5	B+
2	S_1	    C_1	    1103	M	street_2	186	    82	    87.2	B+
</code></pre>
<h3 id="unique和nunique"><code>unique</code>和<code>nunique</code></h3>
<p><code>nunique</code>显示有多少个唯一值</p>
<pre><code class="language-python">df['Physics'].nunique()
7
</code></pre>
<p><code>unique</code>显示所有的唯一值</p>
<pre><code class="language-python">df['Physics'].unique()
array(['A+', 'B+', 'B-', 'A-', 'B', 'A', 'C'], dtype=object)
</code></pre>
<h3 id="count和value_counts"><code>count</code>和<code>value_counts</code></h3>
<p><code>count</code>返回非缺失值元素个数</p>
<pre><code class="language-python">df['Physics'].count()
35
</code></pre>
<p><code>value_counts</code>返回每个元素有多少个</p>
<pre><code class="language-python">df['Physics'].value_counts()
B+    9
B     8
B-    6
A     4
A+    3
A-    3
C     2
Name: Physics, dtype: int64
</code></pre>
<h3 id="describe和info"><code>describe</code>和<code>info</code></h3>
<p><code>info</code>函数返回有哪些列、有多少非缺失值、每列的类型</p>
<pre><code class="language-python">df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 35 entries, 0 to 34
Data columns (total 9 columns):
 #   Column   Non-Null Count  Dtype  
---  ------   --------------  -----  
 0   School   35 non-null     object 
 1   Class    35 non-null     object 
 2   ID       35 non-null     int64  
 3   Gender   35 non-null     object 
 4   Address  35 non-null     object 
 5   Height   35 non-null     int64  
 6   Weight   35 non-null     int64  
 7   Math     35 non-null     float64
 8   Physics  35 non-null     object 
dtypes: float64(1), int64(3), object(5)
memory usage: 2.6+ KB
</code></pre>
<p><code>describe</code>默认统计数值型数据的各个统计量</p>
<pre><code class="language-python">df.describe()
        ID	    Height	    Weight	    Math
count 35.00000	35.000000	35.000000	35.000000
mean  1803.00000 174.142857	74.657143	61.351429
std	536.87741	13.541098	12.895377	19.915164
min	1101.00000	155.000000	53.000000	31.500000
25%	1204.50000	161.000000	63.000000	47.400000
50%	2103.00000	173.000000	74.000000	61.700000
75%	2301.50000	187.500000	82.000000	77.100000
max	2405.00000	195.000000	100.000000	97.000000
</code></pre>
<p>可以自行选择分位数</p>
<pre><code class="language-python">df.describe(percentiles=[.05, .25, .75, .95])
	        ID	  Height	  Weight	   Math
count 35.00000	35.000000	35.000000	35.000000
mean 1803.00000	174.142857	74.657143	61.351429
std	536.87741	13.541098	12.895377	19.915164
min	1101.00000	155.000000	53.000000	31.500000
5%	1102.70000	157.000000	56.100000	32.640000
25%	1204.50000	161.000000	63.000000	47.400000
50%	2103.00000	173.000000	74.000000	61.700000
75%	2301.50000	187.500000	82.000000	77.100000
95%	2403.30000	193.300000	97.600000	90.040000
max	2405.00000	195.000000	100.000000	97.000000
</code></pre>
<p>对于非数值型也可以用<code>describe</code>函数</p>
<pre><code class="language-python">df['Physics'].describe()
count     35
unique     7
top       B+
freq       9
Name: Physics, dtype: object
</code></pre>
<h3 id="idxmax和nlargest"><code>idxmax</code>和<code>nlargest</code></h3>
<p><code>idxmax</code>函数返回最大值，在某些情况下特别适用，<code>idxmin</code>功能类似</p>
<pre><code class="language-python">df['Math'].idxmax()
5
</code></pre>
<p><code>nlargest</code>函数返回前几个大的元素值，<code>nsmallest</code>功能类似</p>
<pre><code class="language-python">df['Math'].nlargest(3)
5     97.0
28    95.5
11    87.7
Name: Math, dtype: float64
</code></pre>
<h3 id="clip和replace"><code>clip</code>和<code>replace</code></h3>
<p><code>clip</code>和<code>replace</code>是两类替换函数,<code>clip</code>是对超过或者低于某些值的数进行截断</p>
<pre><code class="language-python">df['Math'].head()
0    34.0
1    32.5
2    87.2
3    80.4
4    84.8
Name: Math, dtype: float64
df['Math'].clip(33,80).head()
Out[54]:
0    34.0
1    33.0
2    80.0
3    80.0
4    80.0
Name: Math, dtype: float64
df['Math'].mad()
16.924244897959188
</code></pre>
<p><code>replace</code>是对某些值进行替换</p>
<pre><code class="language-python">df['Address'].head()
0    street_1
1    street_2
2    street_2
3    street_2
4    street_4
Name: Address, dtype: object
df['Address'].replace(['street_1','street_2'],['one','two']).head()
0         one
1         two
2         two
3         two
4    street_4
Name: Address, dtype: object
</code></pre>
<p>通过字典，可以直接在表中修改</p>
<pre><code class="language-python">df.replace({'Address':{'street_1':'one','street_2':'two'}}).head()
    School	Class	ID	Gender	Address	Height	Weight	Math	Physics
0	S_1	    C_1	    1101	M	one	    173	    63	    34.0	A+
1	S_1	    C_1	    1102	F	two	    192	    73	    32.5	B+
2	S_1	    C_1	    1103	M	two	    186	    82	    87.2	B+
3	S_1	    C_1	    1104	F	two	    167	    81	    80.4	B-
4	S_1	    C_1	    1105	F	street_4 159	64	    84.8	B+
</code></pre>
<h3 id="apply函数"><code>apply</code>函数</h3>
<p>对于<code>Series</code>，它可以迭代每一列的值操作：</p>
<pre><code class="language-python">df['Math'].apply(lambda x:str(x)+'!').head() #可以使用lambda表达式，也可以使用函数
0    34.0!
1    32.5!
2    87.2!
3    80.4!
4    84.8!
Name: Math, dtype: object
</code></pre>
<p>对于<code>DataFrame</code>，它可以迭代每一个列操作：</p>
<pre><code class="language-python">df.apply(lambda x:x.apply(lambda x:str(x)+'!')).head() #这是一个稍显复杂的例子，有利于理解apply的功能
	School	Class	ID	Gender	Address	Height	Weight	Math	Physics
0	S_1!	C_1!	1101!	M!	street_1!	173!	63!	34.0!	A+!
1	S_1!	C_1!	1102!	F!	street_2!	192!	73!	32.5!	B+!
2	S_1!	C_1!	1103!	M!	street_2!	186!	82!	87.2!	B+!
3	S_1!	C_1!	1104!	F!	street_2!	167!	81!	80.4!	B-!
4	S_1!	C_1!	1105!	F!	street_4!	159!	64!	84.8!	B+!
</code></pre>
<h2 id="排序">排序</h2>
<h3 id="索引排序">索引排序</h3>
<pre><code class="language-python">df.set_index('Math').head() #set_index函数可以设置索引
        School	Class	ID	Gender	Address	    Height	Weight	Physics
Math								
34.0	S_1	    C_1	    1101	M	street_1	173	    63	    A+
32.5	S_1	    C_1	    1102	F	street_2	192	    73	    B+
87.2	S_1	    C_1	    1103	M	street_2	186	    82	    B+
80.4	S_1	    C_1	    1104	F	street_2	167	    81	    B-
84.8	S_1	    C_1	    1105	F	street_4	159	    64	    B+
df.set_index('Math').sort_index().head() #可以设置ascending参数，默认为升序，True
        School	Class	ID	Gender	Address	    Height	Weight	Physics
Math								
31.5	S_1	    C_3	    1301	M	street_4	161	    68	    B+
32.5	S_1 	C_1	    1102	F	street_2	192	    73	    B+
32.7	S_2	    C_3	    2302	M	street_5	171	    88	    A
33.8	S_1	    C_2	    1204	F	street_5	162	    63	    B
34.0	S_1	    C_1	    1101	M	street_1	173	    63	    A+
</code></pre>
<h3 id="值排序">值排序</h3>
<pre><code class="language-python">df.sort_values(by='Class').head()
School	Class	ID	Gender	Address	        Height	Weight	Math	Physics
0	    S_1	    C_1	1101	M	street_1	173	    63	    34.0	A+
19	    S_2	    C_1	2105	M	street_4	170	    81	    34.2	A
18	    S_2	    C_1	2104	F	street_5	159	    97	    72.2	B+
16	    S_2	    C_1	2102	F	street_6	161	    61	    50.6	B+
15	    S_2	    C_1	2101	M	street_7	174	    84	    83.3	C
</code></pre>
<p>多个值排序，即先对第一层排，在第一层相同的情况下对第二层排序</p>
<pre><code class="language-python">df.sort_values(by=['Address','Height']).head()
    School	Class	ID	Gender	Address	    Height	Weight	Math	Physics
0	S_1	    C_1	    1101	M	street_1	173	    63	    34.0	A+
11	S_1	    C_3	    1302	F	street_1	175	    57	    87.7	A-
23	S_2	    C_2	    2204	M	street_1	175	    74	    47.2	B-
33	S_2	    C_4	    2404	F	street_2	160	    84  	67.7	B
3	S_1	    C_1	    1104	F	street_2	167	    81	    80.4	B-
</code></pre>
<h2 id="练习">练习</h2>
<h3 id="练习一">练习一</h3>
<p>现有一份关于美剧《权力的游戏》剧本的数据集，请解决以下问题：</p>
<pre><code class="language-python">pd.read_csv('data/Game_of_Thrones_Script.csv').head()
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411004952.png" alt="" loading="lazy"></figure>
<ul>
<li>在所有的数据中，一共出现了多少人物？</li>
</ul>
<pre><code class="language-python">df['Name'].nunique()
564
</code></pre>
<ul>
<li>以单元格计数（即简单把一个单元格视作一句），谁说了最多的话？</li>
</ul>
<pre><code class="language-python">df['Name'].value_counts().index[0]
'tyrion lannister'
</code></pre>
<ul>
<li>以单词计数，谁说了最多的单词？<br>
由于还没有学分组，因此方法繁琐</li>
</ul>
<pre><code class="language-python">df_words = df.assign(Words=df['Sentence'].apply(lambda x:len(x.split()))).sort_values(by='Name')
df_words.head()
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411005459.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">L_count = []
N_words = list(zip(df_words['Name'],df_words['Words']))
for i in N_words:
    if i == N_words[0]:
        L_count.append(i[1])
        last = i[0]
    else:
        L_count.append(L_count[-1]+i[1] if i[0]==last else i[1])
        last = i[0]
df_words['Count']=L_count
df_words['Name'][df_words['Count'].idxmax()]
'tyrion lannister'
</code></pre>
<h3 id="练习二">练习二</h3>
<p>现有一份关于科比的投篮数据集，请解决如下问题：</p>
<pre><code class="language-python">pd.read_csv('data/Kobe_data.csv',index_col='shot_id').head()
#index_col的作用是将某一列作为行索引
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411005647.png" alt="" loading="lazy"></figure>
<ul>
<li>哪种action_type和combined_shot_type的组合是最多的？</li>
</ul>
<pre><code class="language-python">pd.Series(list(zip(df['action_type'],df['combined_shot_type']))).value_counts().index[0]
('Jump Shot', 'Jump Shot')
</code></pre>
<ul>
<li>在所有被记录的game_id中，遭遇到最多的opponent是一个支？</li>
</ul>
<pre><code class="language-python">pd.Series(list(list(zip(*(pd.Series(list(zip(df['game_id'],df['opponent']))).unique()).tolist()))[1])).value_counts().index[0]
'SAS'
</code></pre>
<h1 id="索引">索引</h1>
<pre><code class="language-python">import pandas as pd
df = pd.read_csv('data/table.csv',index_col='ID')
df.head()
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1101	S_1	    C_1	    M	    street_1	173	    63	    34.0	A+
1102	S_1	    C_1	    F	    street_2	192	    73	    32.5	B+
1103	S_1	    C_1	    M	    street_2	186	    82	    87.2	B+
1104	S_1	    C_1	    F	    street_2	167	    81	    80.4	B-
1105	S_1	    C_1	    F	    street_4	159	    64	    84.8	B+
</code></pre>
<h2 id="单级索引">单级索引</h2>
<h3 id="loc方法-iloc方法-操作符"><code>loc</code>方法、<code>iloc</code>方法、<code>[]</code>操作符</h3>
<p>最常用的索引方法可能就是这三类，其中<code>iloc</code>表示位置索引，<code>loc</code>表示标签索引，<code>[]</code>也具有很大的便利性，各有特点</p>
<h4 id="loc方法"><code>loc</code>方法</h4>
<p>注意：所有在<code>loc</code>中使用的切片全部包含右端点！</p>
<h5 id="单行索引">单行索引</h5>
<pre><code class="language-python">df.loc[1103]
School          S_1
Class           C_1
Gender            M
Address    street_2
Height          186
Weight           82
Math           87.2
Physics          B+
Name: 1103, dtype: object
</code></pre>
<h5 id="多行索引">多行索引</h5>
<pre><code class="language-python">df.loc[[1102,2304]]
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1102	S_1	    C_1	    F	    street_2	192	    73	    32.5	B+
2304	S_2	    C_3	    F	    street_6	164	    81	    95.5	A-
df.loc[1304:].head()
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1304	S_1	    C_3	    M	    street_2	195	    70	    85.2	A
1305	S_1	    C_3	    F	    street_5	187	    69	    61.7	B-
2101	S_2	    C_1	    M	    street_7	174	    84	    83.3	C
2102	S_2	    C_1	    F	    street_6	161	    61	    50.6	B+
2103	S_2	    C_1	    M	    street_4	157	    61	    52.5	B-
df.loc[2402::-1].head()
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
2402	S_2	    C_4	    M	    street_7	166	    82	    48.7	B
2401	S_2	    C_4	    F	    street_2	192	    62	    45.3	A
2305	S_2	    C_3	    M	    street_4	187	    73	    48.9	B
2304	S_2	    C_3	    F	    street_6	164	    81	    95.5	A-
2303	S_2	    C_3	    F	    street_7	190	    99	    65.9	C
</code></pre>
<h5 id="单列索引">单列索引</h5>
<pre><code class="language-python">df.loc[:,'Height'].head()
ID
1101    173
1102    192
1103    186
1104    167
1105    159
Name: Height, dtype: int64
</code></pre>
<h5 id="多列索引">多列索引：</h5>
<pre><code class="language-python">df.loc[:,['Height','Math']].head()
     Height	Math
ID		
1101	173	34.0
1102	192	32.5
1103	186	87.2
1104	167	80.4
1105	159	84.8
df.loc[:,'Height':'Math'].head()
        Height	Weight	Math
ID			
1101	173	    63	    34.0
1102	192	    73	    32.5
1103	186	    82	    87.2
1104	167	    81	    80.4
1105	159	    64	    84.8
</code></pre>
<h5 id="联合索引">联合索引</h5>
<pre><code class="language-python">df.loc[1102:2401:3,'Height':'Math'].head()
        Height	Weight	Math
ID			
1102	192	    73	    32.5
1105	159	    64	    84.8
1203	160	    53	    58.8
1301	161	    68	    31.5
1304	195	    70	    85.2
</code></pre>
<h5 id="函数式索引">函数式索引</h5>
<pre><code class="language-python">df.loc[lambda x:x['Gender']=='M'].head()#loc中使用的函数，传入参数就是前面的df
        School	Class	Gender	Address	Height	Weight	Math	Physics
ID								
1101	S_1	    C_1	    M	street_1	173	    63	    34.0	A+
1103	S_1	    C_1	    M	street_2	186	    82	    87.2	B+
1201	S_1	    C_2	    M	street_5	188	    68	    97.0	A-
1203	S_1	    C_2	    M	street_6	160	    53	    58.8	A+
1301	S_1	    C_3	    M	street_4	161	    68	    31.5	B+
def f(x):
    return [1101,1103]
df.loc[f]
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1101	S_1	    C_1	    M	    street_1	173	    63	    34.0	A+
1103	S_1	    C_1	    M	    street_2	186	    82	    87.2	B+
</code></pre>
<h5 id="布尔索引">布尔索引</h5>
<pre><code class="language-python">df.loc[df['Address'].isin(['street_7','street_4'])].head()
        School	Class	Gender	Address	Height	Weight	Math	Physics
ID								
1105	S_1	    C_1	    F	    street_4	159	    64	84.8	B+
1202	S_1	    C_2	    F	    street_4	176	    94	63.5	B-
1301	S_1	    C_3	    M	    street_4	161	    68	31.5	B+
1303	S_1	    C_3	    M	    street_7	188	    82	49.7	B
2101	S_2	    C_1	    M	    street_7	174	    84	83.3	C
df.loc[[True if i[-1]=='4' or i[-1]=='7' else False for i in df['Address'].values]].head()
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1105	S_1	    C_1	    F	    street_4	159	    64	84.8	B+
1202	S_1	    C_2	    F	    street_4	176	    94	63.5	B-
1301	S_1	    C_3	    M	    street_4	161	    68	31.5	B+
1303	S_1 	C_3	    M	    street_7	188	    82	49.7	B
2101	S_2	    C_1	    M	    street_7	174	    84	83.3	C
</code></pre>
<p>本质上说，<code>loc</code>中能传入的只有布尔列表和索引子集构成的列表，只要把握这个原则就很容易理解上面那些操作</p>
<h4 id="iloc方法"><code>iloc</code>方法</h4>
<p>注意与<code>loc</code>不同，切片右端点不包含</p>
<h5 id="单行索引-2">单行索引</h5>
<pre><code class="language-python">df.iloc[3]
School          S_1
Class           C_1
Gender            F
Address    street_2
Height          167
Weight           81
Math           80.4
Physics          B-
Name: 1104, dtype: object
</code></pre>
<h5 id="多行索引-2">多行索引</h5>
<pre><code class="language-python">df.iloc[3:5]
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1104	S_1 	C_1	    F	    street_2	167	    81  	80.4	B-
1105	S_1	    C_1	    F	    street_4	159	    64	    84.8	B+
</code></pre>
<h5 id="单列索引-2">单列索引</h5>
<pre><code class="language-python">df.iloc[:,3].head()
ID
1101    street_1
1102    street_2
1103    street_2
1104    street_2
1105    street_4
Name: Address, dtype: object
</code></pre>
<h5 id="多列索引-2">多列索引</h5>
<pre><code class="language-python">df.iloc[:,7::-2].head()
    Physics	Weight	Address	    Class
ID				
1101	A+	63  	street_1	C_1
1102	B+	73	    street_2	C_1
1103	B+	82	    street_2	C_1
1104	B-	81	    street_2	C_1
1105	B+	64	    street_4	C_1
</code></pre>
<h5 id="混合索引">混合索引</h5>
<pre><code class="language-python">df.iloc[3::4,7::-2].head()
    Physics	Weight	Address 	Class
ID				
1104	B-	81	    street_2	C_1
1203	A+	53	    street_6	C_2
1302	A-	57	    street_1	C_3
2101	C	84	    street_7	C_1
2105	A	81	    street_4	C_1
</code></pre>
<h5 id="函数式索引-2">函数式索引</h5>
<pre><code class="language-python">df.iloc[lambda x:[3]].head()
    School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1104	S_1	C_1	    F	    street_2	167	    81	    80.4	B-
</code></pre>
<p>小节：由上所述，<code>iloc</code>中接收的参数只能为整数或整数列表，不能使用布尔索引</p>
<h4 id="操作符"><code>[]</code>操作符</h4>
<p>如果不想陷入困境，请不要在行索引为浮点时使用<code>[]</code>操作符，因为在<code>Series</code>中的浮点<code>[]</code>并不是进行位置比较，而是值比较，非常特殊</p>
<h5 id="series的操作"><code>Series</code>的<code>[]</code>操作</h5>
<h6 id="单元素索引">单元素索引</h6>
<pre><code class="language-python">s = pd.Series(df['Math'],index=df.index)
s[1101]#使用的是索引标签
34.0
</code></pre>
<h6 id="多行索引-3">多行索引</h6>
<pre><code class="language-python">s[0:4]#使用的是绝对位置的整数切片，与元素无关，这里容易混淆
ID
1101    34.0
1102    32.5
1103    87.2
1104    80.4
Name: Math, dtype: float64
</code></pre>
<h6 id="函数式索引-3">函数式索引</h6>
<pre><code class="language-python">s[lambda x: x.index[16::-6]]#注意使用lambda函数时，直接切片(如：s[lambda x: 16::-6])就报错，此时使用的不是绝对位置切片，而是元素切片，非常易错
ID
2102    50.6
1301    31.5
1105    84.8
Name: Math, dtype: float64
</code></pre>
<h6 id="布尔索引-2">布尔索引</h6>
<pre><code class="language-python">s[s&gt;80]
ID
1103    87.2
1104    80.4
1105    84.8
1201    97.0
1302    87.7
1304    85.2
2101    83.3
2205    85.4
2304    95.5
Name: Math, dtype: float64
</code></pre>
<h5 id="dataframe的操作"><code>DataFrame</code>的<code>[]</code>操作</h5>
<h6 id="单行索引-3">单行索引</h6>
<pre><code class="language-python">df[1:2]
#这里非常容易写成df['label']，会报错
#同Series使用了绝对位置切片
#如果想要获得某一个元素，可用如下get_loc方法：
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1102	S_1	    C_1	    F	    street_2	192	    73	    32.5	B+
row = df.index.get_loc(1102)
df[row:row+1]
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1102	S_1	    C_1	    F	    street_2	192	    73	    32.5	B+
</code></pre>
<h6 id="多行索引-4">多行索引</h6>
<pre><code class="language-python">#用切片，如果是选取指定的某几行，推荐使用loc，否则很可能报错
df[3:5]
    School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1104	S_1	C_1	    F	    street_2	167	    81	    80.4	B-
1105	S_1	C_1	    F	    street_4	159	    64	    84.8	B+
</code></pre>
<h6 id="单列索引-3">单列索引</h6>
<pre><code class="language-python">df['School'].head()
ID
1101    S_1
1102    S_1
1103    S_1
1104    S_1
1105    S_1
Name: School, dtype: object
</code></pre>
<h6 id="多列索引-3">多列索引</h6>
<pre><code class="language-python">df[['School','Math']].head()
    School	Math
ID		
1101	S_1	34.0
1102	S_1	32.5
1103	S_1	87.2
1104	S_1	80.4
1105	S_1	84.8
</code></pre>
<h6 id="函数式索引-4">函数式索引</h6>
<pre><code class="language-python">df[lambda x:['Math','Physics']].head()
        Math	Physics
ID		
1101	34.0	A+
1102	32.5	B+
1103	87.2	B+
1104	80.4	B-
1105	84.8	B+
</code></pre>
<h6 id="布尔索引-3">布尔索引</h6>
<pre><code class="language-python">df[df['Gender']=='F'].head()

    School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1102	S_1	C_1	    F	    street_2	192	    73	    32.5	B+
1104	S_1	C_1	    F	    street_2	167	    81	    80.4	B-
1105	S_1	C_1	    F	    street_4	159	    64	    84.8	B+
1202	S_1	C_2	    F	    street_4	176	    94	    63.5	B-
1204	S_1	C_2	    F	    street_5	162	    63	    33.8	B
</code></pre>
<p>一般来说，<code>[]</code>操作符常用于列选择或布尔选择，尽量避免行的选择</p>
<h3 id="布尔索引-4">布尔索引</h3>
<h4 id="布尔符号">布尔符号</h4>
<p><code>&amp;</code>,<code>|</code>,<code>~</code>：分别代表和<code>and</code>，或<code>or</code>，取反<code>not</code></p>
<pre><code class="language-python">df[(df['Gender']=='F')&amp;(df['Address']=='street_2')].head()
    School	    Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1102	S_1	    C_1 	F	    street_2	192	    73	    32.5	B+
1104	S_1	    C_1	    F	    street_2	167	    81	    80.4	B-
2401	S_2	    C_4	    F	    street_2	192	    62	    45.3	A
2404	S_2	    C_4	    F	    street_2	160	    84	    67.7	B
df[(df['Math']&gt;85)|(df['Address']=='street_7')].head()
        School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1103	S_1	    C_1	    M	    street_2	186	    82	    87.2	B+
1201	S_1	    C_2	    M	    street_5	188	    68	    97.0	A-
1302	S_1	    C_3	    F	    street_1	175	    57	    87.7	A-
1303	S_1	    C_3	    M	    street_7	188	    82	    49.7	B
1304	S_1	    C_3	    M	    street_2	195	    70  	85.2	A
df[~((df['Math']&gt;75)|(df['Address']=='street_1'))].head()
    School	Class	Gender	Address	    Height	Weight	Math	Physics
ID								
1102	S_1	C_1 	F	    street_2	192	    73	    32.5	B+
1202	S_1	C_2	    F	    street_4	176	    94	    63.5	B-
1203	S_1	C_2	    M	    street_6	160	    53	    58.8	A+
1204	S_1	C_2	    F	    street_5	162	    63  	33.8	B
1205	S_1	C_2	    F	    street_6	167	    63	    68.4	B-
</code></pre>
<p><code>loc</code>和<code>[]</code>中相应位置都能使用布尔列表选择：</p>
<pre><code class="language-python">df.loc[df['Math']&gt;60,(df[:8]['Address']=='street_6').values].head()
#如果不加values就会索引对齐发生错误，Pandas中的索引对齐是一个重要特征，很多时候非常实用
#但是若不加以留意，就会埋下隐患
Physics
ID	
1103	B+
1104	B-
1105	B+
1201	A-
1202	B-
</code></pre>
<h4 id="isin方法"><code>isin</code>方法</h4>
<pre><code class="language-python">df[df['Address'].isin(['street_1','street_4'])&amp;df['Physics'].isin(['A','A+'])]
    School	Class	Gender	Address	Height	Weight	Math	Physics
ID								
1101	S_1	C_1	    M	    street_1	173 	63	34.0	A+
2105	S_2	C_1	    M	    street_4	170	    81	34.2	A
2203	S_2	C_2	    M	    street_4	155	    91	73.8	A+
#上面也可以用字典方式写：
df[df[['Address','Physics']].isin({'Address':['street_1','street_4'],'Physics':['A','A+']}).all(1)]
#all与&amp;的思路是类似的，其中的1代表按照跨列方向判断是否全为True
    School	Class	Gender	Address	Height	Weight	Math	Physics
ID								
1101	S_1	C_1	    M	street_1	173	    63	    34.0	A+
2105	S_2	C_1	    M	street_4	170	    81  	34.2	A
2203	S_2	C_2	    M	street_4	155	    91	    73.8	A+
</code></pre>
<h3 id="快速标量索引">快速标量索引</h3>
<p>当只需要取一个元素时，<code>at</code>和<code>iat</code>方法能够提供更快的实现：</p>
<pre><code class="language-python">display(df.at[1101,'School'])
display(df.loc[1101,'School'])
display(df.iat[0,0])
display(df.iloc[0,0])
#可尝试去掉注释对比时间
#%timeit df.at[1101,'School']
#%timeit df.loc[1101,'School']
#%timeit df.iat[0,0]
#%timeit df.iloc[0,0]
'S_1'
'S_1'
'S_1'
'S_1'
</code></pre>
<h3 id="区间索引">区间索引</h3>
<p>此处介绍并不是说只能在单级索引中使用区间索引，只是作为一种特殊类型的索引方式，在此处先行介绍</p>
<h4 id="利用interval_range方法">利用<code>interval_range</code>方法</h4>
<pre><code class="language-python">pd.interval_range(start=0,end=5)
#closed参数可选'left''right''both''neither'，默认左开右闭
IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],
              closed='right',
              dtype='interval[int64]')
pd.interval_range(start=0,periods=8,freq=5)
#periods参数控制区间个数，freq控制步长
IntervalIndex([(0, 5], (5, 10], (10, 15], (15, 20], (20, 25], (25, 30], (30, 35], (35, 40]],
              closed='right',
              dtype='interval[int64]')
</code></pre>
<h4 id="利用cut将数值列转为区间为元素的分类变量例如统计数学成绩的区间情况">利用<code>cut</code>将数值列转为区间为元素的分类变量，例如统计数学成绩的区间情况：</h4>
<pre><code class="language-python">math_interval = pd.cut(df['Math'],bins=[0,40,60,80,100])
#注意，如果没有类型转换，此时并不是区间类型，而是category类型
math_interval.head()
ID
1101      (0, 40]
1102      (0, 40]
1103    (80, 100]
1104    (80, 100]
1105    (80, 100]
Name: Math, dtype: category
Categories (4, interval[int64]): [(0, 40] &lt; (40, 60] &lt; (60, 80] &lt; (80, 100]]
</code></pre>
<h4 id="区间索引的选取">区间索引的选取</h4>
<pre><code class="language-python">df_i = df.join(math_interval,rsuffix='_interval')[['Math','Math_interval']]\
            .reset_index().set_index('Math_interval')
df_i.head()
ID	Math
Math_interval		
(0, 40]	1101	34.0
(0, 40]	1102	32.5
(80, 100]	1103	87.2
(80, 100]	1104	80.4
(80, 100]	1105	84.8
df_i.loc[65].head()
#包含该值就会被选中
            ID	    Math
Math_interval		
(60, 80]	1202	63.5
(60, 80]	1205	68.4
(60, 80]	1305	61.7
(60, 80]	2104	72.2
(60, 80]	2202	68.5
df_i.loc[[65,90]].head()
            ID	    Math
Math_interval		
(60, 80]	1202	63.5
(60, 80]	1205	68.4
(60, 80]	1305	61.7
(60, 80]	2104	72.2
(60, 80]	2202	68.5
</code></pre>
<p>如果想要选取某个区间，先要把分类变量转为区间变量，再使用<code>overlap</code>方法：</p>
<pre><code class="language-python">#df_i.loc[pd.Interval(70,75)].head() 报错
df_i[df_i.index.astype('interval').overlaps(pd.Interval(70, 85))].head()
            ID	    Math
Math_interval		
(80, 100]	1103	87.2
(80, 100]	1104	80.4
(80, 100]	1105	84.8
(80, 100]	1201	97.0
(60, 80]	1202	63.5
</code></pre>
<h2 id="多级索引">多级索引</h2>
<h3 id="创建多级索引">创建多级索引</h3>
<h4 id="通过from_tuple或from_arrays">通过<code>from_tuple</code>或<code>from_arrays</code></h4>
<h5 id="直接创建元组">直接创建元组</h5>
<pre><code class="language-python">tuples = [('A','a'),('A','b'),('B','a'),('B','b')]
mul_index = pd.MultiIndex.from_tuples(tuples, names=('Upper', 'Lower'))
mul_index
MultiIndex([('A', 'a'),
            ('A', 'b'),
            ('B', 'a'),
            ('B', 'b')],
           names=['Upper', 'Lower'])
pd.DataFrame({'Score':['perfect','good','fair','bad']},index=mul_index)
            Score
Upper	Lower	
A	    a	perfect
        b	good
B	    a	fair
        b	bad
</code></pre>
<h5 id="利用zip创建元组">利用<code>zip</code>创建元组</h5>
<pre><code class="language-python">L1 = list('AABB')
L2 = list('abab')
tuples = list(zip(L1,L2))
mul_index = pd.MultiIndex.from_tuples(tuples, names=('Upper', 'Lower'))
pd.DataFrame({'Score':['perfect','good','fair','bad']},index=mul_index)
                Score
Upper	Lower	
A	    a	    perfect
        b	    good
B	    a	    fair
        b	    bad
</code></pre>
<h5 id="通过array创建">通过<code>Array</code>创建</h5>
<pre><code class="language-python">arrays = [['A','a'],['A','b'],['B','a'],['B','b']]
mul_index = pd.MultiIndex.from_tuples(arrays, names=('Upper', 'Lower'))
pd.DataFrame({'Score':['perfect','good','fair','bad']},index=mul_index)
            Score
Upper	Lower	
A	    a	perfect
        b	good
B	    a	fair
        b	bad
mul_index
#由此看出内部自动转成元组
MultiIndex([('A', 'a'),
            ('A', 'b'),
            ('B', 'a'),
            ('B', 'b')],
           names=['Upper', 'Lower'])
</code></pre>
<h5 id="通过from_product">通过<code>from_product</code></h5>
<pre><code class="language-python">L1 = ['A','B']
L2 = ['a','b']
pd.MultiIndex.from_product([L1,L2],names=('Upper', 'Lower'))
#两两相乘
MultiIndex([('A', 'a'),
            ('A', 'b'),
            ('B', 'a'),
            ('B', 'b')],
           names=['Upper', 'Lower'])
</code></pre>
<h5 id="指定df中的列创建set_index方法">指定<code>df</code>中的列创建（<code>set_index</code>方法）</h5>
<pre><code class="language-python">df_using_mul = df.set_index(['Class','Address'])
df_using_mul.head()
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410182403.png" alt="" loading="lazy"></figure>
<h3 id="多层索引切片">多层索引切片</h3>
<pre><code class="language-python">df_using_mul.head()
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410182403.png" alt="" loading="lazy"></figure>
<h4 id="一般切片">一般切片</h4>
<pre><code class="language-python">#df_using_mul.loc['C_2','street_5']
#当索引不排序时，单个索引会报出性能警告
#df_using_mul.index.is_lexsorted()
#该函数检查是否排序
df_using_mul.sort_index().loc['C_2','street_5']
#df_using_mul.sort_index().index.is_lexsorted()
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410182801.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">#df_using_mul.loc[('C_2','street_5'):] 报错
#当不排序时，不能使用多层切片
df_using_mul.sort_index().loc[('C_2','street_6'):('C_3','street_4')]
#注意此处由于使用了loc，因此仍然包含右端点
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410183032.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_using_mul.sort_index().loc[('C_2','street_7'):'C_3'].head()
#非元组也是合法的，表示选中该层所有元素
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410183116.png" alt="" loading="lazy"></figure>
<h4 id="第一类特殊情况由元组构成列表">第一类特殊情况：由元组构成列表</h4>
<pre><code class="language-python">df_using_mul.sort_index().loc[[('C_2','street_7'),('C_3','street_2')]]
#表示选出某几个元素，精确到最内层索引
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410184950.png" alt="" loading="lazy"></figure>
<h4 id="第二类特殊情况由列表构成元组">第二类特殊情况：由列表构成元组</h4>
<pre><code class="language-python">df_using_mul.sort_index().loc[(['C_2','C_3'],['street_4','street_7']),:]
#选出第一层在‘C_2’和'C_3'中且第二层在'street_4'和'street_7'中的行
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410185033.png" alt="" loading="lazy"></figure>
<h3 id="多层索引中的slice对象">多层索引中的<code>slice</code>对象</h3>
<pre><code class="language-python">L1,L2 = ['A','B','C'],['a','b','c']
mul_index1 = pd.MultiIndex.from_product([L1,L2],names=('Upper', 'Lower'))
L3,L4 = ['D','E','F'],['d','e','f']
mul_index2 = pd.MultiIndex.from_product([L3,L4],names=('Big', 'Small'))
df_s = pd.DataFrame(np.random.rand(9,9),index=mul_index1,columns=mul_index2)
df_s
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410185414.png" alt="" loading="lazy"><br>
索引<code>Slice</code>的使用非常灵活：</p>
<pre><code class="language-python">df_s.loc[idx['B':,df_s['D']['d']&gt;0.3],idx[df_s.sum()&gt;4]]
#df_s.sum()默认为对列求和，因此返回一个长度为9的数值列表
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410185807.png" alt="" loading="lazy"></figure>
<h3 id="索引层的交换">索引层的交换</h3>
<h4 id="swaplevel方法两层交换"><code>swaplevel</code>方法（两层交换）</h4>
<pre><code class="language-python">df_using_mul.head()
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410192040.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_using_mul.swaplevel(i=1,j=0,axis=0).sort_index().head()
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410192504.png" alt="" loading="lazy"></figure>
<h4 id="reorder_levels方法多层交换"><code>reorder_levels</code>方法（多层交换）</h4>
<pre><code class="language-python">df_muls = df.set_index(['School','Class','Address'])
df_muls.head()
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410192659.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_muls.reorder_levels([2,0,1],axis=0).sort_index().head()
</code></pre>
<figure data-type="image" tabindex="22"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410192745.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">#如果索引有name，可以直接使用name
df_muls.reorder_levels(['Address','School','Class'],axis=0).sort_index().head()
</code></pre>
<figure data-type="image" tabindex="23"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410192745.png" alt="" loading="lazy"></figure>
<h2 id="索引设定">索引设定</h2>
<h3 id="index_col参数"><code>index_col</code>参数</h3>
<p><code>index_col</code>是<code>read_csv</code>中的一个参数，而不是某一个方法：</p>
<pre><code class="language-python">pd.read_csv('data/table.csv',index_col=['Address','School']).head()
</code></pre>
<figure data-type="image" tabindex="24"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410193115.png" alt="" loading="lazy"></figure>
<h3 id="reindex和reindex_like"><code>reindex</code>和<code>reindex_like</code></h3>
<p><code>reindex</code>是指重新索引，它的重要特性在于索引对齐，很多时候用于重新排序</p>
<pre><code class="language-python">df.head()
</code></pre>
<figure data-type="image" tabindex="25"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410193223.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.reindex(index=[1101,1203,1206,2402])
</code></pre>
<figure data-type="image" tabindex="26"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410193326.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">
df.reindex(columns=['Height','Gender','Average']).head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410193454.png" alt="" loading="lazy"><br>
可以选择缺失值的填充方法：<code>fill_value</code>和<code>method</code>（<code>bfill</code>/<code>ffill</code>/<code>nearest</code>），其中<code>method</code>参数必须索引单调</p>
<pre><code class="language-python">df.reindex(index=[1101,1203,1206,2402],method='bfill')
#bfill表示用所在索引1206的后一个有效行填充，ffill为前一个有效行，nearest是指最近的
</code></pre>
<figure data-type="image" tabindex="27"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410193710.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.reindex(index=[1101,1203,1206,2402],method='nearest')
#数值上1205比1301更接近1206，因此用前者填充
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410193816.png" alt="" loading="lazy"><br>
<code>reindex_like</code>的作用为生成一个横纵索引完全与参数列表一致的<code>DataFrame</code>，数据使用被调用的表</p>
<pre><code class="language-python">df_temp = pd.DataFrame({'Weight':np.zeros(5),
                        'Height':np.zeros(5),
                        'ID':[1101,1104,1103,1106,1102]}).set_index('ID')
df_temp.reindex_like(df[0:5][['Weight','Height']])
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410194124.png" alt="" loading="lazy"></figure>
<h3 id="set_index和reset_index"><code>set_index</code>和<code>reset_index</code></h3>
<p>先介绍<code>set_index</code>：从字面意思看，就是将某些列作为索引<br>
使用表内列作为索引：</p>
<pre><code class="language-python">df.head()
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410194303.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.set_index('Class').head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410194349.png" alt="" loading="lazy"><br>
利用<code>append</code>参数可以将当前索引维持不变</p>
<pre><code class="language-python">df.set_index('Class',append=True).head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410194712.png" alt="" loading="lazy"><br>
当使用与表长相同的列作为索引（需要先转化为<code>Series</code>，否则报错）：</p>
<pre><code class="language-python">df.set_index(pd.Series(range(df.shape[0]))).head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410194907.png" alt="" loading="lazy"><br>
可以直接添加多级索引</p>
<pre><code class="language-python">df.set_index([pd.Series(range(df.shape[0])),pd.Series(np.ones(df.shape[0]))]).head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410195012.png" alt="" loading="lazy"><br>
下面介绍<code>reset_index</code>方法，它的主要功能是将索引重置<br>
默认状态直接恢复到自然数索引：</p>
<pre><code class="language-python">df.reset_index().head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410195100.png" alt="" loading="lazy"><br>
用<code>level</code>参数指定哪一层被<code>reset</code>，用<code>col_level</code>参数指定<code>set</code>到哪一层</p>
<pre><code class="language-python">L1,L2 = ['A','B','C'],['a','b','c']
mul_index1 = pd.MultiIndex.from_product([L1,L2],names=('Upper', 'Lower'))
L3,L4 = ['D','E','F'],['d','e','f']
mul_index2 = pd.MultiIndex.from_product([L3,L4],names=('Big', 'Small'))
df_temp = pd.DataFrame(np.random.rand(9,9),index=mul_index1,columns=mul_index2)
df_temp.head()
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410195932.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_temp1 = df_temp.reset_index(level=1,col_level=1)
df_temp1.head()
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410200220.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_temp1.columns
#看到的确插入了level2
MultiIndex([( '', 'Lower'),
            ('D',     'd'),
            ('D',     'e'),
            ('D',     'f'),
            ('E',     'd'),
            ('E',     'e'),
            ('E',     'f'),
            ('F',     'd'),
            ('F',     'e'),
            ('F',     'f')],
           names=['Big', 'Small'])
df_temp1.index
#最内层索引被移出
Index(['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C'], dtype='object', name='Upper')
</code></pre>
<h3 id="rename_axis和rename"><code>rename_axis</code>和<code>rename</code></h3>
<p><code>rename_axis</code>是针对多级索引的方法，作用是修改某一层的索引名，而不是索引标签</p>
<pre><code class="language-python">df_temp.rename_axis(index={'Lower':'LowerLower'},columns={'Big':'BigBig'})
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410200250.png" alt="" loading="lazy"><br>
<code>rename</code>方法用于修改列或者行索引标签，而不是索引名：</p>
<pre><code class="language-python">df_temp.rename(index={'A':'T'},columns={'e':'changed_e'}).head()
</code></pre>
<figure data-type="image" tabindex="32"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410200319.png" alt="" loading="lazy"></figure>
<h2 id="常用索引型函数">常用索引型函数</h2>
<h3 id="where函数"><code>where</code>函数</h3>
<p>当对条件为<code>False</code>的单元进行填充：</p>
<pre><code class="language-python">df.head()
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410232150.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.where(df['Gender']=='M').head()
#不满足条件的行全部被设置为NaN
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410232423.png" alt="" loading="lazy"><br>
通过这种方法筛选结果和<code>[]</code>操作符的结果完全一致：</p>
<pre><code class="language-python">df.where(df['Gender']=='M').dropna().head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410232641.png" alt="" loading="lazy"><br>
第一个参数为布尔条件，第二个参数为填充值:</p>
<pre><code class="language-python">df.where(df['Gender']=='M',np.random.rand(df.shape[0],df.shape[1])).head()
</code></pre>
<figure data-type="image" tabindex="34"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410232828.png" alt="" loading="lazy"></figure>
<h3 id="mask函数"><code>mask</code>函数</h3>
<p><code>mask</code>函数与<code>where</code>功能上相反，其余完全一致，即对条件为<code>True</code>的单元进行填充</p>
<pre><code class="language-python">df.mask(df['Gender']=='M').dropna().head()
</code></pre>
<figure data-type="image" tabindex="35"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410233230.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.mask(df['Gender']=='M',np.random.rand(df.shape[0],df.shape[1])).head()
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410233317.png" alt="" loading="lazy"></figure>
<h3 id="query函数"><code>query</code>函数</h3>
<pre><code class="language-python">df.head()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410233421.png" alt="" loading="lazy"><br>
<code>query</code>函数中的布尔表达式中，下面的符号都是合法的：行列索引名、字符串、<code>and</code>/<code>not</code>/<code>or</code>/<code>&amp;</code>/<code>|</code>/<code>~</code>/<code>not in</code>/<code>in</code>/<code>==</code>/<code>!=</code>、四则运算符</p>
<pre><code class="language-python">df.query('(Address in [&quot;street_6&quot;,&quot;street_7&quot;])&amp;(Weight&gt;(70+10))&amp;(ID in [1303,2304,2402])')
</code></pre>
<figure data-type="image" tabindex="37"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410233532.png" alt="" loading="lazy"></figure>
<h2 id="重复元素处理">重复元素处理</h2>
<h3 id="duplicated方法"><code>duplicated</code>方法</h3>
<p>该方法返回了是否重复的布尔列表</p>
<pre><code class="language-python">df.duplicated('Class').head()
ID
1101    False
1102     True
1103     True
1104     True
1105     True
dtype: bool
</code></pre>
<p>可选参数<code>keep</code>默认为<code>first</code>，即首次出现设为不重复，若为<code>last</code>，则最后一次设为不重复，若为<code>False</code>，则所有重复项为<code>False</code></p>
<pre><code class="language-python">df.duplicated('Class',keep='last').tail()
ID
2401     True
2402     True
2403     True
2404     True
2405    False
dtype: bool
df.duplicated('Class',keep=False).head()
ID
1101    True
1102    True
1103    True
1104    True
1105    True
dtype: bool
</code></pre>
<h3 id="drop_duplicates方法"><code>drop_duplicates</code>方法</h3>
<p>从名字上看出为剔除重复项，这在后面章节中的分组操作中可能是有用的，例如需要保留每组的第一个值</p>
<pre><code class="language-python">df.drop_duplicates('Class')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410235736.png" alt="" loading="lazy"><br>
参数与<code>duplicate</code>函数类似：</p>
<pre><code class="language-python">df.drop_duplicates('Class',keep='last')
</code></pre>
<figure data-type="image" tabindex="38"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411000053.png" alt="" loading="lazy"></figure>
<p>在传入多列时等价于将多列共同视作一个多级索引，比较重复项:</p>
<pre><code class="language-python">df.drop_duplicates(['School','Class'])
</code></pre>
<figure data-type="image" tabindex="39"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411000806.png" alt="" loading="lazy"></figure>
<h2 id="抽样函数">抽样函数</h2>
<p>这里的抽样函数指的就是<code>sample</code>函数</p>
<h3 id="n为样本量"><code>n</code>为样本量</h3>
<pre><code class="language-python">df.sample(n=5)
</code></pre>
<figure data-type="image" tabindex="40"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411000925.png" alt="" loading="lazy"></figure>
<h3 id="frac为抽样比"><code>frac</code>为抽样比</h3>
<pre><code class="language-python">df.sample(frac=0.05)
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411001030.png" alt="" loading="lazy"></figure>
<h3 id="replace为是否放回"><code>replace</code>为是否放回</h3>
<pre><code class="language-python">df.sample(n=df.shape[0],replace=True).head()
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411001330.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.sample(n=35,replace=True).index.is_unique
False
</code></pre>
<h3 id="axis为抽样维度默认为0即抽行"><code>axis</code>为抽样维度，默认为<code>0</code>，即抽行</h3>
<pre><code class="language-python">df.sample(n=3,axis=1).head()
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411002725.png" alt="" loading="lazy"></figure>
<h3 id="weights为样本权重自动归一化"><code>weights</code>为样本权重，自动归一化</h3>
<pre><code class="language-python">df.sample(n=3,weights=np.random.rand(df.shape[0])).head()
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411002815.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">#以某一列为权重，这在抽样理论中很常见
df.sample(n=3,weights=df['Math']).head()
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411002849.png" alt="" loading="lazy"></figure>
<h2 id="练习-2">练习</h2>
<h3 id="练习一-2">练习一</h3>
<p>现有一份关于UFO的数据集，请解决下列问题：</p>
<pre><code class="language-python">pd.read_csv('data/UFO.csv').head()
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411003119.png" alt="" loading="lazy"></figure>
<ul>
<li>在所有被观测时间超过60s的时间中，哪个形状最多？</li>
</ul>
<pre><code class="language-python">df = pd.read_csv('data/UFO.csv')
df.rename(columns={'duration (seconds)':'duration'},inplace=True)
df['duration'].astype('float')
df.head()
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411003337.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.query('duration &gt; 60')['shape'].value_counts().index[0]
'light'
</code></pre>
<ul>
<li>对经纬度进行划分：-180°至180°以30°为一个划分，-90°至90°以18°为一个划分，请问哪个区域中报告的UFO事件数量最多？</li>
</ul>
<pre><code class="language-python">bins_long = np.linspace(-180,180,13).tolist()
bins_la = np.linspace(-90,90,11).tolist()
cuts_long = pd.cut(df['longitude'],bins=bins_long)
df['cuts_long'] = cuts_long
cuts_la = pd.cut(df['latitude'],bins=bins_la)
df['cuts_la'] = cuts_la
df.head()
</code></pre>
<figure data-type="image" tabindex="48"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411003744.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.set_index(['cuts_long','cuts_la']).index.value_counts().head()
((-90.0, -60.0], (36.0, 54.0])      27891
((-120.0, -90.0], (18.0, 36.0])     14280
((-120.0, -90.0], (36.0, 54.0])     11960
((-90.0, -60.0], (18.0, 36.0])       9923
((-150.0, -120.0], (36.0, 54.0])     9658
dtype: int64
</code></pre>
<h3 id="练习二-2">练习二</h3>
<p>现有一份关于口袋妖怪的数据集，请解决下列问题：</p>
<pre><code class="language-python">pd.read_csv('data/Pokemon.csv').head()
</code></pre>
<figure data-type="image" tabindex="49"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411003950.png" alt="" loading="lazy"></figure>
<ul>
<li>双属性的Pokemon占总体比例的多少？</li>
</ul>
<pre><code class="language-python">df = pd.read_csv('data/Pokemon.csv')
df.head()
</code></pre>
<figure data-type="image" tabindex="50"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411003950.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df['Type 2'].count()/df.shape[0]
0.5175
</code></pre>
<ul>
<li>在所有种族值（Total）不小于580的Pokemon中，非神兽（<code>Legendary=False</code>）的比例为多少？</li>
</ul>
<pre><code class="language-python">df.query('Total &gt;= 580')['Legendary'].value_counts(normalize=True)
True     0.575221
False    0.424779
Name: Legendary, dtype: float64
</code></pre>
<ul>
<li>在第一属性为格斗系（Fighting）的Pokemon中，物攻排名前三高的是哪些？</li>
</ul>
<pre><code class="language-python">df[df['Type 1']=='Fighting'].sort_values(by='Attack',ascending=False).iloc[:3]
</code></pre>
<figure data-type="image" tabindex="51"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411004358.png" alt="" loading="lazy"></figure>
<ul>
<li>请问六项种族指标（HP、物攻、特攻、物防、特防、速度）极差的均值最大的是哪个属性（只考虑第一属性，且均值是对属性而言）？</li>
</ul>
<pre><code class="language-python">df['range'] = df.iloc[:,5:11].max(axis=1)-df.iloc[:,5:11].min(axis=1)
attribute = df[['Type 1','range']].set_index('Type 1')
max_range = 0
result = ''
for i in attribute.index.unique():
    temp = attribute.loc[i,:].mean()
    if temp.values[0] &gt; max_range:
        max_range = temp.values[0]
        result = i
result
'Steel'
</code></pre>
<ul>
<li>哪个属性（只考虑第一属性）的神兽比例最高？该属性神兽的种族值也是最高的吗？</li>
</ul>
<pre><code class="language-python">df.query('Legendary == True')['Type 1'].value_counts(normalize=True).index[0]
'Psychic'
attribute = df.query('Legendary == True')[['Type 1','Total']].set_index('Type 1')
max_value = 0
result = ''
for i in attribute.index.unique()[:-1]:
    temp = attribute.loc[i,:].mean()
    if temp[0] &gt; max_value:
        max_value = temp[0]
        result = i
result
'Normal'
</code></pre>
<h1 id="分组">分组</h1>
<pre><code class="language-python">import numpy as np
import pandas as pd
df = pd.read_csv('data/table.csv',index_col='ID')
df.head()
</code></pre>
<figure data-type="image" tabindex="52"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411010031.png" alt="" loading="lazy"></figure>
<h2 id="sac过程">SAC过程</h2>
<h3 id="内涵">内涵</h3>
<p>SAC指的是分组操作中的split-apply-combine过程,其中<code>split</code>指基于某一些规则，将数据拆成若干组，<code>apply</code>是指对每一组独立地使用函数，<code>combine</code>指将每一组的结果组合成某一类数据结构</p>
<h3 id="apply过程"><code>apply</code>过程</h3>
<p>在该过程中，我们实际往往会遇到三类问题：</p>
<ul>
<li>整合（<code>Aggregation</code>）——即分组计算统计量（如求均值、求每组元素个数）</li>
<li>变换（<code>Transformation</code>）——即分组对每个单元的数据进行操作（如元素标准化）</li>
<li>过滤（<code>Filtration</code>）——即按照某些规则筛选出一些组（如选出组内某一指标小于50的组）</li>
</ul>
<h2 id="groupby函数"><code>groupby</code>函数</h2>
<h3 id="分组函数的基本内容">分组函数的基本内容</h3>
<h4 id="根据某一列分组">根据某一列分组</h4>
<pre><code class="language-python">grouped_single = df.groupby('School')
</code></pre>
<p>经过<code>groupby</code>后会生成一个<code>groupby</code>对象，该对象本身不会返回任何东西，只有当相应的方法被调用才会起作用<br>
例如取出某一个组：</p>
<pre><code class="language-python">grouped_single.get_group('S_1').head()
</code></pre>
<figure data-type="image" tabindex="53"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411010402.png" alt="" loading="lazy"></figure>
<h4 id="根据某几列分组">根据某几列分组</h4>
<pre><code class="language-python">grouped_mul = df.groupby(['School','Class'])
grouped_mul.get_group(('S_2','C_4'))
</code></pre>
<figure data-type="image" tabindex="54"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411010510.png" alt="" loading="lazy"></figure>
<h4 id="组容量与组数">组容量与组数</h4>
<pre><code class="language-python">grouped_single.size()
School
S_1    15
S_2    20
dtype: int64
grouped_mul.size()
School  Class
S_1     C_1      5
        C_2      5
        C_3      5
S_2     C_1      5
        C_2      5
        C_3      5
        C_4      5
dtype: int64
grouped_single.ngroups
2
grouped_mul.ngroups
7
</code></pre>
<h4 id="组的遍历">组的遍历</h4>
<pre><code class="language-python">for name,group in grouped_single:
    print(name)
    display(group.head())
</code></pre>
<figure data-type="image" tabindex="55"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411010700.png" alt="" loading="lazy"></figure>
<h4 id="level参数用于多级索引和axis参数"><code>level</code>参数（用于多级索引）和<code>axis</code>参数</h4>
<pre><code class="language-python">df.set_index(['Gender','School']).groupby(level=1,axis=0).get_group('S_1').head()
</code></pre>
<figure data-type="image" tabindex="56"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411010759.png" alt="" loading="lazy"></figure>
<h3 id="groupby对象的特点"><code>groupby</code>对象的特点</h3>
<h4 id="查看所有可调用的方法">查看所有可调用的方法</h4>
<p>由此可见，<code>groupby</code>对象可以使用相当多的函数，灵活程度很高</p>
<pre><code class="language-python">print([attr for attr in dir(grouped_single) if not attr.startswith('_')])

['Address', 'Class', 'Gender', 'Height', 'Math', 'Physics', 'School', 'Weight', 'agg', 'aggregate', 'all', 'any', 'apply', 'backfill', 'bfill', 'boxplot', 'corr', 'corrwith', 'count', 'cov', 'cumcount', 'cummax', 'cummin', 'cumprod', 'cumsum', 'describe', 'diff', 'dtypes', 'expanding', 'ffill', 'fillna', 'filter', 'first', 'get_group', 'groups', 'head', 'hist', 'idxmax', 'idxmin', 'indices', 'last', 'mad', 'max', 'mean', 'median', 'min', 'ndim', 'ngroup', 'ngroups', 'nth', 'nunique', 'ohlc', 'pad', 'pct_change', 'pipe', 'plot', 'prod', 'quantile', 'rank', 'resample', 'rolling', 'sem', 'shift', 'size', 'skew', 'std', 'sum', 'tail', 'take', 'transform', 'tshift', 'var']
</code></pre>
<h4 id="分组对象的head和first">分组对象的<code>head</code>和<code>first</code></h4>
<p>对分组对象使用<code>head</code>函数，返回的是每个组的前几行，而不是数据集前几行</p>
<pre><code class="language-python">grouped_single.head(2)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411011041.png" alt="" loading="lazy"><br>
<code>first</code>显示的是以分组为索引的每组的第一个分组信息</p>
<pre><code class="language-python">grouped_single.first()
</code></pre>
<figure data-type="image" tabindex="57"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411011125.png" alt="" loading="lazy"></figure>
<h4 id="分组依据">分组依据</h4>
<p>对于<code>groupby</code>函数而言，分组的依据是非常自由的，只要是与数据框长度相同的列表即可，同时支持函数型分组</p>
<pre><code class="language-python">df.groupby(np.random.choice(['a','b','c'],df.shape[0])).get_group('a').head()
#相当于将np.random.choice(['a','b','c'],df.shape[0])当做新的一列进行分组
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411011420.png" alt="" loading="lazy"><br>
根据奇偶行分组</p>
<pre><code class="language-python">df.groupby(lambda x:'奇数行' if not df.index.get_loc(x)%2==1 else '偶数行').groups
{'偶数行': Int64Index([1102, 1104, 1201, 1203, 1205, 1302, 1304, 2101, 2103, 2105, 2202,
             2204, 2301, 2303, 2305, 2402, 2404],
            dtype='int64', name='ID'),
 '奇数行': Int64Index([1101, 1103, 1105, 1202, 1204, 1301, 1303, 1305, 2102, 2104, 2201,
             2203, 2205, 2302, 2304, 2401, 2403, 2405],
            dtype='int64', name='ID')}
</code></pre>
<p>如果是多层索引，那么<code>lambda</code>表达式中的输入就是元组，下面实现的功能为查看两所学校中男女生分别均分是否及格<br>
注意：此处只是演示<code>groupby</code>的用法，实际操作不会这样写</p>
<pre><code class="language-python">math_score = df.set_index(['Gender','School'])['Math'].sort_index()
grouped_score = df.set_index(['Gender','School']).sort_index().\
            groupby(lambda x:(x,'均分及格' if math_score[x].mean()&gt;=60 else '均分不及格'))
for name,_ in grouped_score:print(name)

(('F', 'S_1'), '均分及格')
(('F', 'S_2'), '均分及格')
(('M', 'S_1'), '均分及格')
(('M', 'S_2'), '均分不及格')
</code></pre>
<h4 id="groupby的操作"><code>groupby</code>的<code>[]</code>操作</h4>
<p>可以用<code>[]</code>选出<code>groupby</code>对象的某个或者某几个列，上面的均分比较可以如下简洁地写出：</p>
<pre><code class="language-python">df.groupby(['Gender','School'])['Math'].mean()&gt;=60
Gender  School
F       S_1        True
        S_2        True
M       S_1        True
        S_2       False
Name: Math, dtype: bool
</code></pre>
<p>用列表可选出多个属性列：</p>
<pre><code class="language-python">df.groupby(['Gender','School'])[['Math','Height']].mean()
</code></pre>
<figure data-type="image" tabindex="58"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411011943.png" alt="" loading="lazy"></figure>
<h4 id="连续型变量分组">连续型变量分组</h4>
<p>例如利用<code>cut</code>函数对数学成绩分组：</p>
<pre><code class="language-python">bins = [0,40,60,80,90,100]
cuts = pd.cut(df['Math'],bins=bins) #可选label添加自定义标签
df.groupby(cuts)['Math'].count()
Math
(0, 40]       7
(40, 60]     10
(60, 80]      9
(80, 90]      7
(90, 100]     2
Name: Math, dtype: int64
</code></pre>
<h2 id="聚合-过滤和变换">聚合、过滤和变换</h2>
<h3 id="聚合aggregation">聚合（<code>Aggregation</code>）</h3>
<h4 id="常用聚合函数">常用聚合函数</h4>
<p>所谓聚合就是把一堆数，变成一个标量，因此<code>mean</code>/<code>sum</code>/<code>size</code>/<code>count</code>/<code>std</code>/<code>var</code>/<code>sem</code>/<code>describe</code>/<code>first</code>/<code>last</code>/<code>nth</code>/<code>min</code>/<code>max</code>都是聚合函数</p>
<h4 id="同时使用多个聚合函数">同时使用多个聚合函数</h4>
<pre><code class="language-python">group_m = grouped_single['Math']
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411012450.png" alt="" loading="lazy"><br>
利用元组进行重命名</p>
<pre><code class="language-python">group_m.agg([('rename_sum','sum'),('rename_mean','mean')])
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411012549.png" alt="" loading="lazy"><br>
指定哪些函数作用哪些列</p>
<pre><code class="language-python">grouped_mul.agg({'Math':['mean','max'],'Height':'var'})
</code></pre>
<figure data-type="image" tabindex="59"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200411012933.png" alt="" loading="lazy"></figure>
<h4 id="使用自定义函数">使用自定义函数</h4>
<pre><code class="language-python">grouped_single['Math'].agg(lambda x:print(x.head(),'间隔'))
#可以发现，agg函数的传入是分组逐列进行的，有了这个特性就可以做许多事情
Series([], Name: Math, dtype: float64) 间隔
1101    34.0
1102    32.5
1103    87.2
1104    80.4
1105    84.8
Name: Math, dtype: float64 间隔
2101    83.3
2102    50.6
2103    52.5
2104    72.2
2105    34.2
Name: Math, dtype: float64 间隔
</code></pre>
<p>官方没有提供极差计算的函数，但通过<code>agg</code>可以容易地实现组内极差计算</p>
<pre><code class="language-python">grouped_single['Math'].agg(lambda x:x.max()-x.min())
School
S_1    65.5
S_2    62.8
Name: Math, dtype: float64
</code></pre>
<h4 id="利用namedagg函数进行多个聚合">利用<code>NamedAgg</code>函数进行多个聚合</h4>
<p>不支持<code>lambda</code>函数，但是可以使用外置的<code>def</code>函数</p>
<pre><code class="language-python">def R1(x):
    return x.max()-x.min()
def R2(x):
    return x.max()-x.median()
grouped_single['Math'].agg(min_score1=pd.NamedAgg(column='col1', aggfunc=R1),
                           max_score1=pd.NamedAgg(column='col2', aggfunc='max'),
                           range_score2=pd.NamedAgg(column='col3', aggfunc=R2)).head()
</code></pre>
<figure data-type="image" tabindex="60"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411015632.png" alt="" loading="lazy"></figure>
<h4 id="带参数的聚合函数">带参数的聚合函数</h4>
<p>判断是否组内数学分数至少有一个值在50-52之间：</p>
<pre><code class="language-python">def f(s,low,high):
    return s.between(low,high).max()
grouped_single['Math'].agg(f,50,52)
School
S_1    False
S_2     True
Name: Math, dtype: bool
</code></pre>
<p>如果需要使用多个函数，并且其中至少有一个带参数，则使用<code>wrap</code>技巧：</p>
<pre><code class="language-python">def f_test(s,low,high):
    return s.between(low,high).max()
def agg_f(f_mul,name,*args,**kwargs):
    def wrapper(x):
        return f_mul(x,*args,**kwargs)
    wrapper.__name__ = name
    return wrapper
new_f = agg_f(f_test,'at_least_one_in_50_52',50,52)
grouped_single['Math'].agg([new_f,'mean']).head()
</code></pre>
<figure data-type="image" tabindex="61"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020002.png" alt="" loading="lazy"></figure>
<h3 id="过滤filteration">过滤（<code>Filteration</code>）</h3>
<p><code>filter</code>函数是用来筛选某些组的（务必记住结果是组的全体），因此传入的值应当是布尔标量</p>
<pre><code class="language-python">grouped_single[['Math','Physics']].filter(lambda x:(x['Math']&gt;32).all()).head()
</code></pre>
<figure data-type="image" tabindex="62"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020136.png" alt="" loading="lazy"></figure>
<h3 id="变换transformation">变换（<code>Transformation</code>）</h3>
<h4 id="传入对象">传入对象</h4>
<p><code>transform</code>函数中传入的对象是组内的列，并且返回值需要与列长完全一致</p>
<pre><code class="language-python">grouped_single[['Math','Height']].transform(lambda x:x-x.min()).head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020250.png" alt="" loading="lazy"><br>
如果返回了标量值，那么组内的所有元素会被广播为这个值</p>
<pre><code class="language-python">grouped_single[['Math','Height']].transform(lambda x:x.mean()).head()
</code></pre>
<figure data-type="image" tabindex="63"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020328.png" alt="" loading="lazy"></figure>
<h4 id="利用变换方法进行组内标准化">利用变换方法进行组内标准化</h4>
<pre><code class="language-python">grouped_single[['Math','Height']].transform(lambda x:(x-x.mean())/x.std()).head()
</code></pre>
<figure data-type="image" tabindex="64"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020400.png" alt="" loading="lazy"></figure>
<h4 id="利用变换方法进行组内缺失值的均值填充">利用变换方法进行组内缺失值的均值填充</h4>
<pre><code class="language-python">df_nan = df[['Math','School']].copy().reset_index()
df_nan.loc[np.random.randint(0,df.shape[0],25),['Math']]=np.nan
df_nan.head()
</code></pre>
<figure data-type="image" tabindex="65"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020536.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_nan.groupby('School').transform(lambda x: x.fillna(x.mean())).join(df.reset_index()['School']).head()
</code></pre>
<figure data-type="image" tabindex="66"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020624.png" alt="" loading="lazy"></figure>
<h2 id="apply函数-2"><code>apply</code>函数</h2>
<h3 id="apply函数的灵活性"><code>apply</code>函数的灵活性</h3>
<p>可能在所有的分组函数中，<code>apply</code>是应用最为广泛的，这得益于它的灵活性：<br>
对于传入值而言，从下面的打印内容可以看到是以分组的表传入<code>apply</code>中：</p>
<pre><code class="language-python">df.groupby('School').apply(lambda x:print(x.head(1)))
     School Class Gender   Address  Height  Weight  Math Physics
ID                                                              
1101    S_1   C_1      M  street_1     173      63  34.0      A+
     School Class Gender   Address  Height  Weight  Math Physics
ID                                                              
2101    S_2   C_1      M  street_7     174      84  83.3       C
</code></pre>
<p><code>apply</code>函数的灵活性很大程度来源于其返回值的多样性：</p>
<h4 id="标量返回值">标量返回值</h4>
<pre><code class="language-python">df[['School','Math','Height']].groupby('School').apply(lambda x:x.max())
</code></pre>
<figure data-type="image" tabindex="67"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411020905.png" alt="" loading="lazy"></figure>
<h4 id="列表返回值">列表返回值</h4>
<pre><code class="language-python">df[['School','Math','Height']].groupby('School').apply(lambda x:x-x.min()).head()
</code></pre>
<figure data-type="image" tabindex="68"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021010.png" alt="" loading="lazy"></figure>
<h4 id="数据框返回值">数据框返回值</h4>
<pre><code class="language-python">df[['School','Math','Height']].groupby('School')\
    .apply(lambda x:pd.DataFrame({'col1':x['Math']-x['Math'].max(),
                                  'col2':x['Math']-x['Math'].min(),
                                  'col3':x['Height']-x['Height'].max(),
                                  'col4':x['Height']-x['Height'].min()})).head()
</code></pre>
<figure data-type="image" tabindex="69"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021144.png" alt="" loading="lazy"></figure>
<h3 id="用apply同时统计多个指标">用<code>apply</code>同时统计多个指标</h3>
<p>此处可以借助<code>OrderedDict</code>工具进行快捷的统计：</p>
<pre><code class="language-python">from collections import OrderedDict
def f(df):
    data = OrderedDict()
    data['M_sum'] = df['Math'].sum()
    data['W_var'] = df['Weight'].var()
    data['H_mean'] = df['Height'].mean()
    return pd.Series(data)
grouped_single.apply(f)
</code></pre>
<figure data-type="image" tabindex="70"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021301.png" alt="" loading="lazy"></figure>
<h2 id="练习-3">练习</h2>
<h3 id="练习一-3">练习一</h3>
<p>现有一份关于diamonds的数据集，列分别记录了克拉数、颜色、开采深度、价格，请解决下列问题：</p>
<pre><code class="language-python">pd.read_csv('data/Diamonds.csv').head()
</code></pre>
<figure data-type="image" tabindex="71"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021433.png" alt="" loading="lazy"></figure>
<ul>
<li>在所有重量超过1克拉的钻石中，价格的极差是多少？</li>
</ul>
<pre><code class="language-python">df_r = df.query('carat&gt;1')['price']
df_r.max()-df_r.min()
17561
</code></pre>
<ul>
<li>若以开采深度的0.2\0.4\0.6\0.8分位数为分组依据，每一组中钻石颜色最多的是哪一种？该种颜色是组内平均而言单位重量最贵的吗？</li>
</ul>
<pre><code class="language-python">bins = df['depth'].quantile(np.linspace(0,1,6)).tolist()
cuts = pd.cut(df['depth'],bins=bins) #可选label添加自定义标签
df['cuts'] = cuts
df.head()
</code></pre>
<figure data-type="image" tabindex="72"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021712.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">color_result = df.groupby('cuts')['color'].describe()
color_result
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021746.png" alt="" loading="lazy"><br>
前三个分位数区间不满足条件，后两个区间中数量最多的颜色的确是均重价格中最贵的</p>
<pre><code class="language-python">df['均重价格']=df['price']/df['carat']
color_result['top'] == [i[1] for i in df.groupby(['cuts','color'])['均重价格'].mean().groupby(['cuts']).idxmax().values]
cuts
(43.0, 60.8]    False
(60.8, 61.6]    False
(61.6, 62.1]    False
(62.1, 62.7]     True
(62.7, 79.0]     True
Name: top, dtype: bool
</code></pre>
<ul>
<li>以重量分组(0-0.5,0.5-1,1-1.5,1.5-2,2+)，按递增的深度为索引排序，求每组中连续的严格递增价格序列长度的最大值。</li>
</ul>
<pre><code class="language-python">df = df.drop(columns='均重价格')
cuts = pd.cut(df['carat'],bins=[0,0.5,1,1.5,2,np.inf]) #可选label添加自定义标签
df['cuts'] = cuts
df.head()
</code></pre>
<figure data-type="image" tabindex="73"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411021934.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">def f(nums):
    if not nums:        
        return 0
    res = 1                            
    cur_len = 1                        
    for i in range(1, len(nums)):      
        if nums[i-1] &lt; nums[i]:        
            cur_len += 1                
            res = max(cur_len, res)     
        else:                       
            cur_len = 1                 
    return res
for name,group in df.groupby('cuts'):
    group = group.sort_values(by='depth')
    s = group['price']
    print(name,f(s.tolist()))
(0.0, 0.5] 8
(0.5, 1.0] 8
(1.0, 1.5] 7
(1.5, 2.0] 11
(2.0, inf] 7
</code></pre>
<ul>
<li>请按颜色分组，分别计算价格关于克拉数的回归系数。（单变量的简单线性回归，并只使用<code>Pandas</code>和<code>Numpy</code>完成）</li>
</ul>
<pre><code class="language-python">for name,group in df[['carat','price','color']].groupby('color'):
    L1 = np.array([np.ones(group.shape[0]),group['carat']]).reshape(2,group.shape[0])
    L2 = group['price']
    result = (np.linalg.inv(L1.dot(L1.T)).dot(L1)).dot(L2).reshape(2,1)
    print('当颜色为%s时，截距项为：%f，回归系数为：%f'%(name,result[0],result[1]))
当颜色为D时，截距项为：-2361.017152，回归系数为：8408.353126
当颜色为E时，截距项为：-2381.049600，回归系数为：8296.212783
当颜色为F时，截距项为：-2665.806191，回归系数为：8676.658344
当颜色为G时，截距项为：-2575.527643，回归系数为：8525.345779
当颜色为H时，截距项为：-2460.418046，回归系数为：7619.098320
当颜色为I时，截距项为：-2878.150356，回归系数为：7761.041169
当颜色为J时，截距项为：-2920.603337，回归系数为：7094.192092
</code></pre>
<h3 id="练习二-3">练习二</h3>
<p>有一份关于美国10年至17年的非法药物数据集，列分别记录了年份、州（5个）、县、药物类型、报告数量，请解决下列问题：</p>
<pre><code class="language-python">pd.read_csv('data/Drugs.csv').head()
</code></pre>
<figure data-type="image" tabindex="74"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411022141.png" alt="" loading="lazy"></figure>
<ul>
<li>按照年份统计，哪个县的报告数量最多？这个县所属的州在当年也是报告数最多的吗？</li>
</ul>
<pre><code class="language-python">idx=pd.IndexSlice
for i in range(2010,2018):
    county = (df.groupby(['COUNTY','YYYY']).sum().loc[idx[:,i],:].idxmax()[0][0])
    state = df.query('COUNTY == &quot;%s&quot;'%county)['State'].iloc[0]
    state_true = df.groupby(['State','YYYY']).sum().loc[idx[:,i],:].idxmax()[0][0]
    if state==state_true:
        print('在%d年，%s县的报告数最多，它所属的州%s也是报告数最多的'%(i,county,state))
    else:
        print('在%d年，%s县的报告数最多，但它所属的州%s不是报告数最多的，%s州报告数最多'%(i,county,state,state_true))
在2010年，PHILADELPHIA县的报告数最多，它所属的州PA也是报告数最多的
在2011年，PHILADELPHIA县的报告数最多，但它所属的州PA不是报告数最多的，OH州报告数最多
在2012年，PHILADELPHIA县的报告数最多，但它所属的州PA不是报告数最多的，OH州报告数最多
在2013年，PHILADELPHIA县的报告数最多，但它所属的州PA不是报告数最多的，OH州报告数最多
在2014年，PHILADELPHIA县的报告数最多，但它所属的州PA不是报告数最多的，OH州报告数最多
在2015年，PHILADELPHIA县的报告数最多，但它所属的州PA不是报告数最多的，OH州报告数最多
在2016年，HAMILTON县的报告数最多，它所属的州OH也是报告数最多的
在2017年，HAMILTON县的报告数最多，它所属的州OH也是报告数最多的
</code></pre>
<ul>
<li>从14年到15年，Heroin的数量增加最多的是哪一个州？它在这个州是所有药物中增幅最大的吗？若不是，请找出符合该条件的药物。</li>
</ul>
<pre><code class="language-python">df_b = df[(df['YYYY'].isin([2014,2015]))&amp;(df['SubstanceName']=='Heroin')]
df_add = df_b.groupby(['YYYY','State']).sum()
(df_add.loc[2015]-df_add.loc[2014]).idxmax()
DrugReports    OH
dtype: object
df_b = df[(df['YYYY'].isin([2014,2015]))&amp;(df['State']=='OH')]
df_add = df_b.groupby(['YYYY','SubstanceName']).sum()
display((df_add.loc[2015]-df_add.loc[2014]).idxmax()) #这里利用了索引对齐的特点
display((df_add.loc[2015]/df_add.loc[2014]).idxmax())
DrugReports    Heroin
dtype: object
DrugReports    Acetyl fentanyl
dtype: object
</code></pre>
<h1 id="变形">变形</h1>
<pre><code class="language-python">import numpy as np
import pandas as pd
df = pd.read_csv('data/table.csv')
df.head()
</code></pre>
<figure data-type="image" tabindex="75"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411022421.png" alt="" loading="lazy"></figure>
<h2 id="透视表">透视表</h2>
<h3 id="pivot"><code>pivot</code></h3>
<p>一般状态下，数据在<code>DataFrame</code>会以压缩（<code>stacked</code>）状态存放，例如上面的<code>Gender</code>，两个类别被叠在一列中，<code>pivot</code>函数可将某一列作为新的<code>cols</code>：</p>
<pre><code class="language-python">df.pivot(index='ID',columns='Gender',values='Height').head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411022620.png" alt="" loading="lazy"><br>
然而<code>pivot</code>函数具有很强的局限性，除了功能上较少之外，还不允许<code>values</code>中出现重复的行列索引对（<code>pair</code>），例如下面的语句就会报错：</p>
<pre><code class="language-python">#df.pivot(index='School',columns='Gender',values='Height').head()
</code></pre>
<p>因此，更多的时候会选择使用强大的<code>pivot_table</code>函数</p>
<h3 id="pivot_table"><code>pivot_table</code></h3>
<pre><code class="language-python">pd.pivot_table(df,index='ID',columns='Gender',values='Height').head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411022800.png" alt="" loading="lazy"><br>
由于功能更多，速度上自然是比不上原来的<code>pivot</code>函数<br>
<code>Pandas</code>中提供了各种选项，下面介绍常用参数：</p>
<h4 id="aggfunc对组内进行聚合统计可传入各类函数默认为mean"><code>aggfunc</code>：对组内进行聚合统计，可传入各类函数，默认为<code>'mean'</code></h4>
<pre><code class="language-python">pd.pivot_table(df,index='School',columns='Gender',values='Height',aggfunc=['mean','sum']).head()
</code></pre>
<figure data-type="image" tabindex="76"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023058.png" alt="" loading="lazy"></figure>
<h4 id="margins汇总边际状态"><code>margins</code>：汇总边际状态</h4>
<pre><code class="language-python">pd.pivot_table(df,index='School',columns='Gender',values='Height',aggfunc=['mean','sum'],margins=True).head()
#margins_name可以设置名字，默认为'All'
</code></pre>
<figure data-type="image" tabindex="77"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023148.png" alt="" loading="lazy"></figure>
<h4 id="行-列-值都可以为多级">行、列、值都可以为多级</h4>
<pre><code class="language-python">pd.pivot_table(df,index=['School','Class'],
               columns=['Gender','Address'],
               values=['Height','Weight'])
</code></pre>
<figure data-type="image" tabindex="78"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023237.png" alt="" loading="lazy"></figure>
<h3 id="crosstab交叉表"><code>crosstab</code>（交叉表）</h3>
<p>交叉表是一种特殊的透视表，典型的用途如分组统计，如现在想要统计关于街道和性别分组的频数：</p>
<pre><code class="language-python">pd.crosstab(index=df['Address'],columns=df['Gender'])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023442.png" alt="" loading="lazy"><br>
交叉表的功能也很强大（但目前还不支持多级分组），下面说明一些重要参数：</p>
<h4 id="values和aggfunc分组对某些数据进行聚合操作这两个参数必须成对出现"><code>values</code>和<code>aggfunc</code>：分组对某些数据进行聚合操作，这两个参数必须成对出现</h4>
<pre><code class="language-python">pd.crosstab(index=df['Address'],columns=df['Gender'],
            values=np.random.randint(1,20,df.shape[0]),aggfunc='min')
#默认参数等于如下方法：
#pd.crosstab(index=df['Address'],columns=df['Gender'],values=1,aggfunc='count')
</code></pre>
<figure data-type="image" tabindex="79"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023554.png" alt="" loading="lazy"></figure>
<h4 id="除了边际参数margins外还引入了normalize参数可选allindexcolumns参数值">除了边际参数<code>margins</code>外，还引入了<code>normalize</code>参数，可选<code>'all'</code>,<code>'index'</code>,<code>'columns'</code>参数值</h4>
<pre><code class="language-python">pd.crosstab(index=df['Address'],columns=df['Gender'],normalize='all',margins=True)
</code></pre>
<figure data-type="image" tabindex="80"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023648.png" alt="" loading="lazy"></figure>
<h2 id="其他变形方法">其他变形方法</h2>
<h3 id="melt"><code>melt</code></h3>
<p><code>melt</code>函数可以认为是<code>pivot</code>函数的逆操作，将<code>unstacked</code>状态的数据，压缩成<code>stacked</code>，使“宽”的<code>DataFrame</code>变“窄”</p>
<pre><code class="language-python">df_m = df[['ID','Gender','Math']]
df_m.head()
</code></pre>
<figure data-type="image" tabindex="81"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023824.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.pivot(index='ID',columns='Gender',values='Math').head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411023911.png" alt="" loading="lazy"><br>
<code>melt</code>函数中的<code>id_vars</code>表示需要保留的列，<code>value_vars</code>表示需要<code>stack</code>的一组列</p>
<pre><code class="language-python">pivoted = df.pivot(index='ID',columns='Gender',values='Math')
result = pivoted.reset_index().melt(id_vars=['ID'],value_vars=['F','M'],value_name='Math')\
                     .dropna().set_index('ID').sort_index()
#检验是否与展开前的df相同，可以分别将这些链式方法的中间步骤展开，看看是什么结果
result.equals(df_m.set_index('ID'))
True
</code></pre>
<h3 id="压缩与展开">压缩与展开</h3>
<h4 id="stack"><code>stack</code></h4>
<p>这是最基础的变形函数，总共只有两个参数：<code>level</code>和<code>dropna</code></p>
<pre><code class="language-python">df_s = pd.pivot_table(df,index=['Class','ID'],columns='Gender',values=['Height','Weight'])
df_s.groupby('Class').head(2)
</code></pre>
<figure data-type="image" tabindex="82"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024210.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_stacked = df_s.stack()
df_stacked.groupby('Class').head(2)
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024305.png" alt="" loading="lazy"><br>
<code>stack</code>函数可以看做将横向的索引放到纵向，因此功能类似与<code>melt</code>，参数<code>level</code>可指定变化的列索引是哪一层（或哪几层，需要列表）</p>
<pre><code class="language-python">df_stacked = df_s.stack(0)
df_stacked.groupby('Class').head(2)
</code></pre>
<figure data-type="image" tabindex="83"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024426.png" alt="" loading="lazy"></figure>
<h4 id="unstack"><code>unstack</code></h4>
<p><code>stack</code>的逆函数，功能上类似于<code>pivot_table</code></p>
<pre><code class="language-python">df_stacked.head()
</code></pre>
<figure data-type="image" tabindex="84"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024525.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">result = df_stacked.unstack().swaplevel(1,0,axis=1).sort_index(axis=1)
result.equals(df_s)
#同样在unstack中可以指定level参数
True
</code></pre>
<h2 id="哑变量与因子化">哑变量与因子化</h2>
<h3 id="dummy-variable哑变量"><code>Dummy Variable</code>（哑变量）</h3>
<p>这里主要介绍<code>get_dummies</code>函数，其功能主要是进行<code>one-hot</code>编码：</p>
<pre><code class="language-python">df_d = df[['Class','Gender','Weight']]
df_d.head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024721.png" alt="" loading="lazy"><br>
现在希望将上面的表格前两列转化为哑变量，并加入第三列<code>Weight</code>数值：</p>
<pre><code class="language-python">pd.get_dummies(df_d[['Class','Gender']]).join(df_d['Weight']).head()
#可选prefix参数添加前缀，prefix_sep添加分隔符
</code></pre>
<figure data-type="image" tabindex="85"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024805.png" alt="" loading="lazy"></figure>
<h3 id="factorize方法"><code>factorize</code>方法</h3>
<p>该方法主要用于自然数编码，并且缺失值会被记做-1，其中<code>sort</code>参数表示是否排序后赋值</p>
<pre><code class="language-python">codes, uniques = pd.factorize(['b', None, 'a', 'c', 'b'], sort=True)
display(codes)
display(uniques)
array([ 1, -1,  0,  2,  1])
array(['a', 'b', 'c'], dtype=object)
</code></pre>
<h2 id="练习-4">练习</h2>
<h2 id="练习一-4">练习一</h2>
<p>继续使用上一章的药物数据集</p>
<pre><code class="language-python">pd.read_csv('data/Drugs.csv').head()
</code></pre>
<figure data-type="image" tabindex="86"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411024927.png" alt="" loading="lazy"></figure>
<ul>
<li>现在请你将数据表转化成如下形态，每行需要显示每种药物在每个地区的10年至17年的变化情况，且前三列需要排序：<br>
<img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025013.png" alt="" loading="lazy"></li>
</ul>
<pre><code class="language-python">df = pd.read_csv('data/Drugs.csv',index_col=['State','COUNTY']).sort_index()
df.head()
</code></pre>
<figure data-type="image" tabindex="87"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025130.png" alt="" loading="lazy"></figure>
<pre><code>result = pd.pivot_table(df,index=['State','COUNTY','SubstanceName']
                 ,columns='YYYY'
                 ,values='DrugReports',fill_value='-').reset_index().rename_axis(columns={'YYYY':''})
result.head()
</code></pre>
<figure data-type="image" tabindex="88"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025216.png" alt="" loading="lazy"></figure>
<ul>
<li>现在请将(a)中的结果恢复到原数据表，并通过<code>equal</code>函数检验初始表与新的结果是否一致（返回<code>True</code>）</li>
</ul>
<pre><code class="language-python">result_melted = result.melt(id_vars=result.columns[:3],value_vars=result.columns[-8:]
                ,var_name='YYYY',value_name='DrugReports').query('DrugReports != &quot;-&quot;')
result2 = result_melted.sort_values(by=['State','COUNTY','YYYY'
                                    ,'SubstanceName']).reset_index().drop(columns='index')
#下面其实无关紧要，只是交换两个列再改一下类型（因为‘-’所以type变成object了）
cols = list(result2.columns)
a, b = cols.index('SubstanceName'), cols.index('YYYY')
cols[b], cols[a] = cols[a], cols[b]
result2 = result2[cols].astype({'DrugReports':'int','YYYY':'int'})
result2.head()
</code></pre>
<figure data-type="image" tabindex="89"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025327.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_tidy = df.reset_index().sort_values(by=result2.columns[:4].tolist()).reset_index().drop(columns='index')
df_tidy.head()
</code></pre>
<figure data-type="image" tabindex="90"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025352.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_tidy.equals(result2)
True
</code></pre>
<h3 id="练习二-4">练习二</h3>
<p>现有一份关于某地区地震情况的数据集，请解决如下问题</p>
<pre><code class="language-python">pd.read_csv('data/Earthquake.csv').head()
</code></pre>
<figure data-type="image" tabindex="91"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025454.png" alt="" loading="lazy"></figure>
<ul>
<li>现在请你将数据表转化成如下形态，将方向列展开，并将距离、深度和烈度三个属性压缩：<br>
<img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025522.png" alt="" loading="lazy"></li>
</ul>
<pre><code class="language-python">df = pd.read_csv('data/Earthquake.csv')
df = df.sort_values(by=df.columns.tolist()[:3]).sort_index(axis=1).reset_index().drop(columns='index')
df.head()
</code></pre>
<figure data-type="image" tabindex="92"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025556.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">result = pd.pivot_table(df,index=['日期','时间','维度','经度']
            ,columns='方向'
            ,values=['烈度','深度','距离'],fill_value='-').stack(level=0).rename_axis(index={None:'地震参数'})
result.head(6)
</code></pre>
<figure data-type="image" tabindex="93"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025627.png" alt="" loading="lazy"></figure>
<ul>
<li>现在请将(a)中的结果恢复到原数据表，并通过<code>equal</code>函数检验初始表与新的结果是否一致（返回<code>True</code>）</li>
</ul>
<pre><code class="language-python">df_result = result.unstack().stack(0)[(~(result.unstack().stack(0)=='-')).any(1)].reset_index()
df_result.columns.name=None
df_result = df_result.sort_index(axis=1).astype({'深度':'float64','烈度':'float64','距离':'float64'})
df_result.head()
</code></pre>
<figure data-type="image" tabindex="94"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025721.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_result.astype({'深度':'float64','烈度':'float64','距离':'float64'},copy=False).dtypes
Out[42]:
方向     object
日期     object
时间     object
深度    float64
烈度    float64
经度    float64
维度    float64
距离    float64
dtype: object
df.equals(df_result)
True
</code></pre>
<h1 id="合并">合并</h1>
<pre><code class="language-python">import numpy as np
import pandas as pd
df = pd.read_csv('data/table.csv')
df.head()
</code></pre>
<figure data-type="image" tabindex="95"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411025849.png" alt="" loading="lazy"></figure>
<h2 id="append与assign"><code>append</code>与<code>assign</code></h2>
<h3 id="append方法"><code>append</code>方法</h3>
<h4 id="利用序列添加行必须指定name">利用序列添加行（必须指定<code>name</code>）</h4>
<pre><code class="language-python">df_append = df.loc[:3,['Gender','Height']].copy()
df_append
</code></pre>
<figure data-type="image" tabindex="96"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411030019.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">s = pd.Series({'Gender':'F','Height':188},name='new_row')
df_append.append(s)
</code></pre>
<figure data-type="image" tabindex="97"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411030052.png" alt="" loading="lazy"></figure>
<h4 id="用dataframe添加表">用<code>DataFrame</code>添加表</h4>
<pre><code class="language-python">df_temp = pd.DataFrame({'Gender':['F','M'],'Height':[188,176]},index=['new_1','new_2'])
df_append.append(df_temp)
</code></pre>
<figure data-type="image" tabindex="98"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411030138.png" alt="" loading="lazy"></figure>
<h3 id="assign方法"><code>assign</code>方法</h3>
<p>该方法主要用于添加列，列名直接由参数指定：</p>
<pre><code class="language-python">s = pd.Series(list('abcd'),index=range(4))
df_append.assign(Letter=s)
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411030302.png" alt="" loading="lazy"><br>
可以一次添加多个列：</p>
<pre><code class="language-python">df_append.assign(col1=lambda x:x['Gender']*2,
                 col2=s)
</code></pre>
<figure data-type="image" tabindex="99"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411030337.png" alt="" loading="lazy"></figure>
<h2 id="combine与update"><code>combine</code>与<code>update</code></h2>
<h3 id="comine方法"><code>comine</code>方法</h3>
<p><code>comine</code>和<code>update</code>都是用于表的填充函数，可以根据某种规则填充</p>
<h4 id="填充对象">填充对象</h4>
<p>可以看出<code>combine</code>方法是按照表的顺序轮流进行逐列循环的，而且自动索引对齐，缺失值为<code>NaN</code>，理解这一点很重要</p>
<pre><code class="language-python">df_combine_1 = df.loc[:1,['Gender','Height']].copy()
df_combine_2 = df.loc[10:11,['Gender','Height']].copy()
df_combine_1.combine(df_combine_2,lambda x,y:print(x,y))
0       M
1       F
10    NaN
11    NaN
Name: Gender, dtype: object 
0     NaN
1     NaN
10      M
11      F
Name: Gender, dtype: object
0     173.0
1     192.0
10      NaN
11      NaN
Name: Height, dtype: float64
0       NaN
1       NaN
10    161.0
11    175.0
Name: Height, dtype: float64
</code></pre>
<figure data-type="image" tabindex="100"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411030857.png" alt="" loading="lazy"></figure>
<h4 id="一些例子">一些例子</h4>
<h5 id="根据列均值的大小填充">根据列均值的大小填充</h5>
<pre><code class="language-python">df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [8, 7], 'B': [6, 5]})
df1.combine(df2,lambda x,y:x if x.mean()&gt;y.mean() else y)
</code></pre>
<figure data-type="image" tabindex="101"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031024.png" alt="" loading="lazy"></figure>
<h5 id="索引对齐特性-2">索引对齐特性</h5>
<p>默认状态下，后面的表没有的行列都会设置为<code>NaN</code></p>
<pre><code class="language-python">df2 = pd.DataFrame({'B': [8, 7], 'C': [6, 5]},index=[1,2])
df1.combine(df2,lambda x,y:x if x.mean()&gt;y.mean() else y)
</code></pre>
<figure data-type="image" tabindex="102"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031214.png" alt="" loading="lazy"></figure>
<h5 id="使得df1原来符合条件的值不会被覆盖">使得<code>df1</code>原来符合条件的值不会被覆盖</h5>
<pre><code class="language-python">df1.combine(df2,lambda x,y:x if x.mean()&gt;y.mean() else y,overwrite=False)
</code></pre>
<figure data-type="image" tabindex="103"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031256.png" alt="" loading="lazy"></figure>
<h5 id="在新增匹配df2的元素位置填充-1">在新增匹配<code>df2</code>的元素位置填充-1</h5>
<pre><code class="language-python">df1.combine(df2,lambda x,y:x if x.mean()&gt;y.mean() else y,fill_value=-1)
</code></pre>
<figure data-type="image" tabindex="104"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031327.png" alt="" loading="lazy"></figure>
<h4 id="combine_first方法"><code>combine_first</code>方法</h4>
<p>这个方法作用是用<code>df2</code>填补<code>df1</code>的缺失值，功能比较简单，但很多时候会比<code>combine</code>更常用，下面举两个例子：</p>
<pre><code class="language-python">df1 = pd.DataFrame({'A': [None, 0], 'B': [None, 4]})
df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]})
df1.combine_first(df2)
</code></pre>
<figure data-type="image" tabindex="105"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031449.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1 = pd.DataFrame({'A': [None, 0], 'B': [4, None]})
df2 = pd.DataFrame({'B': [3, 3], 'C': [1, 1]}, index=[1, 2])
df1.combine_first(df2)
</code></pre>
<figure data-type="image" tabindex="106"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031520.png" alt="" loading="lazy"></figure>
<h3 id="update方法"><code>update</code>方法</h3>
<h4 id="三个特点">三个特点</h4>
<ol>
<li>返回的框索引只会与被调用框的一致（默认使用左连接）</li>
<li>第二个框中的<code>nan</code>元素不会起作用</li>
<li>没有返回值，直接在<code>df</code>上操作</li>
</ol>
<h4 id="例子">例子</h4>
<h5 id="索引完全对齐情况下的操作">索引完全对齐情况下的操作</h5>
<pre><code class="language-python">df1 = pd.DataFrame({'A': [1, 2, 3],
                    'B': [400, 500, 600]})
df2 = pd.DataFrame({'B': [4, 5, 6],
                    'C': [7, 8, 9]})
df1.update(df2)
df1
</code></pre>
<figure data-type="image" tabindex="107"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031732.png" alt="" loading="lazy"></figure>
<h5 id="部分填充">部分填充</h5>
<pre><code class="language-python">df1 = pd.DataFrame({'A': ['a', 'b', 'c'],
                    'B': ['x', 'y', 'z']})
df2 = pd.DataFrame({'B': ['d', 'e']}, index=[1,2])
df1.update(df2)
df1
</code></pre>
<figure data-type="image" tabindex="108"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031823.png" alt="" loading="lazy"></figure>
<h5 id="缺失值不会填充">缺失值不会填充</h5>
<pre><code class="language-python">df1 = pd.DataFrame({'A': [1, 2, 3],
                    'B': [400, 500, 600]})
df2 = pd.DataFrame({'B': [4, np.nan, 6]})
df1.update(df2)
df1
</code></pre>
<figure data-type="image" tabindex="109"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411031859.png" alt="" loading="lazy"></figure>
<h2 id="concat方法"><code>concat</code>方法</h2>
<p><code>concat</code>方法可以在两个维度上拼接，默认纵向凭借（<code>axis=0</code>），拼接方式默认外连接<br>
所谓外连接，就是取拼接方向的并集，而<code>'inner'</code>时取拼接方向（若使用默认的纵向拼接，则为列的交集）的交集<br>
下面举一些例子说明其参数：</p>
<pre><code class="language-python">df1 = pd.DataFrame({'A': ['A0', 'A1'],
                    'B': ['B0', 'B1']},
                    index = [0,1])
df2 = pd.DataFrame({'A': ['A2', 'A3'],
                    'B': ['B2', 'B3']},
                    index = [2,3])
df3 = pd.DataFrame({'A': ['A1', 'A3'],
                    'D': ['D1', 'D3'],
                    'E': ['E1', 'E3']},
                    index = [1,3])
</code></pre>
<p>默认状态拼接：</p>
<pre><code class="language-python">pd.concat([df1,df2])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411033017.png" alt="" loading="lazy"><br>
<code>axis=1</code>时沿列方向拼接：</p>
<pre><code class="language-python">pd.concat([df1,df2],axis=1)
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411033104.png" alt="" loading="lazy"><br>
<code>join</code>设置为内连接（由于<code>axis=0</code>，因此列取交集）：</p>
<pre><code class="language-python">pd.concat([df3,df1],join='inner')
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411033240.png" alt="" loading="lazy"><br>
<code>join</code>设置为外链接：</p>
<pre><code class="language-python">pd.concat([df3,df1],join='outer',sort=True) #sort设置列排序，默认为False
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411033412.png" alt="" loading="lazy"><br>
<code>verify_integrity</code>检查列是否唯一：</p>
<pre><code class="language-python">#pd.concat([df3,df1],verify_integrity=True,sort=True) 报错
</code></pre>
<p>同样，可以添加<code>Series</code>：</p>
<pre><code class="language-python">s = pd.Series(['X0', 'X1'], name='X')
pd.concat([df1,s],axis=1)
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411033553.png" alt="" loading="lazy"><br>
<code>key</code>参数用于对不同的数据框增加一个标号，便于索引：</p>
<pre><code class="language-python">pd.concat([df1,df2], keys=['x', 'y'])
pd.concat([df1,df2], keys=['x', 'y']).index
MultiIndex([('x', 0),
            ('x', 1),
            ('y', 2),
            ('y', 3)],
           )
</code></pre>
<h2 id="merge与join"><code>merge</code>与<code>join</code></h2>
<h3 id="merge函数"><code>merge</code>函数</h3>
<p><code>merge</code>函数的作用是将两个<code>pandas</code>对象横向合并，遇到重复的索引项时会使用笛卡尔积，默认<code>inner</code>连接，可选<code>left</code>、<code>outer</code>、<code>right</code>连接<br>
所谓左连接，就是指以第一个表索引为基准，右边的表中如果不再左边的则不加入，如果在左边的就以笛卡尔积的方式加入<br>
<code>merge</code>/<code>join</code>与<code>concat</code>的不同之处在于<code>on</code>参数，可以指定某一个对象为<code>key</code>来进行连接<br>
同样的，下面举一些例子：</p>
<pre><code class="language-python">left = pd.DataFrame({'key1': ['K0', 'K0', 'K1', 'K2'],
                     'key2': ['K0', 'K1', 'K0', 'K1'],
                      'A': ['A0', 'A1', 'A2', 'A3'],
                      'B': ['B0', 'B1', 'B2', 'B3']}) 
right = pd.DataFrame({'key1': ['K0', 'K1', 'K1', 'K2'],
                      'key2': ['K0', 'K0', 'K0', 'K0'],
                      'C': ['C0', 'C1', 'C2', 'C3'],
                      'D': ['D0', 'D1', 'D2', 'D3']})
right2 = pd.DataFrame({'key1': ['K0', 'K1', 'K1', 'K2'],
                      'key2': ['K0', 'K0', 'K0', 'K0'],
                      'C': ['C0', 'C1', 'C2', 'C3']})
</code></pre>
<p>以<code>key1</code>为准则连接，如果具有相同的列，则默认<code>suffixes=('_x','_y')</code>：</p>
<pre><code class="language-python">pd.merge(left, right, on='key1')
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411033926.png" alt="" loading="lazy"><br>
以多组键连接：</p>
<pre><code class="language-python">pd.merge(left, right, on=['key1','key2'])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411034002.png" alt="" loading="lazy"><br>
默认使用<code>inner</code>连接，因为<code>merge</code>只能横向拼接，所以取行向上<code>keys</code>的交集，下面看如果使用<code>how=outer</code>参数<br>
注意：这里的<code>how</code>就是<code>concat</code>的<code>join</code></p>
<pre><code class="language-python">pd.merge(left, right, how='outer', on=['key1','key2'])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411034951.png" alt="" loading="lazy"><br>
左连接：</p>
<pre><code class="language-python">pd.merge(left, right, how='left', on=['key1', 'key2'])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411035231.png" alt="" loading="lazy"><br>
右连接：</p>
<pre><code class="language-python">pd.merge(left, right, how='right', on=['key1', 'key2'])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411035305.png" alt="" loading="lazy"><br>
如果还是对笛卡尔积不太了解，请务必理解下面这个例子，由于B的所有元素为2，因此需要6行：</p>
<pre><code class="language-python">left = pd.DataFrame({'A': [1, 2], 'B': [2, 2]})
right = pd.DataFrame({'A': [4, 5, 6], 'B': [2, 2, 2]})
pd.merge(left, right, on='B', how='outer')
</code></pre>
<figure data-type="image" tabindex="110"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411035417.png" alt="" loading="lazy"></figure>
<p><code>validate</code>检验的是到底哪一边出现了重复索引，如果是<code>“one_to_one”</code>则两侧索引都是唯一，如果<code>&quot;one_to_many&quot;</code>则左侧唯一</p>
<pre><code class="language-python">left = pd.DataFrame({'A': [1, 2], 'B': [2, 2]})
right = pd.DataFrame({'A': [4, 5, 6], 'B': [2, 3, 4]})
#pd.merge(left, right, on='B', how='outer',validate='one_to_one') #报错
left = pd.DataFrame({'A': [1, 2], 'B': [2, 1]})
pd.merge(left, right, on='B', how='outer',validate='one_to_one')
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411035632.png" alt="" loading="lazy"><br>
<code>indicator</code>参数指示了，合并后该行索引的来源</p>
<pre><code class="language-python">df1 = pd.DataFrame({'col1': [0, 1], 'col_left': ['a', 'b']})
df2 = pd.DataFrame({'col1': [1, 2, 2], 'col_right': [2, 2, 2]})
pd.merge(df1, df2, on='col1', how='outer', indicator=True) #indicator='indicator_column'也是可以的
</code></pre>
<figure data-type="image" tabindex="111"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411035711.png" alt="" loading="lazy"></figure>
<h3 id="join函数"><code>join</code>函数</h3>
<p><code>join</code>函数作用是将多个<code>pandas</code>对象横向拼接，遇到重复的索引项时会使用笛卡尔积，默认左连接，可选<code>inner</code>、<code>outer</code>、<code>right</code>连接</p>
<pre><code class="language-python">left = pd.DataFrame({'A': ['A0', 'A1', 'A2'],
                     'B': ['B0', 'B1', 'B2']},
                    index=['K0', 'K1', 'K2'])
right = pd.DataFrame({'C': ['C0', 'C2', 'C3'],
                      'D': ['D0', 'D2', 'D3']},
                    index=['K0', 'K2', 'K3'])
left.join(right)
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411035952.png" alt="" loading="lazy"><br>
对于<code>many_to_one</code>模式下的合并，往往<code>join</code>更为方便<br>
同样可以指定<code>key</code>：</p>
<pre><code class="language-python">left = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],
                     'B': ['B0', 'B1', 'B2', 'B3'],
                     'key': ['K0', 'K1', 'K0', 'K1']})
right = pd.DataFrame({'C': ['C0', 'C1'],
                      'D': ['D0', 'D1']},
                     index=['K0', 'K1'])
left.join(right, on='key')
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411040126.png" alt="" loading="lazy"><br>
多层<code>key</code>：</p>
<pre><code class="language-python">left = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],
                     'B': ['B0', 'B1', 'B2', 'B3'],
                     'key1': ['K0', 'K0', 'K1', 'K2'],
                     'key2': ['K0', 'K1', 'K0', 'K1']})
index = pd.MultiIndex.from_tuples([('K0', 'K0'), ('K1', 'K0'),
                                   ('K2', 'K0'), ('K2', 'K1')],names=['key1','key2'])
right = pd.DataFrame({'C': ['C0', 'C1', 'C2', 'C3'],
                      'D': ['D0', 'D1', 'D2', 'D3']},
                     index=index)
left.join(right, on=['key1','key2'])
</code></pre>
<figure data-type="image" tabindex="112"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411040203.png" alt="" loading="lazy"></figure>
<h2 id="练习-5">练习</h2>
<h3 id="练习一-5">练习一</h3>
<p>有2张公司的员工信息表，每个公司共有16名员工，共有五个公司，请解决如下问题</p>
<pre><code class="language-python">pd.read_csv('data/Employee1.csv').head()
</code></pre>
<figure data-type="image" tabindex="113"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411040545.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">pd.read_csv('data/Employee2.csv').head()
</code></pre>
<figure data-type="image" tabindex="114"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411040613.png" alt="" loading="lazy"></figure>
<ul>
<li>每个公司有多少员工满足如下条件：既出现第一张表，又出现在第二张表。</li>
</ul>
<pre><code class="language-python">L = list(set(df1['Name']).intersection(set(df2['Name'])))
L
['b1',
 'b3',
 'c13',
 'a6',
 'd10',
 'b15',
 'c10',
 'c12',
 'b7',
 'e10',
 'e11',
 'd5',
 'a1',
 'a3',
 'c3',
 'e8']
</code></pre>
<ul>
<li>将所有不符合1中条件的行筛选出来，合并为一张新表，列名与原表一致。</li>
</ul>
<pre><code class="language-python">df_b1 = df1[~df1['Name'].isin(L)]
df_b2 = df2[~df2['Name'].isin(L)]
df_b = pd.concat([df_b1,df_b2]).set_index('Name')
df_b.head()
</code></pre>
<figure data-type="image" tabindex="115"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411040835.png" alt="" loading="lazy"></figure>
<ul>
<li>现在需要编制所有80位员工的信息表，对于2中的员工要求不变，对于满足1条件员工，它们在某个指标的数值，取偏离它所属公司中满足b员工的均值数较小的哪一个，例如：P公司在两张表的交集为{p1}，并集扣除交集为{p2,p3,p4}，那么如果后者集合的工资均值为1万元，且p1在表1的工资为13000元，在表2的工资为9000元，那么应该最后取9000元作为p1的工资，最后对于没有信息的员工，利用缺失值填充。</li>
</ul>
<pre><code class="language-python">df2 = pd.read_csv('data/Employee2.csv')
df1['重复'] = ['Y_1' if df1.loc[i,'Name'] in L else 'N' for i in range(df1.shape[0])]
df2['重复'] = ['Y_2' if df2.loc[i,'Name'] in L else 'N' for i in range(df2.shape[0])]
df1 = df1.set_index(['Name','重复'])
df2 = df2.set_index(['Name','重复'])
df_c = pd.concat([df1,df2])
result = pd.DataFrame({'Company':[],'Name':[],'Age':[],'Height':[],'Weight':[],'Salary':[]})
group = df_c.groupby(['Company','重复'])
for i in L:
    first = group.get_group((i[0].upper(),'Y_1')).reset_index(level=1).loc[i,:][-4:]
    second = group.get_group((i[0].upper(),'Y_2')).reset_index(level=1).loc[i,:][-4:]
    mean = group.get_group((i[0].upper(),'N')).reset_index(level=1).mean()
    final = [i[0].upper(),i]
    for j in range(4):
        final.append(first[j] if abs(first[j]-mean[j])&lt;abs(second[j]-mean[j]) else second[j])
    result = pd.concat([result,pd.DataFrame({result.columns.tolist()[k]:[final[k]] for k in range(6)})])
result = pd.concat([result.set_index('Name'),df_b])
for i in list('abcde'):
    for j in range(1,17):
        item = i+str(j)
        if item not in result.index:
            result = pd.concat([result,pd.DataFrame({'Company':[i.upper()],'Name':[item]
                 ,'Age':[np.nan],'Height':[np.nan],'Weight':[np.nan],'Salary':[np.nan]}).set_index('Name')])
result['Number'] = [int(i[1:]) for i in result.index]
result.reset_index().drop(columns='Name').set_index(['Company','Number']).sort_index()
</code></pre>
<figure data-type="image" tabindex="116"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411040912.png" alt="" loading="lazy"></figure>
<h3 id="练习二-5">练习二</h3>
<p>有2张课程的分数表（分数随机生成），但专业课（学科基础课、专业必修课、专业选修课）与其他课程混在一起，请解决如下问题：</p>
<pre><code class="language-python">pd.read_csv('data/Course1.csv').head()
pd.read_csv('data/Course2.csv').head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041020.png" alt="" loading="lazy"><br>
<img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041044.png" alt="" loading="lazy"></p>
<ul>
<li>将两张表分别拆分为专业课与非专业课（结果为四张表）。</li>
</ul>
<pre><code class="language-python">df1 = pd.read_csv('data/Course1.csv')
df2 = pd.read_csv('data/Course2.csv')
df_a11,df_a12,df_a21,df_a22 =0,0,0,0
df_a11= df1.query('课程类别 in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
df_a12= df1.query('课程类别 not in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
df_a21= df2.query('课程类别 in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
df_a22= df2.query('课程类别 not in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
df_a11.head()
</code></pre>
<figure data-type="image" tabindex="117"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041236.png" alt="" loading="lazy"></figure>
<ul>
<li>将两张专业课的分数表和两张非专业课的分数表分别合并。</li>
</ul>
<pre><code class="language-python">special = pd.concat([df_a11,df_a21])
common = pd.concat([df_a12,df_a22])
special.query('课程类别 not in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
</code></pre>
<figure data-type="image" tabindex="118"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041321.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">common.query('课程类别 in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
</code></pre>
<figure data-type="image" tabindex="119"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041321.png" alt="" loading="lazy"></figure>
<ul>
<li>不使用1中的步骤，请直接读取两张表合并后拆分。</li>
</ul>
<pre><code class="language-python">df = pd.concat([df1,df2])
special2 = df.query('课程类别 in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
common2 = df.query('课程类别 not in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
(special.equals(special2),common.equals(common2))
(True, True)
</code></pre>
<ul>
<li>专业课程中有缺失值吗，如果有的话请在完成3的同时，用组内（3种类型的专业课）均值填充缺失值后拆分。</li>
</ul>
<pre><code class="language-python">df['分数'] = df.groupby('课程类别').transform(lambda x: x.fillna(x.mean()))['分数']
df.isnull().all()
课程名字    False
课程类别    False
学分      False
分数      False
dtype: bool
special3 = df.query('课程类别 in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
common3 = df.query('课程类别 not in [&quot;学科基础课&quot;,&quot;专业必修课&quot;,&quot;专业选修课&quot;]')
common3.head()
</code></pre>
<figure data-type="image" tabindex="120"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041522.png" alt="" loading="lazy"></figure>
<h1 id="缺失数据">缺失数据</h1>
<pre><code class="language-python">import pandas as pd
import numpy as np
df = pd.read_csv('data/table_missing.csv')
df.head()
</code></pre>
<figure data-type="image" tabindex="121"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041648.png" alt="" loading="lazy"></figure>
<h2 id="缺失观测及其类型">缺失观测及其类型</h2>
<h3 id="了解缺失信息">了解缺失信息</h3>
<h4 id="isna和notna方法"><code>isna</code>和<code>notna</code>方法</h4>
<p>对<code>Series</code>使用会返回布尔列表</p>
<pre><code class="language-python">df['Physics'].isna().head()
0    False
1    False
2    False
3     True
4    False
Name: Physics, dtype: bool
df['Physics'].notna().head()
0     True
1     True
2     True
3    False
4     True
Name: Physics, dtype: bool
</code></pre>
<p>对<code>DataFrame</code>使用会返回布尔表</p>
<pre><code class="language-python">df.isna().head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041831.png" alt="" loading="lazy"><br>
但对于<code>DataFrame</code>我们更关心到底每列有多少缺失值</p>
<pre><code class="language-python">df.isna().sum()
Out[5]:
School      0
Class       4
ID          6
Gender      7
Address     0
Height      0
Weight     13
Math        5
Physics     4
dtype: int64
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 35 entries, 0 to 34
Data columns (total 9 columns):
 #   Column   Non-Null Count  Dtype  
---  ------   --------------  -----  
 0   School   35 non-null     object 
 1   Class    31 non-null     object 
 2   ID       29 non-null     float64
 3   Gender   28 non-null     object 
 4   Address  35 non-null     object 
 5   Height   35 non-null     int64  
 6   Weight   22 non-null     float64
 7   Math     30 non-null     float64
 8   Physics  31 non-null     object 
dtypes: float64(3), int64(1), object(5)
memory usage: 2.6+ KB
</code></pre>
<h4 id="查看缺失值的所以在行">查看缺失值的所以在行</h4>
<p>以最后一列为例，挑出该列缺失值的行</p>
<pre><code class="language-python">df[df['Physics'].isna()]
</code></pre>
<figure data-type="image" tabindex="122"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411041948.png" alt="" loading="lazy"></figure>
<h4 id="挑选出所有非缺失值列">挑选出所有非缺失值列</h4>
<p>使用<code>all</code>就是全部非缺失值，如果是<code>any</code>就是至少有一个不是缺失值</p>
<pre><code class="language-python">df[df.notna().all(1)]
</code></pre>
<figure data-type="image" tabindex="123"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411042043.png" alt="" loading="lazy"></figure>
<h3 id="三种缺失符号">三种缺失符号</h3>
<h4 id="npnan"><code>np.nan</code></h4>
<p><code>np.nan</code>是一个麻烦的东西，首先它不等与任何东西，甚至不等于自己</p>
<pre><code class="language-python">np.nan == np.nan
False
np.nan == 0
False
np.nan == None
False
</code></pre>
<p>在用<code>equals</code>函数比较时，自动略过两侧全是<code>np.nan</code>的单元格，因此结果不会影响</p>
<pre><code class="language-python">df.equals(df)
True
</code></pre>
<p>其次，它在<code>numpy</code>中的类型为浮点，由此导致数据集读入时，即使原来是整数的列，只要有缺失值就会变为浮点型</p>
<pre><code class="language-python">type(np.nan)
float
pd.Series([1,2,3]).dtype
dtype('int64')
pd.Series([1,np.nan,3]).dtype
dtype('float64')
</code></pre>
<p>此外，对于布尔类型的列表，如果是<code>np.nan</code>填充，那么它的值会自动变为<code>True</code>而不是<code>False</code></p>
<pre><code class="language-python">pd.Series([1,np.nan,3],dtype='bool')
0    True
1    True
2    True
dtype: bool
</code></pre>
<p>但当修改一个布尔列表时，会改变列表类型，而不是赋值为<code>True</code></p>
<pre><code class="language-python">s = pd.Series([True,False],dtype='bool')
s
0    1.0
1    NaN
dtype: float64
</code></pre>
<p>在所有的表格读取后，无论列是存放什么类型的数据，默认的缺失值全为<code>np.nan</code>类型<br>
因此整型列转为浮点；而字符由于无法转化为浮点，因此只能归并为<code>object</code>类型（'O'），原来是浮点型的则类型不变</p>
<pre><code class="language-python">df['ID'].dtype
dtype('float64')
df['Math'].dtype
dtype('float64')
df['Class'].dtype
dtype('O')
</code></pre>
<h4 id="none"><code>None</code></h4>
<p><code>None</code>比前者稍微好些，至少它会等于自身</p>
<pre><code class="language-python">None == None
True
</code></pre>
<p>它的布尔值为<code>False</code></p>
<pre><code class="language-python">pd.Series([None],dtype='bool')
0    False
dtype: bool
</code></pre>
<p>修改布尔列表不会改变数据类型</p>
<pre><code class="language-python">s = pd.Series([True,False],dtype='bool')
s[0]=None
s
0    False
1    False
dtype: bool
s = pd.Series([1,0],dtype='bool')
s
0    False
1    False
dtype: bool
</code></pre>
<p>在传入数值类型后，会自动变为<code>np.nan</code></p>
<pre><code class="language-python">type(pd.Series([1,None])[1])
numpy.float64
</code></pre>
<p>只有当传入<code>object</code>类型是保持不动，几乎可以认为，除非人工命名<code>None</code>，它基本不会自动出现在<code>Pandas</code>中</p>
<pre><code class="language-python">type(pd.Series([1,None],dtype='O')[1])
NoneType
</code></pre>
<p>在使用<code>equals</code>函数时不会被略过，因此下面的情况下返回<code>False</code></p>
<pre><code class="language-python">pd.Series([None]).equals(pd.Series([np.nan]))
False
</code></pre>
<h4 id="nat"><code>NaT</code></h4>
<p><code>NaT</code>是针对时间序列的缺失值，是<code>Pandas</code>的内置类型，可以完全看做时序版本的<code>np.nan</code>，与自己不等，且使用<code>equals</code>时也会被跳过</p>
<pre><code class="language-python">s_time = pd.Series([pd.Timestamp('20120101')]*5)
s_time
0   2012-01-01
1   2012-01-01
2   2012-01-01
3   2012-01-01
4   2012-01-01
dtype: datetime64[ns]
s_time[2] = None
s_time
0   2012-01-01
1   2012-01-01
2          NaT
3   2012-01-01
4   2012-01-01
dtype: datetime64[ns]
s_time[2] = np.nan
s_time
0   2012-01-01
1   2012-01-01
2          NaT
3   2012-01-01
4   2012-01-01
dtype: datetime64[ns]
s_time[2] = pd.NaT
s_time
0   2012-01-01
1   2012-01-01
2          NaT
3   2012-01-01
4   2012-01-01
dtype: datetime64[ns]
type(s_time[2])
pandas._libs.tslibs.nattype.NaTType
s_time[2] == s_time[2]
False
s_time.equals(s_time)
True
s = pd.Series([True,False],dtype='bool')
s[1]=pd.NaT
s
0    True
1    True
dtype: bool
</code></pre>
<h3 id="nullable类型与na符号"><code>Nullable</code>类型与<code>NA</code>符号</h3>
<p>官方鼓励用户使用新的数据类型和缺失类型<code>pd.NA</code></p>
<h4 id="nullable整形"><code>Nullable</code>整形</h4>
<p>对于该种类型而言，它与原来标记<code>int</code>上的符号区别在于首字母大写：<code>'Int'</code></p>
<pre><code class="language-python">s_original = pd.Series([1, 2], dtype=&quot;int64&quot;)
s_original
0    1
1    2
dtype: int64
s_new = pd.Series([1, 2], dtype=&quot;Int64&quot;)
s_new
0    1
1    2
dtype: Int64
</code></pre>
<p>它的好处就在于，其中前面提到的三种缺失值都会被替换为统一的<code>NA</code>符号，且不改变数据类型</p>
<pre><code class="language-python">s_original[1] = np.nan
s_original
0    1.0
1    NaN
dtype: float64
s_new[1] = np.nan
s_new
0       1
1    &lt;NA&gt;
dtype: Int64
s_new[1] = None
Out[40]:
0       1
1    &lt;NA&gt;
dtype: Int64
s_new[1] = pd.NaT
s_new
0       1
1    &lt;NA&gt;
dtype: Int64
</code></pre>
<h4 id="nullable布尔"><code>Nullable</code>布尔</h4>
<p>对于该种类型而言，作用与上面的类似，记号为<code>boolean</code></p>
<pre><code class="language-python">s_original = pd.Series([1, 0], dtype=&quot;bool&quot;)
s_original
0     True
1    False
dtype: bool
s_new = pd.Series([0, 1], dtype=&quot;boolean&quot;)
s_new
0    False
1     True
dtype: boolean
s_original[0] = np.nan
s_original
0    NaN
1    0.0
dtype: float64
s_original = pd.Series([1, 0], dtype=&quot;bool&quot;) #此处重新加一句是因为前面赋值改变了bool类型
s_original[0] = None
s_original
0    False
1    False
dtype: bool
s_new[0] = np.nan
s_new
0    &lt;NA&gt;
1    True
dtype: boolean
s_new[0] = None
s_new
0    &lt;NA&gt;
1    True
dtype: boolean
s_new[0] = pd.NaT
s_new
0    &lt;NA&gt;
1    True
dtype: boolean
s = pd.Series(['dog','cat'])
s[s_new]
1    cat
dtype: object
</code></pre>
<h4 id="string类型"><code>string</code>类型</h4>
<p>它本质上也属于<code>Nullable</code>类型，因为并不会因为含有缺失而改变类型</p>
<pre><code class="language-python">s = pd.Series(['dog','cat'],dtype='string')
s
0    dog
1    cat
dtype: string
s[0] = np.nan
s
0    &lt;NA&gt;
1     cat
dtype: string
s[0] = None
s
0    &lt;NA&gt;
1     cat
dtype: string
s[0] = pd.NaT
s
0    &lt;NA&gt;
1     cat
dtype: string
</code></pre>
<p>此外，和<code>object</code>类型的一点重要区别就在于，在调用字符方法后，<code>string</code>类型返回的是<code>Nullable</code>类型，<code>object</code>则会根据缺失类型和数据类型而改变</p>
<pre><code class="language-python">s = pd.Series([&quot;a&quot;, None, &quot;b&quot;], dtype=&quot;string&quot;)
s.str.count('a')
0       1
1    &lt;NA&gt;
2       0
dtype: Int64
s2 = pd.Series([&quot;a&quot;, None, &quot;b&quot;], dtype=&quot;object&quot;)
s2.str.count(&quot;a&quot;)
0    1.0
1    NaN
2    0.0
dtype: float64
s.str.isdigit()
0    False
1     &lt;NA&gt;
2    False
dtype: boolean
s2.str.isdigit()
0    False
1     None
2    False
dtype: object
</code></pre>
<h3 id="na的特性"><code>NA</code>的特性</h3>
<h4 id="逻辑运算">逻辑运算</h4>
<p>只需看该逻辑运算的结果是否依赖<code>pd.NA</code>的取值，如果依赖，则结果还是<code>NA</code>，如果不依赖，则直接计算结果</p>
<pre><code class="language-python">True | pd.NA
True
pd.NA | True
True
False | pd.NA
&lt;NA&gt;
False &amp; pd.NA
False
True &amp; pd.NA
&lt;NA&gt;
</code></pre>
<p>取值不明直接报错</p>
<pre><code class="language-python">#bool(pd.NA)
</code></pre>
<h4 id="算术运算和比较运算">算术运算和比较运算</h4>
<p>这里只需记住除了下面两类情况，其他结果都是<code>NA</code>即可</p>
<pre><code class="language-python">pd.NA ** 0
1
1 ** pd.NA
1
pd.NA + 1
&lt;NA&gt;
&quot;a&quot; * pd.NA
&lt;NA&gt;
pd.NA == pd.NA
&lt;NA&gt;
pd.NA &lt; 2.5
&lt;NA&gt;
np.log(pd.NA)
&lt;NA&gt;
np.add(pd.NA, 1)
&lt;NA&gt;
</code></pre>
<h3 id="convert_dtypes方法"><code>convert_dtypes</code>方法</h3>
<p>这个函数的功能往往就是在读取数据时，就把数据列转为<code>Nullable</code>类型</p>
<pre><code class="language-python">pd.read_csv('data/table_missing.csv').dtypes
School      object
Class       object
ID         float64
Gender      object
Address     object
Height       int64
Weight     float64
Math       float64
Physics     object
dtype: object
pd.read_csv('data/table_missing.csv').convert_dtypes().dtypes
School      string
Class       string
ID           Int64
Gender      string
Address     string
Height       Int64
Weight       Int64
Math       float64
Physics     string
dtype: object
</code></pre>
<h2 id="缺失数据的运算与分组">缺失数据的运算与分组</h2>
<h3 id="加号与乘号规则">加号与乘号规则</h3>
<p>使用加法时，缺失值为<code>0</code></p>
<pre><code class="language-python">s = pd.Series([2,3,np.nan,4])
s.sum()
9.0
</code></pre>
<p>使用乘法时，缺失值为1</p>
<pre><code class="language-python">s.prod()
24.0
</code></pre>
<p>使用累计函数时，缺失值自动略过</p>
<pre><code class="language-python">s.cumsum()
0    2.0
1    5.0
2    NaN
3    9.0
dtype: float64
s.cumprod()
0     2.0
1     6.0
2     NaN
3    24.0
dtype: float64
s.pct_change()
0         NaN
1    0.500000
2    0.000000
3    0.333333
dtype: float64
</code></pre>
<h3 id="groupby方法中的缺失值"><code>groupby</code>方法中的缺失值</h3>
<p>自动忽略为缺失值的组</p>
<pre><code class="language-python">df_g = pd.DataFrame({'one':['A','B','C','D',np.nan],'two':np.random.randn(5)})
df_g
</code></pre>
<figure data-type="image" tabindex="124"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411043549.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_g.groupby('one').groups
{'A': Int64Index([0], dtype='int64'),
 'B': Int64Index([1], dtype='int64'),
 'C': Int64Index([2], dtype='int64'),
 'D': Int64Index([3], dtype='int64')}
</code></pre>
<h2 id="填充与剔除">填充与剔除</h2>
<h3 id="fillna方法"><code>fillna</code>方法</h3>
<h4 id="值填充与前后向填充分别与ffill方法和bfill方法等价">值填充与前后向填充（分别与<code>ffill</code>方法和<code>bfill</code>方法等价）</h4>
<pre><code class="language-python">df['Physics'].fillna('missing').head()
0         A+
1         B+
2         B+
3    missing
4         A-
Name: Physics, dtype: object
df['Physics'].fillna(method='ffill').head()
0    A+
1    B+
2    B+
3    B+
4    A-
Name: Physics, dtype: object
df['Physics'].fillna(method='backfill').head()
0    A+
1    B+
2    B+
3    A-
4    A-
Name: Physics, dtype: object
</code></pre>
<h4 id="填充中的对齐特性">填充中的对齐特性</h4>
<pre><code class="language-python">df_f = pd.DataFrame({'A':[1,3,np.nan],'B':[2,4,np.nan],'C':[3,5,np.nan]})
df_f.fillna(df_f.mean())
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411043820.png" alt="" loading="lazy"><br>
返回的结果中没有C，根据对齐特点不会被填充</p>
<pre><code class="language-python">df_f.fillna(df_f.mean()[['A','B']])
</code></pre>
<figure data-type="image" tabindex="125"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411043920.png" alt="" loading="lazy"></figure>
<h3 id="dropna方法"><code>dropna</code>方法</h3>
<h4 id="axis参数"><code>axis</code>参数</h4>
<pre><code class="language-python">df_d = pd.DataFrame({'A':[np.nan,np.nan,np.nan],'B':[np.nan,3,2],'C':[3,2,1]})
df_d
</code></pre>
<figure data-type="image" tabindex="126"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044023.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_d.dropna(axis=0)
</code></pre>
<figure data-type="image" tabindex="127"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044100.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_d.dropna(axis=1)
</code></pre>
<figure data-type="image" tabindex="128"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044131.png" alt="" loading="lazy"></figure>
<h4 id="how参数可以选all或者any表示全为缺失去除和存在缺失去除"><code>how</code>参数（可以选<code>all</code>或者<code>any</code>，表示全为缺失去除和存在缺失去除）</h4>
<pre><code class="language-python">df_d.dropna(axis=1,how='all')
</code></pre>
<figure data-type="image" tabindex="129"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044229.png" alt="" loading="lazy"></figure>
<h4 id="subset参数即在某一组列范围中搜索缺失值"><code>subset</code>参数（即在某一组列范围中搜索缺失值）</h4>
<pre><code class="language-python">df_d.dropna(axis=0,subset=['B','C'])
</code></pre>
<figure data-type="image" tabindex="130"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044301.png" alt="" loading="lazy"></figure>
<h2 id="插值interpolation">插值（<code>interpolation</code>）</h2>
<h3 id="线性插值">线性插值</h3>
<h4 id="索引无关的线性插值">索引无关的线性插值</h4>
<p>默认状态下，<code>interpolate</code>会对缺失的值进行线性插值</p>
<pre><code class="language-python">s = pd.Series([1,10,15,-5,-2,np.nan,np.nan,28])
s
0     1.0
1    10.0
2    15.0
3    -5.0
4    -2.0
5     NaN
6     NaN
7    28.0
dtype: float64
s.interpolate()
0     1.0
1    10.0
2    15.0
3    -5.0
4    -2.0
5     8.0
6    18.0
7    28.0
dtype: float64
s.interpolate().plot()
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fe7df20af50&gt;
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044457.png" alt="" loading="lazy"><br>
此时的插值与索引无关</p>
<pre><code class="language-python">s.index = np.sort(np.random.randint(50,300,8))
s.interpolate()
#值不变
69      1.0
71     10.0
84     15.0
117    -5.0
119    -2.0
171     8.0
219    18.0
236    28.0
dtype: float64
s.interpolate().plot()
#后面三个点不是线性的（如果几乎为线性函数，请重新运行上面的一个代码块，这是随机性导致的）
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fe7dfc69890&gt;
</code></pre>
<figure data-type="image" tabindex="131"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044614.png" alt="" loading="lazy"></figure>
<h4 id="与索引有关的插值">与索引有关的插值</h4>
<p><code>method</code>中的<code>index</code>和<code>time</code>选项可以使插值线性地依赖索引，即插值为索引的线性函数</p>
<pre><code class="language-python">s.interpolate(method='index').plot()
#可以看到与上面的区别
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fe7dca0c4d0&gt;
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044759.png" alt="" loading="lazy"><br>
如果索引是时间，那么可以按照时间长短插值</p>
<pre><code class="language-python">s_t = pd.Series([0,np.nan,10]
        ,index=[pd.Timestamp('2012-05-01'),pd.Timestamp('2012-05-07'),pd.Timestamp('2012-06-03')])
s_t
2012-05-01     0.0
2012-05-07     NaN
2012-06-03    10.0
dtype: float64
s_t.interpolate().plot()
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fe7dc964850&gt;
</code></pre>
<figure data-type="image" tabindex="132"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044911.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">s_t.interpolate(method='time').plot()
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fe7dc8eda10&gt;
</code></pre>
<figure data-type="image" tabindex="133"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411044937.png" alt="" loading="lazy"></figure>
<h3 id="interpolate中的限制参数"><code>interpolate</code>中的限制参数</h3>
<h4 id="limit表示最多插入多少个"><code>limit</code>表示最多插入多少个</h4>
<pre><code class="language-python">s = pd.Series([1,np.nan,np.nan,np.nan,5])
s.interpolate(limit=2)
0    1.0
1    2.0
2    3.0
3    NaN
4    5.0
dtype: float64
</code></pre>
<h4 id="limit_direction表示插值方向可选forwardbackwardboth默认前向"><code>limit_direction</code>表示插值方向，可选<code>forward</code>,<code>backward</code>,<code>both</code>，默认前向</h4>
<pre><code class="language-python">s = pd.Series([np.nan,np.nan,1,np.nan,np.nan,np.nan,5,np.nan,np.nan,])
s.interpolate(limit_direction='backward')
0    1.0
1    1.0
2    1.0
3    2.0
4    3.0
5    4.0
6    5.0
7    NaN
8    NaN
dtype: float64
</code></pre>
<h4 id="limit_area表示插值区域可选insideoutside默认none"><code>limit_area</code>表示插值区域，可选<code>inside,outside</code>，默认<code>None</code></h4>
<pre><code class="language-python">s = pd.Series([np.nan,np.nan,1,np.nan,np.nan,np.nan,5,np.nan,np.nan,])
s.interpolate(limit_area='inside')
0    NaN
1    NaN
2    1.0
3    2.0
4    3.0
5    4.0
6    5.0
7    NaN
8    NaN
dtype: float64
s = pd.Series([np.nan,np.nan,1,np.nan,np.nan,np.nan,5,np.nan,np.nan,])
s.interpolate(limit_area='outside')
0    NaN
1    NaN
2    1.0
3    NaN
4    NaN
5    NaN
6    5.0
7    5.0
8    5.0
dtype: float64
</code></pre>
<h2 id="练习-6">练习</h2>
<h3 id="练习一-6">练习一</h3>
<p>现有一份虚拟数据集，列类型分别为<code>string</code>/浮点/整型，请解决如下问题</p>
<pre><code class="language-python">pd.read_csv('data/Missing_data_one.csv').head()
</code></pre>
<figure data-type="image" tabindex="134"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411045437.png" alt="" loading="lazy"></figure>
<ul>
<li>请以列类型读入数据，并选出C为缺失值的行。</li>
</ul>
<pre><code class="language-python">df[df['C'].isna()]
</code></pre>
<figure data-type="image" tabindex="135"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411045542.png" alt="" loading="lazy"></figure>
<ul>
<li>现需要将A中的部分单元转为缺失值，单元格中的最小转换概率为25%，且概率大小与所在行B列单元的值成正比。</li>
</ul>
<pre><code class="language-python">df = pd.read_csv('data/Missing_data_one.csv').convert_dtypes()
total_b = df['B'].sum()
min_b = df['B'].min()
df['A'] = pd.Series(list(zip(df['A'].values
                    ,df['B'].values))).apply(lambda x:x[0] if np.random.rand()&gt;0.25*x[1]/min_b else np.nan)
df.head()
</code></pre>
<figure data-type="image" tabindex="136"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411045624.png" alt="" loading="lazy"></figure>
<h3 id="练习二-6">练习二</h3>
<p>现有一份缺失的数据集，记录了36个人来自的地区、身高、体重、年龄和工资，请解决如下问题：</p>
<pre><code class="language-python">pd.read_csv('data/Missing_data_two.csv').head()
</code></pre>
<figure data-type="image" tabindex="137"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411045741.png" alt="" loading="lazy"></figure>
<ul>
<li>统计各列缺失的比例并选出在后三列中至少有两个非缺失值的行。</li>
</ul>
<pre><code class="language-python">df.isna().sum()/df.shape[0]
Out[60]:
编号    0.000000
地区    0.000000
身高    0.000000
体重    0.222222
年龄    0.250000
工资    0.222222
dtype: float64
df_not2na = df[df.iloc[:,-3:].isna().sum(1)&lt;=1]
df_not2na.head()
</code></pre>
<figure data-type="image" tabindex="138"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411045833.png" alt="" loading="lazy"></figure>
<ul>
<li>请结合身高列和地区列中的数据，对体重进行合理插值。<br>
分地区，用排序后的身高信息进行线性插值</li>
</ul>
<pre><code class="language-python">df_method_1 = df.copy()
for name,group in df_method_1.groupby('地区'):
    df_method_1.loc[group.index,'体重'] = group[['身高','体重']].sort_values(by='身高').interpolate()['体重']
df_method_1['体重'] = df_method_1['体重'].round(decimals=2)
df_method_1.head()
</code></pre>
<figure data-type="image" tabindex="139"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411045921.png" alt="" loading="lazy"></figure>
<h1 id="文本数据">文本数据</h1>
<pre><code class="language-python">import pandas as pd
import numpy as np
</code></pre>
<h2 id="string类型的性质"><code>string</code>类型的性质</h2>
<h3 id="string与object的区别"><code>string</code>与<code>object</code>的区别</h3>
<p><code>string</code>类型和<code>object</code>不同之处有三：</p>
<ol>
<li>字符存取方法（string accessor methods，如str.count）会返回相应数据的<code>Nullable</code>类型，而<code>object</code>会随缺失值的存在而改变返回类型</li>
<li>某些<code>Series</code>方法不能在<code>string</code>上使用，例如： <code>Series.str.decode()</code>，因为存储的是字符串而不是字节</li>
<li><code>string</code>类型在缺失值存储或运算时，类型会广播为<code>pd.NA</code>，而不是浮点型<code>np.nan</code><br>
其余全部内容在当前版本下完全一致，但迎合<code>Pandas</code>的发展模式，我们仍然全部用<code>string</code>来操作字符串</li>
</ol>
<h4 id="string类型的转换"><code>string</code>类型的转换</h4>
<p>如果将一个其他类型的容器直接转换<code>string</code>类型可能会出错：</p>
<pre><code class="language-python">#pd.Series([1,'1.']).astype('string') #报错
#pd.Series([1,2]).astype('string') #报错
#pd.Series([True,False]).astype('string') #报错
</code></pre>
<p>当下正确的方法是分两部转换，先转为<code>str</code>型<code>object</code>，在转为<code>string</code>类型：</p>
<pre><code class="language-python">pd.Series([1,'1.']).astype('str').astype('string')
0     1
1    1.
dtype: string
pd.Series([1,2]).astype('str').astype('string')
0    1
1    2
dtype: string
pd.Series([True,False]).astype('str').astype('string')
0     True
1    False
dtype: string
</code></pre>
<h2 id="拆分与拼接">拆分与拼接</h2>
<h3 id="strsplit方法"><code>str.split</code>方法</h3>
<h4 id="分割符与str的位置元素选取">分割符与<code>str</code>的位置元素选取</h4>
<pre><code class="language-python">s = pd.Series(['a_b_c', 'c_d_e', np.nan, 'f_g_h'], dtype=&quot;string&quot;)
s
0    a_b_c
1    c_d_e
2     &lt;NA&gt;
3    f_g_h
dtype: string
</code></pre>
<p>根据某一个元素分割，默认为空格</p>
<pre><code class="language-python">s.str.split('_')
0    [a, b, c]
1    [c, d, e]
2         &lt;NA&gt;
3    [f, g, h]
dtype: object
</code></pre>
<p>这里需要注意<code>split</code>后的类型是<code>object</code>，因为现在<code>Series</code>中的元素已经不是<code>string</code>，而包含了<code>list</code>，且<code>string</code>类型只能含有字符串<br>
对于<code>str</code>方法可以进行元素的选择，如果该单元格元素是列表，那么<code>str[i]</code>表示取出第i个元素，如果是单个元素，则先把元素转为列表在取出</p>
<pre><code class="language-python">s.str.split('_').str[1]
0       b
1       d
2    &lt;NA&gt;
3       g
dtype: object
pd.Series(['a_b_c', ['a','b','c']], dtype=&quot;object&quot;).str[1]
#第一个元素先转为['a','_','b','_','c']
0    _
1    b
dtype: object
</code></pre>
<h4 id="其他参数">其他参数</h4>
<p><code>expand</code>参数控制了是否将列拆开，<code>n</code>参数代表最多分割多少次</p>
<pre><code class="language-python">s.str.split('_',expand=True)
</code></pre>
<figure data-type="image" tabindex="140"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411141602.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">s.str.split('_',n=1)
0    [a, b_c]
1    [c, d_e]
2        &lt;NA&gt;
3    [f, g_h]
dtype: object
s.str.split('_',expand=True,n=1)
</code></pre>
<figure data-type="image" tabindex="141"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411141804.png" alt="" loading="lazy"></figure>
<h3 id="strcat方法"><code>str.cat</code>方法</h3>
<h4 id="不同对象的拼接模式">不同对象的拼接模式</h4>
<p><code>cat</code>方法对于不同对象的作用结果并不相同，其中的对象包括：单列、双列、多列</p>
<h5 id="对于单个series而言就是指所有的元素进行字符合并为一个字符串">对于单个<code>Series</code>而言，就是指所有的元素进行字符合并为一个字符串</h5>
<pre><code class="language-python">s = pd.Series(['ab',None,'d'],dtype='string')
s
0      ab
1    &lt;NA&gt;
2       d
dtype: string
s.str.cat()
'abd'
</code></pre>
<p>其中可选<code>sep</code>分隔符参数，和缺失值替代字符<code>na_rep</code>参数</p>
<pre><code class="language-python">s.str.cat(sep=',')
'ab,d'
s.str.cat(sep=',',na_rep='*')
'ab,*,d'
</code></pre>
<h5 id="对于两个series合并而言是对应索引的元素进行合并">对于两个<code>Series</code>合并而言，是对应索引的元素进行合并</h5>
<pre><code class="language-python">s2 = pd.Series(['24',None,None],dtype='string')
s2
0      24
1    &lt;NA&gt;
2    &lt;NA&gt;
dtype: string
s.str.cat(s2)
0    ab24
1    &lt;NA&gt;
2    &lt;NA&gt;
dtype: string
</code></pre>
<p>同样也有相应参数，需要注意的是两个缺失值会被同时替换</p>
<pre><code class="language-python">s.str.cat(s2,sep=',',na_rep='*')
0    ab,24
1      *,*
2      d,*
dtype: string
</code></pre>
<h5 id="多列拼接可以分为表的拼接和多series拼接">多列拼接可以分为表的拼接和多<code>Series</code>拼接</h5>
<p>表的拼接</p>
<pre><code class="language-python">s.str.cat(pd.DataFrame({0:['1','3','5'],1:['5','b',None]},dtype='string'),na_rep='*')
0    ab15
1     *3b
2     d5*
dtype: string
</code></pre>
<p>多个<code>Series</code>拼接</p>
<pre><code class="language-python">s.str.cat([s+'0',s*2])
0    abab0abab
1         &lt;NA&gt;
2        dd0dd
dtype: string
</code></pre>
<h5 id="cat中的索引对齐"><code>cat</code>中的索引对齐</h5>
<p>当前版本中，如果两边合并的索引不相同且未指定<code>join</code>参数，默认为左连接，设置<code>join='left'</code></p>
<pre><code class="language-python">s2 = pd.Series(list('abc'),index=[1,2,3],dtype='string')
s2
1    a
2    b
3    c
dtype: string
s.str.cat(s2,na_rep='*')
0    ab*
1     *a
2     db
dtype: string
</code></pre>
<h2 id="替换">替换</h2>
<p>广义上的替换，就是指<code>str.replace</code>函数的应用，<code>fillna</code>是针对缺失值的替换<br>
提到替换，就不可避免地接触到正则表达式，这里默认读者已掌握常见正则表达式知识点，若对其还不了解的，可以通过这份资料来熟悉</p>
<h3 id="strreplace的常见用法"><code>str.replace</code>的常见用法</h3>
<pre><code class="language-python">s = pd.Series(['A', 'B', 'C', 'Aaba', 'Baca','', np.nan, 'CABA', 'dog', 'cat'],dtype=&quot;string&quot;)
s
0       A
1       B
2       C
3    Aaba
4    Baca
5        
6    &lt;NA&gt;
7    CABA
8     dog
9     cat
dtype: string
</code></pre>
<p>第一个值写r开头的正则表达式，后一个写替换的字符串</p>
<pre><code class="language-python">s.str.replace(r'^[AB]','***')
0       ***
1       ***
2         C
3    ***aba
4    ***aca
5          
6      &lt;NA&gt;
7      CABA
8       dog
9       cat
dtype: string
</code></pre>
<h3 id="子组与函数替换">子组与函数替换</h3>
<p>通过正整数调用子组（<code>0</code>返回字符本身，从<code>1</code>开始才是子组）</p>
<pre><code class="language-python">s.str.replace(r'([ABC])(\w+)',lambda x:x.group(2)[1:]+'*')
0       A
1       B
2       C
3     ba*
4     ca*
5        
6    &lt;NA&gt;
7     BA*
8     dog
9     cat
dtype: string
</code></pre>
<p>利用?P&lt;....&gt;表达式可以对子组命名调用</p>
<pre><code class="language-python">s.str.replace(r'(?P&lt;one&gt;[ABC])(?P&lt;two&gt;\w+)',lambda x:x.group('two')[1:]+'*')
0       A
1       B
2       C
3     ba*
4     ca*
5        
6    &lt;NA&gt;
7     BA*
8     dog
9     cat
dtype: string
</code></pre>
<h3 id="关于strreplace的注意事项">关于<code>str.replace</code>的注意事项</h3>
<p>首先，要明确<code>str.replace</code>和<code>replace</code>并不是一个东西：<br>
<code>str.replace</code>针对的是<code>object</code>类型或<code>string</code>类型，默认是以正则表达式为操作，目前暂时不支持<code>DataFrame</code>上使用<br>
<code>replace</code>针对的是任意类型的序列或数据框，如果要以正则表达式替换，需要设置<code>regex=True</code>，该方法通过字典可支持多列替换<br>
但现在由于<code>string</code>类型的初步引入，用法上出现了一些问题，这些issue有望在以后的版本中修复</p>
<h4 id="strreplace赋值参数不得为pdna"><code>str.replace</code>赋值参数不得为<code>pd.NA</code></h4>
<p>这听上去非常不合理，例如对满足某些正则条件的字符串替换为缺失值，直接更改为缺失值在当下版本就会报错</p>
<pre><code class="language-python">#pd.Series(['A','B'],dtype='string').str.replace(r'[A]',pd.NA) #报错
#pd.Series(['A','B'],dtype='O').str.replace(r'[A]',pd.NA) #报错
</code></pre>
<p>此时，可以先转为<code>object</code>类型再转换回来，曲线救国：</p>
<pre><code class="language-python">pd.Series(['A','B'],dtype='string').astype('O').replace(r'[A]',pd.NA,regex=True).astype('string')
0    &lt;NA&gt;
1       B
dtype: string
</code></pre>
<p>至于为什么不用<code>replace</code>函数的<code>regex</code>替换（但<code>string</code>类型<code>replace</code>的非正则替换是可以的），原因在下面一条</p>
<h4 id="对于string类型series在使用replace函数时不能使用正则表达式替换">对于<code>string</code>类型<code>Series</code>，在使用<code>replace</code>函数时不能使用正则表达式替换</h4>
<p>该bug现在还未修复</p>
<pre><code class="language-python">pd.Series(['A','B'],dtype='string').replace(r'[A]','C',regex=True)
0    A
1    B
dtype: string
pd.Series(['A','B'],dtype='O').replace(r'[A]','C',regex=True)
0    C
1    B
dtype: object
</code></pre>
<h4 id="string类型序列如果存在缺失值不能使用replace替换"><code>string</code>类型序列如果存在缺失值，不能使用<code>replace</code>替换</h4>
<pre><code class="language-python">#pd.Series(['A',np.nan],dtype='string').replace('A','B') #报错
pd.Series(['A',np.nan],dtype='string').str.replace('A','B')
0       B
1    &lt;NA&gt;
dtype: string
</code></pre>
<p>综上，概况的说，除非需要赋值元素为缺失值（转为<code>object</code>再转回来），否则请使用<code>str.replace</code>方法</p>
<h2 id="子串匹配与提取">子串匹配与提取</h2>
<h3 id="strextract方法"><code>str.extract</code>方法</h3>
<h4 id="常见用法">常见用法</h4>
<pre><code class="language-python">pd.Series(['10-87', '10-88', '10-89'],dtype=&quot;string&quot;).str.extract(r'([\d]{2})-([\d]{2})')
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145115.png" alt="" loading="lazy"><br>
使用子组名作为列名</p>
<pre><code class="language-python">pd.Series(['10-87', '10-88', '-89'],dtype=&quot;string&quot;).str.extract(r'(?P&lt;name_1&gt;[\d]{2})-(?P&lt;name_2&gt;[\d]{2})')
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145145.png" alt="" loading="lazy"><br>
利用<code>?</code>正则标记选择部分提取</p>
<pre><code class="language-python">pd.Series(['10-87', '10-88', '-89'],dtype=&quot;string&quot;).str.extract(r'(?P&lt;name_1&gt;[\d]{2})?-(?P&lt;name_2&gt;[\d]{2})')
</code></pre>
<figure data-type="image" tabindex="142"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145226.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">pd.Series(['10-87', '10-88', '10-'],dtype=&quot;string&quot;).str.extract(r'(?P&lt;name_1&gt;[\d]{2})-(?P&lt;name_2&gt;[\d]{2})?')
</code></pre>
<figure data-type="image" tabindex="143"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145254.png" alt="" loading="lazy"></figure>
<h4 id="expand参数默认为true"><code>expand</code>参数（默认为<code>True</code>）</h4>
<p>对于一个子组的<code>Series</code>，如果<code>expand</code>设置为<code>False</code>，则返回<code>Series</code>，若大于一个子组，则<code>expand</code>参数无效，全部返回<code>DataFrame</code><br>
对于一个子组的<code>Index</code>，如果<code>expand</code>设置为<code>False</code>，则返回提取后的<code>Index</code>，若大于一个子组且<code>expand</code>为<code>False</code>，报错</p>
<pre><code class="language-python">s.index
Index(['A11', 'B22', 'C33'], dtype='object')
s.str.extract(r'([\w])')
        0
A11	a
B22	b
C33	c
s.str.extract(r'([\w])',expand=False)
A11    a
B22    b
C33    c
dtype: string
s.index.str.extract(r'([\w])')
        0
0	A
1	B
2	C
s.index.str.extract(r'([\w])',expand=False)
Index(['A', 'B', 'C'], dtype='object')
s.index.str.extract(r'([\w])([\d])')
        0	1
0	A	1
1	B	2
2	C	3
#s.index.str.extract(r'([\w])([\d])',expand=False) #报错
</code></pre>
<h3 id="strextractall方法"><code>str.extractall</code>方法</h3>
<p>与<code>extract</code>只匹配第一个符合条件的表达式不同，<code>extractall</code>会找出所有符合条件的字符串，并建立多级索引（即使只找到一个）</p>
<pre><code class="language-python">s = pd.Series([&quot;a1a2&quot;, &quot;b1&quot;, &quot;c1&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],dtype=&quot;string&quot;)
two_groups = '(?P&lt;letter&gt;[a-z])(?P&lt;digit&gt;[0-9])'
s.str.extract(two_groups, expand=True)
</code></pre>
<figure data-type="image" tabindex="144"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145631.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">s.str.extractall(two_groups)
</code></pre>
<figure data-type="image" tabindex="145"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145700.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">s['A']='a1'
s.str.extractall(two_groups)
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145728.png" alt="" loading="lazy"><br>
如果想查看第<code>i</code>层匹配，可使用<code>xs</code>方法</p>
<pre><code class="language-python">s = pd.Series([&quot;a1a2&quot;, &quot;b1b2&quot;, &quot;c1c2&quot;], index=[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;],dtype=&quot;string&quot;)
s.str.extractall(two_groups).xs(1,level='match')
</code></pre>
<figure data-type="image" tabindex="146"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411145805.png" alt="" loading="lazy"></figure>
<h3 id="strcontains和strmatch"><code>str.contains</code>和<code>str.match</code></h3>
<p>前者的作用为检测是否包含某种正则模式</p>
<pre><code class="language-python">pd.Series(['1', None, '3a', '3b', '03c'], dtype=&quot;string&quot;).str.contains(r'[0-9][a-z]')
Out[49]:
0    False
1     &lt;NA&gt;
2     True
3     True
4     True
dtype: boolean
</code></pre>
<p>可选参数为<code>na</code></p>
<pre><code class="language-python">pd.Series(['1', None, '3a', '3b', '03c'], dtype=&quot;string&quot;).str.contains('a', na=False)
0    False
1    False
2     True
3    False
4    False
dtype: boolean
</code></pre>
<p><code>str.match</code>与其区别在于，<code>match</code>依赖于<code>python</code>的<code>re.match</code>，检测内容为是否从头开始包含该正则模式</p>
<pre><code class="language-python">pd.Series(['1', None, '3a_', '3b', '03c'], dtype=&quot;string&quot;).str.match(r'[0-9][a-z]',na=False)
0    False
1    False
2     True
3     True
4    False
dtype: boolean
pd.Series(['1', None, '_3a', '3b', '03c'], dtype=&quot;string&quot;).str.match(r'[0-9][a-z]',na=False)
0    False
1    False
2    False
3     True
4    False
dtype: boolean
</code></pre>
<h2 id="常用字符串方法">常用字符串方法</h2>
<h3 id="过滤型方法">过滤型方法</h3>
<h4 id="strstrip"><code>str.strip</code></h4>
<p>常用于过滤空格</p>
<pre><code class="language-python">pd.Series(list('abc'),index=[' space1  ','space2  ','  space3'],dtype=&quot;string&quot;).index.str.strip()
Index(['space1', 'space2', 'space3'], dtype='object')
</code></pre>
<h4 id="strlower和strupper"><code>str.lower</code>和<code>str.upper</code></h4>
<pre><code class="language-python">pd.Series('A',dtype=&quot;string&quot;).str.lower()
0    a
dtype: string
pd.Series('a',dtype=&quot;string&quot;).str.upper()
0    A
dtype: string
</code></pre>
<h4 id="strswapcase和strcapitalize"><code>str.swapcase</code>和<code>str.capitalize</code></h4>
<p>分别表示交换字母大小写和大写首字母</p>
<pre><code class="language-python">pd.Series('abCD',dtype=&quot;string&quot;).str.swapcase()
0    ABcd
dtype: string
pd.Series('abCD',dtype=&quot;string&quot;).str.capitalize()
0    Abcd
dtype: string
</code></pre>
<h3 id="isnumeric方法"><code>isnumeric</code>方法</h3>
<p>检查每一位是否都是数字，请问如何判断是否是数值？（问题二）</p>
<pre><code class="language-python">pd.Series(['1.2','1','-0.3','a',np.nan],dtype=&quot;string&quot;).str.isnumeric()
0    False
1     True
2    False
3    False
4     &lt;NA&gt;
dtype: boolean
</code></pre>
<h2 id="练习-7">练习</h2>
<h3 id="练习一-7">练习一</h3>
<p>现有一份关于字符串的数据集，请解决以下问题：</p>
<pre><code class="language-python">pd.read_csv('data/String_data_one.csv',index_col='人员编号').head()
</code></pre>
<figure data-type="image" tabindex="147"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411152858.png" alt="" loading="lazy"></figure>
<ul>
<li>现对字符串编码存储人员信息（在编号后添加ID列），使用如下格式：“×××（名字）：×国人，性别×，生于×年×月×日”</li>
</ul>
<pre><code class="language-python">(df['姓名']+':'+df['国籍']+'国人，性别'
          +df['性别']+'，生于'
          +df['出生年']+'年'
          +df['出生月']+'月'+df['出生日']+'日').to_frame().rename(columns={0:'ID'}).head()
</code></pre>
<figure data-type="image" tabindex="148"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411153116.png" alt="" loading="lazy"></figure>
<ul>
<li>将1中的人员生日信息部分修改为用中文表示（如一九七四年十月二十三日），其余返回格式不变。</li>
</ul>
<pre><code class="language-python">L_year = list('零一二三四五六七八九')
L_one = [s.strip() for s in list('  二三四五六七八九')]
L_two = [s.strip() for s in list(' 一二三四五六七八九')]
df_new = (df['姓名']+':'+df['国籍']+'国人，性别'+df['性别']+'，生于'
          +df['出生年'].str.replace(r'\d',lambda x:L_year[int(x.group(0))])+'年'
          +df['出生月'].apply(lambda x:x if len(x)==2 else '0'+x)\
                      .str.replace(r'(?P&lt;one&gt;[\d])(?P&lt;two&gt;\d?)',lambda x:L_one[int(x.group('one'))]
                      +bool(int(x.group('one')))*'十'+L_two[int(x.group('two'))])+'月'
          +df['出生日'].apply(lambda x:x if len(x)==2 else '0'+x)\
                      .str.replace(r'(?P&lt;one&gt;[\d])(?P&lt;two&gt;\d?)',lambda x:L_one[int(x.group('one'))]
                      +bool(int(x.group('one')))*'十'+L_two[int(x.group('two'))])+'日')\
          .to_frame().rename(columns={0:'ID'})
df_new.head()
</code></pre>
<figure data-type="image" tabindex="149"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411153155.png" alt="" loading="lazy"></figure>
<ul>
<li>将2中的ID列结果拆分为原列表相应的5列，并使用equals检验是否一致。</li>
</ul>
<pre><code class="language-python">dic_year = {i[0]:i[1] for i in zip(list('零一二三四五六七八九'),list('0123456789'))}
dic_two = {i[0]:i[1] for i in zip(list('十一二三四五六七八九'),list('0123456789'))}
dic_one = {'十':'1','二十':'2','三十':'3',None:''}
df_res = df_new['ID'].str.extract(r'(?P&lt;姓名&gt;[a-zA-Z]+):(?P&lt;国籍&gt;[\d])国人，性别(?P&lt;性别&gt;[\w])，生于(?P&lt;出生年&gt;[\w]{4})年(?P&lt;出生月&gt;[\w]+)月(?P&lt;出生日&gt;[\w]+)日')
df_res['出生年'] = df_res['出生年'].str.replace(r'(\w)+',lambda x:''.join([dic_year[x.group(0)[i]] for i in range(4)]))
df_res['出生月'] = df_res['出生月'].str.replace(r'(?P&lt;one&gt;\w?十)?(?P&lt;two&gt;[\w])',lambda x:dic_one[x.group('one')]+dic_two[x.group('two')]).str.replace(r'0','10')
df_res['出生日'] = df_res['出生日'].str.replace(r'(?P&lt;one&gt;\w?十)?(?P&lt;two&gt;[\w])',lambda x:dic_one[x.group('one')]+dic_two[x.group('two')]).str.replace(r'^0','10')
df_res.head()
</code></pre>
<figure data-type="image" tabindex="150"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411153230.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_res.equals(df)
</code></pre>
<h3 id="练习二-7">练习二</h3>
<p>现有一份半虚拟的数据集，第一列包含了新型冠状病毒的一些新闻标题，请解决以下问题：</p>
<pre><code class="language-python">pd.read_csv('data/String_data_two.csv').head()
</code></pre>
<figure data-type="image" tabindex="151"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411154012.png" alt="" loading="lazy"></figure>
<ul>
<li>选出所有关于北京市和上海市新闻标题的所在行。</li>
</ul>
<pre><code class="language-python">df[df['col1'].str.contains(r'[北京]{2}|[上海]{2}')].head()
</code></pre>
<figure data-type="image" tabindex="152"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411154138.png" alt="" loading="lazy"></figure>
<ul>
<li>求col2的均值。</li>
</ul>
<pre><code class="language-python">#df['col2'].mean() #报错
df['col2'][~(df['col2'].str.replace(r'-?\d+','True')=='True')] #这三行有问题
309    0-
396    9`
485    /7
Name: col2, dtype: object
df.loc[[309,396,485],'col2'] = [0,9,7]
df['col2'].astype('int').mean()
-0.984
</code></pre>
<ul>
<li>求col3的均值。</li>
</ul>
<pre><code class="language-python">#df['col3'].mean() #报错
#df['col3'] #报错
df.columns
Index(['col1', 'col2', 'col3  '], dtype='object')
df.columns = df.columns.str.strip()
df.columns
Index(['col1', 'col2', 'col3'], dtype='object')
df['col3'].head()
0     363.6923
1     -152.281
2     325.6221
3    -204.9313
4         4.05
Name: col3, dtype: object
#df['col3'].mean() #报错
df['col3'][~(df['col3'].str.replace(r'-?\d+\.?\d+','True')=='True')]
28      355`.3567
37             -5
73              1
122    9056.\2253
332    3534.6554{
370             7
Name: col3, dtype: object
df.loc[[28,122,332],'col3'] = [355.3567,9056.2253, 3534.6554]
df['col3'].astype('float').mean()
24.707485
</code></pre>
<h1 id="分类数据">分类数据</h1>
<pre><code class="language-python">import pandas as pd
import numpy as np
df = pd.read_csv('data/table.csv')
df.head()
</code></pre>
<figure data-type="image" tabindex="153"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411154527.png" alt="" loading="lazy"></figure>
<h2 id="category的创建及其性质">`category的创建及其性质</h2>
<h3 id="分类变量的创建">分类变量的创建</h3>
<h4 id="用series创建">用<code>Series</code>创建</h4>
<pre><code class="language-python">pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], dtype=&quot;category&quot;)
0    a
1    b
2    c
3    a
dtype: category
Categories (3, object): [a, b, c]
</code></pre>
<h4 id="对dataframe指定类型创建">对<code>DataFrame</code>指定类型创建</h4>
<pre><code class="language-python">temp_df = pd.DataFrame({'A':pd.Series([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], dtype=&quot;category&quot;),'B':list('abcd')})
temp_df.dtypes
A    category
B      object
dtype: object
</code></pre>
<h4 id="利用内置categorical类型创建">利用内置<code>Categorical</code>类型创建</h4>
<pre><code class="language-python">cat = pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;], categories=['a','b','c'])
pd.Series(cat)
0    a
1    b
2    c
3    a
dtype: category
Categories (3, object): [a, b, c]
</code></pre>
<h4 id="利用cut函数创建">利用<code>cut</code>函数创建</h4>
<p>默认使用区间类型为标签</p>
<pre><code class="language-python">pd.cut(np.random.randint(0,60,5), [0,10,30,60])
[(10, 30], (0, 10], (10, 30], (30, 60], (30, 60]]
Categories (3, interval[int64]): [(0, 10] &lt; (10, 30] &lt; (30, 60]]
</code></pre>
<p>可指定字符为标签</p>
<pre><code class="language-python">pd.cut(np.random.randint(0,60,5), [0,10,30,60], right=False, labels=['0-10','10-30','30-60'])
[10-30, 30-60, 30-60, 10-30, 30-60]
Categories (3, object): [0-10 &lt; 10-30 &lt; 30-60]
</code></pre>
<h3 id="分类变量的结构">分类变量的结构</h3>
<p>一个分类变量包括三个部分，元素值（<code>values</code>）、分类类别（<code>categories</code>）、是否有序（<code>order</code>）<br>
从上面可以看出，使用<code>cut</code>函数创建的分类变量默认为有序分类变量<br>
下面介绍如何获取或修改这些属性</p>
<h4 id="describe方法"><code>describe</code>方法</h4>
<p>该方法描述了一个分类序列的情况，包括非缺失值个数、元素值类别数（不是分类类别数）、最多次出现的元素及其频数</p>
<pre><code class="language-python">s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;,np.nan], categories=['a','b','c','d']))
s.describe()
count     4
unique    3
top       a
freq      2
dtype: object
</code></pre>
<h4 id="categories和ordered属性"><code>categories</code>和<code>ordered</code>属性</h4>
<p>查看分类类别和是否排序</p>
<pre><code class="language-python">s.cat.categories
Index(['a', 'b', 'c', 'd'], dtype='object')
s.cat.ordered
False
</code></pre>
<h3 id="类别的修改">类别的修改</h3>
<h4 id="利用set_categories修改">利用<code>set_categories</code>修改</h4>
<p>修改分类，但本身值不会变化</p>
<pre><code class="language-python">s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;,np.nan], categories=['a','b','c','d']))
s.cat.set_categories(['new_a','c'])
0    NaN
1    NaN
2      c
3    NaN
4    NaN
dtype: category
Categories (2, object): [new_a, c]
</code></pre>
<h4 id="利用rename_categories修改">利用<code>rename_categories</code>修改</h4>
<p>需要注意的是该方法会把值和分类同时修改</p>
<pre><code class="language-python">s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;,np.nan], categories=['a','b','c','d']))
s.cat.rename_categories(['new_%s'%i for i in s.cat.categories])
0    new_a
1    new_b
2    new_c
3    new_a
4      NaN
dtype: category
Categories (4, object): [new_a, new_b, new_c, new_d]
</code></pre>
<p>利用字典修改值</p>
<pre><code class="language-python">s.cat.rename_categories({'a':'new_a','b':'new_b'})
0    new_a
1    new_b
2        c
3    new_a
4      NaN
dtype: category
Categories (4, object): [new_a, new_b, c, d]
</code></pre>
<h4 id="利用add_categories添加">利用<code>add_categories</code>添加</h4>
<pre><code class="language-python">s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;,np.nan], categories=['a','b','c','d']))
s.cat.add_categories(['e'])
0      a
1      b
2      c
3      a
4    NaN
dtype: category
Categories (5, object): [a, b, c, d, e]
</code></pre>
<h4 id="利用remove_categories移除">利用<code>remove_categories</code>移除</h4>
<pre><code class="language-python">s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;,np.nan], categories=['a','b','c','d']))
s.cat.remove_categories(['d'])
0      a
1      b
2      c
3      a
4    NaN
dtype: category
Categories (3, object): [a, b, c]
</code></pre>
<h4 id="删除元素值未出现的分类类型">删除元素值未出现的分类类型</h4>
<pre><code class="language-python">s = pd.Series(pd.Categorical([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;,np.nan], categories=['a','b','c','d']))
s.cat.remove_unused_categories()
0      a
1      b
2      c
3      a
4    NaN
dtype: category
Categories (3, object): [a, b, c]
</code></pre>
<h2 id="分类变量的排序">分类变量的排序</h2>
<p>前面提到，分类数据类型被分为有序和无序，这非常好理解，例如分数区间的高低是有序变量，考试科目的类别一般看做无序变量</p>
<h3 id="序的建立">序的建立</h3>
<h4 id="一般来说会将一个序列转为有序变量可以利用as_ordered方法">一般来说会将一个序列转为有序变量，可以利用<code>as_ordered</code>方法</h4>
<pre><code class="language-python">s = pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category').cat.as_ordered()
s
0    a
1    d
2    c
3    a
dtype: category
Categories (3, object): [a &lt; c &lt; d]
</code></pre>
<p>退化为无序变量，只需要使用<code>as_unordered</code></p>
<pre><code class="language-python">s.cat.as_unordered()
0    a
1    d
2    c
3    a
dtype: category
Categories (3, object): [a, c, d]
</code></pre>
<h4 id="利用set_categories方法中的order参数">利用<code>set_categories</code>方法中的<code>order</code>参数</h4>
<pre><code class="language-python">pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category').cat.set_categories(['a','c','d'],ordered=True)
0    a
1    d
2    c
3    a
dtype: category
Categories (3, object): [a &lt; c &lt; d]
</code></pre>
<h4 id="利用reorder_categories方法">利用<code>reorder_categories</code>方法</h4>
<p>这个方法的特点在于，新设置的分类必须与原分类为同一集合</p>
<pre><code class="language-python">s = pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category')
s.cat.reorder_categories(['a','c','d'],ordered=True)
0    a
1    d
2    c
3    a
dtype: category
Categories (3, object): [a &lt; c &lt; d]
#s.cat.reorder_categories(['a','c'],ordered=True) #报错
#s.cat.reorder_categories(['a','c','d','e'],ordered=True) #报错
</code></pre>
<h3 id="排序-2">排序</h3>
<p>先前在第1章介绍的值排序和索引排序都是适用的</p>
<pre><code class="language-python">s = pd.Series(np.random.choice(['perfect','good','fair','bad','awful'],50)).astype('category')
s.cat.set_categories(['perfect','good','fair','bad','awful'][::-1],ordered=True).head()
0       good
1       fair
2        bad
3    perfect
4    perfect
dtype: category
Categories (5, object): [awful &lt; bad &lt; fair &lt; good &lt; perfect]
s.sort_values(ascending=False).head()
29    perfect
17    perfect
31    perfect
3     perfect
4     perfect
dtype: category
Categories (5, object): [awful, bad, fair, good, perfect]
df_sort = pd.DataFrame({'cat':s.values,'value':np.random.randn(50)}).set_index('cat')
df_sort.head()
value
cat	
good	-1.746975
fair	0.836732
bad	0.094912
perfect	-0.724338
perfect	-1.456362
df_sort.sort_index().head()
value
cat	
awful	0.245782
awful	0.063991
awful	1.541862
awful	-0.062976
awful	0.472542
</code></pre>
<h2 id="分类变量的比较操作">分类变量的比较操作</h2>
<h3 id="与标量或等长序列的比较">与标量或等长序列的比较</h3>
<h4 id="标量比较">标量比较</h4>
<pre><code class="language-python">s = pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category')
s == 'a'
0     True
1    False
2    False
3     True
dtype: bool
</code></pre>
<h4 id="等长序列比较">等长序列比较</h4>
<pre><code class="language-python">s == list('abcd')
0     True
1    False
2     True
3    False
dtype: bool
</code></pre>
<h3 id="与另一分类变量的比较">与另一分类变量的比较</h3>
<h4 id="等式判别包含等号和不等号">等式判别（包含等号和不等号）</h4>
<p>两个分类变量的等式判别需要满足分类完全相同</p>
<pre><code class="language-python">s = pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category')
s == s
0    True
1    True
2    True
3    True
dtype: bool
s != s
0    False
1    False
2    False
3    False
dtype: bool
s_new = s.cat.set_categories(['a','d','e'])
#s == s_new #报错
</code></pre>
<h4 id="不等式判别包含">不等式判别（包含<code>&gt;=</code>,<code>&lt;=</code>,<code>&lt;</code>,<code>&gt;</code>）</h4>
<p>两个分类变量的不等式判别需要满足两个条件：</p>
<ol>
<li>分类完全相同</li>
<li>排序完全相同</li>
</ol>
<pre><code class="language-python">s = pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category')
#s &gt;= s #报错
s = pd.Series([&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;a&quot;]).astype('category').cat.reorder_categories(['a','c','d'],ordered=True)
s &gt;= s
0    True
1    True
2    True
3    True
dtype: bool
</code></pre>
<h2 id="练习-8">练习</h2>
<h3 id="练习一-8">练习一</h3>
<p>现继续使用第四章中的地震数据集，请解决以下问题：</p>
<pre><code class="language-python">pd.read_csv('data/Earthquake.csv').head()
</code></pre>
<figure data-type="image" tabindex="154"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411160352.png" alt="" loading="lazy"></figure>
<ul>
<li>现在将深度分为七个等级：[0,5,10,15,20,30,50,np.inf]，请以深度等级Ⅰ,Ⅱ,Ⅲ,Ⅳ,Ⅴ,Ⅵ,Ⅶ为索引并按照由浅到深的顺序进行排序。</li>
</ul>
<pre><code class="language-python">df_a = df.copy()
df_a['深度'] = pd.cut(df_a['深度'], [-1e-10,5,10,15,20,30,50,np.inf],labels=['Ⅰ','Ⅱ','Ⅲ','Ⅳ','Ⅴ','Ⅵ','Ⅶ'])
df_a.set_index('深度').sort_index().head()
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411160546.png" alt="" loading="lazy"><br>
<img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411160457.png" alt="" loading="lazy"></p>
<ul>
<li>在1的基础上，将烈度分为4个等级：[0,3,4,5,np.inf]，依次对南部地区的深度和烈度等级建立多级索引排序。</li>
</ul>
<pre><code class="language-python">df_a['烈度'] = pd.cut(df_a['烈度'], [-1e-10,3,4,5,np.inf],labels=['Ⅰ','Ⅱ','Ⅲ','Ⅳ'])
df_a.set_index(['深度','烈度']).sort_index().head()
</code></pre>
<figure data-type="image" tabindex="155"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411160615.png" alt="" loading="lazy"></figure>
<h1 id="时序数据">时序数据</h1>
<h2 id="时序的创建">时序的创建</h2>
<h3 id="四类时间变量">四类时间变量</h3>
<figure data-type="image" tabindex="156"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411161719.png" alt="" loading="lazy"></figure>
<h3 id="时间点的创建">时间点的创建</h3>
<h4 id="to_datetime方法"><code>to_datetime</code>方法</h4>
<p><code>Pandas</code>在时间点建立的输入格式规定上给了很大的自由度，下面的语句都能正确建立同一时间点</p>
<pre><code class="language-python">pd.to_datetime('2020.1.1')
pd.to_datetime('2020 1.1')
pd.to_datetime('2020 1 1')
pd.to_datetime('2020 1-1')
pd.to_datetime('2020-1 1')
pd.to_datetime('2020-1-1')
pd.to_datetime('2020/1/1')
pd.to_datetime('1.1.2020')
pd.to_datetime('1.1 2020')
pd.to_datetime('1 1 2020')
pd.to_datetime('1 1-2020')
pd.to_datetime('1-1 2020')
pd.to_datetime('1-1-2020')
pd.to_datetime('1/1/2020')
pd.to_datetime('20200101')
pd.to_datetime('2020.0101')
Timestamp('2020-01-01 00:00:00')
</code></pre>
<p>下面的语句都会报错</p>
<pre><code class="language-python">#pd.to_datetime('2020\\1\\1')
#pd.to_datetime('2020`1`1')
#pd.to_datetime('2020.1 1')
#pd.to_datetime('1 1.2020')
</code></pre>
<p>此时可利用<code>format</code>参数强制匹配</p>
<pre><code class="language-python">pd.to_datetime('2020\\1\\1',format='%Y\\%m\\%d')
pd.to_datetime('2020`1`1',format='%Y`%m`%d')
pd.to_datetime('2020.1 1',format='%Y.%m %d')
pd.to_datetime('1 1.2020',format='%d %m.%Y')
Timestamp('2020-01-01 00:00:00')
</code></pre>
<p>同时，使用列表可以将其转为时间点索引</p>
<pre><code class="language-python">pd.Series(range(2),index=pd.to_datetime(['2020/1/1','2020/1/2']))
2020-01-01    0
2020-01-02    1
dtype: int64
type(pd.to_datetime(['2020/1/1','2020/1/2']))
pandas.core.indexes.datetimes.DatetimeIndex
</code></pre>
<p>对于<code>DataFrame</code>而言，如果列已经按照时间顺序排好，则利用<code>to_datetime</code>可自动转换</p>
<pre><code class="language-python">df = pd.DataFrame({'year': [2020, 2020],'month': [1, 1], 'day': [1, 2]})
pd.to_datetime(df)
0   2020-01-01
1   2020-01-02
dtype: datetime64[ns]
</code></pre>
<h4 id="时间精度与范围限制">时间精度与范围限制</h4>
<p>事实上，<code>Timestamp</code>的精度远远不止<code>day</code>，可以最小到纳秒<code>ns</code></p>
<pre><code class="language-python">pd.to_datetime('2020/1/1 00:00:00.123456789')
Timestamp('2020-01-01 00:00:00.123456789')
</code></pre>
<p>同时，它带来范围的代价就是只有大约584年的时间点是可用的</p>
<pre><code class="language-python">pd.Timestamp.min
Timestamp('1677-09-21 00:12:43.145225')
pd.Timestamp.max
Timestamp('2262-04-11 23:47:16.854775807')
</code></pre>
<h4 id="date_range方法"><code>date_range</code>方法</h4>
<p>一般来说，<code>start</code>/<code>end</code>/<code>periods</code>（时间点个数）/<code>freq</code>（间隔方法）是该方法最重要的参数，给定了其中的3个，剩下的一个就会被确定</p>
<pre><code class="language-python">pd.date_range(start='2020/1/1',end='2020/1/10',periods=3)
DatetimeIndex(['2020-01-01 00:00:00', '2020-01-05 12:00:00',
               '2020-01-10 00:00:00'],
              dtype='datetime64[ns]', freq=None)
pd.date_range(start='2020/1/1',end='2020/1/10',freq='D')
DatetimeIndex(['2020-01-01', '2020-01-02', '2020-01-03', '2020-01-04',
               '2020-01-05', '2020-01-06', '2020-01-07', '2020-01-08',
               '2020-01-09', '2020-01-10'],
              dtype='datetime64[ns]', freq='D')
pd.date_range(start='2020/1/1',periods=3,freq='D')
DatetimeIndex(['2020-01-01', '2020-01-02', '2020-01-03'], dtype='datetime64[ns]', freq='D')
pd.date_range(end='2020/1/3',periods=3,freq='D')
DatetimeIndex(['2020-01-01', '2020-01-02', '2020-01-03'], dtype='datetime64[ns]', freq='D')
</code></pre>
<p>其中<code>freq</code>参数有许多选项:<br>
<img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411162103.png" alt="" loading="lazy"></p>
<pre><code class="language-python">pd.date_range(start='2020/1/1',periods=3,freq='T')
DatetimeIndex(['2020-01-01 00:00:00', '2020-01-01 00:01:00',
               '2020-01-01 00:02:00'],
              dtype='datetime64[ns]', freq='T')
pd.date_range(start='2020/1/1',periods=3,freq='M')
DatetimeIndex(['2020-01-31', '2020-02-29', '2020-03-31'], dtype='datetime64[ns]', freq='M')
pd.date_range(start='2020/1/1',periods=3,freq='BYS')
DatetimeIndex(['2020-01-01', '2021-01-01', '2022-01-03'], dtype='datetime64[ns]', freq='BAS-JAN')
</code></pre>
<p><code>bdate_range</code>是一个类似与<code>date_range</code>的方法，特点在于可以在自带的工作日间隔设置上，再选择<code>weekmask</code>参数和<code>holidays</code>参数<br>
它的<code>freq</code>中有一个特殊的<code>'C'</code>/<code>'CBM'</code>/<code>'CBMS'</code>选项，表示定制，需要联合<code>weekmask</code>参数和<code>holidays</code>参数使用<br>
例如现在需要将工作日中的周一、周二、周五3天保留，并将部分<code>holidays</code>剔除</p>
<pre><code class="language-python">weekmask = 'Mon Tue Fri'
holidays = [pd.Timestamp('2020/1/%s'%i) for i in range(7,13)]
#注意holidays
pd.bdate_range(start='2020-1-1',end='2020-1-15',freq='C',weekmask=weekmask,holidays=holidays)
DatetimeIndex(['2020-01-03', '2020-01-06', '2020-01-13', '2020-01-14'], dtype='datetime64[ns]', freq='C')
</code></pre>
<h3 id="dateoffset对象"><code>DateOffset</code>对象</h3>
<h4 id="dataoffset与timedelta的区别"><code>DataOffset</code>与<code>Timedelta</code>的区别</h4>
<p><code>Timedelta</code>绝对时间差的特点指无论是冬令时还是夏令时，增减<code>1day</code>都只计算24小时<br>
<code>DataOffset</code>相对时间差指，无论一天是23\24\25小时，增减<code>1day</code>都与当天相同的时间保持一致<br>
例如，英国当地时间 2020年03月29日，01:00:00 时钟向前调整 1 小时 变为 2020年03月29日，02:00:00，开始夏令时</p>
<pre><code class="language-python">ts = pd.Timestamp('2020-3-29 01:00:00', tz='Europe/Helsinki')
ts + pd.Timedelta(days=1)
Timestamp('2020-03-30 02:00:00+0300', tz='Europe/Helsinki')
ts + pd.DateOffset(days=1)
Timestamp('2020-03-30 01:00:00+0300', tz='Europe/Helsinki')
</code></pre>
<p>这似乎有些令人头大，但只要把<code>tz</code>（time zone）去除就可以不用管它了，两者保持一致，除非要使用到时区变换</p>
<pre><code class="language-python">ts = pd.Timestamp('2020-3-29 01:00:00')
ts + pd.Timedelta(days=1)
Timestamp('2020-03-30 01:00:00')
ts + pd.DateOffset(days=1)
Timestamp('2020-03-30 01:00:00')
</code></pre>
<h4 id="增减一段时间">增减一段时间</h4>
<p><code>DateOffset</code>的可选参数包括<code>years</code>/<code>months</code>/<code>weeks</code>/<code>days</code>/<code>hours</code>/<code>minutes</code>/<code>seconds</code></p>
<pre><code class="language-python">pd.Timestamp('2020-01-01') + pd.DateOffset(minutes=20) - pd.DateOffset(weeks=2)
Timestamp('2019-12-18 00:20:00')
</code></pre>
<h4 id="各类常用offset对象">各类常用<code>offset</code>对象</h4>
<figure data-type="image" tabindex="157"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411162934.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">pd.Timestamp('2020-01-01') + pd.offsets.Week(2)
Timestamp('2020-01-15 00:00:00')
pd.Timestamp('2020-01-01') + pd.offsets.BQuarterBegin(1)
Timestamp('2020-03-02 00:00:00')
</code></pre>
<h4 id="序列的offset操作">序列的<code>offset</code>操作</h4>
<p>利用<code>apply</code>函数</p>
<pre><code class="language-python">pd.Series(pd.offsets.BYearBegin(3).apply(i) for i in pd.date_range('20200101',periods=3,freq='Y'))
0   2023-01-02
1   2024-01-01
2   2025-01-01
dtype: datetime64[ns]
</code></pre>
<p>直接使用对象加减</p>
<pre><code class="language-python">pd.date_range('20200101',periods=3,freq='Y') + pd.offsets.BYearBegin(3)
DatetimeIndex(['2023-01-02', '2024-01-01', '2025-01-01'], dtype='datetime64[ns]', freq='A-DEC')
</code></pre>
<p>定制<code>offset</code>，可以指定<code>weekmask</code>和<code>holidays</code>参数（思考为什么三个都是一个值）</p>
<pre><code class="language-python">pd.Series(pd.offsets.CDay(3,weekmask='Wed Fri',holidays='2020010').apply(i)
                                  for i in pd.date_range('20200105',periods=3,freq='D'))
0   2020-01-15
1   2020-01-15
2   2020-01-15
dtype: datetime64[ns]
</code></pre>
<h2 id="时序的索引及属性">时序的索引及属性</h2>
<h3 id="索引切片">索引切片</h3>
<pre><code class="language-python">rng = pd.date_range('2020','2021', freq='W')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
ts.head()
2020-01-05    1.513910
2020-01-12    0.921820
2020-01-19   -0.216364
2020-01-26    0.256636
2020-02-02   -1.318088
Freq: W-SUN, dtype: float64
ts['2020-01-26']
0.2566361282801419
</code></pre>
<p>合法字符自动转换为时间点</p>
<pre><code class="language-python">ts['2020-01-26':'20200726'].head()
2020-01-26    0.256636
2020-02-02   -1.318088
2020-02-09   -0.668092
2020-02-16    0.152675
2020-02-23   -1.163632
Freq: W-SUN, dtype: float64
</code></pre>
<h3 id="子集索引">子集索引</h3>
<pre><code class="language-python">ts['2020-7'].head()
2020-07-05    0.756521
2020-07-12    0.170898
2020-07-19   -0.406184
2020-07-26    0.980721
Freq: W-SUN, dtype: float64
</code></pre>
<p>支持混合形态索引</p>
<pre><code class="language-python">ts['2011-1':'20200726'].head()
2020-01-05    1.513910
2020-01-12    0.921820
2020-01-19   -0.216364
2020-01-26    0.256636
2020-02-02   -1.318088
Freq: W-SUN, dtype: float64
</code></pre>
<h3 id="时间点的属性">时间点的属性</h3>
<p>采用<code>dt</code>对象可以轻松获得关于时间的信息</p>
<pre><code class="language-python">pd.Series(ts.index).dt.week.head()
0    1
1    2
2    3
3    4
4    5
dtype: int64
pd.Series(ts.index).dt.day.head()
0     5
1    12
2    19
3    26
4     2
dtype: int64
</code></pre>
<p>利用<code>strftime</code>可重新修改时间格式</p>
<pre><code class="language-python">pd.Series(ts.index).dt.strftime('%Y-间隔1-%m-间隔2-%d').head()
0    2020-间隔1-01-间隔2-05
1    2020-间隔1-01-间隔2-12
2    2020-间隔1-01-间隔2-19
3    2020-间隔1-01-间隔2-26
4    2020-间隔1-02-间隔2-02
dtype: object
</code></pre>
<p>对于<code>datetime</code>对象可以直接通过属性获取信息</p>
<pre><code class="language-python">pd.date_range('2020','2021', freq='W').month
Int64Index([ 1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  3,  4,  4,  4,  4,
             5,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
             8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12,
            12],
           dtype='int64')
pd.date_range('2020','2021', freq='W').weekday
Int64Index([6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6],
           dtype='int64')
</code></pre>
<h2 id="重采样">重采样</h2>
<p>所谓重采样，就是指<code>resample</code>函数，它可以看做时序版本的<code>groupby</code>函数</p>
<h3 id="resample对象的基本操作"><code>resample</code>对象的基本操作</h3>
<p>采样频率一般设置为上面提到的<code>offset</code>字符</p>
<pre><code class="language-python">df_r = pd.DataFrame(np.random.randn(1000, 3),index=pd.date_range('1/1/2020', freq='S', periods=1000),
                  columns=['A', 'B', 'C'])
r = df_r.resample('3min')
r
&lt;pandas.core.resample.DatetimeIndexResampler object at 0x7f0c0f89a7d0&gt;
r.sum()
</code></pre>
<figure data-type="image" tabindex="158"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411163548.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df_r2 = pd.DataFrame(np.random.randn(200, 3),index=pd.date_range('1/1/2020', freq='D', periods=200),
                  columns=['A', 'B', 'C'])
r = df_r2.resample('CBMS')
r.sum()
</code></pre>
<figure data-type="image" tabindex="159"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411163633.png" alt="" loading="lazy"></figure>
<h3 id="采样聚合">采样聚合</h3>
<pre><code class="language-python">r = df_r.resample('3T')
r['A'].mean()
2020-01-01 00:00:00    0.050495
2020-01-01 00:03:00    0.021719
2020-01-01 00:06:00   -0.044430
2020-01-01 00:09:00   -0.015729
2020-01-01 00:12:00   -0.117970
2020-01-01 00:15:00    0.004193
Freq: 3T, Name: A, dtype: float64
r['A'].agg([np.sum, np.mean, np.std])
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411163819.png" alt="" loading="lazy"><br>
类似地，可以使用函数/<code>lambda</code>表达式</p>
<pre><code class="language-python">r.agg({'A': np.sum,'B': lambda x: max(x)-min(x)})
</code></pre>
<figure data-type="image" tabindex="160"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411163855.png" alt="" loading="lazy"></figure>
<h3 id="采样组的迭代">采样组的迭代</h3>
<p>采样组的迭代和<code>groupby</code>迭代完全类似，对于每一个组都可以分别做相应操作</p>
<pre><code class="language-python">small = pd.Series(range(6),index=pd.to_datetime(['2020-01-01 00:00:00', '2020-01-01 00:30:00'
                                                 , '2020-01-01 00:31:00','2020-01-01 01:00:00'
                                                 ,'2020-01-01 03:00:00','2020-01-01 03:05:00']))
resampled = small.resample('H')
for name, group in resampled:
    print(&quot;Group: &quot;, name)
    print(&quot;-&quot; * 27)
    print(group, end=&quot;\n\n&quot;)
Group:  2020-01-01 00:00:00
---------------------------
2020-01-01 00:00:00    0
2020-01-01 00:30:00    1
2020-01-01 00:31:00    2
dtype: int64

Group:  2020-01-01 01:00:00
---------------------------
2020-01-01 01:00:00    3
dtype: int64

Group:  2020-01-01 02:00:00
---------------------------
Series([], dtype: int64)

Group:  2020-01-01 03:00:00
---------------------------
2020-01-01 03:00:00    4
2020-01-01 03:05:00    5
dtype: int64
</code></pre>
<h2 id="窗口函数">窗口函数</h2>
<p>下面主要介绍<code>pandas</code>中两类主要的窗口(<code>window</code>)函数:<code>rolling</code>/<code>expanding</code></p>
<pre><code class="language-python">s = pd.Series(np.random.randn(1000),index=pd.date_range('1/1/2020', periods=1000))
s.head()
2020-01-01    0.659255
2020-01-02   -2.074411
2020-01-03   -1.354148
2020-01-04   -0.774753
2020-01-05    0.360106
Freq: D, dtype: float64
</code></pre>
<h3 id="rolling">Rolling</h3>
<h4 id="常用聚合">常用聚合</h4>
<p>所谓<code>rolling</code>方法，就是规定一个窗口，它和<code>groupby</code>对象一样，本身不会进行操作，需要配合聚合函数才能计算结果</p>
<pre><code class="language-python">s.rolling(window=50)
Rolling [window=50,center=False,axis=0]
s.rolling(window=50).mean()
2020-01-01         NaN
2020-01-02         NaN
2020-01-03         NaN
2020-01-04         NaN
2020-01-05         NaN
                ...   
2022-09-22    0.044807
2022-09-23    0.071231
2022-09-24    0.098303
2022-09-25    0.110776
2022-09-26    0.085055
Freq: D, Length: 1000, dtype: float64
</code></pre>
<p><code>min_periods</code>参数是指需要的非缺失数据点数量阀值</p>
<pre><code class="language-python">s.rolling(window=50,min_periods=3).mean().head()
2020-01-01         NaN
2020-01-02         NaN
2020-01-03   -0.923101
2020-01-04   -0.886014
2020-01-05   -0.636790
Freq: D, dtype: float64
</code></pre>
<p><code>count</code>/<code>sum</code>/<code>mean</code>/<code>median</code>/<code>min</code>/<code>max</code>/<code>std</code>/<code>var</code>/<code>skew</code>/<code>kurt</code>/<code>quantile</code>/<code>cov</code>/<code>corr</code>都是常用的聚合函数</p>
<h4 id="rolling的apply聚合"><code>rolling</code>的<code>apply</code>聚合</h4>
<p>使用<code>apply</code>聚合时，只需记住传入的是<code>window</code>大小的<code>Series</code>，输出的必须是标量即可，比如如下计算变异系数</p>
<pre><code class="language-python">s.rolling(window=50,min_periods=3).apply(lambda x:x.std()/x.mean()).head()
2020-01-01         NaN
2020-01-02         NaN
2020-01-03   -1.534925
2020-01-04   -1.308402
2020-01-05   -1.803185
Freq: D, dtype: float64
</code></pre>
<h4 id="基于时间的rolling">基于时间的<code>rolling</code></h4>
<pre><code class="language-python">s.rolling('15D').mean().head()
2020-01-01    0.659255
2020-01-02   -0.707578
2020-01-03   -0.923101
2020-01-04   -0.886014
2020-01-05   -0.636790
Freq: D, dtype: float64
</code></pre>
<p>可选<code>closed='right'</code>（默认）`'left'<code>\</code>'both'<code>\</code>'neither'`参数，决定端点的包含情况</p>
<pre><code class="language-python">s.rolling('15D', closed='right').sum().head()
2020-01-01    0.659255
2020-01-02   -1.415156
2020-01-03   -2.769304
2020-01-04   -3.544057
2020-01-05   -3.183952
Freq: D, dtype: float64
</code></pre>
<h3 id="expanding"><code>Expanding</code></h3>
<h4 id="expanding函数"><code>expanding</code>函数</h4>
<p>普通的<code>expanding</code>函数等价与<code>rolling(window=len(s),min_periods=1)</code>，是对序列的累计计算</p>
<pre><code class="language-python">s.rolling(window=len(s),min_periods=1).sum().head()
2020-01-01    0.659255
2020-01-02   -1.415156
2020-01-03   -2.769304
2020-01-04   -3.544057
2020-01-05   -3.183952
Freq: D, dtype: float64
s.expanding().sum().head()
2020-01-01    0.659255
2020-01-02   -1.415156
2020-01-03   -2.769304
2020-01-04   -3.544057
2020-01-05   -3.183952
Freq: D, dtype: float64
</code></pre>
<p><code>apply</code>方法也是同样可用的</p>
<pre><code class="language-python">s.expanding().apply(lambda x:sum(x)).head()
2020-01-01    0.659255
2020-01-02   -1.415156
2020-01-03   -2.769304
2020-01-04   -3.544057
2020-01-05   -3.183952
Freq: D, dtype: float64
</code></pre>
<h4 id="几个特别的expanding类型函数">几个特别的<code>Expanding</code>类型函数</h4>
<p><code>cumsum</code>/<code>cumprod</code>/<code>cummax</code>/<code>cummin</code>都是特殊<code>expanding</code>累计计算方法</p>
<pre><code class="language-python">s.cumsum().head()
2020-01-01    0.659255
2020-01-02   -1.415156
2020-01-03   -2.769304
2020-01-04   -3.544057
2020-01-05   -3.183952
Freq: D, dtype: float64
s.cumsum().head()
Out[59]:
2020-01-01    0.659255
2020-01-02   -1.415156
2020-01-03   -2.769304
2020-01-04   -3.544057
2020-01-05   -3.183952
Freq: D, dtype: float64
</code></pre>
<p><code>shift</code>/<code>diff</code>/<code>pct_change</code>都是涉及到了元素关系</p>
<ol>
<li><code>shift</code>是指序列索引不变，但值向后移动</li>
<li><code>diff</code>是指前后元素的差，<code>period</code>参数表示间隔，默认为1，并且可以为负</li>
<li><code>pct_change</code>是值前后元素的变化百分比，<code>period</code>参数与<code>diff</code>类似</li>
</ol>
<pre><code class="language-python">s.shift(2).head()
2020-01-01         NaN
2020-01-02         NaN
2020-01-03    0.659255
2020-01-04   -2.074411
2020-01-05   -1.354148
Freq: D, dtype: float64
s.diff(3).head()
Out[61]:
2020-01-01         NaN
2020-01-02         NaN
2020-01-03         NaN
2020-01-04   -1.434008
2020-01-05    2.434516
Freq: D, dtype: float64
s.pct_change(3).head()
2020-01-01         NaN
2020-01-02         NaN
2020-01-03         NaN
2020-01-04   -2.175196
2020-01-05   -1.173594
Freq: D, dtype: float64
</code></pre>
<h1 id="速查">速查</h1>
<h2 id="series和dataframe对象的创建"><code>Series</code>和<code>DataFrame</code>对象的创建</h2>
<h3 id="series-2"><code>Series</code></h3>
<p><code>Series</code>是<code>pandas</code>中暴露给我们使用的基本对象，它是由相同元素类型构成的一维数据结构，同时具有列表和字典的属性，字典的属性由索引赋予。</p>
<ul>
<li><code>Series</code>：有序，有索引</li>
<li><code>list</code>：  有序，无索引</li>
<li><code>dict</code>：  无序，有索引</li>
</ul>
<h4 id="预览">预览</h4>
<pre><code class="language-python">data = [1,2,3]
index = ['a','b','c']
s = pd.Series(data=data, index=index, name = 'sss')
s
a    1
b    2
c    3
Name: sss, dtype: int64
s.index  # 四个属性之一：索引
Index(['a', 'b', 'c'], dtype='object')
s.name  # 四个属性之二：名字，
'sss'
s.values # 四个属性之三：值
array([1, 2, 3], dtype=int64)
s.dtype # 四个属性之四：元素类型
dtype('int64')
</code></pre>
<h4 id="创建">创建</h4>
<p><code>pd.Series(data=None, index=None, name = None)</code></p>
<ul>
<li><code>data</code>：多种类型，见下面具体介绍；</li>
<li><code>index</code>：索引信息；</li>
<li><code>name</code>：对<code>data</code>的说明，用的不多，一般在和<code>DataFrame</code>、<code>Index</code>互相转换时才需要。</li>
</ul>
<h5 id="data无索引"><code>data</code>无索引</h5>
<p>如果 <code>data</code> 为 <code>ndarray</code>(1D) 或 <code>list</code>(1D)，那么其缺少 <code>Series</code> 需要的索引信息；<br>
如果提供 <code>index</code>，则必须和<code>data</code>长度相同；<br>
如果不提供 <code>index</code>，那么其将生成默认数值索引 <code>range(0, data.shape[0])</code>。</p>
<pre><code class="language-python"># data = [1,2,3]
data1 = np.array([1,2,3])
index1 = ['a','b','c']
s = pd.Series(data = data1, index = index1)
s
a    1
b    2
c    3
dtype: int32
</code></pre>
<h5 id="data有索引"><code>data</code>有索引</h5>
<p>如果 <code>data</code> 为 <code>Series</code> 或 <code>dict</code> ，那么其已经提供了 <code>Series</code> 需要的索引信息，所以 <code>index</code> 项是不需要提供的；<br>
如果额外提供了 <code>index</code> 项，那么其将对当前构建的<code>Series</code>进行 重索引（增删）（等同于<code>reindex</code>操作）。</p>
<pre><code class="language-python"># data = pd.Series([a,b,c], index = ['a','b','c'] )
data2 = { 'a':1, 'b':2,'c':3 }
index2 = ['a','b','d']
s = pd.Series(data = data2, index = index2)
s
a    1.0
b    2.0
d    NaN
dtype: float64
</code></pre>
<p>如上，<code>index</code>项用于从当前已有索引中匹配出相同的行，如果当前索引缺失给定的索引，则填充<code>NaN</code>（<code>NaN</code>：not a number为<code>pandas</code>缺失值标记）。</p>
<h3 id="dataframe-2">DataFrame</h3>
<p><code>DataFrame</code>由具有共同索引的<code>Series</code>按列排列构成（2D），是使用最多的对象。</p>
<h4 id="预览-2">预览</h4>
<pre><code class="language-python">data = [[1,2,3],
       [4,5,6]]
index = ['a','b']
columns = ['A','B','C']
df = pd.DataFrame(data=data, index = index, columns = columns)
df
    A	B	C
a	1	2	3
b	4	5	6
df.index  # 行索引
Index(['a', 'b'], dtype='object')
df.columns  # 列索引，由Series的name构成
Index(['A', 'B', 'C'], dtype='object')
df.values
array([[1, 2, 3],
       [4, 5, 6]], dtype=int64)
df.dtypes  # 这里的dtype带s，查看每列元素类型
A    int64
B    int64
C    int64
dtype: object
</code></pre>
<h4 id="创建-2">创建</h4>
<p><code>pd.DataFrame(data=None, index=None, columns=None)</code><br>
函数有多个参数，对我们有用的主要是：<code>data</code>,<code>index</code>和<code>columns</code>三项</p>
<h4 id="data无-行索引无-列索引"><code>data</code>无 行索引，无 列索引</h4>
<p>如果 <code>data</code> 为 <code>ndarray</code>(2D) or <code>list</code>(2D)，那么其缺少 <code>DataFrame</code> 需要的行、列索引信息；<br>
如果提供 <code>index</code> 或 <code>columns</code> 项，其必须和<code>data</code>的行 或 列长度相同；<br>
如果不提供 <code>index</code> 或 <code>columns</code> 项，那么其将默认生成数值索引<code>range(0, data.shape[0]))</code> 或 <code>range(0, data.shape[1])</code>。</p>
<pre><code class="language-python"># data = [[1,2,3],
#        [4,5,6]]
data1 = np.array([[1,2,3],
                  [4,5,6]] )
index1 = ['a','b']
columns1 = ['A','B','C']
df = pd.DataFrame(data=data1, index = index1, columns = columns1)
df
    A	B	C
a	1	2	3
b	4	5	6
</code></pre>
<h4 id="data无-行索引有-列索引"><code>data</code>无 行索引，有 列索引</h4>
<p>如果<code>data</code>为 <code>dict of (ndarray(1D) or list(1D))</code>，所有<code>ndarray</code>或<code>list</code>的长度必须相同。<code>dict</code>的<code>key</code>为<code>DataFrame</code>提供了需要的<code>columns</code>信息，缺失<code>index</code>；<br>
如果提供 <code>index</code> 项，必须和<code>list</code>的长度相同；<br>
如果不提供 <code>index</code>，那么其将默认生成数值索引<code>range(0, data.shape[0]))</code>；<br>
如果还额外提供了<code>columns</code>项，那么其将对当前构建的<code>DataFrame</code>进行 列重索引。</p>
<pre><code class="language-python">data2 = { 'A' : [1,4], 'B': [2,5], 'C':[3,6] }
index2 = ['a','b']
columns2 = ['A','B','D']
df = pd.DataFrame(data=data2, index = index2, columns = columns2)
df
    A	B	D
a	1	2	NaN
b	4	5	NaN
</code></pre>
<h4 id="data有-行索引有-列索引"><code>data</code>有 行索引，有 列索引</h4>
<p>如果<code>data</code>为 <code>dict of (Series or dict)</code>，那么其已经提供了<code>DataFrame</code>需要的所有信息；<br>
如果多个<code>Series</code>或<code>dict</code>间的索引不一致，那么取并操作（<code>pandas</code>不会试图丢掉信息），缺失的数据填充<code>NaN</code>；<br>
如果提供了<code>index</code>项或<code>columns</code>项，那么其将对当前构建的<code>DataFrame</code>进行 重索引（<code>reindex</code>，<code>pandas</code>内部调用接口）。</p>
<pre><code class="language-python"># data3 = { 'A' : pd.Series([1,4] ,index = ['a','b']), 'B' : pd.Series([2,5] ,index = ['a','b']), 'C' : pd.Series([3,6] ,index = ['a','c']) }
data3 = { 'A' : { 'a':1, 'b':4}, 'B': {'a':2,'b':5}, 'C':{'a':3, 'c':6} }
df = pd.DataFrame(data=data3)
df
    A	B	C
a	1.0	2.0	3.0
b	4.0	5.0	NaN
c	NaN	NaN	6.0
</code></pre>
<h3 id="由文件创建">由文件创建</h3>
<h4 id="由csv文件创建">由<code>.csv</code>文件创建</h4>
<p><code>pd.read_csv(filepath_or_buffer, sep=',', header='infer', names=None,index_col=None, encoding=None )</code><br>
<code>read_csv</code>的参数很多，但这几个参数就够我们使用了：</p>
<ul>
<li><code>filepath_or_buffer</code>：路径和文件名不要带中文，带中文容易报错。</li>
<li><code>sep</code>: <code>csv</code>文件数据的分隔符，默认是<code>','</code>，根据实际情况修改；</li>
<li><code>header</code>：如果有列名，那么这一项不用改；</li>
<li><code>names</code>：如果没有列名，那么必须设置<code>header = None</code>， <code>names</code>为需要传入的列名列表，不设置默认生成数值索引；</li>
<li><code>index_col</code>：<code>list of (int or name)</code>，传入列名的列表或者列名的位置，选取这几列作为索引；</li>
<li><code>encoding</code>：根据你的文档编码来确定，如果有中文读取报错，试试<code>encoding = 'gbk'</code>。</li>
</ul>
<pre><code class="language-python">tips = pd.read_csv( 'tips.csv')
tips.head()
</code></pre>
<figure data-type="image" tabindex="161"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200411215921.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">tips.index
RangeIndex(start=0, stop=244, step=1)
tips.columns
Index(['total_bill', 'tip', 'sex', 'smoker', 'day', 'time', 'size'], dtype='object')
tips.values
array([[16.99, 1.01, 'Female', ..., 'Sun', 'Dinner', 2],
       [10.34, 1.66, 'Male', ..., 'Sun', 'Dinner', 3],
       [21.01, 3.5, 'Male', ..., 'Sun', 'Dinner', 3],
       ...,
       [22.67, 2.0, 'Male', ..., 'Sat', 'Dinner', 2],
       [17.82, 1.75, 'Male', ..., 'Sat', 'Dinner', 2],
       [18.78, 3.0, 'Female', ..., 'Thur', 'Dinner', 2]], dtype=object)
</code></pre>
<h2 id="series和dataframe对象的查-改-增-删"><code>Series</code>和<code>DataFrame</code>对象的查、改、增、 删</h2>
<h3 id="series-3"><code>Series</code></h3>
<h4 id="查">查</h4>
<pre><code class="language-python">data = [1,2,3]
index = ['a','b','c']
s = pd.Series(data=data, index=index)
s
a    1
b    2
c    3
dtype: int64
</code></pre>
<h5 id="快捷查看"><code>[]</code>，快捷查看</h5>
<pre><code class="language-python">s[1] # scalar, 返回一个值
2
s[0:2] # 范围，左闭右开，返回Series切片
a    1
b    2
dtype: int64
s[[0,2]] #列表，返回Series切片
a    1
c    3
dtype: int64
mask = [False,True,False]  #mask，类似于列表，只是长度必须和Series相同，返回Series切片
s[mask]
b    2
dtype: int64
</code></pre>
<h5 id="loc基于索引"><code>.loc[]</code>，基于索引</h5>
<p><code>.loc[]</code>查询方式和<code>[]</code>完全一致。</p>
<pre><code class="language-python">s.loc['b'] # 单索引，返回一个值
2
s.loc['a':'c'] # 范围，注意：左闭右闭，返回Series切片
a    1
b    2
c    3
dtype: int64
s.loc[['a','c']] # 列表，返回Series切片
a    1
c    3
dtype: int64
mask = [False, True, False] # mask，和iloc[]效果等同，返回Series切片
s.loc[mask]
b    2
dtype: int64
</code></pre>
<h5 id="iloc基于位置"><code>.iloc[]</code>，基于位置</h5>
<p>无视索引，只按照位置定位。</p>
<pre><code class="language-python">s.iloc[1] # scalar, 返回一个值
2
s.iloc[0:2] # 范围，左闭右开，返回Series切片
a    1
b    2
dtype: int64
s.iloc[[0,2]] #列表，返回Series切片
a    1
c    3
dtype: int64
mask = [False,True,False]  #mask，类似于列表，只是长度必须和Series相同，返回Series切片
s.iloc[mask]
b    2
dtype: int64
</code></pre>
<h4 id="改">改</h4>
<h5 id="改值">改值</h5>
<p>直接在查的基础上赋值，就可以修改<br>
注意：如果要修改，使用<code>.loc</code>可以确保修改成功，其他方式可能会在临时创建的<code>view</code>上修改。</p>
<pre><code class="language-python">s1 = s.copy()  
s1.loc['a'] = 10   #
s1
a    10
b     2
c     3
dtype: int64
s1.loc['a':'c'] = [10,4,5]
s1
a    10
b     4
c     5
dtype: int32
</code></pre>
<p>函数修改：<code>Series.replace(to_replace=None, value=None, inplace=False)</code></p>
<ul>
<li><code>to_replace</code>：要修改的值，可以为列表；</li>
<li><code>value</code>：改为的值，可以为列表，与<code>to_repalce</code>要匹配；</li>
<li><code>inplace</code>：是否在原地修改；</li>
</ul>
<pre><code class="language-python">s1.replace(to_replace = 10, value = 100, inplace=False)
a    100
b      4
c      5
dtype: int32
</code></pre>
<h5 id="改索引">改索引</h5>
<p>直接在<code>index</code>上改，<code>index</code>类似于<code>tuple</code>，只能引用到别处，不能切片修改</p>
<pre><code class="language-python">s1 = s.copy()
s1.index = ['a','e','f']
s1
a    1
e    2
f    3
dtype: int64
</code></pre>
<p>函数修改：<code>Series.rename(index=None, level = None, inplace = False)</code></p>
<ul>
<li><code>index</code>：<code>list or dict</code>，<code>list</code>类型时必须和已有索引长度相同，<code>dict</code>类型可以部分修改；</li>
<li><code>level</code>：多重索引时，可以指定修改哪一重，从<code>0</code>开始递增；</li>
<li><code>inplace</code>：是否原地修改。</li>
</ul>
<pre><code class="language-python">s1.rename(index = {'e':'b'}, inplace = False)
a    1
b    2
f    3
dtype: int64
</code></pre>
<h4 id="增">增</h4>
<h5 id="直接增一行">直接增一行</h5>
<pre><code class="language-python">s1 = s.copy()
s1.loc['d'] = 4 
s1
a    1
b    2
c    3
d    4
dtype: int64
</code></pre>
<h5 id="函数增多行">函数增多行</h5>
<p><code>Series.append(to_append, ignore_index=False, verify_integrity=False)</code></p>
<ul>
<li><code>to_append</code>: 另一个<code>series</code>或多个<code>Series</code>构成的列表；</li>
<li><code>ignore_index</code>：<code>False</code>-保留原有索引，<code>True</code>-清除所有索引，生成默认数值索引；</li>
<li><code>verify_integrity</code>：<code>True</code>的情况下，如果<code>to_append</code>索引与当前索引有重复，则报错。</li>
</ul>
<pre><code class="language-python">s1 = pd.Series([22,33], index = ['a', 'g'])
s.append(s1, ignore_index=False)
a     1
b     2
c     3
a    22
g    33
dtype: int64
</code></pre>
<h4 id="删">删</h4>
<h5 id="直接删一行">直接删一行</h5>
<pre><code class="language-python">#不建议使用
s1 = s.copy()
del s1['c']
s1
a    1
b    2
dtype: int64
</code></pre>
<h5 id="函数删多行">函数删多行</h5>
<p><code>Series.drop(labels, level=None, inplace=False)</code></p>
<ul>
<li><code>labels</code>：索引，单索引或索引的列表；</li>
<li><code>level</code>：多重索引需要设置；</li>
<li><code>inplace</code>：是否本地修改。</li>
</ul>
<pre><code class="language-python">s1 = s.copy()
s1.drop(['a','c'])
b    2
dtype: int64
</code></pre>
<h3 id="dataframe-3"><code>DataFrame</code></h3>
<pre><code class="language-python">data = [[1,2,3],
        [4,5,6]]
index = ['a','b']
columns = ['A','B','C']
df = pd.DataFrame(data=data, index=index, columns = columns)
df
    A	B	C
a	1	2	3
b	4	5	6
</code></pre>
<h4 id="查-2">查</h4>
<h5 id="快捷查看-2"><code>[]</code>，快捷查看</h5>
<p><code>[]</code> 属于快捷查看方式，只包含下面四种，两种列操作、两种行操作。</p>
<pre><code class="language-python">df['A'] # 列操作，单列索引，返回Series
a    1
b    4
Name: A, dtype: int64
df[['A','C']] # 列操作，列索引列表，返回DataFrame  
    A	C
a	1	3
b	4	6
# df[0]  # 报错，0不是列名
df[0:1]  # 行操作，位置范围，返回DataFrame
    A	B	C
a	1	2	3
# df[[0,1]] #报错，不能这样使用
mask = [False,True] 
df[mask] # 行操作，mask，必须和行长度一致，返回DataFrame
    A	B	C
b	4	5	6
</code></pre>
<h5 id="loc基于索引-2"><code>.loc[]</code>，基于索引</h5>
<p><code>.loc[]</code>在<code>DataFrame</code>中与<code>[]</code>不一致。<br>
<code>DataFrame</code> 有两维，每一维都和 <code>Series</code> 的 <code>.loc[]</code> 用法相同；<br>
<code>Series</code>有四种方式，所以<code>DataFrame</code>有16种方式;<br>
可以缺省后面维度，默认补全为 <code>':'</code> 。<br>
下面都以第一维度为例，第二维可以类比。</p>
<pre><code class="language-python">df.loc['b','B'] # 返回单一值，因为两维都是单索引
5
df.loc['a':'b', 'B'] #返回Series，如果只有一维是单索引
a    2
b    5
Name: B, dtype: int64
df.loc[['a','b'],'B'] #返回Series，如果只有一维是单索引
a    2
b    5
Name: B, dtype: int64
mask1 = [False, True, False] 
df.loc[mask1,'B']
b    5
Name: B, dtype: int64
</code></pre>
<h5 id="iloc基于位置-2"><code>.iloc[]</code>，基于位置</h5>
<p>无视索引，只按照位置定位。</p>
<p><code>DataFrame</code> 有两维，每一维都和 <code>Series</code> 的 <code>.iloc[]</code> 用法相同；<br>
<code>Series</code>有四种方式，所以<code>DataFrame</code>有16种方式；<br>
可以缺省后面维度，默认补全为 <code>':'</code> 。<br>
下面都以第一维度为例，第二维可以类比。</p>
<pre><code class="language-python">df.iloc[1,1] # 返回单一值，因为两维都是scalar
5
df.iloc[0:2,0]  # 返回Series，如果只有一维是scalar
a    1
b    4
Name: A, dtype: int64
df.iloc[[0,1],[0,2]] # 返回DataFrame
    A	C
a	1	3
b	4	6
mask1 = [False, True, False]  # 返回DataFrame
mask2 =[True,False]
df.iloc[mask1,mask2]
    A
b	4
</code></pre>
<h4 id="改-2">改</h4>
<h5 id="改值-2">改值</h5>
<p>在查的基础上赋值进行修改，<code>.loc[]</code>方法确保在原地修改。</p>
<pre><code class="language-python">#修改单值
df1 = df.copy()
df1.loc['a','A'] = 10
df1
    A	B	C
a	10	2	3
b	4	5	6
#修改单列
df1.loc[:, 'A'] = [100,200]  
df1
    A	B	C
a	100	2	3
b	200	5	6
#修改多列
df1.loc[:, ['A','B']] = [[1,2],[3,4]]  
df1
    A	B	C
a	1	2	3
b	3	4	6
#修改行，见下面的增减操作
</code></pre>
<p>函数批量任意修改：<br>
<code>DataFrame.replace(to_replace=None, value=None, inplace=False)</code></p>
<ul>
<li><code>to_replace</code>：要修改的值，可以为列表;</li>
<li><code>value</code>：改为的值，可以为列表，与<code>to_repalce</code>要匹配；</li>
<li><code>inplace</code>：是否在原地修改；</li>
</ul>
<pre><code class="language-python">df1.replace(to_replace = 10, value = 100, inplace=False)
A	B	C
a	1	2	3
b	3	4	6
</code></pre>
<h5 id="改索引-2">改索引</h5>
<p>直接在索引上改，索引类似于<code>tuple</code>，必须全改，不能切片修改</p>
<pre><code class="language-python">df1 = df.copy()
df1.index = ['e','f']
df1.columns = ['E','F','G']
df1
    E	F	G
e	1	2	3
f	4	5	6
</code></pre>
<p>函数修改：<br>
<code>DataFrame.rename(index=None, columns = None, level = None, inplace = False)</code></p>
<ul>
<li><code>index</code>：<code>list or dict</code>，<code>list</code>类型时必须长度相同，<code>dict</code>类型时可以部分修改；</li>
<li><code>columns</code>：<code>list or dict</code>，<code>list</code>时必须长度相同，<code>dict</code>时可以部分修改；</li>
<li><code>level</code>：多重索引时，可以指定修改哪一重，目前还用不着；</li>
<li><code>inplace</code>：是否原地修改。</li>
</ul>
<pre><code class="language-python">df1.rename( index = {'e':'b'},columns = {'E':'A'}, inplace = False)
    A	F	G
b	1	2	3
f	4	5	6
</code></pre>
<h4 id="增-2">增</h4>
<h5 id="直接增一行-2">直接增一行</h5>
<pre><code class="language-python">df1 = df.copy()
df1.loc['c'] = [7,8,9]
df1
    A	B	C
a	1	2	3
b	4	5	6
c	7	8	9
</code></pre>
<h5 id="函数增多行-2">函数增多行</h5>
<p><code>pd.concat(objs, axis=0)</code><br>
确保 列索引 相同，行增加。 （其实这个函数并不要求列索引相同，它可以选择出相同的列。而我写这个教程遵循了python的宣言—明确：做好一件事有一种最好的方法，精确控制每一步，可以少犯错。）</p>
<ul>
<li><code>objs</code>: <code>list of DataFrame</code>；</li>
<li><code>axis</code>: 取<code>0</code>，行增加操作。</li>
</ul>
<pre><code class="language-python">df1 = pd.DataFrame([[22,33,44],[55,66,77]], index = ['c','d'],columns = ['A','B','C'])
pd.concat([df,df1], axis = 0 )
    A	B	C
a	1	2	3
b	4	5	6
c	22	33	44
d	55	66	77
</code></pre>
<h5 id="直接增一列">直接增一列</h5>
<pre><code class="language-python">df1 = df.copy()
df1['H'] = [7,8]
df1
    A	B	C	H
a	1	2	3	7
b	4	5	6	8
</code></pre>
<h5 id="函数增多列">函数增多列</h5>
<p><code>pd.concat(objs, axis=1)</code><br>
确保行索引相同，列增加</p>
<ul>
<li><code>objs</code>: <code>list of DataFrame</code>；</li>
<li><code>axis</code>: 取<code>1</code>，列增加操作。</li>
</ul>
<pre><code class="language-python">df1 = pd.DataFrame([[22,33],[44,55]], index = ['a','b'],columns = ['D','E'])
pd.concat([df,df1], axis =1)
    A	B	C	D	E
a	1	2	3	22	33
b	4	5	6	44	55
</code></pre>
<h4 id="删-2">删</h4>
<h5 id="函数删多行-2">函数删多行</h5>
<p><code>DataFrame.drop(labels, axis = 0, level=None, inplace=False)</code></p>
<ul>
<li><code>labels</code>：索引，单索引或索引的列表；</li>
<li><code>axis</code>：<code>0</code>，删行；</li>
<li><code>level</code>：多重索引需要指定；</li>
<li><code>inplace</code>：是否本地修改。</li>
</ul>
<pre><code class="language-python">df1 = df.copy()
df1.drop(['a'],axis =0 )
    A	B	C
b	4	5	6
</code></pre>
<h5 id="直接删一列">直接删一列</h5>
<pre><code class="language-python">#不建议使用
df1 = df.copy()
del df1['A']
df1
B	C
a	2	3
b	5	6
</code></pre>
<h5 id="函数删多列">函数删多列</h5>
<p><code>DataFrame.drop(labels, axis = 1, level=None, inplace=False)</code></p>
<ul>
<li><code>labels</code>：索引，单索引或索引的列表；</li>
<li><code>axis</code>：1，删列；</li>
<li><code>level</code>：多重索引需要指定；</li>
<li><code>inplace</code>：是否本地修改。</li>
</ul>
<pre><code class="language-python">df1 = df.copy()
df1.drop(['A','C'],axis =1 )
    B
a	2
b	5
</code></pre>
<h2 id="merge详解"><code>merge</code>详解</h2>
<p>函数说明<br>
<code>pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort = False)</code><br>
<code>concat</code>函数本质上是在所有索引上同时进行对齐合并，而如果想在任意列上对齐合并，则需要<code>merge</code>函数，其在<code>sql</code>应用很多。</p>
<ul>
<li><code>left,right</code>： 两个要对齐合并的<code>DataFrame</code>；</li>
<li><code>how</code>： 先做笛卡尔积操作，然后按照要求，保留需要的，缺失的数据填充<code>NaN</code>；
<ul>
<li><code>left</code>: 以左<code>DataFrame</code>为基准，即左侧<code>DataFrame</code>的数据全部保留（不代表完全一致、可能会存在复制），保持原序;</li>
<li><code>right</code>: 以右<code>DataFrame</code>为基准，保持原序;</li>
<li><code>inner</code>: 交，保留左右<code>DataFrame</code>在<code>on</code>上完全一致的行，保持左<code>DataFrame</code>顺序;</li>
<li><code>outer</code>: 并，按照字典顺序重新排序;</li>
</ul>
</li>
<li><code>on</code>：对应列名或者行索引的名字，如果要在<code>DataFrame</code>相同的列索引做对齐，用这个参数；</li>
<li><code>left_on</code>, <code>right_on</code>, <code>left_index</code>, <code>right_index</code>：
<ul>
<li><code>on</code>对应列名或者行索引的名字（所以行索引一般要跟列一样看待，有自己的名字），用这俩参数；<code>DataFrame</code>中用作连接键的列名;这个参数中左右列名不相同，但代表的含义相同时非常有用。</li>
<li><code>index</code>对应要使用的<code>index</code>,不建议使用，会搞晕。使用<code>DataFrame</code>中的行索引做为连接键，用到这个参数时，就有点类似于<code>JOIN</code>函数了</li>
</ul>
</li>
<li><code>sort</code>: <code>True</code> or <code>False</code>，是否按字典序重新排序。</li>
</ul>
<pre><code class="language-python">df1 = pd.DataFrame([[1,2],[3,4]], index = ['a','b'],columns = ['A','B'])
df2 = pd.DataFrame([[1,3],[4,8]], index = ['b','d'],columns = ['B','C'])
df1
    A	B
a	1	2
b	3	4
df2
    B	C
b	1	3
d	4	8
</code></pre>
<p>如果单纯的按照<code>index</code>对齐，不如用<code>concat</code>方法。</p>
<pre><code class="language-python">pd.merge(left = df1, right = df2, how = 'inner' ,left_index = True, right_index = True)
    A	B_x	B_y	C
b	3	4	1	3
#小区别是concat对重复列没有重命名，但是重名的情况不多，而且重名了说明之前设计就不大合理。
pd.concat([df1,df2], join = 'inner',axis =1)
    A	B	B	C
b	3	4	1	3
</code></pre>
<h3 id="on-用法"><code>on</code> 用法</h3>
<p>设置 <code>how = 'inner'</code></p>
<pre><code class="language-python">#对于'B'列：df1的'b'行、df2的'd'行，是相同的，其他都不同。 
pd.merge(left = df1, right = df2, how = 'inner' , on =['B'])
    A	B	C
0	3	4	8
# df1的'A'列'b'行，df2的'C'列'd'行是相同的，其他都不同。
# 其他列如果同名会进行重命名。
pd.merge(left = df1, right = df2, how = 'inner',left_on = ['A'] ,right_on = ['C'])
    A	B_x	B_y	C
0	3	4	1	3
</code></pre>
<h3 id="how-用法"><code>how</code> 用法</h3>
<pre><code class="language-python">#保持左侧DataFrame不变，用右侧来跟它对齐，对不上的填NaN。
pd.merge(left = df1, right = df2, how = 'left', on = ['B'] )
    A	B	C
0	1	2	NaN
1	3	4	8.0
# 保持右侧DataFrame不变，用右侧来跟它对齐，对不上的填NaN。
pd.merge(left = df1, right = df2, how = 'right', on = ['B'] )
A	B	C
0	3.0	4	8
1	NaN	1	3
</code></pre>
<p>对齐的列存在重复值<br>
重复的也没关系，操作逻辑是一致的，完全可以假想不存在重复。</p>
<pre><code class="language-python">df1.loc['a','B'] =4  #改成重复
df1
    A	B
a	1	4
b	3	4
### 保持右侧的列都在，如果左侧对齐的列存在重复值，那么对齐上后也存在重复。
pd.merge(left = df1, right = df2, how = 'right', on = ['B'] )
    A	B	C
0	1.0	4	8
1	3.0	4	8
2	NaN	1	3
</code></pre>
<h2 id="index对象的创建查-改-增-删和使用"><code>Index</code>对象的创建,查、改、增、删和使用</h2>
<ul>
<li>索引类似于元组，其本身是不能赋值修改的；</li>
<li>其在数据进行整体运算时，辅助自动对齐，这是pandas不同于其他数据处理库的一大特征；</li>
<li>多层索引可以帮助改变表的形态，如透视表等。</li>
</ul>
<h3 id="单层索引">单层索引</h3>
<h4 id="创建-3">创建</h4>
<p><code>pd.Index(data, dtype = Object, name = None)</code></p>
<ul>
<li><code>name</code>：一维列表</li>
<li><code>dtype</code>：索引元素的类型，默认为<code>object</code>型</li>
<li><code>name</code>：索引的名字，类似于列的名字</li>
</ul>
<pre><code class="language-python">data = ['a','b','c']
index = pd.Index(data, name = 'name1')
index
Index(['a', 'b', 'c'], dtype='object', name='name1')
</code></pre>
<p>从返回值可以看到，<code>index</code>由三部分组成，可以分别查看。</p>
<pre><code class="language-python">index.name
'name1'
index.values
array(['a', 'b', 'c'], dtype=object)
index.dtype
dtype('O')
</code></pre>
<h4 id="查-3">查</h4>
<p>查询方式和一维<code>ndarray</code>或<code>Series</code>的<code>.iloc[]</code>完全一样。</p>
<pre><code class="language-python">index[0] # scalar，返回值
'a'
index[0:2] # 范围，返回index
Index(['a', 'b'], dtype='object', name='name1')
index[[0,2]] # 列表，返回index
Index(['a', 'c'], dtype='object', name='name1')
mask = [True,False,True]  # mask,返回index
index[mask]
Index(['a', 'c'], dtype='object', name='name1')
</code></pre>
<h4 id="改索引名">改索引名</h4>
<p>虽然索引的值是不能修改的，但是名字确是可以修改的。</p>
<h5 id="直接改">直接改</h5>
<pre><code class="language-python">index.name = 'new_name' 
index
Index(['a', 'b', 'c'], dtype='object', name='new_name')
</code></pre>
<h5 id="函数改">函数改</h5>
<p><code>Index.set_names(names, inplace=False)</code></p>
<ul>
<li><code>names</code>：要设置的名字，可以为名字的列表；</li>
<li><code>inplace</code>：是否原地修改。</li>
</ul>
<pre><code class="language-python">index.set_names('new_name')
Index(['a', 'b', 'c'], dtype='object', name='new_name')
</code></pre>
<h4 id="增-3">增</h4>
<h5 id="按位置添加一行">按位置添加一行</h5>
<p><code>Index.insert(loc, value)</code></p>
<ul>
<li><code>loc</code>：位置编号</li>
<li><code>value</code>：值</li>
</ul>
<pre><code class="language-python">index
Index(['a', 'b', 'c'], dtype='object', name='new_name')
index.insert(1,'d')
Index(['a', 'd', 'b', 'c'], dtype='object', name='new_name')
</code></pre>
<h5 id="尾部添加多行">尾部添加多行</h5>
<p><code>Index.append(other)</code></p>
<ul>
<li><code>other</code>：其他索引对象</li>
</ul>
<pre><code class="language-python">index1 = index.copy()
index1
Index(['a', 'b', 'c'], dtype='object', name='new_name')
index1.append( index)
Index(['a', 'b', 'c', 'a', 'b', 'c'], dtype='object', name='new_name')
</code></pre>
<h4 id="并">并</h4>
<p><code>Index.union(other)</code></p>
<pre><code class="language-python">index2 = pd.Index(['b','c','d'])
index2
Index(['b', 'c', 'd'], dtype='object')
index1.union(index2)
Index(['a', 'b', 'c', 'd'], dtype='object')
</code></pre>
<h4 id="删-3">删</h4>
<h5 id="按位置删除一行">按位置删除一行</h5>
<p><code>Index.delete(loc)</code></p>
<ul>
<li><code>loc</code>：位置编号</li>
</ul>
<pre><code class="language-python">index1.delete(1)
Index(['a', 'c'], dtype='object', name='new_name')
</code></pre>
<h4 id="交">交</h4>
<p><code>Index.intersection(other)</code></p>
<pre><code class="language-python">index1.intersection(index2) 
Index(['b', 'c'], dtype='object')
</code></pre>
<h3 id="多层索引">多层索引</h3>
<h4 id="创建-4">创建</h4>
<p><code>pd.MultiIndex.from_tuples(labels, names = None)</code></p>
<ul>
<li><code>labels</code>：元组或列表的列表；</li>
<li><code>names</code>：名字的列表。</li>
</ul>
<pre><code class="language-python"># data = [['a','one'],['a','two'],['b','one']]
data = [('a','one'),('a','two'),('b','one')]
index = pd.MultiIndex.from_tuples( data, names = ['name1','name2'])
index
MultiIndex(levels=[['a', 'b'], ['one', 'two']],
           labels=[[0, 0, 1], [0, 1, 0]],
           names=['name1', 'name2'])
s = pd.Series([1,2,3], index = index)
s
name1  name2
a      one      1
       two      2
b      one      3
dtype: int64
</code></pre>
<h4 id="查-4">查</h4>
<p>查询方法和单层索引完全一致。</p>
<pre><code class="language-python">index[0]  # scalar，返回值
('a', 'one')
index[0:2]  # 范围，返回MultiIndex
MultiIndex(levels=[['a', 'b'], ['one', 'two']],
           labels=[[0, 0], [0, 1]],
           names=['name1', 'name2'])
index[[0,2]] # 列表，返回MultiIndex
MultiIndex(levels=[['a', 'b'], ['one', 'two']],
           labels=[[0, 1], [0, 0]],
           names=['name1', 'name2'])
mask = [True,False, True] # mask，返回MultiIndex
index[mask]
MultiIndex(levels=[['a', 'b'], ['one', 'two']],
           labels=[[0, 1], [0, 0]],
           names=['name1', 'name2'])
</code></pre>
<p>获取某一层索引：<br>
<code>MultiIndex.get_level_values(level)</code></p>
<ul>
<li><code>level</code>：<code>int</code>，选中的那一层</li>
</ul>
<pre><code class="language-python">index.get_level_values(0)
Index(['a', 'a', 'b'], dtype='object', name='name1')
index.get_level_values(1)
Index(['one', 'two', 'one'], dtype='object', name='name2')
</code></pre>
<h4 id="改-3">改</h4>
<h5 id="改索引名函数改">改索引名（函数改）</h5>
<p><code>MultiIndex.set_names(names, level=None, inplace=False)</code></p>
<ul>
<li><code>names</code>：要设置的名字，可以为名字的列表；</li>
<li><code>level</code>：多层索引需要设置修改的索引层次，可以为列表，要与<code>names</code>匹配；</li>
<li><code>inplace</code>：是否原地修改。</li>
</ul>
<pre><code class="language-python">index.set_names('new_name_1',level=0)
MultiIndex(levels=[['a', 'b'], ['one', 'two']],
           labels=[[0, 0, 1], [0, 1, 0]],
           names=['new_name_1', 'name2'])
</code></pre>
<h5 id="改索引层次顺序">改索引层次顺序</h5>
<p><code>MultiIndex.swaplevel(i=-2, j=-1)</code><br>
改变`level i 和level j的次序</p>
<pre><code class="language-python">index.swaplevel()
MultiIndex(levels=[['one', 'two'], ['a', 'b']],
           labels=[[0, 1, 0], [0, 0, 1]],
           names=['name2', 'name1'])
</code></pre>
<p><code>Series.swaplevel(i=-2, j=-1)</code><br>
<code>DataFrame.swaplevel(i=-2, j=-1, axis = 1)</code></p>
<ul>
<li><code>axis</code>：0-行索引，1-列索引。 这两个函数更实用一些。</li>
</ul>
<pre><code class="language-python">s.swaplevel()
name2  name1
one    a        1
two    a        2
one    b        3
dtype: int64
columns = index.copy()
columns.set_names( names = ['name3','name4'], level = [0,1], inplace = True) #列索引取和行索引相同，只是改了名字
df = pd.DataFrame([[1,2,3],[4,5,6],[7,8,9]], index= index, columns = columns)
df
</code></pre>
<figure data-type="image" tabindex="162"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000038.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df.swaplevel( axis =1)  # 交换列索引顺序
</code></pre>
<figure data-type="image" tabindex="163"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000104.png" alt="" loading="lazy"></figure>
<h3 id="多层索引使用方法">多层索引使用方法</h3>
<p>对<code>values</code>进行查看时，多层索引可以分开使用。</p>
<pre><code class="language-python">df1 = df.copy()
df1
</code></pre>
<p><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000038.png" alt="" loading="lazy"><br>
索引为空不代表缺失，缺省写法，意思是之前的索引一致。</p>
<h4 id="对于外层索引">对于外层索引</h4>
<p>记住：无论是<code>Series</code>还是<code>DataFrame</code>，外层索引都是可以直接使用，也就是说可以认为只有这一层索引</p>
<h5 id=""><code>[]</code></h5>
<pre><code class="language-python">df1['b']  # 列外层
</code></pre>
<figure data-type="image" tabindex="164"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000643.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1[['a','b']] # 列外层
</code></pre>
<figure data-type="image" tabindex="165"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000712.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1[0:2]  # 行外层
</code></pre>
<figure data-type="image" tabindex="166"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000739.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">mask =[True,False,True]  # 行外层
df1[mask]
</code></pre>
<figure data-type="image" tabindex="167"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000809.png" alt="" loading="lazy"></figure>
<h5 id="loc"><code>.loc[]</code></h5>
<pre><code class="language-python">df1.loc['a','b']  # 单行索引'a' 
</code></pre>
<figure data-type="image" tabindex="168"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412000936.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1.loc['a':'b','b']   #范围
</code></pre>
<figure data-type="image" tabindex="169"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001007.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1.loc[['a','b'],'b'] #列表
</code></pre>
<figure data-type="image" tabindex="170"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001034.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">mask = [True, False, True] # mask
df1.loc[mask,'b']
</code></pre>
<figure data-type="image" tabindex="171"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001104.png" alt="" loading="lazy"></figure>
<h5 id="iloc"><code>.iloc[]</code></h5>
<pre><code class="language-python">df1.iloc[0,0:2] 
name3  name4
a      one      1
       two      2
Name: (a, one), dtype: int64
df1.iloc[0:2,0:2] 
</code></pre>
<figure data-type="image" tabindex="172"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001236.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1.iloc[[0,1],0:2] 
</code></pre>
<figure data-type="image" tabindex="173"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001306.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">mask = [True, False, True]
df1.iloc[mask,0:2]
</code></pre>
<figure data-type="image" tabindex="174"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001331.png" alt="" loading="lazy"></figure>
<h4 id="对于内层索引">对于内层索引</h4>
<p>内层索引不可直接使用，必须先外层、再内层，直接使用会报错；<br>
内层只能使用单索引形式，其他形式报错。</p>
<h5 id="-2"><code>[ , ]</code></h5>
<pre><code class="language-python">df1
</code></pre>
<figure data-type="image" tabindex="175"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412001450.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1['a','one']  #取一列，先外层单列索引，再内层单列索引，其他形式都报错
name1  name2
a      one      1
       two      4
b      one      7
Name: (a, one), dtype: int64
</code></pre>
<h5 id="loc-2"><code>.loc[ , ]</code></h5>
<pre><code class="language-python">df1.loc['a','one'] # 取一行，先外层单行索引，再内层单列索引，其他形式都报错
name3  name4
a      one      1
       two      2
b      one      3
Name: (a, one), dtype: int64
</code></pre>
<h4 id="xs直接选取法"><code>xs</code>直接选取法</h4>
<p>适合在单层<code>level</code>选取，不能行列同时操作。<br>
<code>Series.xs(key, level=None, drop_level=True)</code><br>
<code>DataFrame.xs(key, axis=0, level=None, drop_level=True)</code></p>
<ul>
<li><code>key</code>: 要选取的索引值或其列表；</li>
<li><code>axis</code>：0-行索引，1-列索引；</li>
<li><code>level</code>：索引层次；</li>
<li><code>drop_level</code>：<code>True</code> or <code>False</code>，是否显示用于选取的level索引，默认不显示。</li>
</ul>
<pre><code class="language-python">df1 = df.copy()
df1
</code></pre>
<figure data-type="image" tabindex="176"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412002106.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1.xs( 'one', axis = 0, level = 1 )  # 行索引的level 1, 有两行
</code></pre>
<figure data-type="image" tabindex="177"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412002132.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">df1.xs( 'two', axis = 1, level = 1 ) # 列索引的level 1，有一列
</code></pre>
<figure data-type="image" tabindex="178"><img src="https://picgp.oss-cn-beijing.aliyuncs.com/img/20200412002201.png" alt="" loading="lazy"></figure>
<h2 id="普通列和行index的相互转化">普通列和行index的相互转化</h2>
<pre><code class="language-python">data = [[1,2,3],[4,5,6]]
index = ['a','b']
columns = ['A','B','C']
df = pd.DataFrame( data = data, index = index, columns = columns)
df
	A	B	C
a	1	2	3
b	4	5	6
</code></pre>
<h3 id="普通列-转化为-行索引">普通列 转化为 行索引</h3>
<p><code>DataFrame.set_index(keys, drop=True, append=False, inplace=False)</code><br>
-<code>keys</code>：用于转化的列名称，列名或列名的列表，如果是列表则转化为多重索引；</p>
<ul>
<li><code>drop</code>：<code>True</code> or <code>False</code>，是否保留原列；</li>
<li><code>append</code>：<code>True</code> or <code>False</code>，是否保留当前索引；</li>
<li><code>inplace</code>：<code>True</code> or <code>False</code>，是否原地修改。</li>
</ul>
<h4 id="dataframe中的列"><code>DataFrame</code>中的列</h4>
<p>注意：下面的这种用法只能处理单层列索引情况。</p>
<pre><code class="language-python">df.set_index('A', drop = True, append = False) #单列转化为行索引，列名作为索引的名字
    B	C
A		
1	2	3
4	5	6
df.set_index(['A','B'], drop = True, append = False) # 列名的列表
        C
A	B	
1	2	3
4	5	6
df.set_index(['A','C'], drop = False, append = False) # drop = False, 保留原列
        A	B	C
A	C			
1	3	1	2	3
4	6	4	5	6
df.set_index(['A','C'], drop = False, append = True) # append = True, 保留原索引
            A	B	C
    A	C			
a	1	3	1	2	3
b	4	6	4	5	6
</code></pre>
<h4 id="任意列">任意列</h4>
<p>普通列不是必须为<code>DataFrame</code>中的列，任何行数匹配的列表或列表的元组都可以；<br>
此方法可以处理多层列索引情况，方法是先提取需要的列，构建成元组，再来替换索引。</p>
<pre><code class="language-python">li = ['c','d']
df.set_index(keys = [li], append = False)# 注意是[li]不是li，如果是单层，会当做列名处理
## append为False，实现了改索引功能
    A	B	C
c	1	2	3
d	4	5	6
#如果是多层索引情况，append为False，所有索性会被替换
df1 = df.set_index(keys = [li], append = True)
df1
        A	B	C
a	c	1	2	3
b	d	4	5	6
df1.set_index(keys = [['e','f']],append = False)
    A  	B	C
e	1	2	3
f	4	5	6
# 元祖的列表建立多层索引
list_tuple = [('e','f'),('g','h')]
df1.set_index(keys = [list_tuple],append = False)
        A	B	C
e	f	1	2	3
g	h	4	5	6
</code></pre>
<h3 id="行索引-转化为-普通列">行索引 转化为 普通列</h3>
<p><code>DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill='')</code></p>
<ul>
<li><code>level</code>：<code>int</code> 或者行索引的名字，可以为列表，默认包含所有行索引。</li>
<li><code>drop</code>：<code>True</code> or <code>False</code>，是否将行索引插入到列中，默认是插入；</li>
<li><code>inplace</code>：是否本地修改</li>
<li><code>col_level</code>：如果列索引也是多重的，那么新插入的列设置哪一重索引；</li>
<li><code>col_fill</code>：如果有多重索引，除了<code>col_level</code>已经设置的</li>
</ul>
<h4 id="单层-列索引-情况">单层 列索引 情况</h4>
<pre><code class="language-python">df1 = df.set_index(['A','C'], drop = True, append = True)
df1
            B
    A	C	
a	1	3	2
b	4	6	5
# df1.reset_index(level = 'A', drop = False)
df1.reset_index(level = 1, drop = False) #单 行索引
        A	B
    C		
a	3	1	2
b	6	4	5
df1.reset_index(level = [1,2], drop = False) # 行索引的列表
    A	C	B
a	1	3	2
b	4	6	5
In [13]:
#如果所有行索引都恢复为列，那么将生成默认数值索引，如果行索引没有名字，那么生成默认的名字
df1.reset_index(level = [0,1,2], drop = False)
level_0	A	C	B
0	a	1	3	2
1	b	4	6	5
df1.index.set_names(names = 'ab', level = 0, inplace = True)
df1
            B
ab	A	C	
a	1	3	2
b	4	6	5
#行索引如果有名字，那么将其设置为列名
df1.reset_index(level = [0,1,2], drop = False)
    ab	A	C	B
0	a	1	3	2
1	b	4	6	5
df1.reset_index(level = [1,2], drop = True) # drop = True, 直接丢掉选中的行索引，不插入
    B
ab	
a	2
b	5
</code></pre>
<h4 id="多层-列索引-情况">多层 列索引 情况</h4>
<pre><code class="language-python">df1 = df.copy()
df1.columns = pd.MultiIndex.from_tuples( [('one','A'),('one','B'),('two','C')])
df1
     one   two
    A	B	C
a	1	2	3
b	4	5	6
#多重索引下，如果行索引没有名字，那么变为列之后在列索引的外层生成了默认索引：index。
df1.reset_index(level = 0)
index	 one   two
        A	B	C
0	a	1	2	3
1	b	4	5	6
#多重索引下，如果行索引有名字，那么变为列之后在列索引的外层索引名作为列名。
df1.index.set_names(['ab'], inplace = True)
df1
     one   two
    A	B	C
ab			
a	1	2	3
b	4	5	6
df1.reset_index(level = 0)
    ab	 one   two
        A	B	C
0	a	1	2	3
1	b	4	5	6











</code></pre>

        </div>

        


        <div class="flex justify-between py-8">
          
            <div class="prev-post">
              <a href="https://bailingnan.github.io/post/leetcode-chang-yong-shu-ju-jie-gou-python-shi-xian/">
                <h3 class="post-title">
                  <i class="ri-arrow-left-line"></i>
                  LeetCode常用数据结构Python实现
                </h3>
              </a>
            </div>
          

          
            <div class="next-post">
              <a href="https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi/">
                <h3 class="post-title">
                  利用Python进行数据分析
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'f4bd8cbd743b58235644',
    clientSecret: 'df6eff6e7836378726d917c527c47e86f1c30f8b',
    repo: 'bailingnan.github.io',
    owner: 'bailingnan',
    admin: ['bailingnan'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://bailingnan.github.io//media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
