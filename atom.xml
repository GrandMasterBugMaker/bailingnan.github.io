<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bailingnan.github.io/</id>
    <title>白凌南</title>
    <updated>2020-03-27T18:51:21.523Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bailingnan.github.io/"/>
    <link rel="self" href="https://bailingnan.github.io/atom.xml"/>
    <subtitle>DM/DL/RecSys/Python/Java/INTJ</subtitle>
    <logo>https://bailingnan.github.io/images/avatar.png</logo>
    <icon>https://bailingnan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 白凌南</rights>
    <entry>
        <title type="html"><![CDATA[Python代码段]]></title>
        <id>https://bailingnan.github.io/post/python-dai-ma-duan/</id>
        <link href="https://bailingnan.github.io/post/python-dai-ma-duan/">
        </link>
        <updated>2020-03-27T18:19:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="列表">列表</h2>
<ul>
<li>重复元素判定<br>
以下方法可以检查给定列表是不是存在重复元素，它会使用 <code>set()</code> 函数来移除所有重复元素。</li>
</ul>
<pre><code class="language-Python">def all_unique(lst):
    return len(lst) == len(set(lst))
x = [1,1,2,2,3,2,3,4,5,6]
y = [1,2,3,4,5]
all_unique(x) # False
all_unique(y) # True
</code></pre>
<ul>
<li>取两个列表交集：</li>
</ul>
<pre><code class="language-Python">def common_elements(list1, list2):
    common = set(list1).intersection(set(list2))
    return list(common)
</code></pre>
<ul>
<li>压缩<br>
这个方法可以将布尔型的值去掉，例如<code>(False，None，0，“”)</code>，它使用 <code>filter()</code> 函数。</li>
</ul>
<pre><code class="language-Python">def compact(lst):
    return list(filter(bool, lst))
compact([0, 1, False, 2, '', 3, 'a', 's', 34])
# [ 1, 2, 3, 'a', 's', 34 ]
</code></pre>
<ul>
<li>解包<br>
如下代码段可以将打包好的成对列表解开成两组不同的元组。</li>
</ul>
<pre><code class="language-Python">array = [['a', 'b'], ['c', 'd'], ['e', 'f']]
transposed = zip(*array)
print(transposed)
# [('a', 'c', 'e'), ('b', 'd', 'f')]
</code></pre>
<ul>
<li>逗号连接<br>
下面的代码可以将列表连接成单个字符串，且每一个元素间的分隔方式设置为了逗号。</li>
</ul>
<pre><code class="language-Python">hobbies = [&quot;basketball&quot;, &quot;football&quot;, &quot;swimming&quot;]
print(&quot;My hobbies are: &quot; + &quot;, &quot;.join(hobbies))
# My hobbies are: basketball, football, swimming
</code></pre>
<ul>
<li>展开列表<br>
该方法将通过递归的方式将列表的嵌套展开为单个列表。</li>
</ul>
<pre><code class="language-Python">def spread(arg):
    ret = []
    for i in arg:
        if isinstance(i, list):
            ret.extend(i)
        else:
            ret.append(i)
    return ret

def deep_flatten(lst):
    result = []
    result.extend(
        spread(list(map(lambda x: deep_flatten(x) if type(x) == list else x, lst))))
    return result
deep_flatten([1, [2], [[3], 4], 5]) # [1,2,3,4,5]
</code></pre>
<p>非递归：</p>
<pre><code class="language-Python">def spread(arg):
    ret = []
    for i in arg:
        if isinstance(i, list):
            ret.extend(i)
        else:
            ret.append(i)
    return ret
spread([1,2,3,[4,5,6],[7],8,9]) # [1,2,3,4,5,6,7,8,9]
</code></pre>
<p>可以写一个包含 <code>yield from</code> 语句的递归生成器来轻松解决这个问题。比如：</p>
<pre><code class="language-python">from collections import Iterable
def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]
# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x)
</code></pre>
<p>在上面代码中， <code>isinstance(x, Iterable)</code> 检查某个元素是否是可迭代的。 如果是的话， <code>yield from</code> 就会返回所有子例程的值。最终返回结果就是一个没有嵌套的简单序列了。<br>
额外的参数 <code>ignore_types</code> 和检测语句 <code>isinstance(x, ignore_types)</code> 用来将字符串和字节排除在可迭代对象外，防止将它们再展开成单个的字符。 这样的话字符串数组就能最终返回我们所期望的结果了。比如：</p>
<pre><code class="language-python">items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
for x in flatten(items):
    print(x)
Dave
Paula
Thomas
Lewis
</code></pre>
<p>语句 <code>yield from</code> 在你想在生成器中调用其他生成器作为子例程的时候非常有用。 如果你不使用它的话，那么就必须写额外的 <code>for</code> 循环了。比如：</p>
<pre><code class="language-python">def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            for i in flatten(x):
                yield i
        else:
            yield x
</code></pre>
<p>尽管只改了一点点，但是 <code>yield from</code> 语句看上去感觉更好，并且也使得代码更简洁清爽。<br>
之前提到的对于字符串和字节的额外检查是为了防止将它们再展开成单个字符。 如果还有其他你不想展开的类型，修改参数 <code>ignore_types</code> 即可。</p>
<ul>
<li>列表的差<br>
该方法将返回第一个列表的元素，其不在第二个列表内。如果同时要反馈第二个列表独有的元素，还需要加一句 <code>set_b.difference(set_a)</code>。</li>
</ul>
<pre><code class="language-Python">def difference(a, b):
    set_a = set(a)
    set_b = set(b)
    comparison = set_a.difference(set_b)
    return list(comparison)
difference([1,2,3], [1,2,4]) # [3]
</code></pre>
<ul>
<li>通过函数取差<br>
如下方法首先会应用一个给定的函数，然后再返回应用函数后结果有差别的列表元素。</li>
</ul>
<pre><code class="language-Python">def difference_by(a, b, fn):
    b = set(map(fn, b))
    return [item for item in a if fn(item) not in b]
from math import floor
difference_by([2.1, 1.2], [2.3, 3.4],floor) # [1.2]
difference_by([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], lambda v : v['x'])
# [ { x: 2 } ]
</code></pre>
<ul>
<li>Given a list of N numbers。<br>
给定一个含有<code>N</code>个数字的列表。<br>
使用单一的列表生成式来产生一个新的列表，该列表只包含满足以下条件的值：<br>
(a)偶数值<br>
(b)元素为原始列表中偶数切片。<br>
例如，如果<code>list[2]</code>包含的值是偶数。那么这个值应该被包含在新的列表当中。因为这个数字同时在原始列表的偶数序列（2为偶数）上。然而，如果<code>list[3]</code>包含一个偶数，<br>
那个数字不应该被包含在新的列表当中，因为它在原始列表的奇数序列上。<br>
对此问题的简单解决方法如下：</li>
</ul>
<pre><code class="language-Python">[x for x in list[::2] if x%2 == 0]
</code></pre>
<p>例如，给定列表如下：</p>
<pre><code class="language-Python">list = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]
</code></pre>
<p>列表生成式<code>[x for x in list[::2] if x%2 == 0]</code> 的结果是，<code>[10, 18, 78]</code><br>
这个表达式工作的步骤是，第一步取出偶数切片的数字，<br>
第二步剔除其中所有奇数。</p>
<ul>
<li>更长列表</li>
</ul>
<pre><code class="language-Python">def max_length(*lst):
    return max(*lst, key=lambda v: len(v))
r = max_length([1, 2, 3], [4, 5, 6, 7], [8])
print(f'更长的列表是{r}')  # [4, 5, 6, 7]
r = max_length([1, 2, 3], [4, 5, 6, 7], [8, 9])
print(f'更长的列表是{r}')  # [4, 5, 6, 7]
</code></pre>
<ul>
<li>求众数</li>
</ul>
<pre><code>def top1(lst):
    return max(lst, default='列表为空', key=lambda v: lst.count(v))
lst = [1, 3, 3, 2, 1, 1, 2]
r = top1(lst)
print(f'{lst}中出现次数最多的元素为:{r}')  # [1, 3, 3, 2, 1, 1, 2]中出现次数最多的元素为:1
</code></pre>
<ul>
<li>列表之最</li>
</ul>
<pre><code class="language-Python">def max_lists(*lst):
    return max(max(*lst, key=lambda v: max(v)))
r = max_lists([1, 2, 3], [6, 7, 8], [4, 5])
print(r)  # 8
</code></pre>
<ul>
<li>按条件分组</li>
</ul>
<pre><code class="language-Python">def bif_by(lst, f):
    return [ [x for x in lst if f(x)],[x for x in lst if not f(x)]]
records = [25,89,31,34]
bif_by(records, lambda x: x&lt;80) # [[25, 31, 34], [89]]
</code></pre>
<ul>
<li>解压可迭代对象赋值给多个变量<br>
Python 的星号表达式可以用来解决这个问题。比如，你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是排除掉第一个和最后一个分数。如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有 24 个呢？这时候星号表达式就派上用场了：</li>
</ul>
<pre><code class="language-Python">def drop_first_last(grades):
    first, *middle, last = grades
    return avg(middle)
</code></pre>
<p>另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 你可以像下面这样分解这些记录：</p>
<pre><code class="language-Python">record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
name, email, *phone_numbers = record
name
'Dave'
email
'dave@example.com'
phone_numbers
['773-555-1212', '847-555-1212']
</code></pre>
<p>值得注意的是上面解压出的 <code>phone_numbers</code> 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。 所以，任何使用到 <code>phone_numbers</code> 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。<br>
星号表达式也能用在列表的开始部分。比如，你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。你可以这样做：</p>
<pre><code class="language-Python">*trailing_qtrs, current_qtr = sales_record
trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)
return avg_comparison(trailing_avg, current_qtr)
</code></pre>
<p>下面是在 <code>Python</code> 解释器中执行的结果：</p>
<pre><code class="language-Python">*trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
trailing
[10, 8, 7, 1, 9, 5, 10]
current
3
</code></pre>
<p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第1个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值。<br>
值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。 比如，下面是一个带有标签的元组序列：</p>
<pre><code class="language-Python">records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]

def do_foo(x, y):
    print('foo', x, y)

def do_bar(s):
    print('bar', s)

for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)
</code></pre>
<p>星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。<br>
代码示例：</p>
<pre><code class="language-Python">line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
uname, *fields, homedir, sh = line.split(':')
uname
'nobody'
homedir
'/var/empty'
sh
'/usr/bin/false'
</code></pre>
<p>有时候，你想解压一些元素后丢弃它们，你不能简单就使用 <code>*</code> ， 但是你可以使用一个普通的废弃名称，比如 <code>_</code> 或者 <code>ign(ignore)</code>。</p>
<pre><code class="language-Python">record = ('ACME', 50, 123.45, (12, 18, 2012))
name, *_, (*_, year) = record
name
'ACME'
year
2012
</code></pre>
<p>在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。比如，如果你有一个列表， 你可以很容易的将它分割成前后两部分：</p>
<pre><code class="language-Python">items = [1, 10, 7, 4, 5, 9]
head, *tail = items
head
1
tail
[10, 7, 4, 5, 9]
</code></pre>
<p>如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：</p>
<pre><code class="language-Python">def sum(items):
    head, *tail = items
    return head + sum(tail) if tail else head
sum(items)
36
</code></pre>
<p>然后，由于语言层面的限制，递归并不是 <code>Python</code> 擅长的。 因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了。</p>
<ul>
<li>删除序列相同元素并保持顺序<br>
如果序列上的值都是 <code>hashable</code> 类型，那么可以很简单的利用集合或者生成器来解决这个问题。比如：</li>
</ul>
<pre><code class="language-python">def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
</code></pre>
<p>下面是使用上述函数的例子：</p>
<pre><code class="language-python">a = [1, 5, 2, 1, 9, 1, 5, 10]
list(dedupe(a))
[1, 5, 2, 9, 10]
</code></pre>
<p>这个方法仅仅在序列中元素为 <code>hashable</code> 的时候才管用。 如果你想消除元素不可哈希（比如 <code>dict</code> 类型）的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样：</p>
<pre><code class="language-python">def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)
</code></pre>
<p>这里的<code>key</code>参数指定了一个函数，将序列元素转换成 <code>hashable</code> 类型。下面是它的用法示例：</p>
<pre><code class="language-python">a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
</code></pre>
<p>如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任。<br>
如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合。比如：</p>
<pre><code class="language-python">a
[1, 5, 2, 1, 9, 1, 5, 10]
set(a)
{1, 2, 10, 5, 9}
</code></pre>
<p>然而，这种方法不能维护元素的顺序，生成的结果中的元素位置被打乱。而上面的方法可以避免这种情况。<br>
在本节中我们使用了生成器函数让我们的函数更加通用，不仅仅是局限于列表处理。 比如，如果如果你想读取一个文件，消除重复行，你可以很容易像这样做：</p>
<pre><code class="language-python">with open(somefile,'r') as f:
for line in dedupe(f):
    ...
</code></pre>
<p>上述key函数参数模仿了 <code>sorted()</code> , <code>min()</code> 和 <code>max()</code> 等内置函数的相似功能。</p>
<ul>
<li>命名切片<br>
假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段：</li>
</ul>
<pre><code class="language-python">######    0123456789012345678901234567890123456789012345678901234567890'
record = '....................100 .......513.25 ..........'
cost = int(record[20:23]) * float(record[31:37])
</code></pre>
<p>与其那样写，为什么不想这样命名切片呢：</p>
<pre><code class="language-python">SHARES = slice(20, 23)
PRICE = slice(31, 37)
cost = int(record[SHARES]) * float(record[PRICE])
</code></pre>
<p>在这个版本中，你避免了使用大量难以理解的硬编码下标。这使得你的代码更加清晰可读。<br>
一般来讲，代码中如果出现大量的硬编码下标会使得代码的可读性和可维护性大大降低。 比如，如果你回过来看看一年前你写的代码，你会摸着脑袋想那时候自己到底想干嘛啊。 这是一个很简单的解决方案，它让你更加清晰的表达代码的目的。<br>
内置的 <code>slice()</code> 函数创建了一个切片对象。所有使用切片的地方都可以使用切片对象。比如：</p>
<pre><code class="language-python">items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2, 4)
items[2:4]
[2, 3]
items[a]
[2, 3]
items[a] = [10,11]
items
[0, 1, 10, 11, 4, 5, 6]
del items[a]
items
[0, 1, 4, 5, 6]
</code></pre>
<p>如果你有一个切片对象<code>a</code>，你可以分别调用它的 <code>a.start</code> , <code>a.stop</code> , <code>a.step</code> 属性来获取更多的信息。比如：</p>
<pre><code class="language-python">a = slice(5, 50, 2)
a.start
5
a.stop
50
a.step
2
</code></pre>
<p>另外，你还可以通过调用切片的 <code>indices(size)</code> 方法将它映射到一个已知大小的序列上。 这个方法返回一个三元组 <code>(start, stop, step)</code> ，所有的值都会被缩小，直到适合这个已知序列的边界为止。 这样，使用的时就不会出现 <code>IndexError</code> 异常。比如：</p>
<pre><code class="language-python">s = 'HelloWorld'
a.indices(len(s))
(5, 10, 2)
for i in range(*a.indices(len(s))):
    print(s[i])
W
r
d
</code></pre>
<ul>
<li>排序不支持原生比较的对象<br>
内置的 <code>sorted()</code> 函数有一个关键字参数 <code>key</code> ，可以传入一个 <code>callable</code> 对象给它， 这个 <code>callable</code> 对象对每个传入的对象返回一个值，这个值会被 <code>sorted</code> 用来排序这些对象。 比如，如果你在应用程序里面有一个 <code>User</code> 实例序列，并且你希望通过他们的 <code>user_id</code> 属性进行排序， 你可以提供一个以 <code>User</code> 实例作为输入并输出对应 <code>user_id</code> 值的 <code>callable</code> 对象。比如：</li>
</ul>
<pre><code class="language-python">class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)
def sort_notcompare():
    users = [User(23), User(3), User(99)]
    print(users)
    print(sorted(users, key=lambda u: u.user_id))
</code></pre>
<p>另外一种方式是使用 <code>operator.attrgetter()</code> 来代替 <code>lambda</code> 函数：</p>
<pre><code class="language-python">from operator import attrgetter
sorted(users, key=attrgetter('user_id'))
[User(3), User(23), User(99)]
</code></pre>
<p>选择使用 <code>lambda</code> 函数或者是 <code>attrgetter()</code> 可能取决于个人喜好。 但是， <code>attrgetter()</code> 函数通常会运行的快点，并且还能同时允许多个字段进行比较。 这个跟 <code>operator.itemgetter()</code> 函数作用于字典类型很类似。 例如，如果 <code>User</code> 实例还有一个 <code>first_name</code> 和 <code>last_name</code> 属性，那么可以向下面这样排序：</p>
<pre><code class="language-python">by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
</code></pre>
<p>同样需要注意的是，这一小节用到的技术同样适用于像 <code>min()</code> 和 <code>max()</code> 之类的函数。比如：</p>
<pre><code class="language-python">min(users, key=attrgetter('user_id'))
User(3)
max(users, key=attrgetter('user_id'))
User(99)
</code></pre>
<h2 id="元组">元组</h2>
<ul>
<li>取元组元素</li>
</ul>
<pre><code class="language-Python">a,b,c = ('cat','dog','tiger')
# 提取首、尾两个元素：
first,*_,end = (1,2,3,4,5,6)
# 提取首、中、尾三部分：
first,*middle,end = (1,2,3,4,5,6)
</code></pre>
<h2 id="字符串">字符串</h2>
<ul>
<li>字符元素组成判定<br>
检查两个字符串的组成元素是不是一样的。</li>
</ul>
<pre><code class="language-Python">from collections import Counter
def anagram(first, second):
    return Counter(first) == Counter(second)
anagram(&quot;abcd3&quot;, &quot;3acdb&quot;) # True
</code></pre>
<ul>
<li>N 次字符串<br>
该代码块不需要循环语句</li>
</ul>
<pre><code class="language-Python">n = 2;
s =&quot;Programming&quot;
print(s * n)
# ProgrammingProgramming  
</code></pre>
<ul>
<li>列表转字符串 <code>list -&gt; str</code></li>
</ul>
<pre><code class="language-Python">name_list = ['Zarten_1', 'Zarten_2', 'Zarten_3']
name_str = '&amp;'.join(name_list) # &amp;为列表元素之间分隔符
print(type(name_str), name_str)
</code></pre>
<ul>
<li>映射名称到序列元素<br>
<code>collections.namedtuple()</code> 函数通过使用一个普通的元组对象来帮你解决这个问题。 这个函数实际上是一个返回 <code>Python</code> 中标准元组类型子类的一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。 代码示例：</li>
</ul>
<pre><code class="language-python">from collections import namedtuple
Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
sub = Subscriber('jonesy@example.com', '2012-10-19')
sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
sub.addr
'jonesy@example.com'
sub.joined
'2012-10-19'
</code></pre>
<p>尽管 <code>namedtuple</code> 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。 比如：</p>
<pre><code class="language-python">len(sub)
2
addr, joined = sub
addr
'jonesy@example.com'
joined
'2012-10-19'
</code></pre>
<p>命名元组的一个主要用途是将你的代码从下标操作中解脱出来。 因此，如果你从数据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素， 当你在表中添加了新的列的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。<br>
为了说明清楚，下面是使用普通元组的代码：</p>
<pre><code class="language-python">def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] * rec[2]
    return total
</code></pre>
<p>下标操作通常会让代码表意不清晰，并且非常依赖记录的结构。 下面是使用命名元组的版本：</p>
<pre><code class="language-python">from collections import namedtuple
Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total
</code></pre>
<p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。 如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。 但是需要注意的是，不像字典那样，一个命名元组是不可更改的。比如：</p>
<pre><code class="language-python">s = Stock('ACME', 100, 123.45)
s
Stock(name='ACME', shares=100, price=123.45)
s.shares = 75
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre>
<p>如果你真的需要改变属性的值，那么可以使用命名元组实例的 <code>_replace()</code> 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代。比如：</p>
<pre><code class="language-python">s = s._replace(shares=75)
s
Stock(name='ACME', shares=75, price=123.45)
</code></pre>
<p><code>_replace()</code> 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候， 它是一个非常方便的填充数据的方法。 你可以先创建一个包含缺省值的原型元组，然后使用 <code>_replace()</code> 方法创建新的值被更新过的实例。比如：</p>
<pre><code class="language-python">from collections import namedtuple
Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)
# Function to convert a dictionary to a Stock
def dict_to_stock(s):
    return stock_prototype._replace(**s)
</code></pre>
<p>下面是它的使用方法：</p>
<pre><code class="language-python">a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
dict_to_stock(a)
Stock(name='ACME', shares=100, price=123.45, date=None, time=None)
b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
dict_to_stock(b)
Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)
</code></pre>
<p>最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。 这时候你应该考虑定义一个包含 <code>__slots__</code> 方法的类。</p>
<h2 id="运算符">运算符</h2>
<ul>
<li>链式对比,我们可以在一行代码中使用不同的运算符对比多个不同的元素。</li>
</ul>
<pre><code class="language-Python">a = 3
print( 2 &lt; a &lt; 8) # True
print(1 == a &lt; 2) # False
</code></pre>
<ul>
<li>反向迭代</li>
</ul>
<pre><code class="language-Python">for i in reversed(range(1, 10)):
    print(i, end=',')
</code></pre>
<h2 id="函数">函数</h2>
<ul>
<li>链式函数调用<br>
你可以在一行代码内调用多个函数。</li>
</ul>
<pre><code class="language-Python">def add(a, b):
    return a + b
def subtract(a, b):
    return a - b
a, b = 4, 5
print((subtract if a &gt; b else add)(a, b)) # 9 
</code></pre>
<h2 id="字典">字典</h2>
<ul>
<li>合并字典</li>
</ul>
<pre><code class="language-Python">def merge_two_dicts(a, b):
    c = a.copy()   # make a copy of a 
    c.update(b)    # modify keys and values of a with the ones from b
    return c
a = { 'x': 1, 'y': 2}
b = { 'y': 3, 'z': 4}
print(merge_two_dicts(a, b))
# {'y': 3, 'x': 1, 'z': 4}
</code></pre>
<p>在 Python 3.5 或更高版本中，我们也可以用以下方式合并字典：</p>
<pre><code class="language-Python">def merge_dictionaries(a, b)
   return {**a, **b}
a = { 'x': 1, 'y': 2}
b = { 'y': 3, 'z': 4}
print(merge_dictionaries(a, b))
# {'y': 3, 'x': 1, 'z': 4}
</code></pre>
<p>这是一般的字典合并写法</p>
<pre><code class="language-Python">dic1 = {'x': 1, 'y': 2 }
dic2 = {'y': 3, 'z': 4 }
merged1 = {**dic1, **dic2} # {'x': 1, 'y': 3, 'z': 4}
</code></pre>
<p>修改<code>merged[‘x’]=10</code>，<code>dic1</code>中的<code>x</code>值不变，<code>merged</code>是重新生成的一个新字典。<br>
但是，<code>ChainMap</code>却不同，它在内部创建了一个容纳这些字典的列表。因此使用<code>ChainMap</code>合并字典，修改<code>merged[‘x’]=10</code>后，<code>dic1</code>中的<code>x</code>值改变，如下所示：</p>
<pre><code class="language-Python">from collections import ChainMap
merged2 = ChainMap(dic1,dic2)
print(merged2) # ChainMap({'x': 1, 'y': 2}, {'y': 3, 'z': 4})
</code></pre>
<p><strong>Python Cookbook</strong>:<br>
假如你有如下两个字典:</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
</code></pre>
<p>现在假设你必须在两个字典中执行查找操作（比如先从 <code>a</code> 中找，如果找不到再在 <code>b</code> 中找）。 一个非常简单的解决方案就是使用 <code>collections</code> 模块中的 <code>ChainMap</code> 类。比如：</p>
<pre><code class="language-python">from collections import ChainMap
c = ChainMap(a,b)
print(c['x']) # Outputs 1 (from a)
print(c['y']) # Outputs 2 (from b)
print(c['z']) # Outputs 3 (from a)
</code></pre>
<p>一个 <code>ChainMap</code> 接受多个字典并将它们在逻辑上变为一个字典。 然后，这些字典并不是真的合并在一起了， <code>ChainMap</code> 类只是在内部创建了一个容纳这些字典的列表 并重新定义了一些常见的字典操作来遍历这个列表。大部分字典操作都是可以正常使用的，比如：</p>
<pre><code class="language-python">len(c)
3
list(c.keys())
['x', 'y', 'z']
list(c.values())
[1, 2, 3]
</code></pre>
<p>如果出现重复键，那么第一次出现的映射值会被返回。 因此，例子程序中的 <code>c['z']</code> 总是会返回字典 <code>a</code> 中对应的值，而不是 <code>b</code> 中对应的值。<br>
对于字典的更新或删除操作总是影响的是列表中第一个字典。比如：</p>
<pre><code class="language-python">c['z'] = 10
c['w'] = 40
del c['x']
a
{'w': 40, 'z': 10}
del c['y']
Traceback (most recent call last):
...
KeyError: &quot;Key not found in the first mapping: 'y'&quot;
</code></pre>
<p><code>ChainMap</code> 对于编程语言中的作用范围变量（比如 <code>globals</code> , <code>locals</code> 等）是非常有用的。 事实上，有一些方法可以使它变得简单：</p>
<pre><code class="language-python">values = ChainMap()
values['x'] = 1
# Add a new mapping
values = values.new_child()
values['x'] = 2
# Add a new mapping
values = values.new_child()
values['x'] = 3
values
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
values['x']
3
# Discard last mapping
values = values.parents
values['x']
2
# Discard last mapping
values = values.parents
values['x']
1
values
ChainMap({'x': 1})
</code></pre>
<p>作为 <code>ChainMap</code> 的替代，你可能会考虑使用 <code>update()</code> 方法将两个字典合并。比如：</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
merged = dict(b)
merged.update(a)
merged['x']
1
merged['y']
2
merged['z']
3
</code></pre>
<p>这样也能行得通，但是它需要你创建一个完全不同的字典对象（或者是破坏现有字典结构）。 同时，如果原字典做了更新，这种改变不会反应到新的合并字典中去。比如：</p>
<pre><code class="language-python">a['x'] = 13
merged['x']
1
</code></pre>
<p><code>ChainMap</code> 使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果，比如：</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
merged = ChainMap(a, b)
merged['x']
1
a['x'] = 42
merged['x'] # Notice change to merged dicts
42
</code></pre>
<ul>
<li>将两个列表转化为字典<br>
如下方法将会把两个列表转化为单个字典。</li>
</ul>
<pre><code class="language-Python">def to_dictionary(keys, values):
    return dict(zip(keys, values))
keys = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]    
values = [2, 3, 4]
print(to_dictionary(keys, values))
# {'a': 2, 'c': 4, 'b': 3}
</code></pre>
<ul>
<li>值最大的字典</li>
</ul>
<pre><code class="language-Python">def max_pairs(dic):
    if len(dic) == 0:
        return dic
    max_val = max(map(lambda v: v[1], dic.items()))
    return [item for item in dic.items() if item[1] == max_val]
r = max_pairs({'a': -10, 'b': 5, 'c': 3, 'd': 5})
print(r)  # [('b', 5), ('d', 5)]
</code></pre>
<ul>
<li><code>topn</code>字典</li>
</ul>
<pre><code class="language-Python">from heapq import nlargest
# 返回字典d前n个最大值对应的键
def topn_dict(d, n):
    return nlargest(n, d, key=lambda k: d[k])
topn_dict({'a': 10, 'b': 8, 'c': 9, 'd': 10}, 3)  # ['a', 'd', 'c']
</code></pre>
<ul>
<li>查找两字典的相同点</li>
</ul>
<pre><code class="language-python">a = {
    'x' : 1,
    'y' : 2,
    'z' : 3
}

b = {
    'w' : 10,
    'x' : 11,
    'y' : 2
}
</code></pre>
<p>为了寻找两个字典的相同点，可以简单的在两字典的 <code>keys()</code> 或者 <code>items()</code> 方法返回结果上执行集合操作。比如：</p>
<pre><code class="language-python"># Find keys in common
a.keys() &amp; b.keys() # { 'x', 'y' }
# Find keys in a that are not in b
a.keys() - b.keys() # { 'z' }
# Find (key,value) pairs in common
a.items() &amp; b.items() # { ('y', 2) }
</code></pre>
<p>这些操作也可以用于修改或者过滤字典元素。 比如，假如你想以现有字典构造一个排除几个指定键的新字典。 下面利用字典推导来实现这样的需求：</p>
<pre><code class="language-python"># Make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
</code></pre>
<p>一个字典就是一个键集合与值集合的映射关系。 字典的 <code>keys()</code> 方法返回一个展现键集合的键视图对象。 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个 <code>set</code>。<br>
字典的 <code>items()</code> 方法返回一个包含 <code>(键，值)</code> 对的元素视图对象。 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。<br>
尽管字典的 <code>values()</code> 方法也是类似，但是它并不支持这里介绍的集合操作。 某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。 不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成<code>set</code>，然后再执行集合运算就行了。</p>
<ul>
<li>字典的运算<br>
考虑下面的股票名和价格映射字典：</li>
</ul>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
</code></pre>
<p>为了对字典值执行计算操作，通常需要使用 <code>zip()</code> 函数先将键和值反转过来。 比如，下面是查找最小和最大股票价格和股票值的代码：</p>
<pre><code class="language-python">min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')
max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
</code></pre>
<p>类似的，可以使用 <code>zip()</code> 和 <code>sorted()</code> 函数来排列字典数据：</p>
<pre><code class="language-python">prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
#                   (45.23, 'ACME'), (205.55, 'IBM'),
#                   (612.78, 'AAPL')]
</code></pre>
<p>执行这些计算的时候，需要注意的是 <code>zip()</code> 函数创建的是一个只能访问一次的迭代器。 比如，下面的代码就会产生错误：</p>
<pre><code class="language-python">prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names)) # OK
print(max(prices_and_names)) # ValueError: max() arg is an empty sequence
</code></pre>
<p>如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值。比如：</p>
<pre><code class="language-python">min(prices) # Returns 'AAPL'
max(prices) # Returns 'IBM'
</code></pre>
<p>这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算。 或许你会尝试着使用字典的 <code>values()</code> 方法来解决这个问题：</p>
<pre><code class="language-python">min(prices.values()) # Returns 10.75
max(prices.values()) # Returns 612.78
</code></pre>
<p>不幸的是，通常这个结果同样也不是你想要的。 你可能还想要知道对应的键的信息（比如那种股票价格是最低的？）。<br>
你可以在 <code>min()</code> 和 <code>max()</code> 函数中提供 <code>key</code> 函数参数来获取最小值或最大值对应的键的信息。比如：</p>
<pre><code class="language-python">min(prices, key=lambda k: prices[k]) # Returns 'FB'
max(prices, key=lambda k: prices[k]) # Returns 'AAPL'
</code></pre>
<p>但是，如果还想要得到最小值，你又得执行一次查找操作。比如：</p>
<pre><code class="language-python">min_value = prices[min(prices, key=lambda k: prices[k])]
</code></pre>
<p>前面的 <code>zip()</code> 函数方案通过将字典”反转”为 (值，键) 元组序列来解决了上述问题。 当比较两个元组的时候，值会先进行比较，然后才是键。 这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了。<br>
需要注意的是在计算操作中使用到了 (值，键) 对。当多个实体拥有相同的值的时候，键会决定返回结果。 比如，在执行 <code>min()</code> 和 <code>max()</code> 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：</p>
<pre><code class="language-python">prices = { 'AAA' : 45.23, 'ZZZ': 45.23 }
min(zip(prices.values(), prices.keys()))
(45.23, 'AAA')
max(zip(prices.values(), prices.keys()))
(45.23, 'ZZZ')
</code></pre>
<ul>
<li>通过某个关键字排序一个字典列表<br>
通过使用 <code>operator</code> 模块的 <code>itemgetter</code> 函数，可以非常容易的排序这样的数据结构。 假设你从数据库中检索出来网站会员信息列表，并且以下列的数据结构返回：</li>
</ul>
<pre><code class="language-python">rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
</code></pre>
<p>根据任意的字典字段来排序输入结果行是很容易实现的，代码示例：</p>
<pre><code class="language-python">from operator import itemgetter
rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))
print(rows_by_fname)
print(rows_by_uid)
</code></pre>
<p>代码的输出如下：</p>
<pre><code class="language-python">[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]
[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]
</code></pre>
<p><code>itemgetter()</code> 函数也支持多个 <code>keys</code>，比如下面的代码</p>
<pre><code class="language-python">rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)
</code></pre>
<p>会产生如下的输出：</p>
<pre><code class="language-python">[{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}]
</code></pre>
<p>在上面例子中， <code>rows</code> 被传递给接受一个关键字参数的 <code>sorted()</code> 内置函数。 这个参数是 <code>callable</code> 类型，并且从 <code>rows</code> 中接受一个单一元素，然后返回被用来排序的值。 <code>itemgetter()</code> 函数就是负责创建这个 <code>callable</code> 对象的。</p>
<p><code>operator.itemgetter()</code> 函数有一个被 <code>rows</code> 中的记录用来查找值的索引参数。可以是一个字典键名称， 一个整形值或者任何能够传入一个对象的 <code>__getitem__()</code> 方法的值。 如果你传入多个索引参数给 <code>itemgetter()</code> ，它生成的 <code>callable</code> 对象会返回一个包含所有元素值的元组， 并且 <code>sorted()</code> 函数会根据这个元组中元素顺序去排序。 但你想要同时在几个字段上面进行排序（比如通过姓和名来排序，也就是例子中的那样）的时候这种方法是很有用的。<br>
<code>itemgetter()</code> 有时候也可以用 <code>lambda</code> 表达式代替，比如：</p>
<pre><code class="language-python">rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
</code></pre>
<p>这种方案也不错。但是，使用 <code>itemgetter()</code> 方式会运行的稍微快点。因此，如果你对性能要求比较高的话就使用 <code>itemgetter()</code> 方式。<br>
最后，不要忘了这节中展示的技术也同样适用于 <code>min()</code> 和 <code>max()</code> 等函数。比如：</p>
<pre><code class="language-python">min(rows, key=itemgetter('uid'))
{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
max(rows, key=itemgetter('uid'))
{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
</code></pre>
<ul>
<li>字典中提取子集<br>
最简单的方式是使用字典推导。比如：</li>
</ul>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
# Make a dictionary of all prices over 200
p1 = {key: value for key, value in prices.items() if value &gt; 200}
# Make a dictionary of tech stocks
tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}
p2 = {key: value for key, value in prices.items() if key in tech_names}
</code></pre>
<p>大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 <code>dict()</code> 函数也能实现。比如：</p>
<pre><code class="language-python">p1 = dict((key, value) for key, value in prices.items() if value &gt; 200)
</code></pre>
<p>但是，字典推导方式表意更清晰，并且实际上也会运行的更快些 （在这个例子中，实际测试几乎比 <code>dict()</code> 函数方式快整整一倍）。<br>
有时候完成同一件事会有多种方式。比如，第二个例子程序也可以像这样重写：</p>
<pre><code class="language-python"># Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:prices[key] for key in prices.keys() &amp; tech_names }
</code></pre>
<p>但是，运行时间测试结果显示这种方案大概比第一种方案慢 1.6 倍。 如果对程序运行性能要求比较高的话，需要花点时间去做计时测试。</p>
<h2 id="集合">集合</h2>
<ul>
<li>元素频率<br>
下面的方法会根据元素频率取列表中最常见的元素。</li>
</ul>
<pre><code class="language-Python">def most_frequent(list):
    return max(set(list), key = list.count)
list = [1,2,1,2,3,2,1,4,2]
most_frequent(list)
</code></pre>
<h2 id="collections"><code>collections</code></h2>
<h3 id="deque"><code>deque</code></h3>
<ul>
<li>保留最后 <code>N</code> 个元素<br>
使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。</li>
</ul>
<pre><code class="language-Python">q = deque(maxlen=3)
q.append(1)
q.append(2)
q.append(3)
q
deque([1, 2, 3], maxlen=3)
q.append(4)
q
deque([2, 3, 4], maxlen=3)
q.append(5)
q
deque([3, 4, 5], maxlen=3)
</code></pre>
<p>尽管你也可以手动在一个列表上实现这一的操作（比如增加、删除等等）。但是这里的队列方案会更加优雅并且运行得更快些。<br>
更一般的， <code>deque</code> 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p>
<pre><code class="language-python">q = deque()
q.append(1)
q.append(2)
q.append(3)
q
deque([1, 2, 3])
q.appendleft(4)
q
deque([4, 1, 2, 3])
q.pop()
3
q
deque([4, 1, 2])
q.popleft()
4
</code></pre>
<p>在队列两端插入或删除元素时间复杂度都是 <code>O(1)</code> ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 <code>O(N)</code> 。</p>
<h3 id="counter"><code>Counter</code></h3>
<ul>
<li>序列中出现次数最多的元素<br>
<code>collections.Counter</code> 类就是专门为这类问题而设计的， 它甚至有一个有用的 <code>most_common()</code> 方法直接给了你答案。<br>
为了演示，先假设你有一个单词列表并且想找出哪个单词出现频率最高。你可以这样做：</li>
</ul>
<pre><code class="language-python">words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', &quot;you're&quot;, 'under'
]
from collections import Counter
word_counts = Counter(words)
# 出现频率最高的3个单词
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
</code></pre>
<p>作为输入， <code>Counter</code> 对象可以接受任意的由可哈希(<code>hashable</code>)元素构成的序列对象。 在底层实现上，一个 <code>Counter</code>对象就是一个字典，将元素映射到它出现的次数上。比如：</p>
<pre><code class="language-python">word_counts['not']
1
word_counts['eyes']
8
</code></pre>
<p>如果你想手动增加计数，可以简单的用加法：</p>
<pre><code class="language-python">morewords = ['why','are','you','not','looking','in','my','eyes']
for word in morewords:
    word_counts[word] += 1
word_counts['eyes']
9
</code></pre>
<p>或者你可以使用 <code>update()</code> 方法：</p>
<pre><code class="language-python">word_counts.update(morewords)
</code></pre>
<p><code>Counter</code> 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。比如：</p>
<pre><code class="language-python">a = Counter(words)
b = Counter(morewords)
a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
&quot;you're&quot;: 1, &quot;don't&quot;: 1, 'under': 1, 'not': 1})
b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
'my': 1, 'why': 1})
# Combine counts
c = a + b
c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
'around': 2, &quot;you're&quot;: 1, &quot;don't&quot;: 1, 'in': 1, 'why': 1,
'looking': 1, 'are': 1, 'under': 1, 'you': 1})
# Subtract counts
d = a - b
d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
&quot;you're&quot;: 1, &quot;don't&quot;: 1, 'under': 1})
</code></pre>
<p>毫无疑问， <code>Counter</code> 对象在几乎所有需要制表或者计数数据的场合是非常有用的工具。 在解决这类问题的时候你应该优先选择它，而不是手动的利用字典去实现。</p>
<h2 id="heapq"><code>heapq</code></h2>
<ul>
<li>查找最大或最小的 <code>N</code> 个元素<br>
<code>heapq</code> 模块有两个函数：<code>nlargest()</code> 和 <code>nsmallest()</code> 可以完美解决这个问题。</li>
</ul>
<pre><code class="language-python">import heapq
nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
</code></pre>
<p>两个函数都能接受一个关键字参数，用于更复杂的数据结构中：</p>
<pre><code class="language-python">portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>上面代码在对每个元素进行对比的时候，会以 <code>price</code> 的值进行比较。<br>
如果你想在一个集合中查找最小或最大的 <code>N</code> 个元素，并且 <code>N</code> 小于集合元素数量，那么这些函数提供了很好的性能。 因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：</p>
<pre><code class="language-python">nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
import heapq
heap = list(nums)
heapq.heapify(heap)
heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
</code></pre>
<p>堆数据结构最重要的特征是 <code>heap[0]</code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code>heapq.heappop()</code> 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 <code>O(log N)</code>，<code>N</code> 是堆大小）。 比如，如果想要查找最小的 3 个元素，你可以这样做：</p>
<pre><code class="language-python">heapq.heappop(heap)
-4
heapq.heappop(heap)
1
heapq.heappop(heap)
2
</code></pre>
<p>当要查找的元素个数相对比较小的时候，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 是很合适的。 如果你仅仅想查找唯一的最小或最大（<code>N=1</code>）的元素的话，那么使用 <code>min()</code> 和 <code>max()</code> 函数会更快些。 类似的，如果 <code>N</code> 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ <code>sorted(items)[:N]</code> 或者是 <code>sorted(items)[-N:]</code> ）。 需要在正确场合使用函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才能发挥它们的优势 （如果 <code>N</code> 快接近集合大小了，那么使用排序操作会更好些）。</p>
<ul>
<li>实现优先级队列<br>
下面的类利用 <code>heapq</code> 模块实现了一个简单的优先级队列：</li>
</ul>
<pre><code class="language-python">import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>
<p>下面是它的使用方式：</p>
<pre><code class="language-python">class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name)
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
Item('bar')
q.pop()
('spam')
q.pop()
Item('foo')
q.pop()
Item('grok')
</code></pre>
<p>仔细观察可以发现，第一个 <code>pop()</code> 操作返回优先级最高的元素。 另外注意到如果两个有着相同优先级的元素<code>(foo 和 grok)</code>，<code>pop</code> 操作按照它们被插入到队列的顺序返回的。<br>
这一小节我们主要关注 <code>heapq</code> 模块的使用。 函数 <code>heapq.heappush()</code> 和 <code>heapq.heappop()</code> 分别在队列 <code>_queue</code> 上插入和删除第一个元素， 并且队列 <code>_queue</code> 保证第一个元素拥有最高优先级。 <code>heappop()</code> 函数总是返回”最小的”的元素，这就是保证队列<code>pop</code>操作返回正确元素的关键。 另外，由于 <code>push</code> 和 <code>pop</code> 操作时间复杂度为 <code>O(log N)</code>，其中 <code>N</code> 是堆的大小，因此就算是 <code>N</code> 很大的时候它们运行速度也依旧很快。</p>
<p>在上面代码中，队列包含了一个 <code>(-priority, index, item)</code> 的元组。 优先级为负数的目的是使得元素按照优先级从高到低排序。 这个跟普通的按优先级从低到高排序的堆排序恰巧相反。</p>
<p><code>index</code> 变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的 <code>index</code> 下标变量，可以确保元素按照它们插入的顺序排序。 而且， <code>index</code> 变量也在相同优先级元素比较的时候起到重要作用。</p>
<p>为了阐明这些，先假定 <code>Item</code> 实例是不支持排序的：</p>
<pre><code class="language-python">a = Item('foo')
b = Item('bar')
a &lt; b
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
</code></pre>
<p>如果你使用元组 <code>(priority, item)</code> ，只要两个元素的优先级不同就能比较。 但是如果两个元素优先级一样的话，那么比较操作就会跟之前一样出错：</p>
<pre><code class="language-python">a = (1, Item('foo'))
b = (5, Item('bar'))
a &lt; b
True
c = (1, Item('grok'))
a &lt; c
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
</code></pre>
<p>通过引入另外的 <code>index</code> 变量组成三元组 <code>(priority, index, item)</code> ，就能很好的避免上面的错误， 因为不可能有两个元素有相同的 <code>index</code> 值。<code>Python</code> 在做元组比较时候，如果前面的比较已经可以确定结果了， 后面的比较操作就不会发生了：</p>
<pre><code class="language-python">a = (1, 0, Item('foo'))
b = (5, 1, Item('bar'))
c = (1, 2, Item('grok'))
a &lt; b
True
a &lt; c
True
</code></pre>
<p>如果你想在多个线程中使用同一个队列，那么你需要增加适当的锁和信号量机制。</p>
<h2 id="itertools"><code>itertools</code></h2>
<h3 id="groupby"><code>groupby</code></h3>
<ul>
<li>通过某个字段将记录分组<br>
<code>itertools.groupby()</code> 函数对于这样的数据分组操作非常实用。 为了演示，假设你已经有了下列的字典列表：</li>
</ul>
<pre><code class="language-python">rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
</code></pre>
<p>现在假设你想在按 <code>date</code> 分组后的数据块上进行迭代。为了这样做，你首先需要按照指定的字段(这里就是 <code>date</code> )排序， 然后调用 <code>itertools.groupby()</code> 函数：</p>
<pre><code class="language-python">from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))
# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-python">07/01/2012
  {'date': '07/01/2012', 'address': '5412 N CLARK'}
  {'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
  {'date': '07/02/2012', 'address': '5800 E 58TH'}
  {'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
  {'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
  {'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
  {'date': '07/04/2012', 'address': '5148 N CLARK'}
  {'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
</code></pre>
<p><code>groupby()</code> 函数扫描整个序列并且查找连续相同值（或者根据指定 <code>key</code> 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。<br>
一个非常重要的准备步骤是要根据指定的字段将数据排序。 因为 <code>groupby()</code> 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。<br>
如果你仅仅只是想根据 <code>date</code> 字段将数据分组到一个大的数据结构中去，并且允许随机访问， 那么你最好使用 <code>defaultdict()</code> 来构建一个多值字典，</p>
<pre><code class="language-python">from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
    rows_by_date[row['date']].append(row)
</code></pre>
<p>这样的话你可以很轻松的就能对每个指定日期访问对应的记录：</p>
<pre><code class="language-python">for r in rows_by_date['07/01/2012']:
    print(r)
{'date': '07/01/2012', 'address': '5412 N CLARK'}
{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
</code></pre>
<p>在上面这个例子中，我们没有必要先将记录排序。因此，如果对内存占用不是很关心， 这种方式会比先排序然后再通过 <code>groupby()</code> 函数迭代的方式运行得快一些。</p>
<h2 id="迭代器与生成器">迭代器与生成器</h2>
<ul>
<li>过滤序列元素<br>
最简单的过滤序列元素的方法就是使用列表推导。比如：</li>
</ul>
<pre><code class="language-python">mylist = [1, 4, -5, 10, -7, 2, 3, -1]
[n for n in mylist if n &gt; 0]
[1, 4, 10, 2, 3]
[n for n in mylist if n &lt; 0]
[-5, -7, -1]
</code></pre>
<p>使用列表推导的一个潜在缺陷就是如果输入非常大的时候会产生一个非常大的结果集，占用大量内存。 如果你对内存比较敏感，那么你可以使用生成器表达式迭代产生过滤的元素。比如：</p>
<pre><code class="language-python">pos = (n for n in mylist if n &gt; 0)
pos
&lt;generator object &lt;genexpr&gt; at 0x1006a0eb0&gt;
for x in pos:
    print(x)
1
4
10
2
3
</code></pre>
<p>有时候，过滤规则比较复杂，不能简单的在列表推导或者生成器表达式中表达出来。 比如，假设过滤的时候需要处理一些异常或者其他复杂情况。这时候你可以将过滤代码放到一个函数中， 然后使用内建的 <code>filter()</code> 函数。示例如下：</p>
<pre><code class="language-python">values = ['1', '2', '-3', '-', '4', 'N/A', '5']
def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False
ivals = list(filter(is_int, values))
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']
</code></pre>
<p><code>filter()</code> 函数创建了一个迭代器，因此如果你想得到一个列表的话，就得像示例那样使用 <code>list()</code> 去转换。<br>
列表推导和生成器表达式通常情况下是过滤数据最简单的方式。 其实它们还能在过滤的时候转换数据。比如：</p>
<pre><code class="language-python">mylist = [1, 4, -5, 10, -7, 2, 3, -1]
import math
[math.sqrt(n) for n in mylist if n &gt; 0]
[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]
</code></pre>
<p>过滤操作的一个变种就是将不符合条件的值用新的值代替，而不是丢弃它们。 比如，在一列数据中你可能不仅想找到正数，而且还想将不是正数的数替换成指定的数。 通过将过滤条件放到条件表达式中去，可以很容易的解决这个问题，就像这样：</p>
<pre><code class="language-python">clip_neg = [n if n &gt; 0 else 0 for n in mylist]
clip_neg
[1, 4, 0, 10, 0, 2, 3, 0]
clip_pos = [n if n &lt; 0 else 0 for n in mylist]
clip_pos
[0, 0, -5, 0, -7, 0, 0, -1]
</code></pre>
<p>另外一个值得关注的过滤工具就是 <code>itertools.compress()</code> ， 它以一个 <code>iterable</code> 对象和一个相对应的 <code>Boolean</code> 选择器序列作为输入参数。 然后输出 <code>iterable</code> 对象中对应选择器为 <code>True</code> 的元素。 当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。 比如，假如现在你有下面两列数据：</p>
<pre><code class="language-python">addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
</code></pre>
<p>现在你想将那些对应 <code>count</code> 值大于5的地址全部输出，那么你可以这样做：</p>
<pre><code class="language-python">from itertools import compress
more5 = [n &gt; 5 for n in counts]
more5
[False, False, True, False, False, True, True, False]
list(compress(addresses, more5))
['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
</code></pre>
<p>这里的关键点在于先创建一个 <code>Boolean</code> 序列，指示哪些元素符合条件。 然后 <code>compress()</code> 函数根据这个序列去选择输出对应位置为 <code>True</code> 的元素。<br>
和 <code>filter()</code> 函数类似， <code>compress()</code> 也是返回的一个迭代器。因此，如果你需要得到一个列表， 那么你需要使用 <code>list()</code> 来将结果转换为列表类型。</p>
<ul>
<li>转换并同时计算数据<br>
一个非常优雅的方式去结合数据计算与转换就是使用一个生成器表达式参数。 比如，如果你想计算平方和，可以像下面这样做：</li>
</ul>
<pre><code class="language-python">nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)
</code></pre>
<p>下面是更多的例子：</p>
<pre><code class="language-python"># Determine if any .py files exist in a directory
import os
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files):
    print('There be python!')
else:
    print('Sorry, no python.')
# Output a tuple as CSV
s = ('ACME', 50, 123.45)
print(','.join(str(x) for x in s))
# Data reduction across fields of a data structure
portfolio = [
    {'name':'GOOG', 'shares': 50},
    {'name':'YHOO', 'shares': 75},
    {'name':'AOL', 'shares': 20},
    {'name':'SCOX', 'shares': 65}
]
min_shares = min(s['shares'] for s in portfolio)
</code></pre>
<p>上面的示例向你演示了当生成器表达式作为一个单独参数传递给函数时候的巧妙语法（你并不需要多加一个括号）。 比如，下面这些语句是等效的：</p>
<pre><code class="language-python">s = sum((x * x for x in nums)) # 显式的传递一个生成器表达式对象
s = sum(x * x for x in nums) # 更加优雅的实现方式，省略了括号
</code></pre>
<p>使用一个生成器表达式作为参数会比先创建一个临时列表更加高效和优雅。 比如，如果你不使用生成器表达式的话，你可能会考虑使用下面的实现方式：</p>
<pre><code class="language-python">nums = [1, 2, 3, 4, 5]
s = sum([x * x for x in nums])
</code></pre>
<p>这种方式同样可以达到想要的效果，但是它会多一个步骤，先创建一个额外的列表。 对于小型列表可能没什么关系，但是如果元素数量非常大的时候， 它会创建一个巨大的仅仅被使用一次就被丢弃的临时数据结构。而生成器方案会以迭代的方式转换数据，因此更省内存。<br>
在使用一些聚集函数比如 <code>min()</code> 和 <code>max()</code> 的时候你可能更加倾向于使用生成器版本， 它们接受的一个 <code>key</code> 关键字参数或许对你很有帮助。 比如，在上面的证券例子中，你可能会考虑下面的实现版本：</p>
<pre><code class="language-python"># Original: Returns 20
min_shares = min(s['shares'] for s in portfolio)
# Alternative: Returns {'name': 'AOL', 'shares': 20}
min_shares = min(portfolio, key=lambda s: s['shares'])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python笔记]]></title>
        <id>https://bailingnan.github.io/post/python-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/python-bi-ji/">
        </link>
        <updated>2020-03-22T07:24:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python笔记"><code>Python</code>笔记</h1>
<h2 id="编码规范">编码规范</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318181309.png" alt="" loading="lazy"></figure>
<h2 id="对象">对象</h2>
<h3 id="可变与不可变对象">可变与不可变对象</h3>
<ul>
<li><code>Python</code>中的大多数对象，比如列表、字典、<code>NumPy</code>数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改。</li>
<li>字符串和元组，是不可变的。</li>
</ul>
<pre><code class="language-Python">a= 'abc'
b = a.replace('a', 'A')
print(b)
'Abc'
</code></pre>
<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象，有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：<br>
当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了。<br>
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<ul>
<li>变量可以连续赋值:</li>
</ul>
<pre><code class="language-Python">a=b=c=1
</code></pre>
<h3 id="拷贝">拷贝</h3>
<ul>
<li>简单的赋值只是将引用传给新对象，新旧对象除变量名外毫无区别</li>
<li>由于 <code>Python</code> 内部引用计数的特性，对于不可变对象，浅拷贝和深拷贝的作用是一致的，就相当于复制了一份副本，原对象内部的不可变对象的改变，不会影响到复制对象</li>
<li>浅拷贝的拷贝。其实是拷贝了原始元素的引用（内存地址），所以当拷贝可变对象时，原对象内可变对象的对应元素的改变，会在复制对象的对应元素上，有所体现</li>
<li>深拷贝在遇到可变对象时，又在内部做了新建了一个副本。所以，不管它内部的元素如何变化，都不会影响到原来副本的可变对象</li>
<li>如果对子对象修改，则浅拷贝后的结果也会跟着发生变化，而深拷贝则不会。他们的子对象还是指向统一对象（是引用）。<code>list</code>的<code>a=b[:]</code>相当于<code>copy()</code></li>
<li>如果对父对象修改，则不管是浅拷贝还是深拷贝的结果，都不会跟着发生变化。</li>
<li>不管对什么对象修改，指针引用后的结果都会跟着发生相同变化。<br>
标准库中的<code>copy</code>模块提供了两个方法来实现拷贝.一个方法是<code>copy</code>,它返回和参数包含内容一样的对象.</li>
</ul>
<pre><code class="language-Python">import copy
new_list = copy.copy(existing_list)
</code></pre>
<p>有些时候,你希望对象中的属性也被复制,可以使用<code>deepcopy</code>方法:</p>
<pre><code class="language-Python">import copy
new_list_of_dicts = copy.deepcopy(existing_list_of_dicts)
</code></pre>
<p>当你对一个对象赋值的时候(做为参数传递,或者做为返回值),<code>Python</code>和<code>Java</code>一样,总是传递原始对象的引用,而不是一个副本.其它一些语言当赋值的时候总是传递副本,<code>Python</code>从不猜测用户的需求 ,如果你想要一个副本,你必须显式的要求.<br>
<code>Python</code>的行为很简单,迅速,而且一致.然而,如果你需要一个对象拷贝而并没有显式的写出来,会出现问题的,比如:</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
print(id(a)==id(b))
True
b.append(5)
print(a,b) 
[1, 2, 3, 5] [1, 2, 3, 5]
</code></pre>
<p>在这里,变量<code>a</code>和<code>b</code>都指向同一个对象(一个列表),所以,一旦你修改了二者之一,另外一个也会受到影响.无论怎样,都会修改原来的对象。</p>
<pre><code class="language-Python">import copy
c=copy.copy(a)
print(id(c)==id(a))
False
c[1]=222
print(c)
[1,222,3,5]
print(a)
[1,2,3,5]
a=[1,2,[3,4]]
d=copy.copy(a)
print(id(a)==id(d))
False
print(id(a[2])==id(d[2]))
True
a[0]=11
print(a)
[11,2,[3,4]]
print(d)
[1,2,[3,4]]
# 只会复制值的第一层，而不会复制往下的几层数据。
# 复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。
a[2][0]=333
print(d)
[1,2,[333,4]]
e=copy.deepcopy(a)
print(e[2]==a[2])
False
</code></pre>
<p>这种情况就不一样了，这是对<code>a</code>重新指向新的值那么其<code>id</code>就会变而此时<code>b</code>就不会变。</p>
<pre><code class="language-Python">a = [1,2,3]
b = a
print(id(b))
a = {1:2}
print(id(a))
print(id(b))
print(b)
输出：
1998591409928
1998589307016
1998591409928
[1, 2, 3]
</code></pre>
<p>再举一个例子：</p>
<pre><code class="language-Python">import copy
a=[1,[1,2],3]
b=a
b
[1, [1, 2], 3]
id(a)
4549388120
id(b)
4549388120
b[0]=3
a
[3, [1, 2], 3]
c=copy.copy(a)
id(c)
4549389992
id(a)
4549388120
c[0]=4
a
[3, [1, 2], 3]
c
[4, [1, 2], 3]
c[1].append(3)
a
[3, [1, 2, 3], 3]
c
[4, [1, 2, 3], 3]
id(a[2])
140345184649736
id(c[2])
140345184649736
id(c[1])
4549388192
id(a[1])
4549388192
d=copy.deepcopy(a)
id(d)
4549389632
id(a)
4549388120
d[1].append(4)
a
[3, [1, 2, 3], 3]
d
[3, [1, 2, 3, 4], 3]
</code></pre>
<p><code>Python</code> 存储变量的方法跟其他 <code>OOP</code> 语言不同。它与其说是把值赋给变量，不如说是给变量建立了一个到具体值的 <code>reference</code>。<br>
当在 <code>Python</code> 中 <code>a = something</code> 应该理解为给 <code>something</code> 贴上了一个标签 <code>a</code>。当再赋值给 <code>a</code> 的时候，就好像把 <code>a</code> 这个标签从原来的 <code>something</code> 上拿下来，贴到其他对象上，建立新的 <code>reference</code>。 这就解释了一些 <code>Python</code> 中可能遇到的诡异情况：</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
a = [4, 5, 6] # 赋新的值给 a
a
[4, 5, 6]
b
[1, 2, 3]
# a 的值改变后，b 并没有随着 a 变
a = [1, 2, 3]
b = a
a[0], a[1], a[2] = 4, 5, 6 # 改变原来 list 中的元素
a
[4, 5, 6]
b
[4, 5, 6]
# a 的值改变后，b 随着 a 变了
</code></pre>
<p>上面两段代码中，<code>a</code> 的值都发生了变化。区别在于，第一段代码中是直接赋给了 <code>a</code> 新的值(从 <code>[1, 2, 3]</code> 变为 <code>[4, 5, 6]</code>)；而第二段则是把 <code>list</code> 中每个元素分别改变。<br>
首次把 <code>[1, 2, 3]</code> 看成一个物品。<code>a = [1, 2, 3]</code> 就相当于给这个物品上贴上 <code>a</code> 这个标签。而 <code>b = a</code> 就是给这个物品又贴上了一个 <code>b</code> 的标签。<br>
<code>a = [4, 5, 6]</code> 就相当于把 <code>a</code> 标签从 <code>[1 ,2, 3]</code> 上撕下来，贴到了 <code>[4, 5, 6]</code> 上。<br>
在这个过程中，<code>[1, 2, 3]</code> 这个物品并没有消失。 <code>b</code>自始至终都好好的贴在 <code>[1, 2, 3]</code> 上，既然这个 <code>reference</code> 也没有改变过。 <code>b</code> 的值自然不变。<br>
第二种情况：<br>
<code>a[0], a[1], a[2] = 4, 5, 6</code>则是直接改变了 <code>[1, 2, 3]</code> 这个物品本身。把它内部的每一部分都重新改装了一下。内部改装完毕后，<code>[1, 2, 3]</code> 本身变成了 <code>[4, 5, 6]</code>。<br>
而在此过程当中，<code>a</code> 和 <code>b</code> 都没有动，他们还贴在那个物品上。因此自然 <code>a</code>,<code>b</code> 的值都变成了 <code>[4, 5, 6]</code>。<br>
搞明白这个之后就要问了，对于一个复杂对象的浅<code>copy</code>，在<code>copy</code>的时候到底发生了什么？<br>
再看一段代码：</p>
<pre><code class="language-Python">import copy
origin = [1, 2, [3, 4]]
#origin 里边有三个元素：1， 2，[3, 4]
cop1 = copy.copy(origin)
cop2 = copy.deepcopy(origin)
cop1 == cop2
True
cop1 is cop2
False 
#cop1 和 cop2 看上去相同，但已不再是同一个object
origin[2][0] = &quot;hey!&quot; 
origin
[1, 2, ['hey!', 4]]
cop1
[1, 2, ['hey!', 4]]
cop2
[1, 2, [3, 4]]
#把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2
</code></pre>
<p><code>copy</code>对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，<code>Python</code>会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。<br>
所以说看这里的<code>origin[2]</code>，也就是 <code>[3, 4]</code> 这个 <code>list</code>。根据 <code>shallow copy</code> 的定义，在 <code>cop1[2]</code> 指向的是同一个 <code>list [3, 4]</code>。那么，如果这里我们改变了这个 <code>list</code>，就会导致 <code>origin</code> 和 <code>cop1</code> 同时改变。这就是为什么上边 <code>origin[2][0] = “hey!”</code>之后，cop1 也随之变成了 <code>[1, 2, [‘hey!’, 4]]</code>。<br>
<code>deepcopy</code>的时候会将复杂对象的每一层复制一个单独的个体出来。<br>
这时候的 <code>origin[2]</code> 和 <code>cop2[2]</code> 虽然值都等于 <code>[3, 4]</code>，但已经不是同一个 <code>list了</code>。即我们寻常意义上的复制。<br>
总结：</p>
<pre><code class="language-Python">lst = [10, ['A']]

# 指针引用: 不拷贝
a = lst
assert a is lst

# 浅拷贝: 只拷贝 父对象，不会拷贝 子对象
import copy
b = copy.copy(lst)
assert b is not lst and b == lst

# 深拷贝: 拷贝 父对象 及 子对象
c = copy.deepcopy(lst)
assert c is not lst and c == lst

# 修改 list 对象
lst.append(5)
lst[1].append('B')

print(&quot;原始的list对象:  lst =  [10, ['A']]&quot;)
print('修改后list对象:  lst = ', a, '\n')
print('指针引用:  a = ', a)
print('浅拷贝  :  b = ', b)
print('深拷贝  :  c = ', c)
原始的list对象:  lst =  [10, ['A']]
修改后list对象:  lst =  [10, ['A', 'B'], 5] 

指针引用:  a =  [10, ['A', 'B'], 5]
浅拷贝  :  b =  [10, ['A', 'B']]
深拷贝  :  c =  [10, ['A']]
</code></pre>
<p>即:</p>
<ul>
<li>如果对子对象修改，则浅拷贝后的结果也会跟着发生变化，而深拷贝则不会。<code>list</code>的<code>a=b[:]</code>相当于<code>copy()</code></li>
<li>如果对父对象修改，则不管是浅拷贝还是深拷贝的结果，都不会跟着发生变化。</li>
<li>不管对什么对象修改，指针引用后的结果都会跟着发生相同变化。<br>
举例：</li>
</ul>
<pre><code class="language-Python">import copy
base = ['a', 'b', 'c', 'd', 'e']
# 切片
bak1 = base[:]
print(&quot;bak1: &quot;, bak1)
# list工厂函数
bak2 = list(base)
print(&quot;bak2: &quot;, bak2)
# Python list对象的copy方法
bak3 = base.copy()
print(&quot;bak3: &quot;, bak3)
# copy模块的copy方法
bak4 = copy.copy(base)
print(&quot;bak4: &quot;, bak4)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">bak1:  ['a', 'b', 'c', 'd', 'e']
bak2:  ['a', 'b', 'c', 'd', 'e']
bak3:  ['a', 'b', 'c', 'd', 'e']
bak4:  ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>上面的代码使用了四种方式来对数据进行拷贝，这些方法都可以用来拷贝数据，结果都一样。</p>
<ul>
<li>切片<br>
需要拷贝的数据进行切片处理，返回的结果相当于拷贝了一份数据。</li>
<li>工厂方法<br>
使用 <code>Python</code> 的工厂函数 <code>list</code> 来拷贝数据。(<code>Python</code>的工厂函数是比较特殊的，即是类也是函数，关于工厂函数的理解可以另行扩展一下)<br>
拷贝列表时使用 <code>list</code>，如果拷贝字符串则将上面的 <code>list</code> 换成 <code>str</code> ，以此类推。</li>
<li>list对象的copy方法<br>
<code>Python</code> 中的 <code>list</code> 实现了 <code>copy</code> 方法，在拷贝列表时可以直接使用。这里需要注意，比如 <code>str</code> 没有实现 <code>copy</code> 方法，拷贝字符串时使用其他方法拷贝。</li>
<li><code>copy</code>模块的<code>copy</code>方法<br>
在 <code>Python</code> 标准库中有一个 <code>copy</code> 模块，可以使用 <code>copy</code> 模块的 <code>copy()</code> 方法来拷贝数据，<code>copy</code> 模块可以拷贝所有类型的数据。</li>
</ul>
<pre><code class="language-Python">import copy
son = ['Python', 'copy']
base = ['a', 'b', 'c', 'd', 'e', son]
bak1 = base[:]
print(&quot;bak1: &quot;, bak1)
bak2 = list(base)
print(&quot;bak2: &quot;, bak2)
bak3 = base.copy()
print(&quot;bak3: &quot;, bak3)
bak4 = copy.copy(base)
print(&quot;bak4: &quot;, bak4)
print('-' * 20, '分割线', '-' * 20)
son[0] = 'PYTHON'
son[1] = 'COPY'
print('base: ', base)
print(&quot;bak1: &quot;, bak1)
print(&quot;bak2: &quot;, bak2)
print(&quot;bak3: &quot;, bak3)
print(&quot;bak4: &quot;, bak4)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">bak1:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak2:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak3:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak4:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
-------------------- 分割线 --------------------
base:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak1:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak2:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak3:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak4:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
</code></pre>
<p>在实际工作中，数据的嵌套层数是很多的，通常会嵌套好几层。上面就在 <code>base</code> 列表中嵌套了一个 <code>son</code> 子列表。<br>
用上面的四种拷贝方法拷贝 <code>base</code> 列表，然后修改 <code>base</code> 列表中的子列表 <code>son</code> 。重新打印这几个列表，发现不仅 <code>base</code> 列表被修改了，拷贝的列表也全部被修改了。<br>
现在的需求是拷贝一份数据，修改一份保留一份，如果两份数据都被修改，是不符合需求的。<br>
上面的四种拷贝方法都被称为浅拷贝（相对深拷贝而言），浅拷贝 <code>Python</code> 中的可变对象，如果数据中嵌套了可变对象，修改嵌套的可变对象，所有拷贝的数据都会一起被修改。<br>
在 <code>Python</code> 中，所有的数据都是对象，无论是数字，字符串，元组，列表，字典，还是函数，类，甚至是模块。<br>
不可变对象：<br>
<code>int</code>, <code>str</code>, <code>tuple</code> 等类型的数据是不可变对象，不可变对象的特性是数据不可被修改。</p>
<pre><code class="language-Python">a = 'a'
print(id(a))
a = 'b'
print(id(a))
</code></pre>
<p>运行结果：</p>
<pre><code>1543912659912
1543912658232
</code></pre>
<p>如果对不可变对象修改，其实不是修改变量对象，而是重新创建一个同名的变量对象。可以通过 <code>id</code> 函数来判断，<code>id</code> 不一样就证明已经不是同一个变量了。<br>
可变对象：<br>
<code>list</code>， <code>set</code>，<code>dict</code> 等类型的数据是可变对象，相对于不可变对象而言，可变对象的数据可以被修改，修改之后还是同一个<code>id</code>。</p>
<pre><code class="language-Python">base = [1, 2, 3]
print(id(base))
base[0] = 100
print(base)
print(id(base))
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">2182371173000
[100, 2, 3]
2182371173000
</code></pre>
<p>对可变对象进行修改，修改后还是同一个对象，只是可变对象里面的元素指向了不同的数据，这种指向是通过引用的方式来实现的。<br>
上面的代码是对列表进行修改，如果对元组这样修改，代码会报错，就是因为可变对象和不可变对象的区别。<br>
在 <code>Python</code> 程序中，每个对象都会在内存中开辟一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。<br>
在编写代码时，定义的变量名实际是定义指向对象的地址引用名。<br>
我们定义一个列表时，变量名是列表的名字，这个名字指向内存中的一块空间。这个列表里有多个元素，表示这块内存空间中，保存着多个元素的引用。</p>
<ol>
<li>修改引用<br>
当修改列表的元素时，其实是修改列表中的引用。</li>
</ol>
<pre><code class="language-Python">list_a = [1, 2, 3]
list_a[2] = 30
print('list_a: ', list_a)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_a:  [1, 2, 30]
</code></pre>
<p>修改 <code>list_a</code> 中的第三个元素，其实是修改第三个元素的引用（这块内存指向的对象）。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323023647.png" alt="" loading="lazy"><br>
2. 引用传递（拷贝）<br>
当拷贝列表时，其实是拷贝列表中的引用。</p>
<pre><code class="language-Python">list_b = [1, 2, 3]
list_c = list_b.copy()
print('list_c: ', list_c)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_c:  [1, 2, 3]
</code></pre>
<p>拷贝 <code>list_b</code> 到 <code>list_c</code>，其实是给 <code>list_c</code> 新开辟一块内存，然后拷贝一份 <code>list_b</code> 的引用给 <code>list_c</code> ，并不是将 <code>list_b</code>指向的对象拷贝一份。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323023828.png" alt="" loading="lazy"><br>
这里不是将 <code>list_b</code> 赋值给 <code>list_c</code>，那样的结果是 <code>list_b</code> 指向 <code>[1, 2, 3]</code> ，<code>list_c</code> 指向 <code>list_b</code>，是引用关系，而不是拷贝关系。上面列举拷贝的方法时，没有将赋值列为拷贝方法，因为赋值是引用的传递，而不是拷贝。</p>
<ol>
<li>拷贝后修改引用（数据无嵌套）</li>
</ol>
<pre><code class="language-Python">import copy
list_b = [1, 2, 3]
list_c = copy.copy(list_b)
list_b[2] = 30
print('list_b: ', list_b)
print('list_c: ', list_c)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_b:  [1, 2, 30]
list_c:  [1, 2, 3]
</code></pre>
<p>使用 <code>copy.copy()</code> 方法拷贝 <code>list_b</code> 到 <code>list_c</code>，然后修改 <code>list_b</code> 中的引用关系，这样， <code>list_c</code> 不会被修改。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024031.png" alt="" loading="lazy"><br>
2. 嵌套列表的拷贝</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_e = copy.copy(list_d)
print('list_d: ', list_d)
print('list_e: ', list_e)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 3]]
list_e:  [1, [2, 3]]
</code></pre>
<p>对于嵌套的列表，拷贝 <code>list_d</code> 到 <code>list_e</code>，也是拷贝一份 <code>list_d</code> 的引用给 <code>list_e</code> ，与不嵌套的相同。<br>
这里需要特别注意，在浅拷贝嵌套的列表时，只会拷贝最上层的引用，对于子列表的引用，不会拷贝。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024211.png" alt="" loading="lazy"><br>
3. 拷贝的列表随原列表一起被修改</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_e = copy.copy(list_d)
list_d[1][1] = 30
print('list_d: ', list_d)
print('list_e: ', list_e)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 30]]
list_e:  [1, [2, 30]]
</code></pre>
<p>拷贝 <code>list_d</code> 到 <code>list_e</code>，由于没有拷贝子列表的引用 ，当修改子列时， <code>list_d</code> 和 <code>list_e</code> 都引用了子列表 <code>sub</code>，所以 <code>list_d</code> 和 <code>list_e</code>都会被修改。如下图：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024334.png" alt="" loading="lazy"><br>
拷贝数据后，修改其中一个，另一个也跟着被修改，原因就是浅拷贝中，只拷贝了最外层的引用。当修改内层的引用时，所有外层的引用不变，都会指向修改后的结果。<br>
两份数据都被修改，这就是浅拷贝中存在的问题，需要使用深拷贝来解决。<br>
4. 深拷贝保证数据不会被修改</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_f = copy.deepcopy(list_d)
list_d[1][1] = 30
print('list_d: ', list_d)
print('list_e: ', list_f)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 30]]
list_e:  [1, [2, 3]]
</code></pre>
<p>使用 <code>copy</code> 模块的 <code>deepcopy()</code> 方法，在拷贝数据时，会递归地拷贝数据中所有嵌套的引用。<br>
使用 <code>deepcopy()</code> 拷贝 <code>list_d</code> 到 <code>list_f</code> ，然后修改 <code>list_d</code> 中子列表的引用，不会对 <code>list_f</code> 产生影响，所以 <code>list_f</code> 不会被修改。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024515.png" alt="" loading="lazy"></p>
<h3 id="元组">元组</h3>
<ul>
<li>如果要定义一个空的tuple，可以写成()：</li>
</ul>
<pre><code class="language-Python">t = ()
print(t)
()
</code></pre>
<ul>
<li>但是，要定义一个只有1个元素的<code>tuple</code>，如果这么定义：</li>
</ul>
<pre><code class="language-Python">t = (1)
print(t)
1
</code></pre>
<p>定义的不是<code>tuple</code>，是<code>1</code>这个数！这是因为括号()既可以表示<code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>
所以，只有1个元素的<code>tuple</code>定义时必须加一个逗号,，来消除歧义：</p>
<pre><code class="language-Python">t = (1,)
print(t）
(1,)
</code></pre>
<p><code>Python</code>在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<ul>
<li>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</li>
</ul>
<pre><code class="language-Python">tup = tuple(['foo', [1, 2], True])
tup[1].append(3)
print(tup)
('foo', [1, 2, 3], True)
</code></pre>
<h4 id="拆分元组">拆分元组</h4>
<ul>
<li>使用特殊的语法<code>*rest</code>，函数签名中以抓取任意长度列表的位置参数：</li>
</ul>
<pre><code class="language-Python">values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a, b)
(1, 2)
print(rest)
[3, 4, 5]
</code></pre>
<ul>
<li><code>rest</code>的部分是想要舍弃的部分:</li>
</ul>
<pre><code class="language-Python">a, b, *_ = values
</code></pre>
<h4 id="tuple方法"><code>tuple</code>方法</h4>
<ul>
<li>统计值出现频率：</li>
</ul>
<pre><code class="language-Python">a = (1, 2, 2, 2, 3, 4, 2)
print(a.count(2))
4
</code></pre>
<h4 id="常用函数">常用函数</h4>
<ul>
<li><code>len(tuple)</code>:计算元组元素个数。</li>
<li><code>max(tuple)</code>:返回元组中元素最大值。</li>
<li><code>min(tuple)</code>:返回元组中元素最小值。</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="添加和删除元素">添加和删除元素</h4>
<ul>
<li><code>insert</code>在特定的位置插入元素：</li>
</ul>
<pre><code class="language-Python">b_list=['foo', 'bar', 'baz']
b_list.insert(1, 'red')
print(b_list)
['foo', 'red', 'peekaboo', 'baz', 'dwarf']
</code></pre>
<p>与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，使用<code>collections.deque</code>，一个双尾部队列。</p>
<ul>
<li><code>insert</code>的逆运算是<code>pop</code>，它移除并返回指定位置的元素,<code>pop()</code>默认删除最后一个元素：</li>
</ul>
<pre><code class="language-Python">print(b_list.pop(2))
'peekaboo'
print(b_list)
['foo', 'red', 'baz', 'dwarf']
</code></pre>
<ul>
<li><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</li>
</ul>
<pre><code class="language-Python">b_list.append('foo')
print(b_list)
['foo', 'red', 'baz', 'dwarf', 'foo']
b_list.remove('foo')
print(b_list)
['red', 'baz', 'dwarf', 'foo']
</code></pre>
<h4 id="串联和组合列表">串联和组合列表</h4>
<ul>
<li>可以用加号将两个列表串联起来,如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</li>
</ul>
<pre><code class="language-Python">x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>
<ul>
<li>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</li>
</ul>
<pre><code class="language-Python">#快
everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
#慢
everything = []
for chunk in list_of_lists:
    everything = everything + chunk
</code></pre>
<p>考虑下列代码片段：</p>
<pre><code class="language-Python">list = [ [ ] ] * 5
list  # output?
list[0].append(10)
list  # output?
list[1].append(20)
list  # output?
list.append(30)
list  # output?
</code></pre>
<p>2,4,6,8行将输出什么结果？试解释。<br>
输出的结果如下：</p>
<pre><code class="language-Python">[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>
<p>解释如下：<br>
第一行的输出结果直觉上很容易理解，例如 <code>list = [ [ ] ] * 5</code> 就是简单的创造了5个空列表。然而，理解表达式<code>list=[ [ ] ] * 5</code>的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个创建了包含对同一个列表五次引用的列表。只有了解了这一点，我们才能更好的理解接下来的输出结果。<br>
<code>list[0].append(10)</code> 将10附加在第一个列表上。<br>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：</p>
<pre><code class="language-Python">[[10], [10], [10], [10], [10]]
</code></pre>
<p>同理，<code>list[1].append(20)</code>将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：</p>
<pre><code class="language-Python">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
</code></pre>
<p>作为对比， <code>list.append(30)</code>是将整个新的元素附加在外列表上，因此产生的结果是： <code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</code>。</p>
<h4 id="排序">排序</h4>
<ul>
<li><code>sort</code>函数将一个列表原地排序（不创建新的对象）</li>
</ul>
<pre><code class="language-Python">a = [7, 2, 5, 1, 3]
a.sort()
print(a)
[1, 2, 3, 5, 7]
</code></pre>
<ul>
<li><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序<code>key</code>，可以用这个<code>key</code>进行排序。例如，我们可以按长度对字符串进行排序：</li>
</ul>
<pre><code class="language-Python">b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)
print(b)
['He', 'saw', 'six', 'small', 'foxes']
</code></pre>
<h4 id="二分搜索和维护已排序的列表">二分搜索和维护已排序的列表</h4>
<ul>
<li><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值:</li>
</ul>
<pre><code class="language-Python">import bisect
c = [1, 2, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 2))
4
print(bisect.bisect(c, 5))
6
print(bisect.insort(c, 6))
print(c)
[1, 2, 2, 2, 3, 4, 6, 7]
</code></pre>
<h4 id="zip函数">zip函数</h4>
<ul>
<li><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</li>
</ul>
<pre><code class="language-Python">seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
print(list(zipped))
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</code></pre>
<ul>
<li><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</li>
</ul>
<pre><code class="language-Python">seq3 = [False, True]
print(list(zip(seq1, seq2, seq3)))
[('foo', 'one', False), ('bar', 'two', True)]
</code></pre>
<ul>
<li><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</li>
</ul>
<pre><code class="language-Python">for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
0: foo, one
1: bar, two
2: baz, three
</code></pre>
<ul>
<li>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。</li>
</ul>
<pre><code class="language-Python">pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'),('Schilling', 'Curt')]
first_names, last_names = zip(*pitchers)
print(first_names)
('Nolan', 'Roger', 'Schilling')
print(last_names)
('Ryan', 'Clemens', 'Curt')
</code></pre>
<h4 id="reversed函数"><code>reversed</code>函数</h4>
<p><code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或<code>for</code>循环）之后才能创建翻转的序列。</p>
<pre><code class="language-Python">print(list(reversed(range(10))))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<h4 id="列表拷贝">列表拷贝</h4>
<ul>
<li><code>b=a[:]</code>。</li>
<li><code>b=list(a)</code>。</li>
<li>使用<code>copy.copy()</code>函数，或<code>b=a.copy()</code>直接复制<code>list</code>，类似<code>a[:]</code>。</li>
<li>使用<code>copy.deepcopy()</code>。<br>
使用<code>b=a</code>是完全引用，除了名字没区别</li>
</ul>
<h4 id="常用函数-2">常用函数</h4>
<ul>
<li><code>max(list)</code>:返回列表元素最大值</li>
<li><code>min(list)</code>:返回列表元素最小值</li>
<li><code>list.count(obj)</code>:统计某个元素在列表中出现的次数</li>
<li><code>list.extend(seq)</code>:在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li><code>list.index(obj)</code>:从列表中找出某个值第一个匹配项的索引位置</li>
<li><code>list.reverse()</code>:反向列表中元素</li>
</ul>
<h4 id="串联函数">串联函数</h4>
<pre><code class="language-Python">操作函数对象
def f():
    print('i\'m f')
def g():
    print('i\'m g')
[f,g][1]()
i'm g
</code></pre>
<h3 id="字典">字典</h3>
<ul>
<li>多种构造方法:</li>
</ul>
<pre><code class="language-Python">a = dict(one=1, two=2, three=3)
b = {'one':1, 'two':2, 'three':3}
c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
d = dict([('one', 1), ('two', 2), ('three', 3)])
e = dict({'three':3, 'one':1, 'two':2})
print(a)
print(b)
print(c)
print(d)
print(e)
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'three': 3, 'one': 1, 'two': 2}
print(a==b==c==d==e)
&gt;&gt;&gt;True
</code></pre>
<p>特别注意这种构造方法：</p>
<pre><code class="language-Python">t = {x:y for x in range(10) for y in range(10)}
print(t)
{0: 9, 1: 9, 2: 9, 3: 9, 4: 9, 5: 9, 6: 9, 7: 9, 8: 9, 9: 9}
</code></pre>
<pre><code class="language-Python">d = dict(name='Bob', age=20, score=88)
</code></pre>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-Python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个<code>Python</code>命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-Python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
print(d)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-Python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。<br>
要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-Python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<h4 id="删除值">删除值</h4>
<ul>
<li>用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</li>
</ul>
<pre><code class="language-Python">d1={'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer',5: 'some value','dummy': 'another value'}
del d1[5]
print(d1)
{'a': 'some value',
 'b': [1, 2, 3, 4],
 7: 'an integer',
 'dummy': 'another value'}
ret = d1.pop('dummy')
print(ret)
'another value'
print(d1)
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
</code></pre>
<ul>
<li>`popitem():返回并删除字典中的最后一对键和值。</li>
</ul>
<h4 id="更新字典">更新字典</h4>
<ul>
<li>用<code>update</code>方法可以将一个字典与另一个融合,<code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</li>
</ul>
<pre><code class="language-Python">d1.update({'b' : 'foo', 'c' : 12})
print(d1)
{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}
</code></pre>
<h4 id="用序列创建字典">用序列创建字典</h4>
<pre><code class="language-Python">mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value
</code></pre>
<ul>
<li>因为字典本质上是2元元组的集合，<code>dict</code>可以接受2元元组的列表：</li>
</ul>
<pre><code class="language-Python">mapping = dict(zip(range(5), reversed(range(5))))
print(mapping)
{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre>
<h4 id="默认值">默认值</h4>
<pre><code class="language-Python">if key in some_dict:
    value = some_dict[key]
else:
    value = default_value
</code></pre>
<ul>
<li><code>dict</code>的方法<code>get</code>和<code>pop</code>可以取默认值进行返回，上面的<code>if-else</code>语句可以简写成下面：</li>
</ul>
<pre><code class="language-Python">value = some_dict.get(key, default_value)
</code></pre>
<ul>
<li><code>get</code>默认会返回<code>None</code>，如果不存在键，<code>pop</code>会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</li>
</ul>
<pre><code class="language-Python">words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)
print(by_letter)
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
</code></pre>
<ul>
<li>使用<code>setdefault</code>方法：</li>
</ul>
<pre><code class="language-Python">for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
</code></pre>
<ul>
<li><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</li>
</ul>
<pre><code class="language-Python">from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
</code></pre>
<p>给定以下字典的子类，下面的代码能够运行么？为什么？</p>
<pre><code class="language-Python">class DefaultDict(dict):
  def __missing__(self, key):
    return []
d = DefaultDict()
d['florp'] = 127
</code></pre>
<p>能够运行。<br>
当<code>key</code>缺失时，执行<code>DefaultDict</code>类，字典的实例将自动实例化这个数列。</p>
<h4 id="有效的键类型">有效的键类型</h4>
<ul>
<li>字典的值可以是任意<code>Python</code>对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</li>
</ul>
<pre><code class="language-Python">print(hash('string'))
5023931463650008331
print(hash((1, 2, (2, 3))))
1097636502276347782
print(hash((1, 2, [2, 3]))) # fails because lists are mutable
---------------------------------------------------------------------------
TypeError                                 
Traceback (most recent call last)
&lt;iPython-input-129-800cd14ba8be&gt; in &lt;module&gt;()
----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable
TypeError: unhashable type: 'list'
</code></pre>
<h4 id="按键值排序">按键值排序</h4>
<ul>
<li>键：</li>
</ul>
<pre><code class="language-Python">sorted(dict.keys())
</code></pre>
<ul>
<li>值：</li>
</ul>
<pre><code class="language-Python">sorted(dict.items(),key=lamda:item:item[1])
</code></pre>
<h3 id="集合">集合</h3>
<ul>
<li>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过<code>set</code>函数或使用尖括号<code>set</code>语句：</li>
</ul>
<pre><code class="language-Python">print(set([2, 2, 2, 1, 3, 3]))
{1, 2, 3}
print({2, 2, 2, 1, 3, 3})
{1, 2, 3}
</code></pre>
<ul>
<li>通过<code>add(key)</code>方法可以添加元素到set中</li>
<li>通过<code>remove(key)</code>方法可以删除元素：</li>
<li>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</li>
</ul>
<pre><code class="language-Python">a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a.union(b))
{1, 2, 3, 4, 5, 6, 7, 8}
print(a | b)
{1, 2, 3, 4, 5, 6, 7, 8}
</code></pre>
<ul>
<li>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</li>
</ul>
<pre><code class="language-Python">print(a.intersection(b))
{3, 4, 5}
print(a &amp; b)
{3, 4, 5}
</code></pre>
<ul>
<li>
<p>常用集合方法</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317202703.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
</li>
</ul>
<pre><code class="language-Python">c = a.copy()
c |= b
print(c)
{1, 2, 3, 4, 5, 6, 7, 8}
d = a.copy()
d &amp;= b
print(d)
{3, 4, 5}
</code></pre>
<ul>
<li>检测一个集合是否是另一个集合的子集或父集：</li>
</ul>
<pre><code class="language-Python">a_set = {1, 2, 3, 4, 5}
print({1, 2, 3}.issubset(a_set))
True
print(a_set.issuperset({1, 2, 3}))
True
</code></pre>
<h3 id="列表-集合和字典推导式">列表、集合和字典推导式</h3>
<pre><code class="language-Python">[expr for val in collection if condition]
</code></pre>
<p>等同于：</p>
<pre><code class="language-Python">result = []
for val in collection:
    if condition:
        result.append(expr)
</code></pre>
<ul>
<li>字典:</li>
</ul>
<pre><code class="language-Python">dict_comp = {key-expr : value-expr for value in collection if condition}
</code></pre>
<ul>
<li>集合</li>
</ul>
<pre><code class="language-Python">set_comp = {expr for value in collection if condition}
</code></pre>
<ul>
<li><code>map</code>函数可以进一步简化：</li>
</ul>
<pre><code class="language-Python">print(set(map(len, strings)))
{1, 2, 3, 4, 6}
</code></pre>
<h4 id="嵌套列表推导式">嵌套列表推导式</h4>
<pre><code class="language-Python">all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'],['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]
names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') &gt;= 2]
    names_of_interest.extend(enough_es)
</code></pre>
<p>嵌套列表推导式：</p>
<pre><code class="language-Python">result = [name for names in all_data for name in names if name.count('e') &gt;= 2]
print(result)
result=['Steven']
</code></pre>
<p>以下代码正常输出偶数：</p>
<pre><code class="language-Python">[x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
</code></pre>
<p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p>
<pre><code class="language-Python">[x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？<br>
另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p>
<pre><code class="language-Python">[x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>:</p>
<pre><code class="language-Python">[x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。<br>
可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<pre><code class="language-Python">print([[x for x in tup] for tup in some_tuples])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<h3 id="函数">函数</h3>
<h4 id="参数">参数</h4>
<ul>
<li><code>Python</code>函数参数既不是传参也不是传引用。应该称其为传对象引用,如果是数字，字符串，元组则传值,如果是列表，字典则传址。对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容:</li>
</ul>
<pre><code class="language-Python">def append_element(some_list, element):
    some_list.append(element)
data = [1, 2, 3]
append_element(data, 4)
print(data)
[1, 2, 3, 4]
</code></pre>
<pre><code class="language-Python">def func(d):
    d['a'] = 10
    d['b'] = 20            
    d = {'a': 1, 'b': 2}


d = {}                    # 1
func(d)                   # 2
print(d)
########打印结果########
{'a': 10, 'b': 20}
</code></pre>
<p>想一想, 最后的结果为什么还是<code>{'a': 10, 'b': 20}</code>?<br>
首先在全局创建一个空字典,并将<code>d</code>贴上:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/v2-5d4d7a9c04d8feac54b3350d8c5b1435_1440w.jpg" alt="" loading="lazy"><br>
将 <code>d</code> 传入到函数<code>func</code>中,在函数中局部的形参变量也为<code>d</code>,它同样贴在空字典对象上<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174500.png" alt="" loading="lazy"><br>
在函数中前两句,为字典赋值.因为字典是可变的,这一操作对全局的 <code>d</code> 也会产生同样的影响.因为此时全局的<code>d</code>与函数内部的<code>d</code>贴向的是同一个对象<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174540.png" alt="" loading="lazy"><br>
函数最后一句,本质上是将函数内部的<code>d</code>贴向另外一个字典对象,全局的<code>d</code>当然还是贴向原来的字典对象.<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174823.png" alt="" loading="lazy"><br>
函数结束,函数内部的<code>d</code>被回收,而且最后打印结果如下所示<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174908.png" alt="" loading="lazy"></p>
<ul>
<li>函数可以有一些位置参数(<code>positional</code>)和一些关键字参数(<code>keyword</code>)。关键字参数通常用于指定默认值或可选参数</li>
</ul>
<h4 id="默认参数">默认参数</h4>
<pre><code class="language-Python">i = 1
def test(a=i):
    print(a)

i = 2
test()  # 1
</code></pre>
<p>由于参数默认值是在函数定义时而不是函数执行时确定的，所以这段代码<code>test</code>方法的参数默认值时<code>1</code>而不是<code>2</code>。</p>
<pre><code class="language-Python">def add_end(L=[]):
    L.append('END')
    return L
print(add_end())
['END']
print(add_end())
['END', 'END']
</code></pre>
<ul>
<li>Python函数在定义的时候，默认参数L的值就被计算出来了，即<code>[]</code>，因为默认参数L也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。<br>
<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></li>
<li>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</li>
</ul>
<pre><code class="language-Python">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>举例：</p>
<pre><code class="language-Python">def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')

print &quot;list1 = %s&quot; % list1
print &quot;list2 = %s&quot; % list2
print &quot;list3 = %s&quot; % list3

list1 = [10, 'a']
list2 = [123]
list3 = [10, 'a']
</code></pre>
<p>很多人都会误认为<code>list1=[10]</code>，<code>list3=[‘a’]</code>,因为他们以为每次<code>extendList</code>被调用时，列表参数的默认值都将被设置为<code>[]</code>.但实际上的情况是，新的默认列表只在函数被定义的那一刻创建一次。<br>
当<code>extendList</code>被没有指定特定参数<code>list</code>调用时，这组<code>list</code>的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。因此<code>list1</code>和<code>list3</code>是在同一个默认列表上进行操作（计算）的。而<code>list2</code>是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。<br>
<code>extendList</code>的定义可以作如下修改。<br>
尽管，创建一个新的列表，没有特定的列表参数。<br>
下面这段代码可能能够产生想要的结果。</p>
<pre><code class="language-Python">def extendList(val, list=None):
  if list is None:
    list = []
  list.append(val)
  return list
</code></pre>
<p>通过上面的修改，输出结果将变成：</p>
<pre><code class="language-Python">list1 = [10]
list2 = [123]
list3 = ['a']
</code></pre>
<ul>
<li>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。<br>
默认参数的值应该是不可变的对象，比如<code>None</code>、<code>True</code>、<code>False</code>、数字或字符串。 特别的，千万不要像下面这样写代码：</li>
</ul>
<pre><code class="language-python">def spam(a, b=[]): # NO!
    ...
</code></pre>
<p>如果你这么做了，当默认值在其他地方被修改后你将会遇到各种麻烦。这些修改会影响到下次调用这个函数时的默认值。比如：</p>
<pre><code class="language-python">def spam(a, b=[]):
    print(b)
    return b
x = spam(1)
x
[]
x.append(99)
x.append('Yow!')
x
[99, 'Yow!']
spam(1) # Modified list gets returned!
[99, 'Yow!']
</code></pre>
<p>这种结果应该不是你想要的。为了避免这种情况的发生，最好是将默认值设为<code>None</code>， 然后在函数里面检查它，前面的例子就是这样做的。<br>
在测试<code>None</code>值时使用 <code>is</code> 操作符是很重要的，也是这种方案的关键点。 有时候大家会犯下下面这样的错误：</p>
<pre><code class="language-python">def spam(a, b=None):
    if not b: # NO! Use 'b is None' instead
        b = []
</code></pre>
<p>这么写的问题在于尽管<code>None</code>值确实是被当成<code>False</code>， 但是还有其他的对象(比如长度为<code>0</code>的字符串、列表、元组、字典等)都会被当做<code>False</code>。 因此，上面的代码会误将一些其他输入也当成是没有输入。比如：</p>
<pre><code class="language-python">spam(1) # OK
x = []
spam(1, x) # Silent error. x value overwritten by default
spam(1, 0) # Silent error. 0 ignored
spam(1, '') # Silent error. '' ignored
</code></pre>
<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如<code>None</code>、 <code>0</code>或者<code>False</code>值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。<br>
为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的<code>_no_value</code>变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个<code>_no_value</code>实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。<br>
这里对 <code>object()</code> 的使用看上去有点不太常见。<code>object</code> 是<code>python</code>中所有类的基类。 你可以创建 <code>object</code> 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>
<h4 id="可变参数">可变参数</h4>
<pre><code class="language-Python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括<code>0</code>个参数。<br>
如果已经有一个<code>list</code>或者<code>tuple</code>：</p>
<pre><code class="language-Python">nums = [1, 2, 3]
print(calc(*nums))
14
</code></pre>
<h4 id="关键字参数">关键字参数</h4>
<ul>
<li>关键字参数允许你传入<code>0</code>个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</li>
</ul>
<pre><code class="language-Python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</li>
</ul>
<pre><code class="language-Python">person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<ul>
<li>也可以传入任意个数的关键字参数：</li>
</ul>
<pre><code class="language-Python">person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p>关键字参数可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<br>
和可变参数类似，也可以先组装出一个<code>dict</code>，然后，把该<code>dict</code>转换为关键字参数传进去：</p>
<pre><code class="language-Python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>上面复杂的调用可以用简化的写法：</p>
<pre><code>extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把<code>extra</code>这个<code>dict</code>的所有<code>key-value</code>用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个<code>dict</code>，注意``kw<code>获得的</code>dict<code>是</code>extra<code>的一份拷贝，对</code>kw<code>的改动不会影响到函数外的</code>extra`。</p>
<h4 id="命名关键字参数">命名关键字参数</h4>
<ul>
<li>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。<br>
仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</li>
</ul>
<pre><code class="language-Python">def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>和关键字参数<code>**kw不同</code>，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>
调用方式如下：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<ul>
<li>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<ul>
<li>由于调用时缺少参数名<code>city</code>和<code>job</code>，<code>Python</code>解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。<br>
命名关键字参数可以有缺省值，从而简化调用：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，<code>Python</code>解释器将无法识别位置参数和命名关键字参数：</li>
</ul>
<pre><code class="language-Python">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h4 id="强制位置参数">强制位置参数</h4>
<p><code>Python3.8</code> 新增了一个函数形参语法<code>/</code>用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。<br>
在以下的例子中，形参 <code>a</code> 和 <code>b</code> 必须使用指定位置参数，<code>c</code> 或 <code>d</code> 可以是位置形参或关键字形参，而 <code>e</code> 或 <code>f</code> 要求为关键字形参:</p>
<pre><code class="language-Python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>
<p>以下使用方法是正确的:</p>
<pre><code class="language-Python">f(10, 20, 30, d=40, e=50, f=60)
</code></pre>
<p>以下使用方法会发生错误:</p>
<pre><code class="language-Python">f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
</code></pre>
<h4 id="参数组合">参数组合</h4>
<ul>
<li>在<code>Python</code>中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</li>
</ul>
<pre><code class="language-Python">def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<ul>
<li>在函数调用的时候，<code>Python</code>解释器自动按照参数位置和参数名把对应的参数传进去。</li>
</ul>
<pre><code class="language-Python">f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<ul>
<li>通过一个<code>tuple</code>和<code>dict</code>，你也可以调用上述函数：</li>
</ul>
<pre><code class="language-Python">args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<ul>
<li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。<br>
<strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
<li>示例：<br>
<code>Python</code>五类参数：位置参数，关键字参数，默认参数，可变位置或关键字参数的使用。</li>
</ul>
<pre><code class="language-Python">def f(a,*b,c=10,**d):
  print(f'a:{a},b:{b},c:{c},d:{d}')
</code></pre>
<p>默认参数<code>c</code>不能位于可变关键字参数<code>d</code>后.<br>
调用<code>f</code>:</p>
<pre><code class="language-Python">f(1,2,5,width=10,height=20)
a:1,b:(2, 5),c:10,d:{'width': 10, 'height': 20}
</code></pre>
<p>可变位置参数<code>b</code>实参后被解析为元组<code>(2,5)</code>;而<code>c</code>取得默认值10; <code>d</code>被解析为字典.</p>
<p>再次调用<code>f</code>:</p>
<pre><code class="language-Python">f(a=1,c=12)
a:1,b:(),c:12,d:{}
</code></pre>
<p><code>a=1</code>传入时<code>a</code>就是关键字参数，<code>b</code>,<code>d</code>都未传值，<code>c</code>被传入12，而非默认值。<br>
注意观察参数<code>a</code>, 既可以<code>f(1)</code>,也可以<code>f(a=1)</code> 其可读性比第一种更好，建议使用<code>f(a=1)</code>。如果要强制使用<code>f(a=1)</code>，需要在前面添加一个星号:</p>
<pre><code class="language-Python">def f(*,a,*b):
  print(f'a:{a},b:{b}')
</code></pre>
<p>此时<code>f(1)</code>调用，将会报错：<code>TypeError: f() takes 0 positional arguments but 1 was given</code><br>
只能<code>f(a=1)</code>才能<code>OK</code>.</p>
<p>说明前面的<code>*</code>发挥作用，它变为只能传入关键字参数，那么如何查看这个参数的类型呢？借助<code>Python</code>的<code>inspect</code>模块：</p>
<pre><code class="language-Python">for name,val in signature(f).parameters.items():
    print(name,val.kind)
a KEYWORD_ONLY
b VAR_KEYWORD
</code></pre>
<p>可看到参数<code>a</code>的类型为<code>KEYWORD_ONLY</code>，也就是仅仅为关键字参数。<br>
但是，如果<code>f</code>定义为：</p>
<pre><code class="language-Python">def f(a,*b):
  print(f'a:{a},b:{b}')
</code></pre>
<p>查看参数类型：</p>
<p>In [24]: for name,val in signature(f).parameters.items():<br>
...:     print(name,val.kind)<br>
...:<br>
a POSITIONAL_OR_KEYWORD<br>
b VAR_POSITIONAL<br>
可以看到参数a既可以是位置参数也可是关键字参数。</p>
<h4 id="匿名lambda函数">匿名(lambda)函数</h4>
<ul>
<li><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然<code>lambda</code>函数看起来只能写一行，却不等同于<code>C</code>或<code>C++</code>的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<pre><code class="language-Python">strings = ['foo', 'card', 'bar', 'aaaa', 'abab']
strings.sort(key=lambda x: len(set(list(x))))
print(strings)
['aaaa', 'foo', 'abab', 'bar', 'card']
</code></pre>
<p>先看下下面代码的效果：</p>
<pre><code class="language-python">x = 10
a = lambda y: x + y
x = 20
b = lambda y: x + y
print(a(10),b(10))
</code></pre>
<p>现在我问你，<code>a(10)</code>和<code>b(10)</code>返回的结果是什么？如果你认为结果是<code>20</code>和<code>30</code>，那么你就错了：</p>
<pre><code class="language-python">a(10)
30
b(10)
30
</code></pre>
<p>这其中的奥妙在于<code>lambda</code>表达式中的<code>x</code>是一个自由变量， 在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。 因此，在调用这个lambda表达式的时候，<code>x</code>的值是执行时的值。例如：</p>
<pre><code class="language-python">x = 15
a(10)
25
x = 3
a(10)
13
</code></pre>
<p>如果你想让某个匿名函数在定义时就捕获到值，可以将那个参数值定义成默认参数即可，就像下面这样：</p>
<pre><code class="language-python">x = 10
a = lambda y, x=x: x + y
x = 20
b = lambda y, x=x: x + y
a(10)
20
b(10)
30
&gt;&gt;&gt;
在这里列出来的问题是新手很容易犯的错误，有些新手可能会不恰当的使用`lambda`表达式。 比如，通过在一个循环或列表推导中创建一个`lambda`表达式列表，并期望函数能在定义时就记住每次的迭代值。例如：
```python
funcs = [lambda x: x+n for n in range(5)]
for f in funcs:
    print(f(0))
4
4
4
4
4
</code></pre>
<p>但是实际效果是运行是<code>n</code>的值为迭代的最后一个值。现在我们用另一种方式修改一下：</p>
<pre><code class="language-python">funcs = [lambda x, n=n: x+n for n in range(5)]
for f in funcs:
    print(f(0))
0
1
2
3
4
</code></pre>
<p>通过使用函数默认值参数形式，<code>lambda</code>函数在定义时就能绑定到值。</p>
<h4 id="柯里化部分参数应用">柯里化：部分参数应用</h4>
<ul>
<li>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数:</li>
</ul>
<pre><code class="language-Python">def add_numbers(x, y):
    return x + y
add_five = lambda y: add_numbers(5, y)
</code></pre>
<p><code>add_numbers</code>的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的<code>functools</code>模块可以用<code>partial</code>函数将此过程简化：</p>
<pre><code class="language-Python">from functools import partial
add_five = partial(add_numbers, 5)
</code></pre>
<h4 id="生成器">生成器</h4>
<ul>
<li>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是<code>Python</code>的一个重要特点。这是通过一种叫做迭代器协议(<code>iterator protocol</code>，它是一种使对象可迭代的通用方式)的方式实现的，一个原生的使对象可迭代的方法。</li>
<li>生成器(<code>generator</code>)是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的<code>return</code>替换为<code>yeild</code>即可：</li>
</ul>
<pre><code class="language-Python">def squares(n=10):
    print('Generating squares from 1 to {0}'.format(n ** 2))
    for i in range(1, n + 1):
        yield i ** 2
</code></pre>
<ul>
<li>调用该生成器时，没有任何代码会被立即执行：</li>
</ul>
<pre><code class="language-Python">gen = squares()
print(gen)
&lt;generator object squares at 0x7fbbd5ab4570&gt;
</code></pre>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<pre><code class="language-Python">for x in gen:
    print(x, end=' ')
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100
</code></pre>
<p>在一个对象上实现迭代最简单的方式是使用一个生成器函数。使用<code>Node</code>类来表示树形数据结构。你可能想实现一个以深度优先方式遍历树形节点的生成器。 下面是代码示例：</p>
<pre><code class="language-python">class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()
# Example
if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)
    # Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
</code></pre>
<p>在这段代码中，<code>depth_first()</code> 方法简单直观。 它首先返回自己本身并迭代每一个子节点并通过调用子节点的 <code>depth_first()</code> 方法(使用 <code>yield from</code> 语句)返回对应元素。</p>
<h4 id="生成器表达式">生成器表达式</h4>
<p>另一种更简洁的构造生成器的方法是使用生成器表达式(<code>generator expression</code>)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：</p>
<pre><code class="language-Python">gen = (x ** 2 for x in range(100))
print(gen)
&lt;generator object &lt;genexpr&gt; at 0x7fbbd5ab29e8&gt;
</code></pre>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<pre><code class="language-Python">def _make_gen():
    for x in range(100):
        yield x ** 2
gen = _make_gen()
</code></pre>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<pre><code class="language-Python">print(sum(x ** 2 for x in range(100)))
328350
print(dict((i, i **2) for i in range(5)))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>
<h4 id="迭代器">迭代器</h4>
<ul>
<li>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。<br>
可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</li>
</ul>
<pre><code class="language-Python">from collections.abc import Iterator
isinstance((x for x in range(10)), Iterator)
True
isinstance([], Iterator)
False
isinstance({}, Iterator)
False
isinstance('abc', Iterator)
False
</code></pre>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<pre><code class="language-Python">isinstance(iter([]), Iterator)
True
isinstance(iter('abc'), Iterator)
True
</code></pre>
<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>
<p>这是因为<code>Python</code>的<code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>
<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用<code>list</code>是永远不可能存储全体自然数的。</p>
<h5 id="类作为迭代器">类作为迭代器</h5>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。<br>
如果你已经了解的面向对象编程，就知道类都有一个构造函数，<code>Python</code> 的构造函数为 <code>__init__()</code>, 它会在对象初始化的时候执行。<br>
<code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。<br>
<code>__next__()</code> 方法(<code>Python 2</code> 里是 <code>next()</code>)会返回下一个迭代器对象。<br>
创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code class="language-Python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
1
2
3
4
5
</code></pre>
<p><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。<br>
在 20 次迭代后停止执行：</p>
<pre><code>class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
  print(x)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre>
<h5 id="通过字符串调用对象方法">通过字符串调用对象方法</h5>
<p>最简单的情况，可以使用 <code>getattr()</code> ：</p>
<pre><code class="language-python">import math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Point({!r:},{!r:})'.format(self.x, self.y)

    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

p = Point(2, 3)
d = getattr(p, 'distance')(0, 0)  # Calls p.distance(0, 0)
</code></pre>
<p>调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用。 因此，为了调用某个方法，你可以首先通过 <code>getattr()</code> 来查找到这个属性，然后再去以函数方式调用它即可。</p>
<h4 id="函数式编程">函数式编程</h4>
<h5 id="高阶函数">高阶函数</h5>
<h6 id="map函数"><code>map</code>函数</h6>
<ul>
<li><code>map()</code> 会根据提供的函数对指定序列做映射。第一个参数 <code>function</code> 以参数序列中的每一个元素调用 <code>function</code> 函数，返回包含每次 <code>function</code> 函数返回值的新列表。</li>
</ul>
<pre><code class="language-Python">map(function, iterable, ...)
</code></pre>
<ul>
<li><code>function</code>:函数</li>
<li><code>iterable</code>:一个或多个序列</li>
</ul>
<pre><code class="language-Python">def square(x) :            # 计算平方数
    return x ** 2
print(map(square, [1,2,3,4,5]))   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
# 提供了两个列表，对相同位置的列表数据进行相加
print(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
</code></pre>
<h6 id="reduce函数"><code>reduce</code>函数</h6>
<ul>
<li><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是:</li>
</ul>
<pre><code class="language-Python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数13579，reduce就可以派上用场：</p>
<pre><code class="language-Python">from functools import reduce
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))
13579
</code></pre>
<p>考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<pre><code class="language-Python">from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<h6 id="filter函数"><code>filter</code>函数</h6>
<ul>
<li><code>Python</code>内建的<code>filter()</code>函数用于过滤序列。<br>
和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。<br>
注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回<code>list</code>。<br>
筛法求素数：</li>
</ul>
<pre><code>def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
def _not_divisible(n):
    return lambda x: x % n &gt; 0
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<h6 id="sorted函数"><code>sorted</code>函数</h6>
<ul>
<li><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</li>
</ul>
<pre><code class="language-Python">print(sorted([7, 1, 2, 6, 0, 3, 2]))
[0, 1, 2, 2, 3, 6, 7]
print(sorted('horse race'))
[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']
</code></pre>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<pre><code class="language-Python">sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>进行反向排序，不必改动<code>key</code>函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-Python">sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h5 id="返回函数">返回函数</h5>
<pre><code class="language-Python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="language-Python">f = lazy_sum(1, 3, 5, 7, 9)
f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code class="language-Python">f()
25
</code></pre>
<p>函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p>
<h6 id="闭包">闭包</h6>
<ul>
<li>返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</li>
</ul>
<pre><code class="language-Python">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>
你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是1，4，9，但实际结果是：</p>
<pre><code class="language-Python">f1()
9
f2()
9
f3()
9
</code></pre>
<p>全部都是9！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了3，因此最终结果为9。<br>
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>
<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-Python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<pre><code class="language-Python"> f1, f2, f3 = count()
f1()
1
f2()
4
f3()
9
</code></pre>
<pre><code class="language-Python">下面这段代码的输出结果将是什么？请解释。
```Python
def multipliers():
  return [lambda x : i * x for i in range(4)]
print [m(2) for m in multipliers()]
</code></pre>
<p>你如何修改上面的<code>multipliers</code>的定义产生想要的结果？<br>
上面代码输出的结果是<code>[6, 6, 6, 6]</code>(不是我们想的<code>[0, 2, 4, 6]</code>)。<br>
上述问题产生的原因是<code>Python</code>闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。因此，当任何由<code>multipliers()</code>返回的函数被调用时，<code>i</code>的值将在附近的范围进行查找。那时，不管返回的函数是否被调用，for循环已经完成，<code>i</code>被赋予了最终的值3。<br>
因此，每次返回的函数乘以传递过来的值3，因为上段代码传过来的值是2，它们最终返回的都是6(3*2)。碰巧的是，《The Hitchhiker’s Guide to Python》也指出，在与<code>lambdas</code>函数相关也有一个被广泛被误解的知识点，不过跟这个<code>case</code>不一样。由<code>lambda</code>表达式创造的函数没有什么特殊的地方，它其实是和def创造的函数式一样的。<br>
下面是解决这一问题的一些方法。<br>
一种解决方法就是用<code>Python</code>生成器。</p>
<pre><code class="language-Python">def multipliers():
  for i in range(4): yield lambda x : i * x
</code></pre>
<p>另外一个解决方案就是创造一个闭包，利用默认函数立即绑定。</p>
<pre><code class="language-Python">def multipliers():
  return [lambda x, i=i : i * x for i in range(4)]
</code></pre>
<p>还有种替代的方案是，使用偏函数：</p>
<pre><code class="language-Python">from functools import partial
from operator import mul
def multipliers():
  return [partial(mul, i) for i in range(4)]
</code></pre>
<p>通常来讲，闭包的内部变量对于外界来讲是完全隐藏的。 但是，你可以通过编写访问函数并将其作为函数属性绑定到闭包上来实现这个目的。例如：</p>
<pre><code class="language-python">def sample():
    n = 0
    # Closure function
    def func():
        print('n=', n)

    # Accessor methods for n
    def get_n():
        return n

    def set_n(value):
        nonlocal n
        n = value

    # Attach as function attributes
    func.get_n = get_n
    func.set_n = set_n
    return func
</code></pre>
<p>下面是使用的例子:</p>
<pre><code class="language-python">f = sample()
f()
n= 0
f.set_n(10)
f()
n= 10
f.get_n()
10
</code></pre>
<p>讨论<br>
为了说明清楚它如何工作的，有两点需要解释一下。首先，<code>nonlocal</code> 声明可以让我们编写函数来修改内部变量的值。</p>
<h5 id="装饰器">装饰器</h5>
<ul>
<li>在代码运行期间动态增加功能的方式，称之为“装饰器”(<code>Decorator</code>)。<br>
本质上，<code>decorator</code>就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的<code>decorator</code>，可以定义如下：</li>
</ul>
<pre><code class="language-Python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
now()
call now():
2015-3-25
</code></pre>
<p>由于<code>log()</code>是一个<code>decorator</code>，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。<br>
<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。<br>
如果<code>decorator</code>本身需要传入参数，那就需要编写一个返回<code>decorator</code>的高阶函数，写出来会更复杂。比如，要自定义<code>log</code>的文本：</p>
<pre><code class="language-Python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
@log('execute')
def now():
    print('2015-3-25')
now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="language-Python">now = log('execute')(now)
</code></pre>
<p>首先执行<code>log('execute')</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p>
<p>以上两种<code>decorator</code>的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过<code>decorator</code>装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>：</p>
<pre><code class="language-Python">now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个<code>wrapper()</code>函数名字就是<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，<code>Python</code>内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的<code>decorator</code>的写法如下：</p>
<pre><code class="language-pythoh">import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的<code>decorator</code>：</p>
<pre><code>import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>在面向对象(OOP)的设计模式中，<code>decorator</code>被称为装饰模式。<code>OOP</code>的装饰模式需要通过继承和组合来实现，而<code>Python</code>除了能支持<code>OOP</code>的<code>decorator</code>外，直接从语法层次支持<code>decorator</code>。<code>Python</code>的<code>decorator</code>可以用函数实现，也可以用类实现。<br>
<code>decorator</code>可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h6 id="property"><code>@property</code></h6>
<p><code>Python</code>内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<pre><code class="language-Python">class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="language-Python">s = Student()
s.score = 60 # OK，实际转化为s.set_score(60)
s.score # OK，实际转化为s.get_score()
60
s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过<code>getter</code>和<code>setter</code>方法来实现的。<br>
还可以定义只读属性，只定义<code>getter</code>方法，不定义<code>setter</code>方法就是一个只读属性：</p>
<pre><code class="language-Python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。<br>
自定义某个属性的一种简单方法是将它定义为一个<code>property</code>。 例如，下面的代码定义了一个<code>property</code>，增加对一个属性简单的类型检查：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)
</code></pre>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 <code>getter</code> 函数，它使得 <code>first_name</code> 成为一个属性。 其他两个方法给 <code>first_name</code> 属性添加了 <code>setter</code> 和 <code>deleter</code> 函数。 需要强调的是只有在 <code>first_name</code> 属性被创建后， 后面的两个装饰器 <code>@first_name.setter</code> 和 <code>@first_name.deleter</code> 才能被定义。<br>
<code>property</code>的一个关键特征是它看上去跟普通的<code>attribute</code>没什么两样， 但是访问它的时候会自动触发 <code>getter</code> 、<code>setter</code> 和 <code>deleter</code> 方法。例如：</p>
<pre><code class="language-python">a = Person('Guido')
a.first_name # Calls the getter
'Guido'
a.first_name = 42 # Calls the setter
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;prop.py&quot;, line 14, in first_name
        raise TypeError('Expected a string')
TypeError: Expected a string
del a.first_name
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can`t delete attribute
</code></pre>
<p>在实现一个<code>property</code>的时候，底层数据(如果有的话)仍然需要存储在某个地方。 因此，在<code>get</code>和<code>set</code>方法中，你会看到对 <code>_first_name</code> 属性的操作，这也是实际数据保存的地方。 另外，你可能还会问为什么 <code>__init__()</code> 方法中设置了 <code>self.first_name</code> 而不是 <code>self._first_name</code> 。 在这个例子中，我们创建一个<code>property</code>的目的就是在设置<code>attribute</code>的时候进行检查。 因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code>self.first_name</code> ，自动调用 <code>setter</code> 方法， 这个方法里面会进行参数的检查，否则就是直接访问 <code>self._first_name</code> 了。<br>
还能在已存在的<code>get</code>和<code>set</code>方法基础上定义<code>property</code>。例如：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)
</code></pre>
<p>一个<code>property</code>属性其实就是一系列相关绑定方法的集合。如果你去查看拥有<code>property</code>的类， 就会发现<code>property</code>本身的<code>fget</code>、<code>fset</code>和<code>fdel</code>属性就是类里面的普通方法。比如：</p>
<pre><code class="language-python">Person.first_name.fget
&lt;function Person.first_name at 0x1006a60e0&gt;
Person.first_name.fset
&lt;function Person.first_name at 0x1006a6170&gt;
Person.first_name.fdel
&lt;function Person.first_name at 0x1006a62e0&gt;
</code></pre>
<p>通常来讲，你不会直接取调用<code>fget</code>或者<code>fset</code>，它们会在访问<code>property</code>的时候自动被触发。<br>
只有当你确实需要对<code>attribute</code>执行其他额外的操作的时候才应该使用到<code>property</code>。 有时候一些从其他编程语言(比如<code>Java</code>)过来的程序员总认为所有访问都应该通过<code>getter</code>和<code>setter</code>， 所以他们认为代码应该像下面这样写：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
</code></pre>
<p>不要写这种没有做任何其他额外操作的<code>property</code>。 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。 其次，它还会让你的程序运行起来变慢很多。 最后，这样的设计并没有带来任何的好处。 特别是当你以后想给普通<code>attribute</code>访问添加额外的处理逻辑的时候， 你可以将它变成一个<code>property</code>而无需改变原来的代码。 因为访问<code>attribute</code>的代码还是保持原样。<br>
<code>Properties</code>还是一种定义动态计算<code>attribute</code>的方法。 这种类型的<code>attributes</code>并不会被实际的存储，而是在需要的时候计算出来。比如：</p>
<pre><code class="language-python">import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

    @property
    def diameter(self):
        return self.radius * 2

    @property
    def perimeter(self):
        return 2 * math.pi * self.radius
</code></pre>
<p>在这里，我们通过使用<code>properties</code>，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的<code>attribute</code>是一样的。 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。 下面是使用的实例：</p>
<pre><code class="language-python">c = Circle(4.0)
c.radius
4.0
c.area  # Notice lack of ()
50.26548245743669
c.perimeter  # Notice lack of ()
25.132741228718345
</code></pre>
<p>尽管<code>properties</code>可以实现优雅的编程接口，但有些时候你还是会想直接使用<code>getter</code>和<code>setter</code>函数。例如：</p>
<pre><code class="language-python">p = Person('Guido')
p.get_first_name()
'Guido'
p.set_first_name('Larry')
</code></pre>
<p>这种情况的出现通常是因为<code>Python</code>代码被集成到一个大型基础平台架构或程序中。 例如，有可能是一个<code>Python</code>类准备加入到一个基于远程过程调用的大型分布式系统中。 这种情况下，直接使用<code>get/set</code>方法(普通方法调用)而不是<code>property</code>或许会更容易兼容。<br>
最后一点，不要像下面这样写有大量重复代码的<code>property</code>定义：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Repeated property code, but for a different name (bad!)
    @property
    def last_name(self):
        return self._last_name

    @last_name.setter
    def last_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._last_name = value
</code></pre>
<p>重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。<br>
在子类中，扩展定义在父类中的<code>property</code>的功能。考虑如下的代码，它定义了一个<code>property</code>：</p>
<pre><code class="language-python">class Person:
    def __init__(self, name):
        self.name = name

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)
</code></pre>
<p>下面是一个示例类，它继承自<code>Person</code>并扩展了 <code>name</code> 属性的功能：</p>
<pre><code class="language-python">class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>
<p>接下来使用这个新类：</p>
<pre><code class="language-python">s = SubPerson('Guido')
Setting name to Guido
s.name
Getting name
'Guido'
s.name = 'Larry'
Setting name to Larry
s.name = 42
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 16, in name
        raise TypeError('Expected a string')
TypeError: Expected a string
</code></pre>
<p>如果你仅仅只想扩展<code>property</code>的某一个方法，那么可以像下面这样写：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>或者，你只想修改<code>setter</code>方法，就这么写：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)
</code></pre>
<p>在子类中扩展一个<code>property</code>可能会引起很多不易察觉的问题， 因为一个<code>property</code>其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的集合，而不是单个方法。 因此，当你扩展一个<code>property</code>的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个。<br>
在第一个例子中，所有的<code>property</code>方法都被重新定义。 在每一个方法中，使用了 <code>super()</code> 来调用父类的实现。 在 <code>setter</code> 函数中使用 <code>super(SubPerson, SubPerson).name.__set__(self, value)</code> 的语句是没有错的。 为了委托给之前定义的<code>setter</code>方法，需要将控制权传递给之前定义的<code>name</code>属性的 <code>__set__()</code> 方法。 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。 这也是为什么我们要使用 <code>super(SubPerson, SubPerson)</code> 的原因。</p>
<p>如果你只想重定义其中一个方法，那只使用 <code>@property</code> 本身是不够的。比如，下面的代码就无法工作：</p>
<pre><code class="language-python">class SubPerson(Person):
    @property  # Doesn't work
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>如果你试着运行会发现<code>setter</code>函数整个消失了：</p>
<pre><code class="language-python">s = SubPerson('Guido')
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 5, in __init__
        self.name = name
AttributeError: can't set attribute
</code></pre>
<p>你应该像之前说过的那样修改代码：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>这么写后，<code>property</code>之前已经定义过的方法会被复制过来，而<code>getter</code>函数被替换。然后它就能按照期望的工作了：</p>
<pre><code class="language-python">s = SubPerson('Guido')
s.name
Getting name
'Guido'
s.name = 'Larry'
s.name
Getting name
'Larry'
s.name = 42
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 16, in name
        raise TypeError('Expected a string')
TypeError: Expected a string
</code></pre>
<p>在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的 <code>Person</code> 类名。 如果你不知道到底是哪个基类定义了<code>property</code>， 那你只能通过重新定义所有<code>property</code>并使用 <code>super()</code> 来将控制权传递给前面的实现。<br>
值得注意的是上面演示的第一种技术还可以被用来扩展一个描述器。比如：</p>
<pre><code class="language-python"># A descriptor
class String:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        instance.__dict__[self.name] = value

# A class with a descriptor
class Person:
    name = String('name')

    def __init__(self, name):
        self.name = name

# Extending a descriptor with a property
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>
<p>最后值得注意的是，读到这里时，你应该会发现子类化 <code>setter</code> 和 <code>deleter</code> 方法其实是很简单的。</p>
<h6 id="classmethod"><code>@classmethod</code></h6>
<p><code>@classmethod</code>对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。<br>
<code>@classmethod</code>因为持有<code>cls</code>参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>
<pre><code class="language-Python">class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 foo 方法
 
A.func2()               # 不需要实例化
</code></pre>
<h6 id="staticmethod"><code>@staticmethod</code></h6>
<p>将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。<br>
<code>@staticmethod</code>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。<br>
如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接<code>类名.属性名</code>或<code>类名.方法名</code>。</p>
<pre><code class="language-Python">class TestClass:
    name = &quot;test&quot;
    def __init__(self, name):
        self.name = name
    @staticmethod
    def fun(self, x, y):
        return  x + y
cls = TestClass(&quot;felix&quot;)
print &quot;通过实例引用方法&quot;
print cls.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
print &quot;类名直接引用静态方法&quot;
print TestClass.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
</code></pre>
<h6 id="dataclass"><code>@dataclass</code></h6>
<pre><code class="language-Python">class MyClass:
    def __init__(self, var_a, var_b):
        self.var_a = var_a
        self.var_b = var_b
@dataclass
class MyClass:
    var_a: str
    var_b: str
@dataclass
class Number:
    val:int = 0
</code></pre>
<h5 id="偏函数">偏函数</h5>
<ul>
<li><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换。<br>
但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入<code>base</code>参数，就可以做N进制的转换：<br>
<code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</li>
</ul>
<pre><code>import functools
int2 = functools.partial(int, base=2)
int2('1000000')
64
int2('1010101')
85
</code></pre>
<ul>
<li>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>
注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为2，但也可以在函数调用时传入其他值：</li>
</ul>
<pre><code class="language-Python">int2('1000000', base=10)
1000000
</code></pre>
<ul>
<li>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</li>
</ul>
<pre><code class="language-Python">int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了<code>int()</code>函数的关键字参数<code>base</code>，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code class="language-Python">max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>
<pre><code class="language-Python">max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code class="language-Python">args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。<br>
当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
<h4 id="itertools模块"><code>itertools</code>模块</h4>
<ul>
<li>标准库<code>itertools</code>模块中有一组用于许多常见数据算法的生成器。例如，<code>groupby</code>可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</li>
</ul>
<pre><code class="language-Python">import itertools
first_letter = lambda x: x[0]
names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
for letter, names in itertools.groupby(names, first_letter):
    print(letter, list(names)) # names is a generator
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']
</code></pre>
<ul>
<li>常用<code>itertools</code>函数:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373137383639312d313131383233643837363761313034642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f77.png" alt="" loading="lazy"></li>
</ul>
<h3 id="字符串">字符串</h3>
<pre><code class="language-Python"> a= 'ABC'
</code></pre>
<p>在内存中创建了一个<code>'ABC'</code>的字符串；<br>
在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。<br>
也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p>
<pre><code class="language-Python">a = 'ABC'
b = a
a = 'XYZ'
print(b)
'ABC`
</code></pre>
<h4 id="分割">分割</h4>
<pre><code class="language-Python">s = 'Python'
list(s)
['p', 'y', 't', 'h', 'o', 'n']
</code></pre>
<h4 id="模板化或格式化">模板化或格式化</h4>
<pre><code class="language-Python">template = '{0:.2f} {1:s} are worth US${2:d}'
</code></pre>
<ul>
<li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>{1:s}</code>表示格式化第二个参数为字符串。</li>
<li><code>{2:d}</code>表示格式化第三个参数为一个整数。<br>
在括号中的数字用于指向传入对象在 <code>format()</code> 中的位置，如下所示：</li>
</ul>
<pre><code class="language-Python">print('{0} 和 {1}'.format('Google', 'Runoob'))
Google 和 Runoob
print('{1} 和 {0}'.format('Google', 'Runoob'))
Runoob 和 Google
</code></pre>
<p>如果在<code>format()</code> 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code class="language-Python">print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
菜鸟教程网址： www.runoob.com
</code></pre>
<p>位置及关键字参数可以任意的结合:</p>
<pre><code class="language-Python">print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
站点列表 Google, Runoob, 和 Taobao。
</code></pre>
<p>可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 <code>Pi</code> 保留到小数点后三位：</p>
<pre><code class="language-Python">import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre>
<p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。<br>
最简单的就是传入一个字典, 然后使用方括号 <code>[]</code> 来访问键值 :</p>
<pre><code class="language-Python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<p>也可以通过在 <code>table</code> 变量前使用 <code>**</code> 来实现相同的功能：</p>
<pre><code class="language-Python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<h4 id="常用操作">常用操作</h4>
<ul>
<li><code>str.join(iterable)</code>:返回一个由 <code>iterable</code> 中的字符串拼接而成的字符串。比<code>+</code>效率要高。<br>
如果你想要合并的字符串是在一个序列或者 <code>iterable</code> 中，那么最快的方式就是使用 <code>join()</code> 方法。比如：</li>
</ul>
<pre><code class="language-python">parts = ['Is', 'Chicago', 'Not', 'Chicago?']
' '.join(parts)
'Is Chicago Not Chicago?'
','.join(parts)
'Is,Chicago,Not,Chicago?'
''.join(parts)
'IsChicagoNotChicago?'
</code></pre>
<p>初看起来，这种语法看上去会比较怪，但是 <code>join()</code> 被指定为字符串的一个方法。 这样做的部分原因是你想去连接的对象可能来自各种不同的数据序列(比如列表，元组，字典，文件，集合或生成器等)， 如果在所有这些对象上都定义一个 <code>join()</code> 方法明显是冗余的。 因此你只需要指定你想要的分割字符串并调用他的 <code>join()</code> 方法去将文本片段组合起来。<br>
如果你仅仅只是合并少数几个字符串，使用加号<code>(+)</code>通常已经足够了：</p>
<pre><code class="language-python">a = 'Is Chicago'
b = 'Not Chicago?'
a + ' ' + b
'Is Chicago Not Chicago?'
</code></pre>
<p>加号<code>(+)</code>操作符在作为一些复杂字符串格式化的替代方案的时候通常也工作的很好，比如：</p>
<pre><code class="language-python">print('{} {}'.format(a,b))
Is Chicago Not Chicago?
print(a + ' ' + b)
Is Chicago Not Chicago?
</code></pre>
<p>如果你想在源码中将两个字面字符串合并起来，你只需要简单的将它们放到一起，不需要用加号<code>(+)</code>。比如：</p>
<pre><code class="language-python">a = 'Hello' 'World'
a
'HelloWorld'
</code></pre>
<p>字符串合并可能看上去并不需要用一整节来讨论。 但是不应该小看这个问题，程序员通常在字符串格式化的时候因为选择不当而给应用程序带来严重性能损失。<br>
最重要的需要引起注意的是，当我们使用加号<code>(+)</code>操作符去连接大量的字符串的时候是非常低效率的， 因为加号连接会引起内存复制以及垃圾回收操作。 特别的，你永远都不应像下面这样写字符串连接代码：</p>
<pre><code class="language-python">s = ''
for p in parts:
    s += p
</code></pre>
<p>这种写法会比使用 <code>join()</code> 方法运行的要慢一些，因为每一次执行<code>+=</code>操作的时候会创建一个新的字符串对象。 你最好是先收集所有的字符串片段然后再将它们连接起来。<br>
一个相对比较聪明的技巧是利用生成器表达式转换数据为字符串的同时合并字符串，比如：</p>
<pre><code class="language-python">data = ['ACME', 50, 91.1]
','.join(str(d) for d in data)
'ACME,50,91.1'
</code></pre>
<p>同样还得注意不必要的字符串连接操作。有时候程序员在没有必要做连接操作的时候仍然多此一举。比如在打印的时候：</p>
<pre><code class="language-python">print(a + ':' + b + ':' + c) # Ugly
print(':'.join([a, b, c])) # Still ugly
print(a, b, c, sep=':') # Better
</code></pre>
<p>当混合使用<code>I/O</code>操作和字符串连接操作的时候，有时候需要仔细研究你的程序。 比如，考虑下面的两端代码片段：</p>
<pre><code class="language-python"># Version 1 (string concatenation)
f.write(chunk1 + chunk2)
# Version 2 (separate I/O operations)
f.write(chunk1)
f.write(chunk2)
</code></pre>
<p>如果两个字符串很小，那么第一个版本性能会更好些，因为<code>I/O</code>系统调用天生就慢。 另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效， 因为它避免了创建一个很大的临时结果并且要复制大量的内存块数据。 还是那句话，有时候是需要根据你的应用程序特点来决定应该使用哪种方案。<br>
最后谈一下，如果你准备编写构建大量小字符串的输出代码， 你最好考虑下使用生成器函数，利用yield语句产生输出片段。比如：</p>
<pre><code class="language-python">def sample():
    yield 'Is'
    yield 'Chicago'
    yield 'Not'
    yield 'Chicago?'
</code></pre>
<p>这种方法一个有趣的方面是它并没有对输出片段到底要怎样组织做出假设。 例如，你可以简单的使用 <code>join()</code> 方法将这些片段合并起来：</p>
<pre><code class="language-python">text = ''.join(sample())
</code></pre>
<p>或者你也可以将字符串片段重定向到<code>I/O</code>：</p>
<pre><code class="language-python">for part in sample():
    f.write(part)
</code></pre>
<p>再或者你还可以写出一些结合<code>I/O</code>操作的混合方案：</p>
<pre><code class="language-python">def combine(source, maxsize):
    parts = []
    size = 0
    for part in source:
        parts.append(part)
        size += len(part)
        if size &gt; maxsize:
            yield ''.join(parts)
            parts = []
            size = 0
    yield ''.join(parts)
# 结合文件操作
with open('filename', 'w') as f:
    for part in combine(sample(), 32768):
        f.write(part)
</code></pre>
<p>这里的关键点在于原始的生成器函数并不需要知道使用细节，它只负责生成字符串片段就行了。</p>
<ul>
<li><code>eval(str)</code>:用来计算在字符串中的有效<code>Python</code>表达式,并返回一个对象</li>
<li><code>str.center(width[, fillchar])</code>:返回长度为 <code>width</code> 的字符串，原字符串在其正中。 使用指定的 <code>fillchar</code> 填充两边的空位（默认使用 <code>ASCII</code> 空格符）。 如果 <code>width</code> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</li>
<li><code>str.count(str, beg= 0,end=len(string))</code>:返回 <code>str</code> 在 <code>string</code> 里面出现的次数，如果 <code>beg</code> 或者 <code>end</code>指定则返回指定范围内 <code>str</code> 出现的次数</li>
<li><code>str.find(str, beg=0, end=len(string))</code>:检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code> ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回<code>-1</code></li>
<li><code>str.upper()</code>:转换字符串中的小写字母为大写</li>
<li><code>str.lower()</code>:转换字符串中所有大写字符为小写</li>
<li><code>str.replace(old, new [, max])</code>:将字符串中的 <code>str1</code> 替换成 <code>str2</code>,如果<code>max</code>指定，则替换不超过<code>max</code>次。<br>
想处理中间的空格,使用 <code>replace()</code> 方法。示例如下：</li>
</ul>
<pre><code class="language-python">s.replace(' ', '')
'helloworld'
</code></pre>
<ul>
<li><code>str.split(str=&quot;&quot;, num=string.count(str))</code>:<code>num=string.count(str))</code> 以<code>str</code>为分隔符截取字符串，如果<code>num</code>有指定值，则仅截取<code>num+1</code>个子字符串</li>
<li><code>str.strip([chars])</code>:截掉字符串两边的空格或指定字符。</li>
<li>匹配的是字面字符串，那么你通常只需要调用基本字符串方法就行， 比如 <code>str.find()</code> , <code>str.endswith()</code> , <code>str.startswith()</code> 或者类似的方法：</li>
</ul>
<pre><code class="language-python">text = 'yeah, but no, but yeah, but no, but yeah'
# Exact match
text == 'yeah'
False
# Match at start or end
text.startswith('yeah')
True
text.endswith('no')
False
# Search for the location of the first occurrence
text.find('no')
10
</code></pre>
<h3 id="运算符">运算符</h3>
<h4 id="和is"><code>==</code>和<code>is</code></h4>
<ul>
<li>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法:</li>
</ul>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
c = list(a)
print(a is b)
True
# 因为list总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。
print(a is not c)
True
print(a == c)
True
</code></pre>
<p><code>is</code> 用于判断两个变量引用对象是否为同一个， <code>==</code> 用于判断引用变量的值是否相等。<br>
<code>a is b</code> 相当于 <code>id(a)==id(b)</code>.<br>
如果 <code>a=10;b=a;</code> 则此时 <code>a</code> 和 <code>b</code> 的内存地址一样的;<br>
但当 <code>a=[1,2,3]</code>; 另 <code>b=a[:]</code> 时，虽然 <code>a</code> 和 <code>b</code> 的值一样，但内存地址不一样。</p>
<h4 id="any和all"><code>any()</code>和<code>all()</code></h4>
<p><code>any()</code>, <code>all()</code>很好理解，就是字面意思，即参数中任何一个为 <code>true</code> 或者全部为 <code>true</code> 则返回 <code>true</code>。</p>
<h4 id="十进制转二进制">十进制转二进制</h4>
<pre><code class="language-Python">bin(10)
'0b1010'
</code></pre>
<h2 id="模块">模块</h2>
<ul>
<li>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，<code>Python</code>就把这个目录当成普通目录，而不是一个包。</li>
<li>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</li>
<li>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。<br>
<code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该``.py文件的名称，例如：<br>
运行<code>Python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；<br>
运行<code>Python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael]</code>。<br>
注意当使用 <code>from package import item</code> 这种形式的时候，对应的 <code>item</code> 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。<br>
<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。<br>
反之，如果使用形如 <code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</li>
<li>内置的函数 <code>dir()</code> 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</li>
<li><code>sys.argv</code> 是一个包含命令行参数的列表。<code>sys.path</code> 包含了一个 <code>Python</code> 解释器自动查找所需模块的路径的列表。</li>
<li>搜索路径是由一系列目录名组成的，<code>Python</code>解释器就依次从这些目录中去寻找所引入的模块。<br>
搜索路径是在<code>Python</code>编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在<code>sys</code>模块中的<code>path</code>变量，做一个简单的实验，在交互式解释器中，输入以下代码：</li>
</ul>
<pre><code class="language-Python">import sys
sys.path
['', '/usr/lib/Python3.4', '/usr/lib/Python3.4/plat-x86_64-linux-gnu', '/usr/lib/Python3.4/lib-dynload', '/usr/local/lib/Python3.4/dist-packages', '/usr/lib/Python3/dist-packages']
</code></pre>
<p><code>sys.path</code> 输出是一个列表，其中第一项是空串<code>''</code>，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行<code>Python</code>解释器的目录（对于脚本的话就是运行的脚本所在的目录）。<br>
因此若在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。<br>
了解了搜索路径的概念，就可以在脚本中修改<code>sys.path</code>来引入一些不在搜索路径中的模块。<br>
如果我们要添加自己的搜索目录，有两种方法：<br>
一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<pre><code class="language-Python">import sys
sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是在运行时修改，运行结束后失效。<br>
第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，<code>Python</code>自己本身的搜索路径不受影响。<br>
现在，在解释器的当前目录或者 <code>sys.path</code>中的一个目录里面来创建一个<code>fibo.py</code>的文件，代码如下：</p>
<pre><code class="language-Python"># 斐波那契(fibonacci)数列模块
def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre>
<p>然后进入<code>Python</code>解释器，使用下面的命令导入这个模块：</p>
<pre><code class="language-Python">import fibo
</code></pre>
<p>这样做并没有把直接定义在<code>fibo</code>中的函数名称写入到当前符号表里，只是把模块<code>fibo</code>的名字写到了那里。</p>
<h3 id="name属性"><code>name</code>属性</h3>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code class="language-Python3"># Filename: using_name.py
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<pre><code class="language-shell">$ Python using_name.py
程序自身在运行
$ Python
&gt;&gt;&gt; import using_name
我来自另一模块
</code></pre>
<p>说明： 每个模块都有一个<code>__name_</code>_属性，当其值是<code>'__main__'</code>时，表明该模块自身在运行，否则是被引入。</p>
<h4 id="包">包</h4>
<ul>
<li>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</li>
</ul>
<pre><code class="language-Python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<p>如果 <code>__all__</code>真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 <code>sound.effects</code> 里的任何子模块。他只是把包<code>sound.effects</code>和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。<br>
这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code class="language-Python">import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre>
<p>这个例子中，在执行 <code>from...import</code> 前，包 <code>sound.effects</code> 中的 <code>echo</code> 和 <code>surround</code> 模块都被导入到当前的命名空间中了。（当然如果定义了 <code>__all__</code> 就更没问题了）</p>
<h2 id="oop">OOP</h2>
<h3 id="访问限制">访问限制</h3>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在<code>Python</code>中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量(<code>private</code>)，只有内部可以访问，外部不能访问:</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
<pre><code class="language-Python">bart = Student('Bart Simpson', 59)
bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>外部代码要获取<code>name</code>和<code>score</code>,修改属性,可以给<code>Student</code>类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<pre><code class="language-Python">class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
    def set_score(self, score):
        self.__score = score
</code></pre>
<p>那种直接通过<code>bart.score = 99</code>也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code class="language-Python">class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>在<code>Python</code>中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是<code>private</code>变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。<br>
下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为<code>Python</code>解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name来访问__name</code>变量：</p>
<pre><code class="language-Python">bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的<code>Python</code>解释器可能会把<code>__name</code>改成不同的变量名。<br>
总的来说就是，<code>Python</code>本身没有任何机制阻止你干坏事，一切全靠自觉。<br>
最后注意下面的这种错误写法：</p>
<pre><code class="language-Python">bart = Student('Bart Simpson', 59)
bart.get_name()
'Bart Simpson'
bart.__name = 'New Name' # 设置__name变量！
bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和<code>class</code>内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被<code>Python</code>解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<pre><code class="language-Python">bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<p>你还可能会遇到在类定义中使用两个下划线<code>(__)</code>开头的命名。比如：</p>
<pre><code class="language-python">class B:
    def __init__(self):
        self.__private = 0

    def __private_method(self):
        pass

    def public_method(self):
        pass
        self.__private_method()
</code></pre>
<p>使用双下划线开始会导致访问名称变成其他形式。 比如，在前面的类<code>B</code>中，私有属性会被分别重命名为 <code>_B__private</code> 和 <code>_B__private_method</code> 。 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p>
<pre><code class="language-python">class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1 # Does not override B.__private

    # Does not override B.__private_method()
    def __private_method(self):
        pass
</code></pre>
<p>这里，私有名称 <code>__private</code> 和 <code>__private_method</code> 被重命名为 <code>_C__private</code> 和 <code>_C__private_method</code> ，这个跟父类<code>B</code>中的名称是完全不同的。<br>
大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<h3 id="继承和多态">继承和多态</h3>
<pre><code class="language-Python">#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
</code></pre>
<pre><code class="language-Python">class Animal(object):
    def run(self):
        print('Animal is running...')
class Dog(Animal):
    def run(self):
        print('Dog is running...')
</code></pre>
<p>子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。]</p>
<pre><code class="language-Python">a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
isinstance(a, list)
True
isinstance(b, Animal)
True
isinstance(c, Dog)
True
</code></pre>
<p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p>
<pre><code class="language-Python">isinstance(c, Animal)
True
</code></pre>
<p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！<br>
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p>
<pre><code class="language-Python">def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<pre><code class="language-Python">run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>多态的好处就是，当我们需要传入<code>Dog</code>时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>还是<code>Dog</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>
对扩展开放：允许新增<code>Animal</code>子类；<br>
对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>
对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>
对于<code>Python</code>这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<pre><code class="language-Python">class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>
<code>Python</code>的<code>“file-like object“</code>就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为<code>“file-like object“</code>。许多函数接收的参数就是<code>“file-like object“</code>，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。<br>
下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-Python">class Parent(object):
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass
print Parent.x, Child1.x, Child2.x
Child1.x = 2
print Parent.x, Child1.x, Child2.x
Parent.x = 3
print Parent.x, Child1.x, Child2.x
1 1 1
1 2 1
3 2 3
</code></pre>
<p>让很多人困惑或惊讶的是最后一行输出为什么是3 2 3 而不是 3 2 1.为什么在改变<code>parent.x</code>的同时也改变了<code>child2.x</code>的值？但与此同时没有改变<code>Child1.x</code>的值？<br>
此答案的关键是，在<code>Python</code>中，类变量在内部是以字典的形式进行传递。<br>
如果一个变量名没有在当前类下的字典中发现。则在更高级的类（如它的父类）中尽心搜索直到引用的变量名被找到。（如果引用变量名在自身类和更高级类中没有找到，将会引发一个属性错误。）<br>
因此,在父类中设定<code>x = 1</code>,让变量<code>x</code>类(带有值1)能够在其类和其子类中被引用到。这就是为什么第一个打印语句输出结果是1 1 1<br>
因此，如果它的任何一个子类被覆写了值（例如说，当我们执行语句<code>Child1.x = 2</code>）,这个值只在子类中进行了修改。这就是为什么第二个打印语句输出结果是1 2 1<br>
最终，如果这个值在父类中进行了修改，（例如说，当我们执行语句<code>Parent.x = 3</code>）,这个改变将会影响那些还没有覆写子类的值（在这个例子中就是<code>Child2</code>）这就是为什么第三打印语句输出结果是3 2 3</p>
<h3 id="获取对象信息">获取对象信息</h3>
<h4 id="使用type">使用<code>type()</code></h4>
<p>判断对象类型，使用<code>type()</code>函数：</p>
<pre><code class="language-Python">type(123)
&lt;class 'int'&gt;
type('str')
&lt;class 'str'&gt;
type(None)
&lt;type(None) 'NoneType'&gt;
type(abs)
&lt;class 'builtin_function_or_method'&gt;
type(a)
&lt;class '__main__.Animal'&gt;
&gt;&gt;&gt; import types
def fn():
    pass
type(fn)==types.FunctionType
True
type(abs)==types.BuiltinFunctionType
True
type(lambda x: x)==types.LambdaType
True
type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h4 id="使用isinstance">使用<code>isinstance()</code></h4>
<p>判断<code>class</code>的类型，可以使用<code>isinstance()</code>函数。</p>
<pre><code class="language-Python">isinstance([1, 2, 3], (list, tuple))
True
isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</strong></p>
<h4 id="使用dir">使用dir()</h4>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个<code>str</code>对象的所有属性和方法：</p>
<pre><code class="language-Python">dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p>类似<code>__xxx__</code>的属性和方法在<code>Python</code>中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在<code>Python</code>中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<pre><code class="language-Python">len('ABC')
3
'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<pre><code class="language-Python">class MyDog(object):
    def __len__(self):
        return 100
dog = MyDog()
len(dog)
100
</code></pre>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p>
<pre><code class="language-Python">'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<pre><code class="language-Python">class MyObject(object):
    def __init__(self):
        self.x = 9
    def power(self):
        return self.x * self.x
obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code class="language-Python">hasattr(obj, 'x') # 有属性'x'吗？
True
obj.x
9
hasattr(obj, 'y') # 有属性'y'吗？
False
setattr(obj, 'y', 19) # 设置一个属性'y'
hasattr(obj, 'y') # 有属性'y'吗？
True
getattr(obj, 'y') # 获取属性'y'
19
obj.y # 获取属性'y'
19
</code></pre>
<p>如果试图获取不存在的属性，会抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-Python">getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个<code>default</code>参数，如果属性不存在，就返回默认值：</p>
<pre><code>getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code class="language-Python">hasattr(obj, 'power') # 有属性'power'吗？
True
getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<h4 id="实例属性和类属性">实例属性和类属性</h4>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>直接在<code>class</code>中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<pre><code class="language-Python">class Student(object):
    name = 'Student'
</code></pre>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<pre><code class="language-Python">class Student(object):
    name = 'Student'
s = Student() # 创建实例s
print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
print(Student.name) # 打印类的name属性
Student
s.name = 'Michael' # 给实例绑定name属性
print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
del s.name # 如果删除实例的name属性
print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>
实例属性属于各个实例所有，互不干扰；<br>
类属性属于类所有，所有实例共享一个属性；<br>
不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h4 id="使用__slots__">使用<code>__slots__</code></h4>
<p>给实例绑定一个方法：</p>
<pre><code class="language-Python">def set_age(self, age): # 定义一个函数作为实例方法
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25) # 调用实例方法
s.age # 测试结果
25
</code></pre>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<pre><code class="language-Python">s2 = Student() # 创建新的实例
s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p>为了给所有实例都绑定方法，可以给class绑定方法：</p>
<pre><code class="language-Python">def set_score(self, score):
    self.score = score
Student.set_score = set_score
</code></pre>
<p>给class绑定方法后，所有实例均可调用.<br>
通常情况下，上面的<code>set_score</code>方法可以直接定义在<code>class</code>中，但动态绑定允许我们在程序运行的过程中动态给<code>class</code>加上功能，这在静态语言中很难实现。<br>
限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。<br>
为了达到限制的目的，<code>Python</code>允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>
<pre><code class="language-Python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```Python
s = Student() # 创建新的实例
s.name = 'Michael' # 绑定属性'name'
s.age = 25 # 绑定属性'age'
s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>由于<code>'score'</code>没有被放到_<code>_slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<pre><code class="language-Python">class GraduateStudent(Student):
    pass
g = GraduateStudent()
g.score = 9999
</code></pre>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h4 id="多重继承">多重继承</h4>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318023741.png" alt="" loading="lazy"></figure>
<pre><code class="language-Python">class Animal(object):
    pass
# 大类:
class Mammal(Animal):
    pass
class Bird(Animal):
    pass
# 各种动物:
class Dog(Mammal):
    pass
class Bat(Mammal):
    pass
class Parrot(Bird):
    pass
class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上<code>Runnable</code>和<code>Flyable</code>的功能，只需要先定义好<code>Runnable</code>和<code>Flyable</code>的类：</p>
<pre><code class="language-Python">class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要<code>Runnable</code>功能的动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p>
<pre><code class="language-Python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要<code>Flyable</code>功能的动物，就多继承一个<code>Flyable</code>，例如<code>Bat</code>：</p>
<pre><code class="language-Python">class Bat(Mammal, Flyable):
    pass
</code></pre>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。<br>
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>为了更好地看出继承关系，我们把<code>Runnable</code>和<code>Flyable</code>改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让某个动物同时拥有好几个<code>MixIn</code>：</p>
<pre><code class="language-Python">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><code>MixIn</code>的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个<code>MixIn</code>的功能，而不是设计多层次的复杂的继承关系。</p>
<p><code>Python</code>自带的很多库也使用了<code>MixIn</code>。举个例子，<code>Python</code>自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的<code>TCP</code>服务，定义如下：</p>
<pre><code class="language-Python">class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的<code>UDP</code>服务，定义如下：</p>
<pre><code class="language-Python">class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个<code>CoroutineMixIn</code>：</p>
<pre><code class="language-Python">class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br>
由于<code>Python</code>允许使用多重继承，因此，<code>MixIn</code>就是一种常见的设计。<br>
只允许单一继承的语言（如<code>Java</code>）不能使用<code>MixIn</code>的设计。</p>
<ul>
<li>若是父类中有相同的方法名，而在子类使用时未指定，<code>Python</code>从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
</ul>
<pre><code class="language-Python">#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
 
#另一个类，多重继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
 
#多重继承
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<ul>
<li><code>super()</code><br>
如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</li>
</ul>
<pre><code class="language-Python">class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
调用子类方法
调用父类方法
</code></pre>
<p>如果重写了<code>__init__</code>时，要继承父类的构造方法，可以使用 <code>super</code> 关键字：</p>
<pre><code class="language-Python">super(子类，self).__init__(参数1，参数2，....)
</code></pre>
<p>为了调用父类(超类)的一个方法，可以使用 <code>super()</code> 函数，比如：</p>
<pre><code class="language-python">class A:
    def spam(self):
        print('A.spam')
class B(A):
    def spam(self):
        print('B.spam')
        super().spam()  # Call parent spam()
</code></pre>
<p><code>super()</code> 函数的一个常见用法是在 <code>__init__()</code> 方法中确保父类被正确的初始化了：</p>
<pre><code class="language-python">class A:
    def __init__(self):
        self.x = 0
class B(A):
    def __init__(self):
        super().__init__()
        self.y = 1
</code></pre>
<p><code>super()</code> 的另外一个常见用法出现在覆盖<code>Python</code>特殊方法的代码中，比如：</p>
<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>
<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。 如果某个属性名以下划线<code>(_)</code>开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code> ， 否则的话就委派给内部的代理对象 <code>self._obj</code> 去处理。 这看上去有点意思，因为就算没有显式的指明某个类的父类， <code>super()</code> 仍然可以有效的工作。<br>
实际上，大家对于在<code>Python</code>中如何正确使用 <code>super()</code> 函数普遍知之甚少。 你有时候会看到像下面这样直接调用父类的一个方法：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')
</code></pre>
<p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。 比如，考虑如下的情况：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')
class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')

class B(Base):
    def __init__(self):
        Base.__init__(self)
        print('B.__init__')

class C(A,B):
    def __init__(self):
        A.__init__(self)
        B.__init__(self)
        print('C.__init__')
</code></pre>
<p>如果你运行这段代码就会发现 <code>Base.__init__()</code> 被调用两次，如下所示：</p>
<pre><code>c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
</code></pre>
<p>可能两次调用 <code>Base.__init__()</code> 没什么坏处，但有时候却不是。 另一方面，假设你在代码中换成使用 <code>super()</code> ，结果就很完美了：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        super().__init__()
        print('A.__init__')

class B(Base):
    def __init__(self):
        super().__init__()
        print('B.__init__')

class C(A,B):
    def __init__(self):
        super().__init__()  # Only one call to super() here
        print('C.__init__')
</code></pre>
<p>运行这个新版本后，你会发现每个 <code>__init__()</code> 方法只会被调用一次了：</p>
<pre><code class="language-python">c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
</code></pre>
<p>为了弄清它的原理，我们需要花点时间解释下<code>Python</code>是如何实现继承的。 对于你定义的每一个类，<code>Python</code>会计算出一个所谓的方法解析顺序(<code>MRO</code>)列表。 这个<code>MRO</code>列表就是一个简单的所有基类的线性顺序表。例如：</p>
<pre><code class="language-python">C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,
&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>为了实现继承，<code>Python</code>会在<code>MRO</code>列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个<code>MRO</code>列表的构造是通过一个<code>C3</code>线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的<code>MRO</code>列表并遵循如下三条准则：</p>
<ol>
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
<li>老实说，你所要知道的就是<code>MRO</code>列表中的类顺序会让你定义的任意类层级关系变得有意义。</li>
</ol>
<p>当你使用 <code>super()</code> 函数时，<code>Python</code>会在<code>MRO</code>列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个<code>MRO</code>列表，每个方法也只会被调用一次。 这也是为什么在第二个例子中你不会调用两次 <code>Base.__init__()</code> 的原因。</p>
<p><code>super()</code> 有个令人吃惊的地方是它并不一定去查找某个类在<code>MRO</code>中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p>
<pre><code class="language-python">class A:
    def spam(self):
        print('A.spam')
        super().spam()
</code></pre>
<p>如果你试着直接使用这个类就会出错：</p>
<pre><code class="language-python">a = A()
a.spam()
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;&lt;stdin&gt;&quot;, line 4, in spam
AttributeError: 'super' object has no attribute 'spam'
</code></pre>
<p>但是，如果你使用多继承的话看看会发生什么：</p>
<pre><code class="language-python">class B:
    def spam(self):
        print('B.spam')
class C(A,B):
    pass
c = C()
c.spam()
A.spam
B.spam
</code></pre>
<p>你可以看到在类A中使用 <code>super().spam()</code> 实际上调用的是跟类<code>A</code>毫无关系的类<code>B</code>中的 <code>spam()</code> 方法。 这个用类<code>C</code>的<code>MRO</code>列表就可以完全解释清楚了：</p>
<pre><code class="language-python">C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,
&lt;class 'object'&gt;)
</code></pre>
<p>在定义混入类的时候这样使用 <code>super()</code> 是很普遍的。</p>
<p>然而，由于 <code>super()</code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 <code>super()</code> 调用一个非直接父类方法时不会出错。 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在<code>MRO</code>上面的查找链肯定可以找到某个确定的方法。</p>
<h4 id="定制类">定制类</h4>
<h5 id="__str__"><code>__str__</code></h5>
<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。<br>
怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name: %s)' % self.name
print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>
但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p>
<pre><code class="language-Python">s = Student('Michael')
s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h5 id="__iter__"><code>__iter__</code></h5>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，<code>Python</code>的<code>for</code>循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br>
我们以斐波那契数列为例，写一个<code>Fib</code>类，可以作用于<code>for</code>循环：</p>
<pre><code class="language-Python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把<code>Fib</code>实例作用于<code>for</code>循环：</p>
<pre><code class="language-Python">for n in Fib():
    print(n)
1
1
2
3
5
...
46368
75025
</code></pre>
<h5 id="__getitem__"><code>__getitem__</code></h5>
<p><code>Fib</code>实例虽然能作用于<code>for</code>循环，看起来和<code>list</code>有点像，但是，把它当成<code>list</code>来使用还是不行,要表现得像<code>list</code>那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<pre><code class="language-Python">class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
f = Fib()
f[0]
1
f[1]
1
f[2]
2
f[3]
3
f[10]
89
f[100]
573147844013817084101
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
f = Fib()
f[0:5]
[1, 1, 2, 3, 5]
f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作<code>key</code>的<code>object</code>，例如<code>str</code>。<br>
与之对应的是<code>__setitem__()</code>方法，把对象视作<code>list</code>或<code>dict</code>来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。<br>
总之，通过上面的方法，我们自己定义的类表现得和<code>Python</code>自带的<code>list</code>、<code>tuple</code>、<code>dict</code>没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h5 id="__getattr__"><code>__getattr__</code></h5>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p>
<pre><code class="language-Python">s = Student()
print(s.name)
Michael
print(s.score)
Traceback (most recent call last):
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个<code>attribute</code>。</p>
<p>要避免这个错误，除了可以加上一个<code>score</code>属性外，<code>Python</code>还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如<code>score</code>，<code>Python</code>解释器会试图调用<code>__getattr__(self, 'score')</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值。<br>
返回函数也是完全可以的：</p>
<pre><code class="language-oython">class Student(object):
    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="language-Python">s.age()
25
</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在_<code>_getattr__</code>中查找。<br>
此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让<code>class</code>只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-Python">class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<h5 id="__call__"><code>__call__</code></h5>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在<code>Python</code>中，答案是肯定的。<br>
任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
调用方式如下：
```Python
s = Student('Michael')
s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。<br>
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。<br>
那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例。<br>
通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h5 id="实现比较操作">实现比较操作</h5>
<p><code>Python</code>类对每个比较操作都需要实现一个特殊方法来支持。 例如为了支持<code>&gt;=</code>操作符，你需要定义一个 <code>__ge__()</code> 方法。 尽管定义一个方法没什么问题，但如果要你实现所有可能的比较方法那就有点烦人了。</p>
<p>装饰器 <code>functools.total_ordering</code> 就是用来简化这个处理的。 使用它来装饰一个类，你只需定义一个 <code>__eq__()</code> 方法， 外加其他方法(<code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, or <code>__ge__</code>)中的一个即可。 然后装饰器会自动为你填充其它比较方法。<br>
作为例子，我们构建一些房子，然后给它们增加一些房间，最后通过房子大小来比较它们：</p>
<pre><code class="language-python">from functools import total_ordering

class Room:
    def __init__(self, name, length, width):
        self.name = name
        self.length = length
        self.width = width
        self.square_feet = self.length * self.width

@total_ordering
class House:
    def __init__(self, name, style):
        self.name = name
        self.style = style
        self.rooms = list()

    @property
    def living_space_footage(self):
        return sum(r.square_feet for r in self.rooms)

    def add_room(self, room):
        self.rooms.append(room)

    def __str__(self):
        return '{}: {} square foot {}'.format(self.name,
                self.living_space_footage,
                self.style)

    def __eq__(self, other):
        return self.living_space_footage == other.living_space_footage

    def __lt__(self, other):
        return self.living_space_footage &lt; other.living_space_footage
</code></pre>
<p>这里我们只是给<code>House</code>类定义了两个方法：<code>__eq__()</code> 和 <code>__lt__()</code> ，它就能支持所有的比较操作：</p>
<pre><code class="language-python"># Build a few houses, and add rooms to them
h1 = House('h1', 'Cape')
h1.add_room(Room('Master Bedroom', 14, 21))
h1.add_room(Room('Living Room', 18, 20))
h1.add_room(Room('Kitchen', 12, 16))
h1.add_room(Room('Office', 12, 12))
h2 = House('h2', 'Ranch')
h2.add_room(Room('Master Bedroom', 14, 21))
h2.add_room(Room('Living Room', 18, 20))
h2.add_room(Room('Kitchen', 12, 16))
h3 = House('h3', 'Split')
h3.add_room(Room('Master Bedroom', 14, 21))
h3.add_room(Room('Living Room', 18, 20))
h3.add_room(Room('Office', 12, 16))
h3.add_room(Room('Kitchen', 15, 17))
houses = [h1, h2, h3]
print('Is h1 bigger than h2?', h1 &gt; h2) # prints True
print('Is h2 smaller than h3?', h2 &lt; h3) # prints True
print('Is h2 greater than or equal to h1?', h2 &gt;= h1) # Prints False
print('Which one is biggest?', max(houses)) # Prints 'h3: 1101-square-foot Split'
print('Which is smallest?', min(houses)) # Prints 'h2: 846-square-foot Ranch'
</code></pre>
<p>其实 <code>total_ordering</code> 装饰器也没那么神秘。 它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已。 比如你定义了 <code>__le__()</code> 方法，那么它就被用来构建所有其他的需要定义的那些特殊方法。 实际上就是在类里面像下面这样定义了一些特殊方法：</p>
<pre><code class="language-python">class House:
    def __eq__(self, other):
        pass
    def __lt__(self, other):
        pass
    # Methods created by @total_ordering
    __le__ = lambda self, other: self &lt; other or self == other
    __gt__ = lambda self, other: not (self &lt; other or self == other)
    __ge__ = lambda self, other: not (self &lt; other)
    __ne__ = lambda self, other: not self == other
</code></pre>
<p>当然，你自己去写也很容易，但是使用 <code>@total_ordering</code> 可以简化代码，何乐而不为呢。</p>
<h4 id="枚举类">枚举类</h4>
<pre><code class="language-Python">from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="language-Python">for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从1开始计数。<br>
如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<pre><code class="language-Python">from enum import Enum, unique
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。<br>
访问这些枚举类型可以有若干种方法：</p>
<pre><code class="language-Python">day1 = Weekday.Mon
print(day1)
Weekday.Mon
print(Weekday.Tue)
Weekday.Tue
print(Weekday['Tue'])
Weekday.Tue
print(Weekday.Tue.value)
2
rint(day1 == Weekday.Mon)
True
print(day1 == Weekday.Tue)
False
rint(Weekday(1))
Weekday.Mon
print(day1 == Weekday(1))
True
Weekday(7)
Traceback (most recent call last):
ValueError: 7 is not a valid Weekday
for name, member in Weekday.__members__.items():
    print(name, '=&gt;', member)
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据<code>value</code>的值获得枚举常量。<br>
<code>Enum</code>可以把一组相关常量定义在一个<code>class</code>中，且<code>class</code>不可变，而且成员可以直接比较。</p>
<h4 id="使用元类">使用元类</h4>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。<br>
比方说我们要定义一个<code>Hello</code>的<code>class</code>，就写一个<code>hello.py</code>模块：</p>
<pre><code class="language-Python">class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当<code>Python</code>解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的<code>class</code>对象，测试如下：</p>
<pre><code class="language-Python">from hello import Hello
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个<code>class</code>，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</p>
<p>我们说<code>class</code>的定义是运行时动态创建的，而创建<code>class</code>的方法就是使用<code>type()</code>函数。</p>
<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)</code>...的定义：</p>
<pre><code class="language-Python">def fn(self, name='world'): # 先定义函数
    print('Hello, %s.' % name)
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个<code>class</code>对象，<code>type()</code>函数依次传入3个参数：<br>
<code>class</code>的名称；<br>
继承的父类集合，注意<code>Python</code>支持多重继承，如果只有一个父类，别忘了<code>tuple</code>的单元素写法；<br>
class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。<br>
通过<code>type()</code>函数创建的类和直接写<code>class</code>是完全一样的，因为<code>Python</code>解释器遇到<code>class</code>定义时，仅仅是扫描一下<code>class</code>定义的语法，然后调用<code>type()</code>函数创建出<code>class</code>。<br>
正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。<br>
<code>metaclass</code><br>
除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用<code>metaclass</code>。<br>
<code>metaclass</code>，直译为元类，简单的解释就是：<br>
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>
但是如果我们想创建出类呢？那就必须根据<code>metaclass</code>创建出类，所以：先定义<code>metaclass</code>，然后创建类。<br>
连接起来就是：先定义<code>metaclass</code>，就可以创建类，最后创建实例。<br>
所以，<code>metaclass</code>允许你创建类或者修改类。换句话说，你可以把类看成是<code>metaclass</code>创建出来的“实例”。</p>
<p><code>metaclass</code>是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用<code>metaclass</code>的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。<br>
我们先看一个简单的例子，这个<code>metaclass</code>可以给我们自定义的<code>MyList</code>增加一个<code>add</code>方法：</p>
<p>定义<code>ListMetaclass</code>，按照默认习惯，<code>metaclass</code>的类名总是以<code>Metaclass</code>结尾，以便清楚地表示这是一个<code>metaclass</code>：</p>
<pre><code class="language-Python"># metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
有了`ListMetaclass`，我们在定义类的时候还要指示使用`ListMetaclass`来定制类，传入关键字参数`metaclass`：
```Python
class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示<code>Python</code>解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<br>
<code>__new__()</code>方法接收到的参数依次是：<br>
当前准备创建的类的对象；<br>
类的名字；<br>
类继承的父类集合；<br>
类的方法集合。<br>
测试一下MyList是否可以调用add()方法：</p>
<pre><code class="language-Python">L = MyList()
L.add(1)
L
[1]
</code></pre>
<p>而普通的list没有<code>add()</code>方法：</p>
<pre><code class="language-Python">L2 = list()
L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过<code>metaclass</code>修改纯属变态。</p>
<h2 id="命名空间和作用域">命名空间和作用域</h2>
<h3 id="三种命名空间">三种命名空间：</h3>
<ul>
<li>内置名称(<code>built-in names</code>)， <code>Python</code> 语言内置的名称，比如函数名 <code>abs</code>、<code>char</code> 和异常名称 <code>BaseException</code>、<code>Exception</code> 等等。</li>
<li>全局名称(<code>global names</code>)，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li>
<li>局部名称(<code>local names</code>)，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）<br>
<code>Python</code> 的查找顺序为：<strong>局部的命名空间</strong> -&gt; <strong>全局命名空间</strong> -&gt; <strong>内置命名空间</strong>。</li>
</ul>
<h4 id="四种作用域">四种作用域：</h4>
<ul>
<li>L(Local)：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li>E(Enclosing)：包含了非局部(<code>non-local</code>)也非全局(<code>non-global</code>)的变量。比如两个嵌套函数，一个函数（或类） <code>A</code> 里面又包含了一个函数 <code>B</code> ，那么对于<code>B</code> 中的名称来说 <code>A</code> 中的作用域就为 <code>nonlocal</code>。</li>
<li>G(<code>Global</code>)：当前脚本的最外层，比如当前模块的全局变量。</li>
<li>B(<code>Built-in</code>)： 包含了内建的变量/关键字等。最后被搜索。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200320015425.png" alt="" loading="lazy"><br>
<code>Python</code> 中只有模块(<code>module</code>)，类(<code>class</code>)以及函数(<code>def</code>、<code>lambda</code>)才会引入新的作用域，其它的代码块(如 <code>if</code>/<code>elif</code>/<code>else</code>/、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</li>
</ul>
<pre><code class="language-Python">if True:
    msg = 'I am from Runoob'
msg
'I am from Runoob'
</code></pre>
<p>实例中 <code>msg</code> 变量定义在 <code>if</code> 语句块中，但外部还是可以访问的。<br>
如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<pre><code class="language-Python">def test():
    msg_inner = 'I am from Runoob'
msg_inner
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'msg_inner' is not defined
</code></pre>
<p>从报错的信息上看，说明了 <code>msg_inner</code> 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="global-和-nonlocal关键字"><code>global</code> 和 <code>nonlocal</code>关键字</h4>
<pre><code class="language-Python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
fun1()
print(num)
1
123
123
</code></pre>
<p>如果要修改嵌套作用域(<code>enclosing</code> 作用域，外层非全局作用域)中的变量则需要 <code>nonlocal</code> 关键字了，如下实例：</p>
<pre><code class="language-Python">def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
100
100
</code></pre>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<pre><code class="language-Python">a = 10
def test():
    a = a + 1
    print(a)
test()
Traceback (most recent call last):
  File &quot;test.py&quot;, line 7, in &lt;module&gt;
    test()
  File &quot;test.py&quot;, line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>错误信息为局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。<br>
修改 <code>a</code> 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<pre><code class="language-Python">a = 10
def test(a):
    a = a + 1
    print(a)
test(a)
11
</code></pre>
<h2 id="错误和异常处理">错误和异常处理</h2>
<pre><code class="language-Python">def attempt_float(x):
    try:
        return float(x)
    except ValueError:
        return x
</code></pre>
<p>某些情况下，你可能不想抑制异常，你想无论<code>try</code>部分的代码是否成功，都执行一段代码。可以使用<code>finally</code>：</p>
<pre><code class="language-Python">f = open(path, 'w')

try:
    write_to_file(f)
finally:
    f.close()
</code></pre>
<p>这里，文件处理<code>f</code>总会被关闭。相似的，你可以用<code>else</code>让只在<code>try</code>部分成功的情况下，才执行代码：</p>
<pre><code class="language-Python">f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
</code></pre>
<ul>
<li>可以有多个<code>except</code>来捕获不同类型的错误：</li>
</ul>
<pre><code class="language-Python">try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<ul>
<li>Python的错误其实也是<code>class</code>，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</li>
</ul>
<pre><code class="language-Python">try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
第二个`except`永远也捕获不到`UnicodeError`，因为`UnicodeError`是`ValueError`的子类，如果有，也被第一个`except`给捕获了。
</code></pre>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>
<pre><code class="language-Python">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
</code></pre>
<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>
<pre><code class="language-Python">def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise
bar()
</code></pre>
<p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去。<br>
这种错误处理方式相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个<code>Error</code>，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="language-Python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p>
<ul>
<li><code>Python</code> 使用 <code>raise</code> 语句抛出一个指定的异常。<br>
<code>raise</code>语法格式如下：</li>
</ul>
<pre><code class="language-Python">raise [Exception [, args [, traceback]]]
</code></pre>
<p>以下实例如果 x 大于 5 就触发异常:</p>
<pre><code>x = 10
if x &gt; 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
</code></pre>
<p>执行以上代码会触发异常：</p>
<pre><code class="language-Python">Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre>
<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<br>
如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <code>raise</code> 语句就可以再次把它抛出。</p>
<pre><code class="language-Python">try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre>
<h3 id="调试">调试</h3>
<ul>
<li>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>(assert)</code>来替代：</li>
</ul>
<pre><code class="language-Python">def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n
def main():
    foo('0')
</code></pre>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>
如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>
<pre><code class="language-shell">$ Python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
</code></pre>
<ul>
<li><code>logging</code><br>
把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</li>
</ul>
<pre><code class="language-Python">import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
</code></pre>
<pre><code class="language-shell">$ Python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。<br>
<code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如<code>console</code>和文件。</p>
<h2 id="文件和操作系统">文件和操作系统</h2>
<ul>
<li>为了打开一个文件以便读写，可以使用内置的<code>open</code>函数以及一个相对或绝对的文件路径：</li>
</ul>
<pre><code class="language-Python">path = 'examples/segismundo.txt'
f = open(path)
</code></pre>
<ul>
<li>默认情况下，文件是以只读模式<code>('r')</code>打开的。然后，我们就可以像处理列表那样来处理这个文件句柄<code>f</code>了，比如对行进行迭代：</li>
</ul>
<pre><code class="language-Python">for line in f:
    pass
</code></pre>
<ul>
<li>如果使用<code>open</code>创建文件对象，一定要用<code>close</code>关闭它。关闭文件可以返回操作系统资源：</li>
</ul>
<pre><code class="language-Python">f.close()
</code></pre>
<ul>
<li>用<code>with</code>语句可以可以更容易地清理打开的文件,这样可以在退出代码块时，自动关闭文件：</li>
</ul>
<pre><code>with open(path) as f:
    lines = [x.rstrip() for x in f]
</code></pre>
<ul>
<li>读写模式：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211525.png" alt="" loading="lazy"></li>
<li>向文件写入，可以使用文件的<code>write</code>或<code>writelines</code>方法。例如，我们可以创建一个无空行版的<code>prof_mod.py</code>：</li>
</ul>
<pre><code class="language-Python">with open('tmp.txt', 'w') as handle:
    handle.writelines(x for x in open(path) if len(x) &gt; 1)
with open('tmp.txt') as f:
    lines = f.readlines()
</code></pre>
<pre><code class="language-Python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。<br>
以<code>'w'</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>'a'</code>以追加<code>(append)</code>模式写入。</p>
<ul>
<li>调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。</li>
<li>常用文件方法<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211726.png" alt="" loading="lazy"></li>
</ul>
<h3 id="操作文件和目录">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<ul>
<li>查看当前目录的绝对路径:</li>
</ul>
<pre><code class="language-Python">os.path.abspath('.')
'/Users/michael'
- 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
````Python
os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
</code></pre>
<ul>
<li>创建一个目录:</li>
</ul>
<pre><code class="language-Python">os.mkdir('/Users/michael/testdir')
</code></pre>
<ul>
<li>删掉一个目录:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>os.rmdir('/Users/michael/testdir')<br>
把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符.<br>
同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-Python">os.path.split('/Users/michael/testdir/file.txt')

('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<pre><code class="language-Python">os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。<br>
文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<ul>
<li>对文件重命名:</li>
</ul>
<pre><code>os.rename('test.txt', 'test.py')
</code></pre>
<ul>
<li>删掉文件:</li>
</ul>
<pre><code class="language-Python">os.remove('test.py')
</code></pre>
<p><code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<h3 id="序列化">序列化</h3>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-Python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-Python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-Python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。</p>
<p>要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-Python"> json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><code>Python</code>的<code>dict</code>对象可以直接序列化为<code>JSON</code>的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>
<pre><code class="language-Python">import json
class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p>
<pre><code class="language-Python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<code>Student</code>对象不是一个可序列化为<code>JSON</code>的对象。<br>
前面的代码之所以无法把<code>Student</code>类实例序列化为<code>JSON</code>，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个<code>JSON</code>的<code>{}</code>对象。<br>
可选参数<code>default</code>就是把任意一个对象变成一个可序列为<code>JSON</code>的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="language-Python">def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>：</p>
<pre><code class="language-Python">print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p>
<pre><code class="language-Python">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的<code>class</code>。<br>
同样的道理，如果我们要把<code>JSON</code>反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="language-Python">def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-Python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的<code>Student</code>实例对象。</p>
<h2 id="标准库">标准库</h2>
<h3 id="collections"><code>collections</code></h3>
<h4 id="namedtuple"><code>namedtuple</code></h4>
<pre><code class="language-Python">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
p.x
1
p.y
2
</code></pre>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>
这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<h4 id="deque"><code>deque</code></h4>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<pre><code class="language-Python">from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
# 清除所有元素
q.clear()
# 计算x的个数
q.count(x)
#移除找到的第一个 value。
q.remove(value)
#逆序排列
q.reverse()
</code></pre>
<p><code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="defaultdict"><code>defaultdict</code></h4>
<p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<pre><code class="language-Python">from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
dd['key1'] # key1存在
'abc'
dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<pre><code class="language-Python">from collections import deque

dlist=deque([1,'a'])
dlist.append('b') # 在末尾加数据
dlist.appendleft(0) # 在最前端插入数据
print(dlist)
# 输出 :  deque([0, 1, 'a', 'b'])

dlist.pop() # 删除末尾的数据
dlist.popleft() # 删除最前端的数据
print(dlist)
# 输出 :  deque([1, 'a'])

dlist.extend(['b','c']) # 在末尾追加list 数据
dlist.extendleft([-1,0])# 在前端插入list 数据
print(dlist)
# 输出 : deque([0, -1, 1, 'a', 'b', 'c'])

print(dlist.index('a')) # 找出 a 的索引位置
# 输出 :  3

dlist.insert(2, 555) # 在索引2 的位置插入555
print(dlist)
# 输出 :  deque([0, -1, 555, 1, 'a', 'b', 'c'])

print(dlist.count('a')) # 查找 ‘a’ 的数量

dlist.remove(1) # 删除第一个匹配值
dlist.reverse()  # 反向
print(dlist)
# 输出 :  deque(['c', 'b', 'a', 555, -1, 0])


dlist.rotate(-2) # 将左端的元素移动到右端
print(dlist)
# 输出 :  deque(['a', 555, -1, 0, 'c', 'b'])

dlist.rotate(2) # 将右端的元素移动到左端
print(dlist)
# 输出 :  deque(['c', 'b', 'a', 555, -1, 0])

dl1=dlist # 赋值 dlist 值变化，dl1的值也会修改
dl2=dlist.copy() # 拷贝 dlist, 拷贝后对dl修改不影响dlist的值
dlist.pop() # 删除最后一个数据, dl1的值也被修改
print(dl1) # 输出： deque(['c', 'b', 'a', 555, -1])
print(dl2) # 输出： deque(['c', 'b', 'a', 555, -1, 0])
</code></pre>
<ul>
<li>合并字典<br>
这是一般的字典合并写法</li>
</ul>
<pre><code class="language-Python">dic1 = {'x': 1, 'y': 2 }
dic2 = {'y': 3, 'z': 4 }
merged1 = {**dic1, **dic2} # {'x': 1, 'y': 3, 'z': 4}
</code></pre>
<p>修改<code>merged[‘x’]=10</code>，<code>dic1</code>中的<code>x</code>值不变，<code>merged</code>是重新生成的一个新字典。<br>
但是，<code>ChainMap</code>却不同，它在内部创建了一个容纳这些字典的列表。因此使用<code>ChainMap</code>合并字典，修改<code>merged[‘x’]=10</code>后，<code>dic1</code>中的<code>x</code>值改变，如下所示：</p>
<pre><code class="language-Python">from collections import ChainMap
merged2 = ChainMap(dic1,dic2)
print(merged2) # ChainMap({'x': 1, 'y': 2}, {'y': 3, 'z': 4})
</code></pre>
<p>默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="ordereddict"><code>OrderedDict</code></h4>
<p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。<br>
如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>：</p>
<pre><code class="language-Python">from collections import OrderedDict
d = dict([('a', 1), ('b', 2), ('c', 3)])
d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，<code>OrderedDict的Key</code>会按照插入的顺序排列，不是<code>Key</code>本身排序：</p>
<pre><code class="language-Python">od = OrderedDict()
od['z'] = 1
od['y'] = 2
od['x'] = 3
list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p><code>OrderedDict</code>可以实现一个<code>FIFO</code>（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的<code>Key</code>：</p>
<pre><code class="language-Python">from collections import OrderedDict
class LastUpdatedOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity
    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h4 id="chainmap"><code>ChainMap</code></h4>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。<br>
什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。<br>
下面的代码演示了如何查找user和color这两个参数：</p>
<pre><code class="language-Python">from collections import ChainMap
import os, argparse
# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}
# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }
# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)
# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
</code></pre>
<p>没有任何参数时，打印出默认参数：</p>
<pre><code class="language-shell">$ Python3 use_chainmap.py 
color=red
user=guest
</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code class="language-shell">$ Python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<pre><code class="language-shell">$ user=admin color=green Python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<pre><code class="language-Python">from collections import ChainMap
m1 = {'Type': 'admin', 'codeID': '00001'}
m2 = {'name': 'woodname','codeID': '00002'}
m = ChainMap(m1, m2)
print(m)
# 输出：
# ChainMap({'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
print(m.maps)
# 输出：[{'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'}]
for i in m.items():
    print(i)
# 输出：
# ('name', 'woodname')
# ('codeID', '00001')
# ('Type', 'admin')
print(m['name']) # 读取元素的值
print(m['codeID']) # 注意，当key重复时以最前一个为准
print(m.get('Type'))
# 输出：
# woodname
# 00001
# admin
# 新增map
m3 = {'data': '888'}
m=m.new_child(m3) # 将 m3 加入m
print(m)
# 输出：
# ChainMap({'data': '888'}, {'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
print(m.parents) # m 的父亲
# 输出：ChainMap({'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
print(m.parents.parents)
# 输出 ： ChainMap({'name': 'woodname', 'codeID': '00002'})
</code></pre>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('c = {}'.format(m['c']))
c = C
</code></pre>
<p>可以通过 <code>maps</code> 属性将结果以列表形式返回。由于列表是可变的，所以可以对这个列表重新排序，或者添加新的值。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print(m.maps)    # [{'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'}]
print('c = {}\n'.format(m['c']))    # c = C
# reverse the list
m.maps = list(reversed(m.maps))
print(m.maps)    # [{'b': 'B', 'c': 'D'}, {'a': 'A', 'c': 'C'}]
print('c = {}'.format(m['c']))    # c = D
</code></pre>
<p><code>ChainMap</code> 不会给子映射创建一个单独的空间，所以对子映射修改时，结果也会反馈到 <code>ChainMap</code> 上。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('Before: {}'.format(m['c']))    # Before: C
a['c'] = 'E'
print('After : {}'.format(m['c']))    # After : E
</code></pre>
<p>也可以通过 <code>ChainMap</code> 直接设置值，实际上只修改了第一个字典中的值。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('Before:', m)    # Before: ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
m['c'] = 'E'
print('After :', m)    # After : ChainMap({'a': 'A', 'c': 'E'}, {'b': 'B', 'c': 'D'})
print('a:', a)    # a: {'a': 'A', 'c': 'E'}
</code></pre>
<p><code>ChainMap</code>提供了一个简单的方法，用于在<code>maps</code>列表的前面创建一个新实例，这样做的好处是可以避免修改现有的底层数据结构。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m1 = collections.ChainMap(a, b)
m2 = m1.new_child()
print(m1)    # ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
print(m2)    # ChainMap({}, {'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
m2['c'] = 'E'
print(m1)    # ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
print(m2)    # ChainMap({'c': 'E'}, {'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
</code></pre>
<p>这种堆叠行为使得将<code>ChainMap</code> 实例用作模板或应用程序上下文变得非常方便。具体来说，在一次迭代中很容易添加或更新值，然后丢弃下一次迭代的更改。<br>
对于新上下文已知或预先构建的情况，也可以将映射传递给<code>new_child()</code>。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
c = {'c': 'E'}
m1 = collections.ChainMap(a, b)
m2 = m1.new_child(c)
print('m1[&quot;c&quot;] = {}'.format(m1['c']))    # m1[&quot;c&quot;] = C
print('m2[&quot;c&quot;] = {}'.format(m2['c']))    # m2[&quot;c&quot;] = E
</code></pre>
<p>这相当于：</p>
<pre><code class="language-Python">m2 = collections.ChainMap(c, *m1.maps)
</code></pre>
<h4 id="counter"><code>Counter</code></h4>
<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code class="language-Python">from collections import Counter
c = Counter()
for ch in 'programming':
c[ch] = c[ch] + 1
c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
c.update('hello') # 也可以一次性update
c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<ul>
<li><code>elements()</code>:返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，<code>elements()</code> 将会忽略它。</li>
</ul>
<pre><code class="language-Python">c = Counter(a=4, b=2, c=0, d=-2)
sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']
</code></pre>
<ul>
<li><code>most_common([n])</code>:返回一个列表，其中包含<code>n</code> 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 <code>n</code> 被省略或为 <code>None</code>，<code>most_common()</code> 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序：</li>
</ul>
<pre><code class="language-Python">Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
</code></pre>
<pre><code class="language-Python">c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
c &amp; d                       # intersection:  min(c[x], d[x]) 
Counter({'a': 1, 'b': 1})
c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
</code></pre>
<p><code>Counter</code> 支持三种初始化形式：</p>
<pre><code class="language-Python">print(collections.Counter(['a', 'b', 'c', 'a', 'b', 'b']))
print(collections.Counter({'a': 2, 'b': 3, 'c': 1}))
print(collections.Counter(a=2, b=3, c=1))
# output
# Counter({'b': 3, 'a': 2, 'c': 1})
# Counter({'b': 3, 'a': 2, 'c': 1})
# Counter({'b': 3, 'a': 2, 'c': 1})
</code></pre>
<p><code>Counter</code> 初始化时也可以不传参数，然后通过<code>update()</code>方法更新。</p>
<pre><code class="language-Python">c = collections.Counter()
print('Initial :', c)    # Initial : Counter()
c.update('abcdaab')
print('Sequence:', c)    # Sequence: Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})
c.update({'a': 1, 'd': 5})
print('Dict    :', c)    # Dict    : Counter({'d': 6, 'a': 4, 'b': 2, 'c': 1})
</code></pre>
<p>计数值基于新数据而不是替换而增加。在上例中，计数<code>a</code>从3到 4。<br>
<code>Counter</code> 中的值，可以使用字典 <code>API</code> 获取它的值。</p>
<pre><code class="language-Python">c = collections.Counter('abcdaab')
for letter in 'abcde':
    print('{} : {}'.format(letter, c[letter]))
# output
# a : 3
# b : 2
# c : 1
# d : 1
# e : 0
</code></pre>
<p>对于 <code>Counter</code> 中没有的键，不会报 <code>KeyError</code>。如本例中的 <code>e</code>，将其计数为0。<br>
<code>elements()</code>方法返回一个迭代器，遍历它可以获得 <code>Counter</code> 中的值。</p>
<pre><code class="language-Python">c = collections.Counter('extremely')
c['z'] = 0
print(c)    # Counter({'e': 3, 'x': 1, 't': 1, 'r': 1, 'm': 1, 'l': 1, 'y': 1, 'z': 0})
print(list(c.elements()))    # ['e', 'e', 'e', 'x', 't', 'r', 'm', 'l', 'y']
</code></pre>
<p>不保证元素的顺序，并且不包括计数小于或等于零的值。<br>
使用<code>most_common()</code>产生序列最常遇到的输入值和它们各自的计数。</p>
<pre><code class="language-Python">c = collections.Counter()
with open('/usr/share/dict/words', 'rt') as f:
    for line in f:
        c.update(line.rstrip().lower())
print('Most common:')
for letter, count in c.most_common(3):
    print('{}: {:&gt;7}'.format(letter, count))

# output
# Most common:
# e:  235331
# i:  201032
# a:  199554
</code></pre>
<p>此示例计算在系统字典所有单词中的字母生成频率分布，然后打印三个最常见的字母。如果没有参数的话，会按频率顺序生成所有项目的列表。<br>
<code>Counter</code>实例支持算术和聚合结果。这个例子显示了标准的操作符计算新的<code>Counter</code>实例，就地操作符 <code>+=</code>，<code>-=</code>，<code>&amp;=</code>，和<code>|=</code>也支持。</p>
<pre><code class="language-Python">c1 = collections.Counter(['a', 'b', 'c', 'a', 'b', 'b'])
c2 = collections.Counter('alphabet')

print('C1:', c1)
print('C2:', c2)

print('\nCombined counts:')
print(c1 + c2)

print('\nSubtraction:')
print(c1 - c2)

print('\nIntersection (taking positive minimums):')
print(c1 &amp; c2)

print('\nUnion (taking maximums):')
print(c1 | c2)

# output
# C1: Counter({'b': 3, 'a': 2, 'c': 1})
# C2: Counter({'a': 2, 'l': 1, 'p': 1, 'h': 1, 'b': 1, 'e': 1, 't': 1})
# 
# Combined counts:
# Counter({'a': 4, 'b': 4, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
# 
# Subtraction:
# Counter({'b': 2, 'c': 1})
# 
# Intersection (taking positive minimums):
# Counter({'a': 2, 'b': 1})
# 
# Union (taking maximums):
# Counter({'b': 3, 'a': 2, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
</code></pre>
<p>每次<code>Counter</code>通过操作产生新的时，任何具有零或负计数的项目都将被丢弃。计数<code>a</code>在<code>c1</code>和<code>c2</code>中是相同的，因此相减之后变为零。</p>
<h3 id="heapq"><code>heapq</code></h3>
<p>这个模块提供了堆队列算法的实现，也称为优先队列算法。<br>
堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <code>k</code> ，都有 <code>heap[k]</code> &lt;= <code>heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。<br>
这个<code>API</code>与教材的堆算法实现有所不同，具体区别有两方面：</p>
<ol>
<li>我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 <code>Python</code> 使用从零开始的索引。</li>
<li>我们的 <code>pop</code> 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。但是可以通过取反来实现最大堆。<br>
要创建一个堆，可以使用<code>list</code>来初始化为 <code>[]</code> ，或者你可以通过一个函数 <code>heapify()</code> ，来把一个<code>list</code>转换成堆。</li>
</ol>
<ul>
<li><code>heapq.heappush(heap, item)</code>:将 <code>item</code> 的值加入 <code>heap</code> 中，保持堆的不变性。</li>
<li><code>heapq.heappop(heap)</code>:弹出并返回 <code>heap</code> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <code>IndexError</code> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</li>
<li><code>heapq.heappushpop(heap, item)</code>:将 <code>item</code> 放入堆中，然后弹出并返回 <code>heap</code> 的最小元素。该组合操作比先调用  <code>heappush()</code> 再调用 <code>heappop()</code> 运行起来更有效率。</li>
<li><code>heapq.heapify(x)</code>:将<code>list x</code> 转换成堆，原地，线性时间内。</li>
<li><code>heapq.heapreplace(heap, item)</code>:弹出并返回 <code>heap</code> 中最小的一项，同时推入新的 <code>item</code>。 堆的大小不变。 如果堆为空则引发 <code>IndexError</code>。<br>
这个单步骤操作比 <code>heappop()</code> 加 <code>heappush()</code> 更高效，并且在使用固定大小的堆时更为适宜。 <code>pop/push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>
返回的值可能会比添加的 <code>item</code> 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。<br>
-<code>heapq.merge(*iterables, key=None, reverse=False)</code><br>
将多个已排序的输入合并为一个已排序的输出。返回已排序值的<code>iterator</code>。<br>
类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</li>
<li><code>heapq.nlargest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code>个最大元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</li>
<li><code>heapq.nsmallest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code> 个最小元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。<br>
两个函数在 <code>n</code> 值较小时性能最好。 对于更大的值，使用 <code>sorted()</code> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <code>min()</code> 和 <code>max()</code> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。<br>
堆排序:<br>
堆排序 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</li>
</ul>
<pre><code class="language-Python">def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]
heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>如果我们想要<code>heapq</code>排序的是一个对象。那么heapq并不知道应该依据对象当中的哪个参数来作为排序的衡量标准，所以这个时候，需要我们自己定义一个获取关键字的函数，传递给<code>heapq</code>，这样才可以完成排序。<br>
比如说，我们现在有一批电脑，我们希望<code>heapq</code>能够根据电脑的价格排序：</p>
<pre><code class="language-Python">laptops = [
    {'name': 'ThinkPad', 'amount': 100, 'price': 91.1},
    {'name': 'Mac', 'amount': 50, 'price': 543.22},
    {'name': 'Surface', 'amount': 200, 'price': 21.09},
    {'name': 'Alienware', 'amount': 35, 'price': 31.75},
    {'name': 'Lenovo', 'amount': 45, 'price': 16.35},
    {'name': 'Huawei', 'amount': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>在调用<code>nlargest</code>和<code>nsmallest</code>的时候，我们额外传递了一个参数<code>key</code>，我们传入的是一个匿名函数，它返回的结果是这个对象的<code>price</code>，也就是说我们希望<code>heapq</code>根据对象的<code>price</code>来进行排序。<br>
这类似于 <code>sorted(iterable)</code>，但与 <code>sorted()</code> 不同的是这个实现是不稳定的。<br>
优先队列 是堆的常用场合，并且它的实现包含了多个挑战：</p>
<ol>
<li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li>
<li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。<br>
针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。<br>
下面的类利用 <code>heapq</code> 模块实现了一个简单的优先级队列：</li>
</ol>
<pre><code class="language-python">import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>
<p>下面是它的使用方式：</p>
<pre><code class="language-python">class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name)
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
Item('bar')
q.pop()
('spam')
q.pop()
Item('foo')
q.pop()
Item('grok')
</code></pre>
<h3 id="bisect"><code>bisect</code></h3>
<ul>
<li><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code><br>
在 <code>a</code> 中找到 <code>x</code> 合适的插入点以维持有序。参数 <code>lo</code> 和 <code>hi</code> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <code>x</code> 已经在 <code>a</code> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <code>a</code> 是列表（<code>list</code>）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code>，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</li>
<li><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.bisect(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>bisect_left()</code>，但是返回的插入点是 <code>a</code> 中已存在元素 <code>x</code> 的右侧。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi]) for the right side</code>。</li>
<li><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code><br>
将 <code>x</code> 插入到一个有序序列 <code>a</code> 里，并维持其有序。如果 <code>a</code> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 <code>O(log n)</code> 的，插入却是 <code>O(n)</code> 的。</li>
<li><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.insort(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>insort_left()</code>，但是把 <code>x</code> 插入到 <code>a</code> 中已存在元素 <code>x</code>的右侧。<br>
函数 <code>bisect()</code> 还可以用于数字表查询。这个例子是使用 <code>bisect()</code> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：<code>90</code> 分及以上是 <code>'A'</code>，<code>80</code> 到 <code>89</code> 是 <code>'B'</code>，以此类推</li>
</ul>
<pre><code class="language-Python">def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']
</code></pre>
<h3 id="itertools"><code>itertools</code></h3>
<ul>
<li><code>itertools.count(start=0,step=1)</code>:创建一个迭代器，生成从 <code>n</code> 开始的连续整数，如果忽略 <code>n</code>，则从 <code>0</code> 开始计算。</li>
</ul>
<pre><code class="language-Python">for n in itertools.count():
    if 100000 &lt; n &lt; 100010:
        print n
    if n &gt; 1000000:
        break
100001
100002
100003
100004
100005
100006
100007
100008
100009
</code></pre>
<ul>
<li><code>itertools.cycle(iterable)</code>:把传入的一个序列无限重复下去。</li>
</ul>
<pre><code class="language-Python">for c in itertools.cycle(&quot;AB&quot;):
    if count &gt; 4:
        break
    print c
   count += 1     
A
B
A
B
A
</code></pre>
<ul>
<li><code>itertools.repeat(object [,times])</code>:创建一个迭代器，重复生成 <code>object</code>，<code>times</code>（如果已提供）指定重复计数，如果未提供 <code>times</code>，将无止尽返回该对象。</li>
</ul>
<pre><code class="language-Python">for x in itertools.repeat(&quot;hello world&quot;, 5):
    print x    
hello world
hello world
hello world
hello world
hello world
</code></pre>
<ul>
<li><code>itertools.chain(*iterables)</code>:把一组迭代对象串联起来，形成一个更大的迭代器。</li>
</ul>
<pre><code class="language-Python">for c in itertools.chain('ABC', 'XYZ'):
    print c    
A
B
C
X
Y
Z
</code></pre>
<ul>
<li><code>itertools.permutations(iterable[, r])：返回</code>iterable<code>中任意取</code>r<code>个元素做排列的元组的迭代器，如果不指定</code>r<code>，那么序列的长度与</code>iterable` 中的项目数量相同。</li>
</ul>
<pre><code class="language-Python">for elem in itertools.permutations('abc', 2):
    print elem
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
for elem in itertools.permutations('abc'):
    print elem
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
</code></pre>
<ul>
<li><code>itertools.combinations(iterable, r)</code>:组合，如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，<code>ab</code> 和 <code>ba</code> 则视为重复，此时只放回 <code>ab</code>. 示例：</li>
</ul>
<pre><code class="language-Python">for elem in itertools.combinations('abc', 2):
    print elem   
('a', 'b')
('a', 'c')
('b', 'c')
</code></pre>
<ul>
<li><code>itertools.combinations_with_replacement(iterable, r)</code>:与 <code>combinations</code> 类似，但允许重复值，即如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，会多出 <code>aa</code>, <code>bb</code>, <code>cc</code>。</li>
<li><code>itertools.compress(data, selectors)</code>:<br>
相当于 <code>bool</code> 选取，只有当 <code>selectors</code> 对应位置的元素为 <code>true</code> 时，才保留 <code>data</code> 中相应位置的元素，否则去除。</li>
</ul>
<pre><code class="language-Python">list(itertools.compress('abcdef', [1, 1, 0, 1, 0, 1]))
['a', 'b', 'd', 'f']
list(itertools.compress('abcdef', [True, False, True]))
['a', 'c']
</code></pre>
<ul>
<li><code>itertools.groupby(iterable[, keyfunc])</code>:对<code>iterable</code>中的元素进行分组。<code>keyfunc</code> 是分组函数，用于对 <code>iterable</code> 的连续项进行分组，如果不指定，则默认对 <code>iterable</code> 中的连续相同项进行分组，返回一个 <code>(key, sub-iterator)</code> 的迭代器。</li>
</ul>
<pre><code class="language-Python">for key, value_iter in itertools.groupby('aaabbbaaccd'):
    print key, list(value_iter)  
a ['a', 'a', 'a']
b ['b', 'b', 'b']
a ['a', 'a']
c ['c', 'c']
d ['d']
data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f']
for key, value_iter in itertools.groupby(data, len):
    print key, list(value_iter)   
1 ['a']
2 ['bb', 'cc']
3 ['ddd', 'eee']
1 ['f']
</code></pre>
<p>注意，注意，注意：必须先排序后才能分组，因为<code>groupby</code>是通过比较相邻元素来分组的。可以看第二个例子，因为 <code>a</code> 和<code>f</code> 没有排在一起，所以最后没有分组到同一个列表中。</p>
<ul>
<li><code>itertools.islice(iterable, [start,] stop [, step])</code>:切片选择，<code>start</code> 是开始索引，<code>stop</code> 是结束索引，<code>step</code> 是步长，<code>start</code>和 <code>step</code> 可选。</li>
</ul>
<pre><code class="language-Python">list(itertools.islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
list(itertools.islice(itertools.count(), 6))
[0, 1, 2, 3, 4, 5]
list(itertools.islice(itertools.count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
list(itertools.islice(itertools.count(), 3, 10, 2))
[3, 5, 7, 9]
</code></pre>
<ul>
<li><code>itertools.tee(iterable, n=2)</code>:从 <code>iterable</code> 创建 <code>n</code> 个独立的迭代器，以元组的形式返回。</li>
</ul>
<pre><code class="language-Python">itertools.tee(&quot;abcedf&quot;)
(&lt;itertools.tee at 0x7fed7b8f59e0&gt;, &lt;itertools.tee at 0x7fed7b8f56c8&gt;)
iter1, iter2 = itertools.tee(&quot;abcedf&quot;)
list(iter1)
['a', 'b', 'c', 'e', 'd', 'f']
list(iter2)
['a', 'b', 'c', 'e', 'd', 'f']
</code></pre>
<ul>
<li><code>itertools.product(*iterables, repeat=1)</code>:<br>
大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。<br>
嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。<br>
要计算可迭代对象自身的笛卡尔积，将可选参数 <code>repeat</code> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</li>
<li><code>itertools.dropwhile</code></li>
</ul>
<pre><code class="language-Python"> x = itertools.dropwhile(lambda e: e &lt; 5, range(10))
print(list(x))
[5, 6, 7, 8, 9]
</code></pre>
<ul>
<li><code>itertools.filterfalse</code>:<br>
保留对应真值为<code>False</code>的元素</li>
</ul>
<pre><code class="language-Python">x = itertools.filterfalse(lambda e: e &lt; 5, (1, 5, 3, 6, 9, 4))
print(list(x))
[5, 6, 9]
</code></pre>
<h3 id="math"><code>math</code></h3>
<ul>
<li><code>math.ceil(x)</code>:返回 <code>x</code> 的上限，即大于或者等于 <code>x</code> 的最小整数。</li>
<li><code>math.comb(n, k)</code>:返回不重复且无顺序地从 <code>n</code> 项中选择 <code>k</code> 项的方式总数。</li>
<li><code>math.fabs(x)</code>:返回 <code>x</code> 的绝对值。</li>
<li><code>math.floor(x)</code>:返回 <code>x</code> 的向下取整，小于或等于 <code>x</code> 的最大整数。</li>
<li><code>math.gcd(a, b)</code>:最大公约数</li>
<li><code>math.exp(x)</code>:返回 <code>e</code> 次 <code>x</code> 幂</li>
<li><code>math.pow(x, y)</code>:将返回 <code>x</code> 的 <code>y</code> 次幂。</li>
<li><code>math.sqrt(x)</code>:返回 <code>x</code> 的平方根。</li>
<li><code>math.pi</code>:数学常数 π = 3.141592...，精确到可用精度。</li>
<li><code>math.e</code>:数学常数 e = 2.718281...，精确到可用精度。</li>
<li><code>math.inf</code>:浮点正无穷大。</li>
</ul>
<h3 id="time"><code>time</code></h3>
<p>在 <code>Python</code> 中，用三种方式来表示时间，分别是时间戳、格式化时间字符串和结构化时间</p>
<ul>
<li>时间戳（<code>timestamp</code>）：也就是 1970 年 1 月 1 日之后的秒，例如 1506388236.216345，可以通过<code>time.time()</code>获得。时间戳是一个浮点数，可以进行加减运算，但请注意不要让结果超出取值范围。</li>
<li>格式化的时间字符串（<code>string_time</code>）：也就是年月日时分秒这样的我们常见的时间字符串，例如2017-09-26 09:12:48，可以通过<code>time.strftime('%Y-%m-%d')</code>获得;<br>
结构化时间（<code>struct_time</code>）：一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code>，可以通过<code>time.localtime()</code>获得。</li>
<li>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>等方法可以获得一个格式化时间字符串。</li>
</ul>
<pre><code class="language-Python">time.strftime('%Y-%m-%d %H:%M:%S')
'2017-09-26 10:04:28'
</code></pre>
<p><code>time.strptime(string[,format])</code><br>
将格式化时间字符串转化成结构化时间。该方法是<code>time.strftime()</code>方法的逆操作。<code>time.strptime()</code>方法根据指定的格式把一个时间字符串解析为时间元组。要注意的是，你提供的字符串要和 <code>format</code> 参数的格式一一对应，如果 <code>string</code> 中日期间使用<code>“-”</code>分隔，<code>format</code> 中也必须使用<code>“-”</code>分隔，时间中使用冒号<code>“:”</code>分隔，后面也必须使用冒号分隔，否则会报格式不匹配的错误。并且值也要在合法的区间范围内。</p>
<pre><code class="language-Python">stime = &quot;2017-09-26 12:11:30&quot;
st = time.strptime(stime,&quot;%Y-%m-%d %H:%M:%S&quot;)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321211914.png" alt="" loading="lazy"></figure>
<ul>
<li><code>time.time()</code>:返回当前系统时间戳。时间戳可以做算术运算。</li>
</ul>
<pre><code class="language-Python">time.time()
1506391907.020303
该方法经常用于计算程序运行时间：
```Python
import time
def func():
    time.sleep(1.14)
    pass

t1 = time.time()
func()
t2 = time.time()
print(t2 - t1)
</code></pre>
<h3 id="datetime"><code>datetime</code></h3>
<pre><code class="language-Python">from datetime import datetime, date, time
dt = datetime(2011, 10, 29, 20, 30, 21)
dt.day
29
dt.minute
30
</code></pre>
<ul>
<li>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</li>
</ul>
<pre><code class="language-Python">dt.date()
datetime.date(2011, 10, 29)
dt.time()
datetime.time(20, 30, 21)
</code></pre>
<ul>
<li><code>strftime</code>方法可以将<code>datetime</code>格式化为字符串：</li>
</ul>
<pre><code class="language-Python">dt.strftime('%m/%d/%Y %H:%M')
'10/29/2011 20:30'
</code></pre>
<ul>
<li><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</li>
</ul>
<pre><code class="language-Python">datetime.strptime('20091031', '%Y%m%d')
datetime.datetime(2009, 10, 31, 0, 0)
</code></pre>
<ul>
<li>计算差值</li>
</ul>
<pre><code class="language-Python">now = date.today()
birthday = date(1964, 7, 31)
age = now - birthday
age.days
14368
</code></pre>
<ul>
<li>格式化命令</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317190745.png" alt="" loading="lazy"></figure>
<h2 id="os"><code>os</code></h2>
<ul>
<li><code>os.path.exists(path)</code>:路径存在则返回<code>True</code>,路径损坏返回<code>False</code></li>
<li><code>os.path.join(path1[, path2[, ...]])</code>:把目录和文件名合成一个路径</li>
<li><code>os.system('mkdir today')</code>:命令行命令</li>
<li><code>os.environ</code>:<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;7&quot;</code></li>
</ul>
<h2 id="path"><code>Path</code></h2>
<p>在过去，文件的路径是纯字符串，现在它会是一个<code>pathlib.Path</code>对象:</p>
<pre><code class="language-Python">from pathlib import Path
p = Path('/home/ubuntu')
PosixPath('/home/ubuntu')
str(p)
'/home/ubuntu'
</code></pre>
<p>过去路径拼接最正确的方法是用<code>os.path.join</code>:</p>
<pre><code class="language-Python">os.path.join('/', 'home', 'dongwm/code')
'/home/dongwm/code'
os.path.join('/home', 'dongwm/code')
'/home/dongwm/code'
现在可以用`pathlib.Path`提供的`joinpath`来拼接:
```Python
Path('/').joinpath('home', 'dongwm/code')
PosixPath('/home/dongwm/code')
但是更简单和方便的方法是用`/`运算符:
```Python
Path('/') / 'home' / 'dongwm/code'
PosixPath('/home/dongwm/code')
Path('/') / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
'/' / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
</code></pre>
<p>使用<code>Path</code>对象的<code>parents</code>属性可以拿到各级目录列表(索引值越大越接近<code>root</code>)，而<code>parent</code>就表示父级目录:</p>
<pre><code class="language-Python">p = Path('/Users/dongweiming/test')
p.parents[0]
PosixPath('/Users/dongweiming')
p.parents[1]
PosixPath('/Users')
p.parents[2]
PosixPath('/')
p.parent
PosixPath('/Users/dongweiming')
p.parent.parent
PosixPath('/Users')
</code></pre>
<p>获得文件后缀名:</p>
<pre><code class="language-Python">p = Path('/usr/local/etc/my.cnf')
p.suffix, p.stem
('.cnf', 'my')
</code></pre>
<p>当文件有多个后缀，可以用<code>suffixes</code>返回文件所有后缀列表:</p>
<pre><code class="language-Python">Path('my.tar.bz2').suffixes
['.tar', '.bz2']
Path('my.tar').suffixes
['.tar']
Path('my').suffixes
[]
</code></pre>
<p>Python语言没有内置创建文件的方法(<code>linux</code>下的<code>touch</code>命令)，过去这么做:</p>
<pre><code class="language-Python">with open('new.txt', 'a') as f:
</code></pre>
<p>现在可以直接用<code>Path</code>的<code>touch</code>方法:</p>
<pre><code class="language-Python">Path('new.txt').touch()
</code></pre>
<p><code>touch</code>接受<code>mode</code>参数，能够在创建时确认文件权限，还能通过<code>exist_ok</code>参数方式确认是否可以重复<code>touch</code>(默认可以重复创建，会更新文件的<code>mtime</code>)</p>
<ul>
<li><code>filename.exists()</code>；路径是否存在</li>
<li>打开文件：</li>
</ul>
<pre><code class="language-Python">data_folder = Path(&quot;source_data/text_files/&quot;)
file_to_open = data_folder / &quot;raw_data.txt&quot;
print(file_to_open.read_text())
</code></pre>
<ul>
<li>与<code>os</code>模块对比<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321202526.png" alt="" loading="lazy"></li>
</ul>
<h2 id="第三方库">第三方库</h2>
<h3 id="h5py"><code>h5py</code></h3>
<p>h5py文件是存放两类对象的容器，数据集(<code>dataset</code>)和组(<code>group</code>)，<code>dataset</code>类似数组类的数据集合，和<code>numpy</code>的数组差不多。<code>group</code>是像文件夹一样的容器，它好比<code>Python</code>中的字典，有键(<code>key</code>)和值(<code>value</code>)。<code>group</code>中可以存放<code>dataset</code>或者其他的<code>group</code>。”键”就是组成员的名称，”值”就是组成员对象本身(组或者数据集)</p>
<pre><code class="language-Python">import h5py
</code></pre>
<h4 id="创建">创建</h4>
<pre><code class="language-Python">with h5py.File('test.h5','w') as f:
</code></pre>
<h4 id="读取">读取</h4>
<pre><code class="language-Python">with h5py.File('test.h5','r') as f:
</code></pre>
<p><code>h5py</code>文件就像一个 <code>Python</code> 字典，因此我们可以检查<code>key</code>,</p>
<pre><code class="language-Python">list(f.keys())
['mydataset']
</code></pre>
<p>文件中有一个数据集，即<code>mydataset</code>:</p>
<pre><code class="language-Python">dset = f['mydataset']
dset.shape
(100,)
dset.dtype
dtype('int32')
dset[...] = np.arange(100)
dset[0]
0
dset[10]
10
dset[0:100:10]
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
data = f['mydataset'][:]
</code></pre>
<h4 id="创建数据集">创建数据集：</h4>
<pre><code class="language-Python">d1=f.create_dataset(&quot;dset1&quot;, (20,), 'i')
for key in f.keys():
    print(key)
    print(f[key].name)
    print(f[key].shape)
    print(f[key].value)
dset1
/dset1
(20,)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</code></pre>
<pre><code class="language-Python">dset3 = f.create_dataset('subgroup2/dataset_three', (10,), dtype='i')
</code></pre>
<h4 id="赋值">赋值</h4>
<pre><code class="language-Python">d1=f.create_dataset(&quot;dset1&quot;,(20,),'i')
d1[...]=np.arange(20)
#或者我们可以直接按照下面的方式创建数据集并赋值
f[&quot;dset2&quot;]=np.arange(15)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<p>如果我们有现成的<code>numpy</code>数组，那么可以在创建数据集的时候就赋值，这个时候就不必指定数据的类型和形状了，只需要把数组名传给参数<code>data</code>。</p>
<pre><code class="language-Python">a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
</code></pre>
<h4 id="综合示例1">综合示例1</h4>
<pre><code class="language-Python">#分别创建dset1,dset2,dset3这三个数据集
a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)

d2=f.create_dataset(&quot;dset2&quot;,(3,4),'i')
d2[...]=np.arange(12).reshape((3,4))

f[&quot;dset3&quot;]=np.arange(15)

for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
/dset3
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<h4 id="创建group需要首先以append模式打开文件">创建<code>group</code>,需要首先以<code>append</code>模式打开文件</h4>
<pre><code class="language-Python">f = h5py.File('mydataset.hdf5', 'a')
grp = f.create_group(&quot;subgroup&quot;)
</code></pre>
<pre><code class="language-Python">g1=f.create_group(&quot;bar&quot;)
#在bar这个组里面分别创建name为dset1,dset2的数据集并赋值。
g1[&quot;dset1&quot;]=np.arange(10)
g1[&quot;dset2&quot;]=np.arange(12).reshape((3,4))

for key in g1.keys():
    print(g1[key].name)
    print(g1[key].value)
/bar/dset1
[0 1 2 3 4 5 6 7 8 9]
/bar/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>
<p>注意观察数据集<code>dset1</code>和<code>dset2</code>的名字是不是有点和前面的不一样，如果是直接创建的数据集，不在任何组里面，那么它的名字就是<code>/+名字</code>，现在这两个数据集都在<code>bar</code>这个<code>group</code>(组)里面，名字就变成了<code>/bar+/</code>名字，是不是有点文件夹的感觉！继续看下面的代码，你会对<code>group</code>和<code>dataset</code>的关系进一步了解。</p>
<pre><code class="language-Python">#创建组bar1,组bar2，数据集dset
g1=f.create_group(&quot;bar1&quot;)
g2=f.create_group(&quot;bar2&quot;)
d=f.create_dataset(&quot;dset&quot;,data=np.arange(10))

#在bar1组里面创建一个组car1和一个数据集dset1。
c1=g1.create_group(&quot;car1&quot;)
d1=g1.create_dataset(&quot;dset1&quot;,data=np.arange(10))

#在bar2组里面创建一个组car2和一个数据集dset2
c2=g2.create_group(&quot;car2&quot;)
d2=g2.create_dataset(&quot;dset2&quot;,data=np.arange(10))

#根目录下的组和数据集
for key in f.keys():
    print(f[key].name)
/bar1
/bar2
/dset

#bar1这个组下面的组和数据集
for key in g1.keys():
    print(g1[key].name)
/bar1/car1
/bar1/dset1
#bar2这个组下面的组和数据集
for key in g2.keys():
    print(g2[key].name)
/bar2/car2
/bar2/dset2
#顺便看下car1组和car2组下面都有什么，估计你都猜到了为空。
print(c1.keys())
print(c2.keys())
[]
[]
</code></pre>
<ul>
<li>综合示例2</li>
</ul>
<pre><code class="language-Python">#遍历文件中的一级组
for group in f.keys():
    print (group)
    #根据一级组名获得其下面的组
    group_read = f[group]
    #遍历该一级组下面的子组
    for subgroup in group_read.keys():
        print subgroup     
        #根据一级组和二级组名获取其下面的dataset          
        dset_read = f[group+'/'+subgroup]                           
        #遍历该子组下所有的dataset
        for dset in dset_read.keys():
            #获取dataset数据
            dset1 = f[group+'/'+subgroup+'/'+dset]
            print dset1.name
            data = np.array(dset1)
            print data.shape
            x = data[...,0]
            y = data[...,1]        
</code></pre>
<h4 id="pandas对h5py的操作"><code>Pandas</code>对<code>h5py</code>的操作</h4>
<h5 id="写出">写出</h5>
<ul>
<li><code>path</code>：字符型输入，用于指定<code>h5</code>文件的名称（不在当前工作目录时需要带上完整路径信息）</li>
<li><code>mode</code>：用于指定<code>IO</code>操作的模式，与<code>Python</code>内建的<code>open()</code>中的参数一致，默认为<code>'a'</code>，即当指定文件已存在时不影响原有数据写入，指定文件不存在时则新建文件；<code>'r'</code>，只读模式；<code>'w'</code>，创建新文件（会覆盖同名旧文件）；<code>'r+'</code>，与<code>'a'</code>作用相似，但要求文件必须已经存在；</li>
<li><code>complevel</code>：<code>int</code>型，用于控制<code>h5</code>文件的压缩水平，取值范围在0-9之间，越大则文件的压缩程度越大，占用的空间越小，但相对应的在读取文件时需要付出更多解压缩的时间成本，默认为<code>0</code>，代表不压缩<br>
创建一个<code>HDF5 IO</code>对象<code>store</code>：</li>
</ul>
<pre><code class="language-Python">store = pd.HDFStore('demo.h5')
s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
df = pd.DataFrame(np.random.randn(8, 3),
                 columns=['A', 'B', 'C'])
store['s'],store['df'] = s,df
</code></pre>
<p>从<code>pandas</code>中的数据结构直接导出到本地<code>h5</code>文件中：</p>
<pre><code class="language-Python">#创建新的数据框
df_ = pd.DataFrame(np.random.randn(5,5))
#导出到已存在的h5文件中，这里需要指定key
df_.to_hdf(path_or_buf='demo.h5',key='df_')
#创建于本地demo.h5进行IO连接的store对象
store = pd.HDFStore('demo.h5')
#查看指定h5对象中的所有键
print(store.keys())
</code></pre>
<p>利用store对象的<code>put()</code>方法，其主要参数如下：</p>
<ul>
<li><code>key</code>：指定<code>h5</code>文件中待写入数据的<code>key</code></li>
<li><code>value</code>：指定与<code>key</code>对应的待写入的数据</li>
<li><code>format</code>：字符型输入，用于指定写出的模式，<code>'fixed'</code>对应的模式速度快，但是不支持追加也不支持检索；<code>'table'</code>对应的模式以表格的模式写出，速度稍慢，但是支持直接通过<code>store</code>对象进行追加和表格查询操作<br>
使用<code>put()</code>方法将数据存入<code>store</code>对象中：</li>
</ul>
<pre><code class="language-Python">store.put(key='s',value=s);store.put(key='df',value=df)
</code></pre>
<p>既然是键值对的格式，那么可以查看<code>store</code>的<code>items</code>属性（注意这里<code>store</code>对象只有<code>items</code>和<code>keys</code>属性，没有<code>values</code>属性）：</p>
<pre><code class="language-Python">store.items
</code></pre>
<p>调用<code>store</code>对象中的数据直接用对应的键名来索引即可：</p>
<pre><code class="language-Python">store['df']
</code></pre>
<p>删除<code>store</code>对象中指定数据的方法有两种，一是使用<code>remove()</code>方法，传入要删除数据对应的键：</p>
<pre><code class="language-Python">store.remove('s')
print(store.keys())
</code></pre>
<p>二是使用<code>Python</code>中的关键词<code>del</code>来删除指定数据：</p>
<pre><code class="language-Python">del store['s']
</code></pre>
<h5 id="读取-2">读取</h5>
<pre><code class="language-Python">store = pd.HDFStore('demo.h5')
'''方式1'''
df1 = store['df']
'''方式2'''
df2 = store.get('df')
</code></pre>
<pre><code class="language-Python">df = pd.read_hdf('demo.h5',key='df')
</code></pre>
<ul>
<li>删除对象</li>
</ul>
<pre><code class="language-Python">del subgroup[&quot;MyDataset&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode26. 删除排序数组中的重复项]]></title>
        <id>https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</id>
        <link href="https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/">
        </link>
        <updated>2020-02-22T08:23:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python3">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        cnt=len(set(nums))
        j=0
        for i in range(len(nums)):
            if i!=0:
                if(nums[i]==nums[i-1]):
                    continue
            nums[j]=nums[i]
            j+=1
        if(j&lt;len(nums)):
            del(nums[j:len(nums)])
        return j
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Numpy笔记]]></title>
        <id>https://bailingnan.github.io/post/numpy-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/numpy-bi-ji/">
        </link>
        <updated>2020-02-15T14:58:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="numpy常用函数"><code>NumPy</code>常用函数</h1>
<pre><code class="language-python">import numpy as np
</code></pre>
<h2 id="numpy基础数据结构">Numpy基础数据结构</h2>
<h3 id="多维数组">多维数组</h3>
<pre><code class="language-python">ar = np.array([1,2,3,4,5,6,7])
print(ar.ndim)     # 输出数组维度的个数（轴数），或者说“秩”，维度的数量也称rank
print(ar.shape)    # 数组的维度，对于n行m列的数组，shape为（n，m）
print(ar.size)     # 数组的元素总数，对于n行m列的数组，元素总数为n*m
print(ar.dtype)    # 数组中元素的类型，类似type()（注意了，type()是函数，.dtype是方法）
print(ar.itemsize) # 数组中每个元素的字节大小，int32l类型字节为4，float64的字节为8
print(ar.data)     # 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。
</code></pre>
<h3 id="arange类似range在给定间隔内返回均匀间隔的值"><code>arange()</code>，类似<code>range()</code>，在给定间隔内返回均匀间隔的值。</h3>
<pre><code class="language-python">print(np.arange(10))    # 返回0-9，整型
print(np.arange(10.0))  # 返回0.0-9.0，浮点型
print(np.arange(5,12))  # 返回5-11
print(np.arange(5.0,12,2))  # 返回5.0-12.0，步长为2
</code></pre>
<h3 id="linspace返回在间隔开始停止上计算的num个均匀间隔的样本"><code>linspace()</code>:返回在间隔[开始，停止]上计算的<code>num</code>个均匀间隔的样本。</h3>
<pre><code class="language-python">np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
</code></pre>
<ul>
<li><code>start</code>：起始值</li>
<li><code>stop</code>：结束值</li>
<li><code>num</code>：生成样本数，默认为<code>50</code></li>
<li><code>endpoint</code>：如果为真，则停止是最后一个样本。否则，不包括在内。默认值为<code>True</code>。</li>
<li><code>retstep</code>：如果为真，返回（样本，步长），其中步长是样本之间的间距 → 输出为一个包含2个元素的元组，第一个元素为<code>array</code>，第二个为步长实际值</li>
</ul>
<h3 id="zeros_likeones_like返回具有和给定数组相同形状和类型的零矩阵和全为1矩阵"><code>zeros_like()</code>/<code>ones_like()</code>，返回具有和给定数组相同形状和类型的零矩阵和全为1矩阵</h3>
<pre><code class="language-python">ar= np.array([list(range(5)),list(range(5,10))])
ar1 = np.zeros_like(ar)
ar2=np.ones_like(ar)
</code></pre>
<h3 id="eye单位矩阵"><code>eye()</code>,单位矩阵</h3>
<pre><code class="language-python">np.eye(5)
</code></pre>
<h3 id="empty"><code>empty()</code></h3>
<p><code>empty</code>可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可</p>
<pre><code class="language-python">np.empty((2, 3, 2))
array([[[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]],
       [[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]]])
</code></pre>
<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
</blockquote>
<h3 id="数组创建函数">数组创建函数</h3>
<p>列出了一些数组创建函数。由于<code>NumPy</code>关注的是数值计算，因此，如果没有特别指定，数据类型基本都是<code>float64</code>（浮点数）:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327170700.png" alt="" loading="lazy"></p>
<h2 id="numpy通用函数"><code>NumPy</code>通用函数</h2>
<h3 id="数组的运算">数组的运算</h3>
<p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。<code>NumPy</code>用户称其为矢量化（<code>vectorization</code>）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<pre><code class="language-python">arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
arr * arr 
array([[  1.,   4.,   9.],
       [ 16.,  25.,  36.]])
arr - arr
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
</code></pre>
<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
<pre><code class="language-python">1 / arr 
array([[ 1.    ,  0.5   ,  0.3333],
       [ 0.25  ,  0.2   ,  0.1667]])
arr ** 0.5 
array([[ 1.    ,  1.4142,  1.7321],
       [ 2.    ,  2.2361,  2.4495]])
</code></pre>
<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<pre><code class="language-python">arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])
arr2 
array([[  0.,   4.,   1.],
       [  7.,   2.,  12.]])
arr2 &gt; arr
array([[False,  True, False],
       [ True, False,  True]], dtype=bool)
</code></pre>
<h3 id="数组形状">数组形状</h3>
<ul>
<li><code>.T</code>/<code>.reshape()</code>/<code>.resize()</code>,都是生成新的数组</li>
<li>转置：<br>
转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有<code>transpose</code>方法，还有一个特殊的<code>T</code>属性：</li>
</ul>
<pre><code class="language-python">arr = np.arange(15).reshape((3, 5))
arr 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
arr.T
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
</code></pre>
<p>在进行矩阵计算时，经常需要用到该操作，比如利用<code>np.dot</code>计算矩阵内积：</p>
<pre><code class="language-python">arr = np.random.randn(6, 3)
arr 
array([[-0.8608,  0.5601, -1.2659],
       [ 0.1198, -1.0635,  0.3329],
       [-2.3594, -0.1995, -1.542 ],
       [-0.9707, -1.307 ,  0.2863],
       [ 0.378 , -0.7539,  0.3313],
       [ 1.3497,  0.0699,  0.2467]])
np.dot(arr.T, arr)
array([[ 9.2291,  0.9394,  4.948 ],
       [ 0.9394,  3.7662, -1.3622],
       [ 4.948 , -1.3622,  4.3437]])
</code></pre>
<p>对于高维数组，<code>transpose</code>需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p>
<pre><code class="language-python">arr = np.arange(16).reshape((2, 2, 4))
arr
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],
       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],
       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
</code></pre>
<p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。<br>
简单的转置可以使用<code>.T</code>，它其实就是进行轴对换而已。<code>ndarray</code>还有一个<code>swapaxes</code>方法，它需要接受一对轴编号：</p>
<pre><code class="language-python">arr 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],
       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])
arr.swapaxes(1, 2) 
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],
       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])
</code></pre>
<p><code>swapaxes</code>也是返回源数据的视图（不会进行任何复制操作）。</p>
<h4 id="改变形状">改变形状</h4>
<ul>
<li><code>numpy.reshape(a, newshape, order='C')</code>：为数组提供新形状，而不更改其数据，所以元素数量需要一致</li>
</ul>
<pre><code class="language-python">ar3 = ar1.reshape(2,5)     # 用法1：直接将已有数组改变形状             
ar4 = np.zeros((4,6)).reshape(3,8)   # 用法2：生成数组后直接改变形状
ar5 = np.reshape(np.arange(12),(3,4))   # 用法3：参数内添加数组，目标形状
</code></pre>
<ul>
<li><code>numpy.resize(a, new_shape)</code>：返回具有指定形状的新数组，如有必要可重复填充所需数量的元素,<code>resize</code> 方法将直接修改原数组本身的维度。</li>
</ul>
<h4 id="数组摊平">数组摊平</h4>
<ul>
<li><code>a.ravel()</code> :返回的是 <code>view</code>，会影响原始矩阵。</li>
<li><code>a.flatten()</code>: 都是将多维数组降为一维，<code>flatten()</code> 返回一份新的数组，且对它所做的修改不会影响原始数组。</li>
</ul>
<h3 id="数组的复制">数组的复制</h3>
<pre><code class="language-python">ar1 = np.arange(10)
ar2 = ar1
</code></pre>
<p>python的赋值逻辑：指向内存中生成的一个值 → 这里<code>ar1</code>和<code>ar2</code>指向同一个值，所以<code>ar1</code>改变，<code>ar2</code><strong>一起改变</strong></p>
<pre><code class="language-python">ar3 = ar1.copy()
</code></pre>
<ul>
<li><code>copy()</code>:生成数组及其数据的完整拷贝,<code>ar3</code>改变<code>ar1</code><strong>不随之改变</strong></li>
<li><code>view()</code>:创建一个新数组对象来查看相同数据。改变其中一个变量的 <code>shape</code> 并不会对应改变另一个。但这两个数组是共享所有元素的，所以改变一个数组的某个元素同样会改变另一个数组的对应元素。</li>
</ul>
<h3 id="数组类型转换">数组类型转换：</h3>
<ul>
<li><code>ar.astype()</code>:类型转换</li>
</ul>
<pre><code class="language-python">ar1 = np.arange(10,dtype=float)# 可以在参数位置设置数组类型
ar2 = ar1.astype(np.int32)# a.astype()：转换数组类型,数组类型用np.int32，而不是直接int32
</code></pre>
<p>如果某字符串数组表示的全是数字，也可以用<code>astype</code>将其转换为数值形式：</p>
<pre><code class="language-python">numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
numeric_strings.astype(float)
array([  1.25,  -9.6 ,  42.  ])
</code></pre>
<blockquote>
<p>注意：使用<code>numpy.string_</code>类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。<code>pandas</code>提供了更多非数值数据的便利的处理方法。<br>
笔记：调用<code>astype</code>总会创建一个新的数组（一个数据的备份），即使新的<code>dtype</code>与旧的<code>dtype</code>相同。</p>
</blockquote>
<h3 id="数组堆叠">数组堆叠:</h3>
<ul>
<li><code>np.stack((a,b),axis)</code>:形状必须相同</li>
<li><code>np.hstack((a,b))</code>:注意:((a,b))，这里形状必须一样,水平（按列顺序）堆叠数组</li>
<li><code>np.vstack((a,b))</code>:这里形状可以不一样,垂直（按行顺序）堆叠数组</li>
</ul>
<pre><code class="language-python">a = np.array([[1],[2],[3]]) 
b = np.array([['a'],['b'],['c']])  
ar2 = np.hstack((a,b))  
</code></pre>
<pre><code class="language-python">a = np.array([[1],[2],[3]])   
b = np.array([['a'],['b'],['c'],['d']])   
ar2 = np.vstack((a,b)) 
</code></pre>
<ul>
<li><code>np.column_stack(a,b,c)</code>:可以将每个元素作为一列，例如 <code>np.column_stack((a,b,c))</code> 就将向量 <code>a</code> 作为第一列、<code>b</code> 作为第二列、<code>c</code> 作为第三列</li>
</ul>
<h3 id="数组拆分">数组拆分</h3>
<ul>
<li><code>numpy.hsplit(ary, indices_or_sections)</code>：将数组水平（逐列）拆分为多个子数组 → 按列拆分,输出结果为列表，列表中元素为数组</li>
</ul>
<pre><code class="language-python">ar = np.arange(16).reshape(4,4)
ar1 = np.hsplit(ar,2)
</code></pre>
<ul>
<li><code>numpy.vsplit(ary, indices_or_sections)</code>：:将数组垂直（行方向）拆分为多个子数组 → 按行拆</li>
</ul>
<pre><code class="language-python">ar2 = np.vsplit(ar,4)
</code></pre>
<h3 id="数组运算">数组运算</h3>
<h4 id="基本运算">基本运算</h4>
<ul>
<li><code>a.T</code>/<code>a.transpose()</code>：转置</li>
<li><code>a*b</code>:点乘</li>
<li><code>np.dot(a,b)/a.dot(b)</code>:叉乘</li>
</ul>
<h4 id="统计量">统计量</h4>
<p><code>sum</code>、<code>mean</code>以及标准差<code>std</code>等聚合计算（<code>aggregation</code>，通常叫做约简（<code>reduction</code>））既可以当做数组的实例方法调用，也可以当做顶级<code>NumPy</code>函数使用。</p>
<pre><code class="language-python">ar.mean() # 求平均值
np.mean(arr)
ar.max() # 求最大值
ar.min()  # 求最小值
ar.std()  # 求标准差
ar.var()  # 求方差
ar.sum()
np.sum(ar,axis = 0)  # 求和，np.sum() → axis为0，按列求和；axis为1，按行求和
np.sort(np.array([1,4,3,2,5,6]))  # 排序
</code></pre>
<p>下表列出了全部的基本数组统计方法。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327235323.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327235341.png" alt="" loading="lazy"></p>
<h4 id="其他">其他</h4>
<ul>
<li><code>np.clip(array,min,max))</code>:限制数组中最小值为<code>min</code>,最大值为<code>max</code></li>
<li><code>np.append(array,element/array)</code>:将元素或者新数组的每一个元素添加至新数组</li>
<li><code>np.diff(array,n=num)</code>:求取该数组两个元素之间的差，可用于计算相对误差，差分数组比原来少n个元素</li>
</ul>
<h3 id="基本索引及切片">基本索引及切片</h3>
<p>当有些维度没有指定索引时，空缺的维度被默认为取所有元素。<br>
<code>NumPy</code>还允许使用 <code>dots (...)</code> 表示足够多的冒号来构建完整的索引元组。<br>
比如，如果 <code>x</code> 是 5 维数组：</p>
<ul>
<li><code>x[1,2,...]</code> 等于 <code>x[1,2,:,:,:]</code></li>
<li><code>x[...,3]</code> 等于 <code>x[:,:,:,:,3]</code></li>
<li><code>x[4,...,5,:]</code> 等于 <code>x[4,:,:,5,:]</code><br>
<code>flat</code> 是一个在数组所有元素中运算的迭代器，如下将逐元素地对数组进行操作。</li>
</ul>
<pre><code class="language-python">for element in b.flat:
    print(element)
</code></pre>
<pre><code class="language-python">ar = np.arange(16).reshape(4,4)
print(ar, '数组轴数为%i' %ar.ndim)   # 4*4的数组
print(ar[2],  '数组轴数为%i' %ar[2].ndim)  # 切片为下一维度的一个元素，所以是一维数组
print(ar[2][1]) # 二次索引，得到一维数组中的一个值
print(ar[1:3],  '数组轴数为%i' %ar[1:3].ndim)  # 切片为两个一维数组组成的二维数组
print(ar[2,2])  # 切片数组中的第三行第三列 → 10
print(ar[:2,1:])  # 切片数组中的1,2行、2,3,4列 → 二维数组
</code></pre>
<p>你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p>
<pre><code class="language-python">arr2d[0][2]
arr2d[0, 2]
</code></pre>
<h4 id="布尔型索引">布尔型索引</h4>
<pre><code class="language-python">m = ar &gt; 5
print(m)  # 这里m是一个判断矩阵
print(ar[m])  # 用m判断矩阵去筛选ar数组中&gt;5的元素 → 重点！后面的pandas判断方式原理就来自此处
</code></pre>
<pre><code class="language-python">names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np.random.randn(7, 4)
names 
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='&lt;U4')
data 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 1.669 , -0.4386, -0.5397,  0.477 ],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre>
<p>假设每个名字都对应<code>data</code>数组中的一行，而我们想要选出对应于名字<code>&quot;Bob&quot;</code>的所有行。跟算术运算一样，数组的比较运算（如<code>==</code>）也是矢量化的。因此，对<code>names</code>和字符串<code>&quot;Bob&quot;</code>的比较运算将会产生一个布尔型数组：</p>
<pre><code class="language-python">names == 'Bob'
array([ True, False, False,  True, False, False, False], dtype=bool)
</code></pre>
<p>这个布尔型数组可用于数组索引：</p>
<pre><code class="language-python">data[names == 'Bob']
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.669 , -0.4386, -0.5397,  0.477 ]])
</code></pre>
<p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：</p>
<pre><code class="language-python">data[names == 'Bob'] 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.669 , -0.4386, -0.5397,  0.477 ]])
</code></pre>
<p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。<br>
下面的例子，我选取了<code>names == 'Bob'</code>的行，并索引了列：</p>
<pre><code class="language-python">data[names == 'Bob', 2:] 
array([[ 0.769 ,  1.2464],
       [-0.5397,  0.477 ]])
data[names == 'Bob', 3]
array([ 1.2464,  0.477 ])
</code></pre>
<p>要选择除<code>&quot;Bob&quot;</code>以外的其他值，既可以使用不等于符号（<code>!=</code>），也可以通过<code>~</code>对条件进行否定：</p>
<pre><code class="language-python">names != 'Bob'
array([False,  True,  True, False,  True,  True,  True], dtype=bool)
data[~(names == 'Bob')]

array([[ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre>
<p><code>~</code>操作符用来反转条件很好用：</p>
<pre><code class="language-python">cond = names == 'Bob'
data[~cond]
array([[ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre>
<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用<code>&amp;</code>（和）、<code>|</code>（或）之类的布尔算术运算符即可：</p>
<pre><code class="language-python">mask = (names == 'Bob') | (names == 'Will')
mask
array([ True, False,  True,  True,  True, False, False], dtype=bool)
data[mask] 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 1.669 , -0.4386, -0.5397,  0.477 ],
       [ 3.2489, -1.0212, -0.5771,  0.1241]])
</code></pre>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。<br>
注意：<code>Python</code>关键字<code>and</code>和<code>or</code>在布尔型数组中无效。要使用<code>&amp;</code>与<code>|</code>。<br>
通过布尔型数组设置值是一种经常用到的手段。为了将<code>data</code>中的所有负值都设置为<code>0</code>，我们只需：</p>
<pre><code class="language-python">data[data &lt; 0] = 0
data 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.0072,  0.    ,  0.275 ,  0.2289],
       [ 1.3529,  0.8864,  0.    ,  0.    ],
       [ 1.669 ,  0.    ,  0.    ,  0.477 ],
       [ 3.2489,  0.    ,  0.    ,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [ 0.    ,  0.    ,  0.    ,  0.    ]])
</code></pre>
<p>通过一维布尔数组设置整行或列的值也很简单：</p>
<pre><code class="language-python">data[names != 'Joe'] = 7
data 
array([[ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 1.0072,  0.    ,  0.275 ,  0.2289],
       [ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [ 0.    ,  0.    ,  0.    ,  0.    ]])
</code></pre>
<p>后面会看到，这类二维数据的操作也可以用<code>pandas</code>方便的来做。</p>
<h4 id="数组索引及切片的值更改-复制">数组索引及切片的值更改、复制</h4>
<pre><code class="language-python">ar = np.arange(10)
print(ar)
ar[5] = 100
ar[7:9] = 200# 一个标量赋值给一个索引/切片时，会自动改变/传播原始数组
</code></pre>
<p>跟列表最重要的区别在于，由于<code>NumPy</code>的设计目的是处理大数据，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。<br>
作为例子，先创建一个<code>arr</code>的切片：</p>
<pre><code class="language-python">arr_slice = arr[5:8]
arr_slice
array([12, 12, 12])
</code></pre>
<p>现在，当我修改<code>arr_slice</code>中的值，变动也会体现在原始数组<code>arr</code>中：</p>
<pre><code class="language-python">arr_slice[1] = 12345
arr
array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,   
  9])
</code></pre>
<p>切片<code>[ : ]</code>会给数组中的所有值赋值：</p>
<pre><code class="language-python">arr_slice[:] = 64
arr
array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
</code></pre>
<blockquote>
<p>注意：如果你想要得到的是<code>ndarray</code>切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<h4 id="花式索引">花式索引</h4>
<pre><code class="language-python">arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr 
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])
</code></pre>
<p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或<code>ndarray</code>即可：</p>
<pre><code class="language-python">arr[[4, 3, 0, 6]] 
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])
</code></pre>
<p>使用负数索引将会从末尾开始选取行：</p>
<pre><code class="language-python">arr[[-3, -5, -7]] 
array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 1.,  1.,  1.,  1.]])
</code></pre>
<p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p>
<pre><code class="language-python">arr = np.arange(32).reshape((8, 4))
arr 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
array([ 4, 23, 29, 10])
</code></pre>
<p>最终选出的是元素<code>(1,0)</code>、<code>(5,3)</code>、<code>(7,1)</code>和<code>(2,2)</code>。无论数组是多少维的，花式索引总是一维的。<br>
这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p>
<pre><code class="language-python">arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]] 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
</code></pre>
<p>花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<h4 id="元素级数组函数">元素级数组函数</h4>
<p>通用函数（即<code>ufunc</code>）是一种对<code>ndarray</code>中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。<br>
许多<code>ufunc</code>都是简单的元素级变体，如<code>sqrt</code>和<code>exp</code>：</p>
<pre><code class="language-python">arr = np.arange(10)
arr
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.sqrt(arr) 
array([ 0.    ,  1.    ,  1.4142,  1.7321,  2.    ,  2.2361,  2.4495,
        2.6458,  2.8284,  3.    ])
np.exp(arr) 
array([    1.    ,     2.7183,     7.3891,    20.0855,    54.5982,
         148.4132,   403.4288,  1096.6332,  2980.958 ,  8103.0839])
</code></pre>
<p>这些都是一元（<code>unary</code>）<code>ufunc</code>。另外一些（如<code>add</code>或<code>maximum</code>）接受2个数组（因此也叫二元（<code>binary</code>）<code>ufunc</code>），并返回一个结果数组：</p>
<pre><code class="language-python">x = np.random.randn(8)
y = np.random.randn(8)
x 
array([-0.0119,  1.0048,  1.3272, -0.9193, -1.5491,  0.0222,  0.7584,
       -0.6605])
y 
array([ 0.8626, -0.01  ,  0.05  ,  0.6702,  0.853 , -0.9559, -0.0235,
       -2.3042])
np.maximum(x, y) 
array([ 0.8626,  1.0048,  1.3272,  0.6702,  0.853 ,  0.0222,  0.7584,   
       -0.6605])
</code></pre>
<p>这里，<code>numpy.maximum</code>计算了<code>x</code>和<code>y</code>中元素级别最大的元素。<br>
虽然并不常见，但有些<code>ufunc</code>的确可以返回多个数组。<code>modf</code>就是一个例子，它是<code>Python</code>内置函数<code>divmod</code>的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<pre><code class="language-python">arr = np.random.randn(7) * 5
arr
array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])
remainder, whole_part = np.modf(arr)
remainder
array([-0.2623, -0.0915, -0.663 ,  0.3731,
0.6182,  0.45  ,  0.0077])
whole_part
array([-3., -6., -6.,  5.,  3.,  3.,  5.])
</code></pre>
<p><code>Ufuncs</code>可以接受一个<code>out</code>可选参数，这样就能在数组原地进行操作：</p>
<pre><code class="language-python">arr
array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])
np.sqrt(arr)
array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])
np.sqrt(arr, arr)
array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])
arr
array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])
</code></pre>
<p>下表分别列出了一些一元和二元<code>ufunc</code>:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327185117.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327185147.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327185203.png" alt="" loading="lazy"></p>
<h4 id="将条件逻辑表述为数组运算">将条件逻辑表述为数组运算</h4>
<p><code>numpy.where</code>函数是三元表达式<code>x if condition else y</code>的矢量化版本。假设我们有一个布尔数组和两个值数组：</p>
<pre><code class="language-python">xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])
</code></pre>
<p>假设我们想要根据<code>cond</code>中的值选取<code>xarr</code>和<code>yarr</code>的值：当<code>cond</code>中的值为<code>True</code>时，选取<code>xarr</code>的值，否则从<code>yarr</code>中选取。列表推导式的写法应该如下所示：</p>
<pre><code class="language-python">result = [(x if c else y)for x, y, c in zip(xarr, yarr, cond)]
result
[1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]
</code></pre>
<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯<code>Python</code>完成的）。第二，无法用于多维数组。若使用<code>np.where</code>，则可以将该功能写得非常简洁：</p>
<pre><code class="language-python">result = np.where(cond, xarr, yarr)
result
array([ 1.1,  2.2,  1.3,  1.4,  2.5])
</code></pre>
<p><code>np.where</code>的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，<code>where</code>通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为<code>2</code>，将所有负值替换为<code>－2</code>。若利用<code>np.where</code>，则会非常简单：</p>
<pre><code class="language-python">arr = np.random.randn(4, 4)
arr 
array([[-0.5031, -0.6223, -0.9212, -0.7262],
       [ 0.2229,  0.0513, -1.1577,  0.8167],
       [ 0.4336,  1.0107,  1.8249, -0.9975],
       [ 0.8506, -0.1316,  0.9124,  0.1882]])
arr &gt; 0 
array([[False, False, False, False],
       [ True,  True, False,  True],
       [ True,  True,  True, False],
       [ True, False,  True,  True]], dtype=bool)
np.where(arr &gt; 0, 2, -2)
Out[175]: 
array([[-2, -2, -2, -2],
       [ 2,  2, -2,  2],
       [ 2,  2,  2, -2],
       [ 2, -2,  2,  2]])
</code></pre>
<p>使用<code>np.where</code>，可以将标量和数组结合起来。例如，可用常数<code>2</code>替换<code>arr</code>中所有正的值：</p>
<pre><code class="language-python">np.where(arr &gt; 0, 2, arr) # set only positive values to 2 
array([[-0.5031, -0.6223, -0.9212, -0.7262],
       [ 2.    ,  2.    , -1.1577,  2.    ],
       [ 2.    ,  2.    ,  2.    , -0.9975],
       [ 2.    , -0.1316,  2.    ,  2.    ]])
</code></pre>
<p>传递给<code>where</code>的数组大小可以不相等，甚至可以是标量值。</p>
<h4 id="用于布尔型数组的方法">用于布尔型数组的方法</h4>
<p><code>sum</code>经常被用来对布尔型数组中的<code>True</code>值计数：</p>
<pre><code class="language-python">arr = np.random.randn(100)
(arr &gt; 0).sum() # Number of positive values
42
另外还有两个方法`any`和`all`，它们对布尔型数组非常有用。`any`用于测试数组中是否存在一个或多个`True`，而`all`则检查数组中所有值是否都是`True`：
```python
bools = np.array([False, False, True, False])
bools.any()
True
bools.all()
False
</code></pre>
<p>这两个方法也能用于非布尔型数组，所有非<code>0</code>元素将会被当做<code>True</code>。</p>
<h4 id="排序">排序</h4>
<p>跟<code>Python</code>内置的列表类型一样，<code>NumPy</code>数组也可以通过<code>sort</code>方法就地排序：</p>
<pre><code class="language-python">arr = np.random.randn(6)
arr
array([ 0.6095, -0.4938,  1.24  , -0.1357,  1.43  , -0.8469])
arr.sort()
arr
array([-0.8469, -0.4938, -0.1357,  0.6095,  1.24  ,  1.43  ])
</code></pre>
<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给<code>sort</code>即可：</p>
<pre><code class="language-python">arr = np.random.randn(5, 3)
arr 
array([[ 0.6033,  1.2636, -0.2555],
       [-0.4457,  0.4684, -0.9616],
       [-1.8245,  0.6254,  1.0229],
       [ 1.1074,  0.0909, -0.3501],
       [ 0.218 , -0.8948, -1.7415]])
arr.sort(1)
arr 
array([[-0.2555,  0.6033,  1.2636],
       [-0.9616, -0.4457,  0.4684],
       [-1.8245,  0.6254,  1.0229],
       [-0.3501,  0.0909,  1.1074],
       [-1.7415, -0.8948,  0.218 ]])
</code></pre>
<p>顶级方法<code>np.sort</code>返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p>
<pre><code class="language-python">large_arr = np.random.randn(1000)
large_arr.sort()
large_arr[int(0.05 * len(large_arr))] # 5% quantile
-1.5311513550102103
</code></pre>
<p>在<code>pandas</code>中还可以找到一些其他跟排序有关的数据操作（比如根据一列或多列对表格型数据进行排序）。</p>
<h4 id="唯一化以及其它的集合逻辑">唯一化以及其它的集合逻辑</h4>
<p><code>NumPy</code>提供了一些针对一维<code>ndarray</code>的基本集合运算。最常用的可能要数<code>np.unique</code>了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<pre><code class="language-python">numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)
#返回：
unique_indices:return_index=True时，原始数组中唯一值首次出现的索引。
unique_inverse:return_inverse=True时，从唯一数组重建原始数组的索引。
unique_counts:return_counts=True时，每个唯一值在原始数组中出现的次数。
</code></pre>
<pre><code class="language-python">names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names) 
array(['Bob', 'Joe', 'Will'],
      dtype='&lt;U4')
ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])
np.unique(ints)
array([1, 2, 3, 4])
</code></pre>
<p>拿跟<code>np.unique</code>等价的纯<code>Python</code>代码来对比一下：</p>
<pre><code class="language-python">sorted(set(names))
['Bob', 'Joe', 'Will']
</code></pre>
<p>另一个函数<code>np.in1d</code>用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<pre><code class="language-python">values = np.array([6, 0, 0, 3, 2, 5, 6])
np.in1d(values, [2, 3, 6])
array([ True, False, False,  True,  True, False,  True], dtype=bool)
</code></pre>
<p><code>NumPy</code>中的集合函数见下表。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328001840.png" alt="" loading="lazy"></p>
<h4 id="线性代数">线性代数</h4>
<p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如<code>MATLAB</code>），通过<code>*</code>对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，<code>NumPy</code>提供了一个用于矩阵乘法的<code>dot</code>函数（既是一个数组方法也是<code>NumPy</code>命名空间中的一个函数）：</p>
<pre><code class="language-python">x = np.array([[1., 2., 3.], [4., 5., 6.]])
y = np.array([[6., 23.], [-1, 7], [8, 9]])
x 
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])
y 
array([[  6.,  23.],
       [ -1.,   7.],
       [  8.,   9.]])
x.dot(y) 
array([[  28.,   64.],
       [  67.,  181.]])
</code></pre>
<p><code>x.dot(y)</code>等价于<code>np.dot(x, y)</code>：</p>
<pre><code class="language-python">np.dot(x, y) 
array([[  28.,   64.],
       [  67.,  181.]])
</code></pre>
<p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p>
<pre><code class="language-python">np.dot(x, np.ones(3))
array([  6.,  15.])
</code></pre>
<p><code>@</code>符（类似<code>Python 3.5</code>）也可以用作中缀运算符，进行矩阵乘法：</p>
<pre><code class="language-python">x @ np.ones(3)
array([  6.,  15.])
</code></pre>
<p><code>numpy.linalg</code>中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟<code>MATLAB</code>和<code>R</code>等语言所使用的是相同的行业标准线性代数库，如<code>BLAS</code>、<code>LAPACK</code>、<code>Intel MKL</code>（<code>Math Kernel Library</code>，可能有，取决于你的<code>NumPy</code>版本）等：</p>
<pre><code class="language-python">from numpy.linalg import inv, qr
X = np.random.randn(5, 5)
mat = X.T.dot(X)
inv(mat) 
array([[  933.1189,   871.8258, -1417.6902, -1460.4005,  1782.1391],
       [  871.8258,   815.3929, -1325.9965, -1365.9242,  1666.9347],
       [-1417.6902, -1325.9965,  2158.4424,  2222.0191, -2711.6822],
       [-1460.4005, -1365.9242,  2222.0191,  2289.0575, -2793.422 ],
       [ 1782.1391,  1666.9347, -2711.6822, -2793.422 ,  3409.5128]])
mat.dot(inv(mat)) 
array([[ 1.,  0., -0., -0., -0.],
       [-0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [-0.,  0.,  0.,  1., -0.],
       [-0.,  0.,  0.,  0.,  1.]])
q, r = qr(mat)
r 
array([[-1.6914,  4.38  ,  0.1757,  0.4075, -0.7838],
       [ 0.    , -2.6436,  0.1939, -3.072 , -1.0702],
       [ 0.    ,  0.    , -0.8138,  1.5414,  0.6155],
       [ 0.    ,  0.    ,  0.    , -2.6445, -2.1669],
       [ 0.    ,  0.    ,  0.    ,  0.    ,  0.0002]])
</code></pre>
<p>表达式<code>X.T.dot(X)</code>计算<code>X</code>和它的转置<code>X.T</code>的点积。<br>
下表列出了一些最常用的线性代数函数。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328002434.png" alt="" loading="lazy"></p>
<h2 id="numpy随机数"><code>NumPy</code>随机数</h2>
<h3 id="随机数生成">随机数生成</h3>
<ul>
<li><code>np.random.normal(size=(4,4))</code>:#生成一个标准正态分布的4*4样本值</li>
<li><code>np.random.rand(d0, d1, ..., dn)</code>：生成一个<code>[0,1)</code>之间的随机浮点数或N维浮点数组 —— 均匀分布</li>
<li><code>np.random.randn(d0, d1, ..., dn)</code>：生成一个浮点数或N维浮点数组 —— 正态分布</li>
<li><code>np.random.randint(low, high=None, size=None, dtype='l')</code>：生成一个整数或N维整数数组,若<code>high</code>不为<code>None</code>时，取<code>[low,high)</code>之间随机整数，否则取值<code>[0,low)</code>之间随机整数，且<code>high</code>必须大于<code>low</code>,<code>dtype</code>参数：只能是<code>int</code>类型</li>
</ul>
<h2 id="附录">附录</h2>
<h3 id="ndarray对象的内部机理"><code>ndarray</code>对象的内部机理</h3>
<p><code>NumPy</code>的<code>ndarray</code>提供了一种将同质数据块（可以是连续或跨越）解释为多维数组对象的方式。正如你之前所看到的那样，数据类型（<code>dtype</code>）决定了数据的解释方式，比如浮点数、整数、布尔值等。<br>
<code>ndarray</code>如此强大的部分原因是所有数组对象都是数据块的一个跨度视图（<code>strided view</code>）。你可能想知道数组视图<code>arr[::2,::-1]</code>不复制任何数据的原因是什么。简单地说，<code>ndarray</code>不只是一块内存和一个<code>dtype</code>，它还有跨度信息，这使得数组能以各种步幅（<code>step size</code>）在内存中移动。更准确地讲，<code>ndarray</code>内部由以下内容组成：</p>
<ol>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或<code>dtype</code>，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（<code>shape</code>）的元组。</li>
<li>一个跨度元组（<code>stride</code>），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。<br>
下图简单地说明了<code>ndarray</code>的内部结构。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328003441.png" alt="" loading="lazy"></li>
</ol>
<h3 id="高级数组操作">高级数组操作</h3>
<h4 id="数组重塑">数组重塑</h4>
<p>与<code>reshape</code>将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化（<code>flattening</code>）或散开（<code>raveling</code>）：</p>
<pre><code class="language-python">arr = np.arange(15).reshape((5, 3))
arr 
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
arr.ravel()
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>
<p>如果结果中的值与原始数组相同，<code>ravel</code>不会产生源数据的副本。<code>flatten</code>方法的行为类似于<code>ravel</code>，只不过它总是返回数据的副本：</p>
<pre><code class="language-python">arr.flatten()
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>
<h4 id="数组的合并和拆分">数组的合并和拆分</h4>
<p><code>numpy.concatenate</code>可以按指定轴将一个由数组组成的序列（如元组、列表等）连接到一起：</p>
<pre><code class="language-python">arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([[7, 8, 9], [10, 11, 12]])
np.concatenate([arr1, arr2], axis=0) 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])
np.concatenate([arr1, arr2], axis=1) 
array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])
</code></pre>
<p>对于常见的连接操作，<code>NumPy</code>提供了一些比较方便的方法（如<code>vstack</code>和<code>hstack</code>）。因此，上面的运算还可以表达为：</p>
<pre><code class="language-python">np.vstack((arr1, arr2)) 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])
np.hstack((arr1, arr2))
array([[ 1,  2,  3,  7,  8,  9],
[ 4,  5,  6, 10, 11, 12]])
</code></pre>
<p>与此相反，<code>split</code>用于将一个数组沿指定轴拆分为多个数组,传入到<code>np.split</code>的值<code>[1,3]</code>指示在哪个索引处分割数组。：</p>
<pre><code class="language-python">arr = np.random.randn(5, 2)
arr 
array([[-0.2047,  0.4789],
       [-0.5194, -0.5557],
       [ 1.9658,  1.3934],
       [ 0.0929,  0.2817],
       [ 0.769 ,  1.2464]])
first, second, third = np.split(arr, [1, 3])
first
array([[-0.2047,  0.4789]])
second 
array([[-0.5194, -0.5557],
       [ 1.9658,  1.3934]])
third 
array([[ 0.0929,  0.2817],
       [ 0.769 ,  1.2464]])
</code></pre>
<p>下表中列出了所有关于数组连接和拆分的函数，其中有些是专门为了方便常见的连接运算而提供的。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328005543.png" alt="" loading="lazy"></p>
<h4 id="元素的重复操作tile和repeat">元素的重复操作：<code>tile</code>和<code>repeat</code></h4>
<p>对数组进行重复以产生更大数组的工具主要是<code>repeat</code>和<code>tile</code>这两个函数。<code>repeat</code>会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p>
<pre><code class="language-python">arr = np.arange(3)
arr
array([0, 1, 2])
arr.repeat(3)
array([0, 0, 0, 1, 1, 1, 2, 2, 2])
</code></pre>
<blockquote>
<p>笔记：跟其他流行的数组编程语言（如<code>MATLAB</code>）不同，<code>NumPy</code>中很少需要对数组进行重复（<code>replicate</code>）。这主要是因为广播（<code>broadcasting</code>，我们将在下一节中讲解该技术）能更好地满足该需求。<br>
默认情况下，如果传入的是一个整数，则各元素就都会重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数：</p>
</blockquote>
<pre><code class="language-python">arr.repeat([2, 3, 4])
array([0, 0, 1, 1, 1, 2, 2, 2, 2])
</code></pre>
<p>对于多维数组，还可以让它们的元素沿指定轴重复：</p>
<pre><code class="language-python">arr = np.random.randn(2, 2)
arr 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386]])
       arr.repeat(2, axis=0)
array([[-2.0016, -0.3718],
       [-2.0016, -0.3718],
       [ 1.669 , -0.4386],
       [ 1.669 , -0.4386]])
</code></pre>
<p>注意，如果没有设置轴向，则数组会被扁平化，这可能不会是你想要的结果。同样，在对多维进行重复时，也可以传入一组整数，这样就会使各切片重复不同的次数：</p>
<pre><code class="language-python">arr.repeat([2, 3], axis=0)
array([[-2.0016, -0.3718],
       [-2.0016, -0.3718],
       [ 1.669 , -0.4386],
       [ 1.669 , -0.4386],
       [ 1.669 , -0.4386]])
arr.repeat([2, 3], axis=1) 
array([[-2.0016, -2.0016, -0.3718, -0.3718, -0.3718],
       [ 1.669 ,  1.669 , -0.4386, -0.4386, -0.4386]])
</code></pre>
<p><code>tile</code>的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p>
<pre><code class="language-python">arr
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386]])
np.tile(arr, 2)
array([[-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386]])
</code></pre>
<p>第二个参数是瓷砖的数量。对于标量，瓷砖是水平铺设的，而不是垂直铺设。它可以是一个表示“铺设”布局的元组：</p>
<pre><code class="language-python">arr 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386]])
np.tile(arr, (2, 1)) 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386],
       [-2.0016, -0.3718],
       [ 1.669 , -0.4386]])
np.tile(arr, (3, 2))
array([[-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386],
       [-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386],
       [-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386]])
</code></pre>
<h4 id="花式索引的等价函数take和put">花式索引的等价函数：<code>take</code>和<code>put</code></h4>
<p>获取和设置数组子集的一个办法是通过整数数组使用花式索引：</p>
<pre><code class="language-python">arr = np.arange(10) * 100
inds = [7, 1, 2, 6]
arr[inds]
array([700, 100, 200, 600])
</code></pre>
<p><code>ndarray</code>还有其它方法用于获取单个轴向上的选区：</p>
<pre><code class="language-python">arr.take(inds)
array([700, 100, 200, 600])
arr.put(inds, 42)
arr
array([  0,  42,  42, 300, 400, 500,  42,  42,800, 900])
arr.put(inds, [40, 41, 42, 43])
arr
array([  0,  41,  42, 300, 400, 500,  43,  40, 800, 900])
</code></pre>
<p>要在其它轴上使用<code>take</code>，只需传入<code>axis</code>关键字即可：</p>
<pre><code class="language-python">inds = [2, 0, 2, 1]
arr = np.random.randn(2, 4)
arr
array([[-0.5397,  0.477 ,  3.2489, -1.0212],
       [-0.5771,  0.1241,  0.3026,  0.5238]])
arr.take(inds, axis=1)
array([[ 3.2489, -0.5397,  3.2489,  0.477 ],
       [ 0.3026, -0.5771,  0.3026,  0.1241]])
</code></pre>
<p><code>put</code>不接受<code>axis</code>参数，它只会在数组的扁平化版本（一维，<code>C</code>顺序）上进行索引。因此，在需要用其他轴向的索引设置元素时，最好还是使用花式索引。</p>
<h3 id="广播">广播</h3>
<p>广播（<code>broadcasting</code>）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：</p>
<pre><code class="language-python">arr = np.arange(5)
arr
array([0, 1, 2, 3, 4])
arr * 4
array([ 0,  4,  8, 12, 16])
</code></pre>
<p>这里我们说：在这个乘法运算中，标量值<code>4</code>被广播到了其他所有的元素上。<br>
<code>Broadcast</code>（广播）的规则：</p>
<ol>
<li>让所有输入数组都向其中<code>shape</code>最长的数组看齐，<code>shape</code>中不足的部分都通过在前面加<code>1</code>补齐</li>
<li>输出数组的<code>shape</code>是输入数组<code>shape</code>的各个轴上的最大值</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为<code>1</code>时，这个数组能够用来计算，否则出错</li>
<li>当输入数组的某个轴的长度为<code>1</code>时，沿着此轴运算时都用此轴上的第一组值</li>
<li>两个<code>array</code>的<code>shape</code>长度与<code>shape</code>的每个对应值都相等的时候，那么结果就是对应元素逐元素运算，运算的结果<code>shape</code>不变。<code>shape</code>长度不相等时，先把短的<code>shape</code>前面一直补<code>1</code>，直到与长的<code>shape</code>长度相等时，此时，两个<code>array</code>的<code>shape</code>对应位置上的值 ：</li>
</ol>
<ul>
<li>相等;</li>
<li>其中一个为<code>1</code>;<br>
满足其一才能进行广播。<br>
譬如：<br>
#可以广播<br>
A      (4d array):  8 x 1 x 6 x 1<br>
B      (3d array):      7 x 1 x 5<br>
Result (4d array):  8 x 7 x 6 x 5<br>
#不可以广播<br>
A  (2d array):      2 x 1<br>
B  (3d array):  8 x 4 x 3（倒数第二维不匹配）<br>
看一个例子，我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：</li>
</ul>
<pre><code class="language-python">arr = np.random.randn(4, 3)
arr.mean(0)
array([-0.3928, -0.3824, -0.8768])
demeaned = arr - arr.mean(0)
demeaned
array([[ 0.3937,  1.7263,  0.1633],
       [-0.4384, -1.9878, -0.9839],
       [-0.468 ,  0.9426, -0.3891],
       [ 0.5126, -0.6811,  1.2097]])
demeaned.mean(0)
array([-0.,  0., -0.])
</code></pre>
<p>下图形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328010928.png" alt="" loading="lazy"><br>
于是就得到了：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328010949.png" alt="" loading="lazy"><br>
虽然我是一名经验丰富的<code>NumPy</code>老手，但经常还是得停下来画张图并想想广播的原则。再来看一下最后那个例子，假设你希望对各行减去那个平均值。由于<code>arr.mean(0)</code>的长度为<code>3</code>，所以它可以在<code>0</code>轴向上进行广播：因为<code>arr</code>的后缘维度是<code>3</code>，所以它们是兼容的。根据该原则，要在<code>1</code>轴向上做减法（即各行减去行平均值），较小的那个数组的形状必须是<code>(4,1)</code>：</p>
<pre><code class="language-python">arr
array([[ 0.0009,  1.3438, -0.7135],
       [-0.8312, -2.3702, -1.8608],
       [-0.8608,  0.5601, -1.2659],
       [ 0.1198, -1.0635,  0.3329]])
row_means = arr.mean(1)
row_means.shape
(4,)
row_means.reshape((4, 1)) 
array([[ 0.2104],
       [-1.6874],
       [-0.5222],
       [-0.2036]])
demeaned = arr - row_means.reshape((4, 1))
demeaned.mean(1)
array([ 0., -0.,  0.,  0.])
</code></pre>
<p>下图说明了该运算的过程。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328011257.png" alt="" loading="lazy"><br>
下图展示了另外一种情况，这次是在一个三维数组上沿<code>0</code>轴向加上一个二维数组。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328011338.png" alt="" loading="lazy"><br>
对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。下图说明了要在三维数组各维度上广播的形状需求。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328011338.png" alt="" loading="lazy"><br>
于是就有了一个非常普遍的问题（尤其是在通用算法中），即专门为了广播而添加一个长度为<code>1</code>的新轴。虽然<code>reshape</code>是一个办法，但插入轴需要构造一个表示新形状的元组。这是一个很郁闷的过程。因此，<code>NumPy</code>数组提供了一种通过索引机制插入轴的特殊语法。下面这段代码通过特殊的<code>np.newaxis</code>属性以及“全”切片来插入新轴：</p>
<pre><code class="language-python">arr = np.zeros((4, 4))
arr_3d = arr[:, np.newaxis, :]
arr_3d.shape
(4, 1, 4)
arr_1d = np.random.normal(size=3)
arr_1d[:, np.newaxis] 
array([[-2.3594],
       [-0.1995],
       [-1.542 ]])
arr_1d[np.newaxis, :]
array([[-2.3594, -0.1995, -1.542 ]])
</code></pre>
<p>因此，如果我们有一个三维数组，并希望对轴<code>2</code>进行距平化，那么只需要编写下面这样的代码就可以了：</p>
<pre><code class="language-python">arr = np.random.randn(3, 4, 5)
depth_means = arr.mean(2)
depth_means 
array([[-0.4735,  0.3971, -0.0228,  0.2001],
       [-0.3521, -0.281 , -0.071 , -0.1586],
       [ 0.6245,  0.6047,  0.4396, -0.2846]])
depth_means.shape
(3, 4)
demeaned = arr - depth_means[:, :, np.newaxis]
demeaned.mean(2)
array([[ 0.,  0., -0., -0.],
       [ 0.,  0., -0.,  0.],
       [ 0.,  0., -0., -0.]])
</code></pre>
<p>有些读者可能会想，在对指定轴进行距平化时，有没有一种既通用又不牺牲性能的方法呢？实际上是有的，但需要一些索引方面的技巧：</p>
<pre><code class="language-python">def demean_axis(arr, axis=0):
    means = arr.mean(axis)

    # This generalizes things like [:, :, np.newaxis] to N dimensions
    indexer = [slice(None)] * arr.ndim#slice(None)等价于:,
    indexer[axis] = np.newaxis
    return arr - means[indexer]
</code></pre>
<p>算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作。对于最简单的情况，我们可以这样做：</p>
<pre><code class="language-python">arr = np.zeros((4, 3))
arr[:] = 5
arr 
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
</code></pre>
<p>但是，假设我们想要用一个一维数组来设置目标数组的各列，只要保证形状兼容就可以了：</p>
<pre><code class="language-python">col = np.array([1.28, -0.42, 0.44, 1.6])
arr
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
arr[:] = col[:, np.newaxis]
arr 
array([[ 1.28,  1.28,  1.28],
       [-0.42, -0.42, -0.42],
       [ 0.44,  0.44,  0.44],
       [ 1.6 ,  1.6 ,  1.6 ]])
arr[:2] = [[-1.37], [0.509]]
arr
array([[-1.37 , -1.37 , -1.37 ],
       [ 0.509,  0.509,  0.509],
       [ 0.44 ,  0.44 ,  0.44 ],
       [ 1.6  ,  1.6  ,  1.6  ]])
</code></pre>
<h3 id="ufunc高级应用"><code>ufunc</code>高级应用</h3>
<p>虽然许多<code>NumPy</code>用户只会用到通用函数所提供的快速的元素级运算，但通用函数实际上还有一些高级用法能使我们丢开循环而编写出更为简洁的代码。<br>
<code>ufunc</code>实例方法<br>
<code>NumPy</code>的各个二元<code>ufunc</code>都有一些用于执行特定矢量化运算的特殊方法。下表汇总了这些方法。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328012803.png" alt="" loading="lazy"><br>
<code>reduce</code>接受一个数组参数，并通过一系列的二元运算对其值进行聚合（可指明轴向）。例如，我们可以用<code>np.add.reduce</code>对数组中各个元素进行求和：</p>
<pre><code class="language-python">arr = np.arange(10)
np.add.reduce(arr)
45
arr.sum()
45
</code></pre>
<p>起始值取决于<code>ufunc</code>（对于<code>add</code>的情况，就是<code>0</code>）。如果<br>
如果设置了轴号，约简运算就会沿该轴向执行。这就使你能用一种比较简洁的方式得到某些问题的答案。在下面这个例子中，我们用<code>np.logical_and</code>检查数组各行中的值是否是有序的：</p>
<pre><code class="language-python">np.random.seed(12346)  # for reproducibility
arr = np.random.randn(5, 5)
arr[::2].sort(1) # sort a few rows
arr[:, :-1] &lt; arr[:, 1:] 
array([[ True,  True,  True,  True],
       [False,  True, False, False],
       [ True,  True,  True,  True],
       [ True, False,  True,  True],
       [ True,  True,  True,  True]], dtype=bool)
np.logical_and.reduce(arr[:, :-1] &lt; arr[:, 1:], axis=1)
array([ True, False,  True, False,  True], dtype=bool)
</code></pre>
<blockquote>
<p>注意，<code>logical_and.reduce</code>跟<code>all</code>方法是等价的。<br>
<code>ccumulate</code>跟<code>reduce</code>的关系就像<code>cumsum</code>跟<code>sum</code>的关系那样。它产生一个跟原数组大小相同的中间“累计”值数组：</p>
</blockquote>
<pre><code class="language-python">arr = np.arange(15).reshape((3, 5))
np.add.accumulate(arr, axis=1) 
array([[ 0,  1,  3,  6, 10],
       [ 5, 11, 18, 26, 35],
       [10, 21, 33, 46, 60]])
</code></pre>
<p><code>outer</code>用于计算两个数组的叉积：</p>
<pre><code class="language-python">arr = np.arange(3).repeat([1, 2, 2])
arr
array([0, 1, 1, 2, 2])
np.multiply.outer(arr, np.arange(5))
array([[0, 0, 0, 0, 0],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8],
       [0, 2, 4, 6, 8]])
</code></pre>
<p><code>outer</code>输出结果的维度是两个输入数据的维度之和：</p>
<pre><code class="language-python">x, y = np.random.randn(3, 4), np.random.randn(5)
result = np.subtract.outer(x, y)
result.shape
(3, 4, 5)
</code></pre>
<p>最后一个方法<code>reduceat</code>用于计算“局部约简”，其实就是一个对数据各切片进行聚合的<code>groupby</code>运算。它接受一组用于指示如何对值进行拆分和聚合的“面元边界”：</p>
<pre><code class="language-python">arr = np.arange(10)
np.add.reduceat(arr, [0, 5, 8])
array([10, 18, 17])
</code></pre>
<p>最终结果是在<code>arr[0:5]</code>、<code>arr[5:8]</code>以及<code>arr[8:]</code>上执行的约简。跟其他方法一样，这里也可以传入一个<code>axis</code>参数：</p>
<pre><code class="language-python">arr = np.multiply.outer(np.arange(4), np.arange(5))
arr
array([[ 0,  0,  0,  0,  0],
       [ 0,  1,  2,  3,  4],
       [ 0,  2,  4,  6,  8],
       [ 0,  3,  6,  9, 12]])
np.add.reduceat(arr, [0, 2, 4], axis=1)
array([[ 0,  0,  0],
       [ 1,  5,  4],
       [ 2, 10,  8],
       [ 3, 15, 12]])
</code></pre>
<h3 id="编写新的ufunc">编写新的<code>ufunc</code></h3>
<p>有多种方法可以让你编写自己的<code>NumPy ufuncs</code>。<br>
<code>numpy.frompyfunc</code>接受一个<code>Python</code>函数以及两个分别表示输入输出参数数量的参数。例如，下面是一个能够实现元素级加法的简单函数：</p>
<pre><code class="language-python">def add_elements(x, y):
    return x + y
add_them = np.frompyfunc(add_elements, 2, 1)
add_them(np.arange(8), np.arange(8))
array([0, 2, 4, 6, 8, 10, 12, 14], dtype=object)
</code></pre>
<p>用<code>frompyfunc</code>创建的函数总是返回<code>Python</code>对象数组，这一点很不方便。幸运的是，还有另一个办法，即<code>numpy.vectorize</code>。虽然没有<code>frompyfunc</code>那么强大，但可以让你指定输出类型：</p>
<pre><code class="language-python">add_them = np.vectorize(add_elements, otypes=[np.float64])
add_them(np.arange(8), np.arange(8))
array([  0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.])
</code></pre>
<p>虽然这两个函数提供了一种创建<code>ufunc</code>型函数的手段，但它们非常慢，因为它们在计算每个元素时都要执行一次<code>Python</code>函数调用，这就会比<code>NumPy</code>自带的基于<code>C</code>的<code>ufunc</code>慢很多：</p>
<pre><code class="language-python">arr = np.random.randn(10000)
%timeit add_them(arr, arr)
4.12 ms +- 182 us per loop (mean +- std. dev. of 7 runs, 100 loops each)
%timeit np.add(arr, arr)
6.89 us +- 504 ns per loop (mean +- std. dev. of 7 runs, 100000 loops each)
</code></pre>
<h3 id="结构化和记录式数组">结构化和记录式数组</h3>
<p>你可能已经注意到了，到目前为止我们所讨论的<code>ndarray</code>都是一种同质数据容器，也就是说，在它所表示的内存块中，各元素占用的字节数相同（具体根据<code>dtype</code>而定）。从表面上看，它似乎不能用于表示异质或表格型的数据。结构化数组是一种特殊的<code>ndarray</code>，其中的各个元素可以被看做<code>C</code>语言中的结构体（<code>struct</code>，这就是“结构化”的由来）或<code>SQL</code>表中带有多个命名字段的行：</p>
<pre><code class="language-python">dtype = [('x', np.float64), ('y', np.int32)]
sarr = np.array([(1.5, 6), (np.pi, -2)], dtype=dtype)
sarr
array([( 1.5   ,  6), ( 3.1416, -2)],
      dtype=[('x', '&lt;f8'), ('y', '&lt;i4')])
</code></pre>
<p>定义结构化<code>dtype</code>（请参考<code>NumPy</code>的在线文档）的方式有很多。最典型的办法是元组列表，各元组的格式为(<code>field_name</code>,<code>field_data_type</code>)。这样，数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：</p>
<pre><code class="language-python">sarr[0]
( 1.5, 6)
sarr[0]['y']
6
</code></pre>
<p>字段名保存在<code>dtype.names</code>属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制：</p>
<pre><code class="language-python">sarr['x']
array([ 1.5   ,  3.1416])
</code></pre>
<p>嵌套<code>dtype</code>和多维字段<br>
在定义结构化<code>dtype</code>时，你可以再设置一个形状（可以是一个整数，也可以是一个元组）：</p>
<pre><code class="language-python">dtype = [('x', np.int64, 3), ('y', np.int32)]
arr = np.zeros(4, dtype=dtype)
arr
array([([0, 0, 0], 0), ([0, 0, 0], 0), ([0, 0, 0], 0), ([0, 0, 0], 0)],
      dtype=[('x', '&lt;i8', (3,)), ('y', '&lt;i4')])
</code></pre>
<p>在这种情况下，各个记录的<code>x</code>字段所表示的是一个长度为<code>3</code>的数组：</p>
<pre><code class="language-python">arr[0]['x']
array([0, 0, 0])
</code></pre>
<p>这样，访问<code>arr['x']</code>即可得到一个二维数组，而不是前面那个例子中的一维数组：</p>
<pre><code class="language-python">arr['x']
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
</code></pre>
<p>这就使你能用单个数组的内存块存放复杂的嵌套结构。你还可以嵌套<code>dtype</code>，作出更复杂的结构。下面是一个简单的例子：</p>
<pre><code class="language-python">dtype = [('x', [('a', 'f8'), ('b', 'f4')]), ('y', np.int32)]
data = np.array([((1, 2), 5), ((3, 4), 6)], dtype=dtype)
data['x']
array([( 1.,  2.), ( 3.,  4.)],
      dtype=[('a', '&lt;f8'), ('b', '&lt;f4')])
data['y']
array([5, 6], dtype=int32)
data['x']['a']
array([ 1.,  3.])
</code></pre>
<p><code>pandas</code>的<code>DataFrame</code>并不直接支持该功能，但它的分层索引机制跟这个差不多。<br>
跟<code>pandas</code>的<code>DataFrame</code>相比，<code>NumPy</code>的结构化数组是一种相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套列的表格型结构。由于数组中的每个元素在内存中都被表示为固定的字节数，所以结构化数组能够提供非常快速高效的磁盘数据读写（包括内存映像）、网络传输等功能。<br>
结构化数组的另一个常见用法是，将数据文件写成定长记录字节流，这是<code>C</code>和<code>C++</code>代码中常见的数据序列化手段（业界许多历史系统中都能找得到）。只要知道文件的格式（记录的大小、元素的顺序、字节数以及数据类型等），就可以用<code>np.fromfile</code>将数据读入内存。</p>
<h3 id="更多有关排序的话题">更多有关排序的话题</h3>
<p>跟<code>Python</code>内置的列表一样，<code>ndarray</code>的<code>sort</code>实例方法也是就地排序。也就是说，数组内容的重新排列是不会产生新数组的：</p>
<pre><code class="language-python">arr = np.random.randn(6)
arr.sort()
arr
array([-1.082 ,  0.3759,  0.8014,  1.1397,  1.2888,  1.8413])
</code></pre>
<p>在对数组进行就地排序时要注意一点，如果目标数组只是一个视图，则原始数组将会被修改：</p>
<pre><code class="language-python">arr = np.random.randn(3, 5)
arr 
array([[-0.3318, -1.4711,  0.8705, -0.0847, -1.1329],
       [-1.0111, -0.3436,  2.1714,  0.1234, -0.0189],
       [ 0.1773,  0.7424,  0.8548,  1.038 , -0.329 ]])
arr[:, 0].sort()  # Sort first column values in-place
arr
array([[-1.0111, -1.4711,  0.8705, -0.0847, -1.1329],
       [-0.3318, -0.3436,  2.1714,  0.1234, -0.0189],
       [ 0.1773,  0.7424,  0.8548,  1.038 , -0.329 ]])
</code></pre>
<p>相反，<code>numpy.sort</code>会为原数组创建一个已排序副本。另外，它所接受的参数（比如<code>kind</code>）跟<code>ndarray.sort</code>一样：</p>
<pre><code class="language-python">arr = np.random.randn(5)
arr
array([-1.1181, -0.2415, -2.0051,  0.7379, -1.0614])
np.sort(arr)
array([-2.0051, -1.1181, -1.0614, -0.2415,  0.7379])
arr
array([-1.1181, -0.2415, -2.0051,  0.7379, -1.0614])
</code></pre>
<p>这两个排序方法都可以接受一个<code>axis</code>参数，以便沿指定轴向对各块数据进行单独排序：</p>
<pre><code class="language-python">arr = np.random.randn(3, 5)
arr
array([[ 0.5955, -0.2682,  1.3389, -0.1872,  0.9111],
       [-0.3215,  1.0054, -0.5168,  1.1925, -0.1989],
       [ 0.3969, -1.7638,  0.6071, -0.2222, -0.2171]])
arr.sort(axis=1)
arr
array([[-0.2682, -0.1872,  0.5955,  0.9111,  1.3389],
       [-0.5168, -0.3215, -0.1989,  1.0054,  1.1925],
       [-1.7638, -0.2222, -0.2171,  0.3969,  0.6071]])
</code></pre>
<p>你可能注意到了，这两个排序方法都不可以被设置为降序。其实这也无所谓，因为数组切片会产生视图（也就是说，不会产生副本，也不需要任何其他的计算工作）。许多<code>Python</code>用户都很熟悉一个有关列表的小技巧：<code>values[::-1]</code>可以返回一个反序的列表。对<code>ndarray</code>也是如此：</p>
<pre><code class="language-python">arr[:, ::-1]
array([[ 1.3389,  0.9111,  0.5955, -0.1872, -0.2682],
       [ 1.1925,  1.0054, -0.1989, -0.3215, -0.5168],
       [ 0.6071,  0.3969, -0.2171, -0.2222, -1.7638]])
</code></pre>
<h4 id="间接排序argsort和lexsort">间接排序：<code>argsort</code>和<code>lexsort</code></h4>
<p>在数据分析工作中，常常需要根据一个或多个键对数据集进行排序。例如，一个有关学生信息的数据表可能需要以姓和名进行排序（先姓后名）。这就是间接排序的一个例子，如果你阅读过有关<code>pandas</code>的章节，那就已经见过不少高级例子了。给定一个或多个键，你就可以得到一个由整数组成的索引数组（我亲切地称之为索引器），其中的索引值说明了数据在新顺序下的位置。<code>argsort</code>和<code>numpy.lexsort</code>就是实现该功能的两个主要方法。下面是一个简单的例子：</p>
<pre><code class="language-python">values = np.array([5, 0, 1, 3, 2])
indexer = values.argsort()
indexer
array([1, 2, 4, 3, 0])
values[indexer]
array([0, 1, 2, 3, 5])
</code></pre>
<p>一个更复杂的例子，下面这段代码根据数组的第一行对其进行排序：</p>
<pre><code class="language-python">arr = np.random.randn(3, 5)
arr[0] = values
arr 
array([[ 5.    ,  0.    ,  1.    ,  3.    ,  2.    ],
       [-0.3636, -0.1378,  2.1777, -0.4728,  0.8356],
       [-0.2089,  0.2316,  0.728 , -1.3918,  1.9956]])
arr[:, arr[0].argsort()]
array([[ 0.    ,  1.    ,  2.    ,  3.    ,  5.    ],
       [-0.1378,  2.1777,  0.8356, -0.4728, -0.3636],
       [ 0.2316,  0.728 ,  1.9956, -1.3918, -0.2089]])
</code></pre>
<p><code>lexsort</code>跟<code>argsort</code>差不多，只不过它可以一次性对多个键数组执行间接排序（字典序）。假设我们想对一些以姓和名标识的数据进行排序：</p>
<pre><code class="language-python">first_name = np.array(['Bob', 'Jane', 'Steve', 'Bill', 'Barbara'])
last_name = np.array(['Jones', 'Arnold', 'Arnold', 'Jones', 'Walters'])
sorter = np.lexsort((first_name, last_name))
sorter
array([1, 2, 3, 0, 4])
zip(last_name[sorter], first_name[sorter])
&lt;zip at 0x7fa203eda1c8&gt;
</code></pre>
<p>刚开始使用<code>lexsort</code>的时候可能会比较容易头晕，这是因为键的应用顺序是从最后一个传入的算起的。不难看出，<code>last_name</code>是先于<code>first_name</code>被应用的。</p>
<blockquote>
<p>笔记：<code>Series</code>和<code>DataFrame</code>的<code>sort_index</code>以及<code>Series</code>的<code>order</code>方法就是通过这些函数的变体（它们还必须考虑缺失值）实现的。</p>
</blockquote>
<h4 id="其他排序算法">其他排序算法</h4>
<p>稳定的（<code>stable</code>）排序算法会保持等价元素的相对位置。对于相对位置具有实际意义的那些间接排序而言，这一点非常重要：</p>
<pre><code class="language-python">values = np.array(['2:first', '2:second', '1:first', '1:second','1:third'])
key = np.array([2, 2, 1, 1, 1])
indexer = key.argsort(kind='mergesort')
indexer
array([2, 3, 4, 0, 1])
values.take(indexer)
array(['1:first', '1:second', '1:third', '2:first', '2:second'],
      dtype='&lt;U8')
</code></pre>
<p><code>mergesort</code>（合并排序）是唯一的稳定排序，它保证有<code>O(nlogn)</code>的性能（空间复杂度），但是其平均性能比默认的<code>quicksort</code>（快速排序）要差。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200328020416.png" alt="" loading="lazy"></p>
<h4 id="部分排序数组">部分排序数组</h4>
<p>排序的目的之一可能是确定数组中最大或最小的元素。<code>NumPy</code>有两个优化方法，<code>numpy.partition</code>和<code>np.argpartition</code>，可以在第k个最小元素划分的数组：</p>
<pre><code class="language-python">np.random.seed(12345)
arr = np.random.randn(20)
arr
array([-0.2047,  0.4789, -0.5194, -0.5557,  1.9658,  1.3934,  0.0929,
        0.2817,  0.769 ,  1.2464,  1.0072, -1.2962,  0.275 ,  0.2289,
        1.3529,  0.8864, -2.0016, -0.3718,  1.669 , -0.4386])
np.partition(arr, 3)
array([-2.0016, -1.2962, -0.5557, -0.5194, -0.3718, -0.4386, -0.2047,
        0.2817,  0.769 ,  0.4789,  1.0072,  0.0929,  0.275 ,  0.2289,
        1.3529,  0.8864,  1.3934,  1.9658,  1.669 ,  1.2464])
</code></pre>
<p>当你调用<code>partition(arr, 3)</code>，结果中的头三个元素是最小的三个，没有特定的顺序。<code>numpy.argpartition</code>与<code>numpy.argsort</code>相似，会返回索引，重排数据为等价的顺序：</p>
<pre><code class="language-python">indices = np.argpartition(arr, 3)
indices
array([16, 11,  3,  2, 17, 19,  0,  7,  8,  1, 10,  6, 12, 13, 14, 15,  5,
        4, 18,  9])
arr.take(indices)
array([-2.0016, -1.2962, -0.5557, -0.5194, -0.3718, -0.4386, -0.2047,
        0.2817,  0.769 ,  0.4789,  1.0072,  0.0929,  0.275 ,  0.2289,
        1.3529,  0.8864,  1.3934,  1.9658,  1.669 ,  1.2464])
</code></pre>
<p><code>searchsorted</code>是一个在有序数组上执行二分查找的数组方法，只要将值插入到它返回的那个位置就能维持数组的有序性：</p>
<pre><code class="language-python">arr = np.array([0, 1, 7, 12, 15])
arr.searchsorted(9)
3
</code></pre>
<p>你可以传入一组值就能得到一组索引：</p>
<pre><code class="language-python">arr.searchsorted([0, 8, 11, 16])
array([0, 3, 3, 5])
</code></pre>
<p>从上面的结果中可以看出，对于元素<code>0</code>，<code>searchsorted</code>会返回<code>0</code>。这是因为其默认行为是返回相等值组的左侧索引：</p>
<pre><code class="language-python">arr = np.array([0, 0, 0, 1, 1, 1, 1])
arr.searchsorted([0, 1])
array([0, 3])
arr.searchsorted([0, 1], side='right')
array([3, 7])
</code></pre>
<p>再来看<code>searchsorted</code>的另一个用法，假设我们有一个数据数组（其中的值在<code>0</code>到<code>10000</code>之间），还有一个表示“面元边界”的数组，我们希望用它将数据数组拆分开：</p>
<pre><code class="language-python">data = np.floor(np.random.uniform(0, 10000, size=50))
bins = np.array([0, 100, 1000, 5000, 10000])
data
array([ 9940.,  6768.,  7908.,  1709.,   268.,  8003., 9037.,   246.,
        4917.,  5262.,  5963.,   519.,  8950.,  7282.,  8183.,  5002.,
        8101.,   959.,  2189.,  2587.,  4681.,  4593.,  7095.,  1780.,
        5314.,  1677.,  7688.,  9281.,  6094.,  1501.,  4896.,  3773.,
        8486.,  9110.,  3838.,  3154.,  5683.,  1878.,  1258.,  6875.,
        7996.,  5735.,  9732.,  6340.,  8884.,  4954.,  3516.,  7142.,
        5039.,  2256.])
</code></pre>
<p>然后，为了得到各数据点所属区间的编号（其中1表示面元<code>[0,100)</code>），我们可以直接使用<code>searchsorted</code>：</p>
<pre><code class="language-python">labels = bins.searchsorted(data)
labels 
array([4, 4, 4, 3, 2, 4, 4, 2, 3, 4, 4, 2, 4, 4, 4, 4, 4, 2, 3, 3, 3, 3, 4,
       3, 4, 3, 4, 4, 4, 3, 3, 3, 4, 4, 3, 3, 4, 3, 3, 4, 4, 4, 4, 4, 4, 3,
       3, 4, 4, 3])
</code></pre>
<p>通过<code>pandas</code>的<code>groupby</code>使用该结果即可非常轻松地对原数据集进行拆分：</p>
<pre><code class="language-python">pd.Series(data).groupby(labels).mean()
2     498.000000
3    3064.277778
4    7389.035714
dtype: float64
</code></pre>
<h3 id="用numba编写快速numpy函数">用<code>Numba</code>编写快速<code>NumPy</code>函数</h3>
<p><code>Numba</code>是一个开源项目，它可以利用<code>CPUs</code>、<code>GPUs</code>或其它硬件为类似<code>NumPy</code>的数据创建快速函数。它使用了<code>LLVM</code>项目，将<code>Python</code>代码转换为机器代码。<br>
为了介绍<code>Numba</code>，来考虑一个纯粹的<code>Python</code>函数，它使用<code>for</code>循环计算表达式<code>(x - y).mean()</code>：</p>
<pre><code class="language-python">import numpy as np
def mean_distance(x, y):
    nx = len(x)
    result = 0.0
    count = 0
    for i in range(nx):
        result += x[i] - y[i]
        count += 1
    return result / count
</code></pre>
<p><code>Numba</code>的版本要比它快过100倍。我们可以转换这个函数为编译的<code>Numba</code>函数，使用<code>numba.jit</code>函数：</p>
<pre><code class="language-python">import numba as nb
numba_mean_distance = nb.jit(mean_distance)
</code></pre>
<p>也可以写成装饰器：</p>
<pre><code class="language-python">@nb.njit
def mean_distance(x, y):
    nx = len(x)
    result = 0.0
    count = 0
    for i in range(nx):
        result += x[i] - y[i]
        count += 1
    return result / count
</code></pre>
<h3 id="性能建议">性能建议</h3>
<p>使用<code>NumPy</code>的代码的性能一般都很不错，因为数组运算一般都比纯<code>Python</code>循环快得多。下面大致列出了一些需要注意的事项：</p>
<ul>
<li>将<code>Python</code>循环和条件逻辑转换为数组运算和布尔数组运算。</li>
<li>尽量使用广播。</li>
<li>避免复制数据，尽量使用数组视图（即切片）。</li>
<li>利用<code>ufunc</code>及其各种方法。<br>
在某些应用场景中，数组的内存布局可以对计算速度造成极大的影响。这是因为性能差别在一定程度上跟<code>CPU</code>的高速缓存（<code>cache</code>）体系有关。运算过程中访问连续内存块（例如，对以<code>C</code>顺序存储的数组的行求和）一般是最快的，因为内存子系统会将适当的内存块缓存到超高速的<code>L1</code>或<code>L2``CPU Cache</code>中。此外，<code>NumPy</code>的<code>C</code>语言基础代码（某些）对连续存储的情况进行了优化处理，这样就能避免一些跨越式的内存访问。</li>
</ul>
<p>一个数组的内存布局是连续的，就是说元素是以它们在数组中出现的顺序（即<code>Fortran</code>型（列优先）或<code>C</code>型（行优先））存储在内存中的。默认情况下，<code>NumPy</code>数组是以<code>C</code>型连续的方式创建的。列优先的数组（比如<code>C</code>型连续数组的转置）也被称为<code>Fortran</code>型连续。通过<code>ndarray</code>的<code>flags</code>属性即可查看这些信息：</p>
<pre><code class="language-python">arr_c = np.ones((1000, 1000), order='C')
arr_f = np.ones((1000, 1000), order='F')
arr_c.flags
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
arr_f.flags
  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
arr_f.flags.f_contiguous
True
</code></pre>
<p>在这个例子中，对两个数组的行进行求和计算，理论上说，<code>arr_c</code>会比<code>arr_f</code>快，因为<code>arr_c</code>的行在内存中是连续的。<br>
注意，在构造数组的视图时，其结果不一定是连续的：</p>
<pre><code class="language-python">arr_c[:50].flags.contiguous
True
arr_c[:, :50].flags
  C_CONTIGUOUS : False
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[待安装包]]></title>
        <id>https://bailingnan.github.io/post/dai-an-zhuang-bao/</id>
        <link href="https://bailingnan.github.io/post/dai-an-zhuang-bao/">
        </link>
        <updated>2020-02-07T02:42:25.000Z</updated>
        <content type="html"><![CDATA[<p>flake8<br>
SpeedTorch<br>
ohmyzsh<br>
pypy<br>
skorch<br>
<strong>tpot</strong><br>
<strong>wandb</strong><br>
<strong>FBLearner Flow</strong><br>
<strong>mlflow</strong><br>
<strong>Neptune.ai</strong><br>
<strong>nyaggle</strong><br>
<strong>fastai</strong>有协同过滤<br>
<strong>torch-optimizer</strong> 拓展pytorch优化器<br>
<strong>test tube</strong><br>
<strong>neptune-notebooks</strong><br>
<strong>comet_ml</strong><br>
<strong>tensorwatch</strong>notebook里可运行<br>
<strong>swifter</strong>加速pandas<br>
<strong>modin(加载数据和查询数据更快，统计方法pandas更快)</strong><br>
<strong>numba</strong><br>
<strong>cupy(1000万以上数据才更快)</strong><br>
Cython<br>
hyperparameter_hunter</p>
<p>DeepSpeed 微软分布式训练工具<br>
dvc<br>
<strong>hiddenlayer</strong><br>
syncthing<br>
ignite<br>
pytorch-lightning<br>
fastai<br>
prefetch_generator<br>
torchsummary<br>
apex<br>
dali<br>
optuna<br>
pip-review<br>
autogluon<br>
arthas<br>
greys-anatomy<br>
implicit<br>
eli5<br>
icecream<br>
stackprinter<br>
dlrm<br>
buffalo<br>
cupy<br>
acptum<br>
featuretools<br>
boruta_py<br>
Categorical-encoding<br>
Tsfresh<br>
Scikit-Optimize<br>
Hyperopt<br>
ray<br>
ENAS-pytorch<br>
MLBox<br>
h2o<br>
AutoKeras<br>
TPOT<br>
Auto-Sklearn</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matplotlib笔记]]></title>
        <id>https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi-di-09-zhang-hui-tu-he-ke-shi-hua/</id>
        <link href="https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi-di-09-zhang-hui-tu-he-ke-shi-hua/">
        </link>
        <updated>2020-02-04T09:09:53.000Z</updated>
        <content type="html"><![CDATA[<p>信息可视化（也叫绘图）是数据分析中最重要的工作之一。它可能是探索过程的一部分，例如，帮助我们找出异常值、必要的数据转换、得出有关模型的idea等。另外，做一个可交互的数据可视化也许是工作的最终目标。Python有许多库进行静态或动态的数据可视化，但我这里重要关注于matplotlib（http://matplotlib.org/）和基于它的库。</p>
<p>matplotlib是一个用于创建出版质量图表的桌面绘图包（主要是2D方面）。该项目是由John Hunter于2002年启动的，其目的是为Python构建一个MATLAB式的绘图接口。matplotlib和IPython社区进行合作，简化了从IPython shell（包括现在的Jupyter notebook）进行交互式绘图。matplotlib支持各种操作系统上许多不同的GUI后端，而且还能将图片导出为各种常见的矢量（vector）和光栅（raster）图：PDF、SVG、JPG、PNG、BMP、GIF等。除了几张，本书中的大部分图都是用它生成的。</p>
<p>随着时间的发展，matplotlib衍生出了多个数据可视化的工具集，它们使用matplotlib作为底层。其中之一是seaborn（http://seaborn.pydata.org/），本章后面会学习它。</p>
<p>学习本章代码案例的最简单方法是在Jupyter notebook进行交互式绘图。在Jupyter notebook中执行下面的语句：</p>
<pre><code class="language-python">%matplotlib notebook
</code></pre>
<h1 id="91-matplotlib-api入门">9.1 matplotlib API入门</h1>
<p>matplotlib的通常引入约定是：</p>
<pre><code class="language-python">In [11]: import matplotlib.pyplot as plt
</code></pre>
<p>在Jupyter中运行%matplotlib notebook（或在IPython中运行%matplotlib），就可以创建一个简单的图形。如果一切设置正确，会看到图9-1：</p>
<pre><code class="language-python">In [12]: import numpy as np

In [13]: data = np.arange(10)

In [14]: data
Out[14]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [15]: plt.plot(data)
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/7178691-7032e333a6ecdd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-1 简单的线图" loading="lazy"></figure>
<p>虽然seaborn这样的库和pandas的内置绘图函数能够处理许多普通的绘图任务，但如果需要自定义一些高级功能的话就必须学习matplotlib API。</p>
<blockquote>
<p>笔记：虽然本书没有详细地讨论matplotlib的各种功能，但足以将你引入门。matplotlib的示例库和文档是学习高级特性的最好资源。</p>
</blockquote>
<h2 id="figure和subplot">Figure和Subplot</h2>
<p>matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure：</p>
<pre><code class="language-python">In [16]: fig = plt.figure()
</code></pre>
<p>如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。</p>
<p>不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：</p>
<pre><code class="language-python">In [17]: ax1 = fig.add_subplot(2, 2, 1)
</code></pre>
<p>这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个subplot中的第一个（编号从1开始）。如果再把后面两个subplot也创建出来，最终得到的图像如图9-2所示：</p>
<pre><code class="language-python">In [18]: ax2 = fig.add_subplot(2, 2, 2)

In [19]: ax3 = fig.add_subplot(2, 2, 3)
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://upload-images.jianshu.io/upload_images/7178691-b8cff158e64eae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-2 带有三个subplot的Figure" loading="lazy"></figure>
<blockquote>
<p>提示：使用Jupyter notebook有一点不同，即每个小窗重新执行后，图形会被重置。因此，对于复杂的图形，，你必须将所有的绘图命令存在一个小窗里。</p>
</blockquote>
<p>这里，我们运行同一个小窗里的所有命令：</p>
<pre><code class="language-python">fig = plt.figure()
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3)
</code></pre>
<p>如果这时执行一条绘图命令（如plt.plot([1.5, 3.5, -2, 1.6])），matplotlib就会在最后一个用过的subplot（如果没有则创建一个）上进行绘制，隐藏创建figure和subplot的过程。因此，如果我们执行下列命令，你就会得到如图9-3所示的结果：</p>
<pre><code class="language-python">In [20]: plt.plot(np.random.randn(50).cumsum(), 'k--')
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://upload-images.jianshu.io/upload_images/7178691-7bcbd5e56fdbbd92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-3 绘制一次之后的图像" loading="lazy"></figure>
<p>&quot;k--&quot;是一个线型选项，用于告诉matplotlib绘制黑色虚线图。上面那些由fig.add_subplot所返回的对象是AxesSubplot对象，直接调用它们的实例方法就可以在其它空着的格子里面画图了，如图9-4所示：</p>
<pre><code class="language-python">In [21]: ax1.hist(np.random.randn(100), bins=20, color='k', alpha=0.3)

In [22]: ax2.scatter(np.arange(30), np.arange(30) + 3 * np.random.randn(30))
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://upload-images.jianshu.io/upload_images/7178691-2297bcaf355db24c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-4 继续绘制两次之后的图像" loading="lazy"></figure>
<p>你可以在matplotlib的文档中找到各种图表类型。</p>
<p>创建包含subplot网格的figure是一个非常常见的任务，matplotlib有一个更为方便的方法plt.subplots，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组：</p>
<pre><code class="language-python">In [24]: fig, axes = plt.subplots(2, 3)

In [25]: axes
Out[25]: 
array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb626374048&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb62625db00&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6262f6c88&gt;],
       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6261a36a0&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb626181860&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6260fd4e0&gt;]], dtype
=object)
</code></pre>
<p>这是非常实用的，因为可以轻松地对axes数组进行索引，就好像是一个二维数组一样，例如axes[0,1]。你还可以通过sharex和sharey指定subplot应该具有相同的X轴或Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib会自动缩放各图表的界限。有关该方法的更多信息，请参见表9-1。</p>
<pre><code class="language-python">matplotlib.pyplot.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)[source]
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://upload-images.jianshu.io/upload_images/7178691-88bb55faca7d01ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-1 pyplot.subplots的选项" loading="lazy"></figure>
<h2 id="调整subplot周围的间距">调整subplot周围的间距</h2>
<p>默认情况下，matplotlib会在subplot外围留下一定的边距，并在subplot之间留下一定的间距。间距跟图像的高度和宽度有关，因此，如果你调整了图像大小（不管是编程还是手工），间距也会自动调整。利用Figure的subplots_adjust方法可以轻而易举地修改间距，此外，它也是个顶级函数：</p>
<pre><code class="language-python">subplots_adjust(left=None, bottom=None, right=None, top=None,
                wspace=None, hspace=None)
</code></pre>
<p>wspace和hspace用于控制宽度和高度的百分比，可以用作subplot之间的间距。下面是一个简单的例子，其中我将间距收缩到了0（如图9-5所示）：</p>
<pre><code class="language-python">fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
for i in range(2):
    for j in range(2):
        axes[i, j].hist(np.random.randn(500), bins=50, color='k', alpha=0.5)
plt.subplots_adjust(wspace=0, hspace=0)
</code></pre>
<figure data-type="image" tabindex="6"><img src="http://upload-images.jianshu.io/upload_images/7178691-80be7ffc3dec88a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-5 各subplot之间没有间距" loading="lazy"></figure>
<p>不难看出，其中的轴标签重叠了。matplotlib不会检查标签是否重叠，所以对于这种情况，你只能自己设定刻度位置和刻度标签。后面几节将会详细介绍该内容。</p>
<h2 id="颜色-标记和线型">颜色、标记和线型</h2>
<p>matplotlib的plot函数接受一组X和Y坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据x和y绘制绿色虚线，你可以执行如下代码：</p>
<pre><code class="language-python">ax.plot(x, y, 'g--')
</code></pre>
<p>这种在一个字符串中指定颜色和线型的方式非常方便。在实际中，如果你是用代码绘图，你可能不想通过处理字符串来获得想要的格式。通过下面这种更为明确的方式也能得到同样的效果：</p>
<pre><code class="language-python">ax.plot(x, y, linestyle='--', color='g')
</code></pre>
<p>常用的颜色可以使用颜色缩写，你也可以指定颜色码（例如，'#CECECE'）。你可以通过查看plot的文档字符串查看所有线型的合集（在IPython和Jupyter中使用plot?）。</p>
<p>可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle）。<br>
具体形式  fmt = '[color][marker][line]'</p>
<pre><code class="language-python">=============    ===============================
    character        color
    =============    ===============================
    ``'b'``          blue 蓝
    ``'g'``          green 绿
    ``'r'``          red 红
    ``'c'``          cyan 蓝绿
    ``'m'``          magenta 洋红
    ``'y'``          yellow 黄
    ``'k'``          black 黑
    ``'w'``          white 白
    =============    ===============================
=============    ===============================
    character        description
    =============    ===============================
    ``'.'``          point marker点标记
    ``','``          pixel marker像素标记（极小点）
    ``'o'``          circle marker实心圈标记
    ``'v'``          triangle_down marker倒三角标记
    ``'^'``          triangle_up marker上三角标记
    ``'&lt;'``          triangle_left marker
    ``'&gt;'``          triangle_right marker
    ``'1'``          tri_down marker
    ``'2'``          tri_up marker
    ``'3'``          tri_left marker
    ``'4'``          tri_right marker
    ``'s'``          square marker
    ``'p'``          pentagon marker
    ``'*'``          star marker
    ``'h'``          hexagon1 marker
    ``'H'``          hexagon2 marker
    ``'+'``          plus marker十字标记
    ``'x'``          x markerx标记
    ``'D'``          diamond marker
    ``'d'``          thin_diamond marker
    ``'|'``          vline marker
    ``'_'``          hline marker
    =============    ===============================
=============    ===============================
    character        description
    =============    ===============================
    ``'-'``          solid line style 实线
    ``'--'``         dashed line style 虚线
    ``'-.'``         dash-dot line style 点画线
    ``':'``          dotted line style 点线
    ``''``           无线条
    =============    ===============================
</code></pre>
<p>线图可以使用标记强调数据点。因为matplotlib可以创建连续线图，在点之间进行插值，因此有时可能不太容易看出真实数据点的位置。标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面（见图9-6）：</p>
<pre><code class="language-python">In [30]: from numpy.random import randn

In [31]: plt.plot(randn(30).cumsum(), 'ko--')
</code></pre>
<figure data-type="image" tabindex="7"><img src="http://upload-images.jianshu.io/upload_images/7178691-404d816f3e1d6621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-6 带有标记的线型图示例" loading="lazy"></figure>
<p>还可以将其写成更为明确的形式：</p>
<pre><code class="language-python">plot(randn(30).cumsum(), color='k', linestyle='dashed', marker='o')
</code></pre>
<p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过drawstyle选项修改（见图9-7）：</p>
<pre><code class="language-python">In [33]: data = np.random.randn(30).cumsum()

In [34]: plt.plot(data, 'k--', label='Default')
Out[34]: [&lt;matplotlib.lines.Line2D at 0x7fb624d86160&gt;]

In [35]: plt.plot(data, 'k-', drawstyle='steps-post', label='steps-post')
Out[35]: [&lt;matplotlib.lines.Line2D at 0x7fb624d869e8&gt;]

In [36]: plt.legend(loc='best')
</code></pre>
<figure data-type="image" tabindex="8"><img src="http://upload-images.jianshu.io/upload_images/7178691-3ec7642e1a592f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-7 不同drawstyle选项的线型图" loading="lazy"></figure>
<p>你可能注意到运行上面代码时有输出&lt;matplotlib.lines.Line2D at ...&gt;。matplotlib会返回引用了新添加的子组件的对象。大多数时候，你可以放心地忽略这些输出。这里，因为我们传递了label参数到plot，我们可以创建一个plot图例，指明每条使用plt.legend的线。</p>
<blockquote>
<p>笔记：你必须调用plt.legend（或使用ax.legend，如果引用了轴的话）来创建图例，无论你绘图时是否传递label标签选项。</p>
</blockquote>
<h2 id="刻度-标签和图例">刻度、标签和图例</h2>
<p>对于大多数的图表装饰项，其主要实现方式有二：使用过程型的pyplot接口（例如，matplotlib.pyplot）以及更为面向对象的原生matplotlib API。</p>
<p>pyplot接口的设计目的就是交互式使用，含有诸如xlim、xticks和xticklabels之类的方法。它们分别控制图表的范围、刻度位置、刻度标签等。其使用方式有以下两种：</p>
<ul>
<li>调用时不带参数，则返回当前的参数值（例如，plt.xlim()返回当前的X轴绘图范围）。</li>
<li>调用时带参数，则设置参数值（例如，plt.xlim([0,10])会将X轴的范围设置为0到10）。</li>
</ul>
<p>所有这些方法都是对当前或最近创建的AxesSubplot起作用的。它们各自对应subplot对象上的两个方法，以xlim为例，就是ax.get_xlim和ax.set_xlim。我更喜欢使用subplot的实例方法（因为我喜欢明确的事情，而且在处理多个subplot时这样也更清楚一些）。当然你完全可以选择自己觉得方便的那个。</p>
<h2 id="设置标题-轴标签-刻度以及刻度标签">设置标题、轴标签、刻度以及刻度标签</h2>
<p>为了说明自定义轴，我将创建一个简单的图像并绘制一段随机漫步（如图9-8所示）：</p>
<pre><code class="language-python">In [37]: fig = plt.figure()

In [38]: ax = fig.add_subplot(1, 1, 1)

In [39]: ax.plot(np.random.randn(1000).cumsum())
</code></pre>
<figure data-type="image" tabindex="9"><img src="http://upload-images.jianshu.io/upload_images/7178691-caf9300dacb61fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-8 用于演示xticks的简单线型图（带有标签）" loading="lazy"></figure>
<p>要改变x轴刻度，最简单的办法是使用set_xticks和set_xticklabels。前者告诉matplotlib要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过set_xticklabels将任何其他的值用作标签：</p>
<pre><code class="language-python">In [40]: ticks = ax.set_xticks([0, 250, 500, 750, 1000])

In [41]: labels = ax.set_xticklabels(['one', 'two', 'three', 'four', 'five'],
   ....:                             rotation=30, fontsize='small')
</code></pre>
<p>rotation选项设定x刻度标签倾斜30度。最后，再用set_xlabel为X轴设置一个名称，并用set_title设置一个标题（见图9-9的结果）：</p>
<pre><code class="language-python">In [42]: ax.set_title('My first matplotlib plot')
Out[42]: &lt;matplotlib.text.Text at 0x7fb624d055f8&gt;

In [43]: ax.set_xlabel('Stages')
</code></pre>
<figure data-type="image" tabindex="10"><img src="http://upload-images.jianshu.io/upload_images/7178691-741f968323bd818f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-9 用于演示xticks的简单线型图" loading="lazy"></figure>
<p>Y轴的修改方式与此类似，只需将上述代码中的x替换为y即可。轴的类有集合方法，可以批量设定绘图选项。前面的例子，也可以写为：</p>
<pre><code class="language-python">props = {
    'title': 'My first matplotlib plot',
    'xlabel': 'Stages'
}
ax.set(**props)
</code></pre>
<h2 id="添加图例">添加图例</h2>
<p>图例（legend）是另一种用于标识图表元素的重要工具。添加图例的方式有多种。最简单的是在添加subplot的时候传入label参数：</p>
<pre><code class="language-python">In [44]: from numpy.random import randn

In [45]: fig = plt.figure(); ax = fig.add_subplot(1, 1, 1)

In [46]: ax.plot(randn(1000).cumsum(), 'k', label='one')
Out[46]: [&lt;matplotlib.lines.Line2D at 0x7fb624bdf860&gt;]

In [47]: ax.plot(randn(1000).cumsum(), 'k--', label='two')
Out[47]: [&lt;matplotlib.lines.Line2D at 0x7fb624be90f0&gt;]

In [48]: ax.plot(randn(1000).cumsum(), 'k.', label='three')
Out[48]: [&lt;matplotlib.lines.Line2D at 0x7fb624be9160&gt;]
</code></pre>
<p>在此之后，你可以调用ax.legend()或plt.legend()来自动创建图例（结果见图9-10）：</p>
<pre><code class="language-python">In [49]: ax.legend(loc='best')
</code></pre>
<figure data-type="image" tabindex="11"><img src="http://upload-images.jianshu.io/upload_images/7178691-651ff89750c0a89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-10 带有三条线以及图例的简单线型图" loading="lazy"></figure>
<p>legend方法有几个其它的loc位置参数选项。请查看文档字符串（使用ax.legend?）。</p>
<p>loc告诉matplotlib要将图例放在哪。如果你不是吹毛求疵的话，&quot;best&quot;是不错的选择，因为它会选择最不碍事的位置。要从图例中去除一个或多个元素，不传入label或传入label='<em>nolegend</em>'即可。（中文第一版这里把best错写成了beat）</p>
<h2 id="注解以及在subplot上绘图">注解以及在Subplot上绘图</h2>
<p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过text、arrow和annotate函数进行添加。text可以将文本绘制在图表的指定坐标(x,y)，还可以加上一些自定义格式：</p>
<pre><code class="language-python">ax.text(x, y, 'Hello world!',
        family='monospace', fontsize=10)
</code></pre>
<p>注解中可以既含有文本也含有箭头。例如，我们根据最近的标准普尔500指数价格（来自Yahoo!Finance）绘制一张曲线图，并标出2008年到2009年金融危机期间的一些重要日期。你可以在Jupyter notebook的一个小窗中试验这段代码（图9-11是结果）：</p>
<pre><code class="language-python">from datetime import datetime

fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)

data = pd.read_csv('examples/spx.csv', index_col=0, parse_dates=True)
spx = data['SPX']

spx.plot(ax=ax, style='k-')

crisis_data = [
    (datetime(2007, 10, 11), 'Peak of bull market'),
    (datetime(2008, 3, 12), 'Bear Stearns Fails'),
    (datetime(2008, 9, 15), 'Lehman Bankruptcy')
]

for date, label in crisis_data:
    ax.annotate(label, xy=(date, spx.asof(date) + 75),
                xytext=(date, spx.asof(date) + 225),
                arrowprops=dict(facecolor='black', headwidth=4, width=2,
                                headlength=4),
                horizontalalignment='left', verticalalignment='top')

# Zoom in on 2007-2010
ax.set_xlim(['1/1/2007', '1/1/2011'])
ax.set_ylim([600, 1800])

ax.set_title('Important dates in the 2008-2009 financial crisis')
</code></pre>
<figure data-type="image" tabindex="12"><img src="http://upload-images.jianshu.io/upload_images/7178691-3127eaa51f5e4c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-11 2008-2009年金融危机期间的重要日期" loading="lazy"></figure>
<p>这张图中有几个重要的点要强调：ax.annotate方法可以在指定的x和y坐标轴绘制标签。我们使用set_xlim和set_ylim人工设定起始和结束边界，而不使用matplotlib的默认方法。最后，用ax.set_title添加图标标题。</p>
<p>更多有关注解的示例，请访问matplotlib的在线示例库。</p>
<p>图形的绘制要麻烦一些。matplotlib有一些表示常见图形的对象。这些对象被称为块（patch）。其中有些（如Rectangle和Circle），可以在matplotlib.pyplot中找到，但完整集合位于matplotlib.patches。</p>
<p>要在图表中添加一个图形，你需要创建一个块对象shp，然后通过ax.add_patch(shp)将其添加到subplot中（如图9-12所示）：</p>
<pre><code class="language-python">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)

rect = plt.Rectangle((0.2, 0.75), 0.4, 0.15, color='k', alpha=0.3)
circ = plt.Circle((0.7, 0.2), 0.15, color='b', alpha=0.3)
pgon = plt.Polygon([[0.15, 0.15], [0.35, 0.4], [0.2, 0.6]],
                   color='g', alpha=0.5)

ax.add_patch(rect)
ax.add_patch(circ)
ax.add_patch(pgon)
</code></pre>
<figure data-type="image" tabindex="13"><img src="http://upload-images.jianshu.io/upload_images/7178691-1f8a3d7a3a02d7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-12 由三个块图形组成的图" loading="lazy"></figure>
<p>如果查看许多常见图表对象的具体实现代码，你就会发现它们其实就是由块patch组装而成的。</p>
<h2 id="将图表保存到文件">将图表保存到文件</h2>
<p>利用plt.savefig可以将当前图表保存到文件。该方法相当于Figure对象的实例方法savefig。例如，要将图表保存为SVG文件，你只需输入：</p>
<pre><code class="language-python">plt.savefig('figpath.svg')
</code></pre>
<p>文件类型是通过文件扩展名推断出来的。因此，如果你使用的是.pdf，就会得到一个PDF文件。我在发布图片时最常用到两个重要的选项是dpi（控制“每英寸点数”分辨率）和bbox_inches（可以剪除当前图表周围的空白部分）。要得到一张带有最小白边且分辨率为400DPI的PNG图片，你可以：</p>
<pre><code class="language-python">plt.savefig('figpath.png', dpi=400, bbox_inches='tight')
</code></pre>
<p>savefig并非一定要写入磁盘，也可以写入任何文件型的对象，比如BytesIO：</p>
<pre><code class="language-python">from io import BytesIO
buffer = BytesIO()
plt.savefig(buffer)
plot_data = buffer.getvalue()
</code></pre>
<p>表9-2列出了savefig的其它选项。</p>
<figure data-type="image" tabindex="14"><img src="http://upload-images.jianshu.io/upload_images/7178691-4bee796bf7262423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-2 Figure.savefig的选项" loading="lazy"></figure>
<h2 id="matplotlib配置">matplotlib配置</h2>
<p>matplotlib自带一些配色方案，以及为生成出版质量的图片而设定的默认配置信息。幸运的是，几乎所有默认行为都能通过一组全局参数进行自定义，它们可以管理图像大小、subplot边距、配色方案、字体大小、网格类型等。一种Python编程方式配置系统的方法是使用rc方法。例如，要将全局的图像默认大小设置为10×10，你可以执行：</p>
<pre><code class="language-python">plt.rc('figure', figsize=(10, 10))
</code></pre>
<p>rc的第一个参数是希望自定义的对象，如'figure'、'axes'、'xtick'、'ytick'、'grid'、'legend'等。其后可以跟上一系列的关键字参数。一个简单的办法是将这些选项写成一个字典：</p>
<pre><code class="language-python">font_options = {'family' : 'monospace',
                'weight' : 'bold',
                'size'   : 'small'}
plt.rc('font', **font_options)
</code></pre>
<p>要了解全部的自定义选项，请查阅matplotlib的配置文件matplotlibrc（位于matplotlib/mpl-data目录中）。如果对该文件进行了自定义，并将其放在你自己的.matplotlibrc目录中，则每次使用matplotlib时就会加载该文件。</p>
<p>下一节，我们会看到，seaborn包有若干内置的绘图主题或类型，它们使用了matplotlib的内部配置。</p>
<h1 id="92-使用pandas和seaborn绘图">9.2 使用pandas和seaborn绘图</h1>
<p>matplotlib实际上是一种比较低级的工具。要绘制一张图表，你组装一些基本组件就行：数据展示（即图表类型：线型图、柱状图、盒形图、散布图、等值线图等）、图例、标题、刻度标签以及其他注解型信息。</p>
<p>在pandas中，我们有多列数据，还有行和列标签。pandas自身就有内置的方法，用于简化从DataFrame和Series绘制图形。另一个库seaborn（https://seaborn.pydata.org/），由Michael Waskom创建的静态图形库。Seaborn简化了许多常见可视类型的创建。</p>
<blockquote>
<p>提示：引入seaborn会修改matplotlib默认的颜色方案和绘图类型，以提高可读性和美观度。即使你不使用seaborn API，你可能也会引入seaborn，作为提高美观度和绘制常见matplotlib图形的简化方法。</p>
</blockquote>
<h2 id="线型图">线型图</h2>
<p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线型图（如图9-13所示）：</p>
<pre><code class="language-python">In [60]: s = pd.Series(np.random.randn(10).cumsum(), index=np.arange(0, 100, 10))

In [61]: s.plot()
</code></pre>
<figure data-type="image" tabindex="15"><img src="http://upload-images.jianshu.io/upload_images/7178691-f28e5ab2ac94c7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-13 简单的Series图表示例" loading="lazy"></figure>
<p>该Series对象的索引会被传给matplotlib，并用以绘制X轴。可以通过use_index=False禁用该功能。X轴的刻度和界限可以通过xticks和xlim选项进行调节，Y轴就用yticks和ylim。plot参数的完整列表请参见表9-3。我只会讲解其中几个，剩下的就留给读者自己去研究了。</p>
<figure data-type="image" tabindex="16"><img src="http://upload-images.jianshu.io/upload_images/7178691-6d9fbf863c09370a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="http://upload-images.jianshu.io/upload_images/7178691-44e50562aeb5eb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-3 Series.plot方法的参数" loading="lazy"></figure>
<p>pandas的大部分绘图方法都有一个可选的ax参数，它可以是一个matplotlib的subplot对象。这使你能够在网格布局中更为灵活地处理subplot的位置。</p>
<p>DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例（如图9-14所示）：</p>
<pre><code class="language-python">In [62]: df = pd.DataFrame(np.random.randn(10, 4).cumsum(0),
   ....:                   columns=['A', 'B', 'C', 'D'],
   ....:                   index=np.arange(0, 100, 10))

In [63]: df.plot()
</code></pre>
<figure data-type="image" tabindex="18"><img src="http://upload-images.jianshu.io/upload_images/7178691-a1234d5e5ee41a40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-14 简单的DataFrame绘图" loading="lazy"></figure>
<p>plot属性包含一批不同绘图类型的方法。例如，df.plot()等价于df.plot.line()。后面会学习这些方法。</p>
<blockquote>
<p>笔记：plot的其他关键字参数会被传给相应的matplotlib绘图函数，所以要更深入地自定义图表，就必须学习更多有关matplotlib API的知识。</p>
</blockquote>
<p>DataFrame还有一些用于对列进行灵活处理的选项，例如，是要将所有列都绘制到一个subplot中还是创建各自的subplot。详细信息请参见表9-4。</p>
<figure data-type="image" tabindex="19"><img src="http://upload-images.jianshu.io/upload_images/7178691-96651ecaa90f1c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-4 专用于DataFrame的plot参数" loading="lazy"></figure>
<blockquote>
<p>注意： 有关时间序列的绘图，请见第11章。</p>
</blockquote>
<h2 id="柱状图">柱状图</h2>
<p>plot.bar()和plot.barh()分别绘制水平和垂直的柱状图。这时，Series和DataFrame的索引将会被用作X（bar）或Y（barh）刻度（如图9-15所示）：</p>
<pre><code class="language-python">In [64]: fig, axes = plt.subplots(2, 1)

In [65]: data = pd.Series(np.random.rand(16), index=list('abcdefghijklmnop'))

In [66]: data.plot.bar(ax=axes[0], color='k', alpha=0.7)
Out[66]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb62493d470&gt;

In [67]: data.plot.barh(ax=axes[1], color='k', alpha=0.7)
</code></pre>
<figure data-type="image" tabindex="20"><img src="http://upload-images.jianshu.io/upload_images/7178691-cd54c7ccfa3f0687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-15 水平和垂直的柱状图" loading="lazy"></figure>
<p>color='k'和alpha=0.7设定了图形的颜色为黑色，并使用部分的填充透明度。对于DataFrame，柱状图会将每一行的值分为一组，并排显示，如图9-16所示：</p>
<pre><code class="language-python">In [69]: df = pd.DataFrame(np.random.rand(6, 4),
   ....:                   index=['one', 'two', 'three', 'four', 'five', 'six'],
   ....:                   columns=pd.Index(['A', 'B', 'C', 'D'], name='Genus'))

In [70]: df
Out[70]: 
Genus         A         B         C         D
one    0.370670  0.602792  0.229159  0.486744
two    0.420082  0.571653  0.049024  0.880592
three  0.814568  0.277160  0.880316  0.431326
four   0.374020  0.899420  0.460304  0.100843
five   0.433270  0.125107  0.494675  0.961825
six    0.601648  0.478576  0.205690  0.560547

In [71]: df.plot.bar()
</code></pre>
<figure data-type="image" tabindex="21"><img src="http://upload-images.jianshu.io/upload_images/7178691-bfc141acb37d99b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-16 DataFrame的柱状图" loading="lazy"></figure>
<p>注意，DataFrame各列的名称&quot;Genus&quot;被用作了图例的标题。</p>
<p>设置stacked=True即可为DataFrame生成堆积柱状图，这样每行的值就会被堆积在一起（如图9-17所示）：</p>
<pre><code class="language-python">In [73]: df.plot.barh(stacked=True, alpha=0.5)
</code></pre>
<figure data-type="image" tabindex="22"><img src="http://upload-images.jianshu.io/upload_images/7178691-c19e4246eb897978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-17 DataFrame的堆积柱状图" loading="lazy"></figure>
<blockquote>
<p>笔记：柱状图有一个非常不错的用法：利用value_counts图形化显示Series中各值的出现频率，比如s.value_counts().plot.bar()。</p>
</blockquote>
<p>再以本书前面用过的那个有关小费的数据集为例，假设我们想要做一张堆积柱状图以展示每天各种聚会规模的数据点的百分比。我用read_csv将数据加载进来，然后根据日期和聚会规模创建一张交叉表：</p>
<pre><code class="language-python">In [75]: tips = pd.read_csv('examples/tips.csv')

In [76]: party_counts = pd.crosstab(tips['day'], tips['size'])

In [77]: party_counts
Out[77]: 
size  1   2   3   4  5  6
day                      
Fri   1  16   1   1  0  0
Sat   2  53  18  13  1  0
Sun   0  39  15  18  3  1
Thur  1  48   4   5  1  3

# Not many 1- and 6-person parties
In [78]: party_counts = party_counts.loc[:, 2:5]
</code></pre>
<p>然后进行规格化，使得各行的和为1，并生成图表（如图9-18所示）：</p>
<pre><code class="language-python"># Normalize to sum to 1
In [79]: party_pcts = party_counts.div(party_counts.sum(1), axis=0)

In [80]: party_pcts
Out[80]: 
size         2         3         4         5
day                                         
Fri   0.888889  0.055556  0.055556  0.000000
Sat   0.623529  0.211765  0.152941  0.011765
Sun   0.520000  0.200000  0.240000  0.040000
Thur  0.827586  0.068966  0.086207  0.017241

In [81]: party_pcts.plot.bar()
</code></pre>
<figure data-type="image" tabindex="23"><img src="http://upload-images.jianshu.io/upload_images/7178691-2918f67936823834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-18 每天各种聚会规模的比例" loading="lazy"></figure>
<p>于是，通过该数据集就可以看出，聚会规模在周末会变大。</p>
<p>对于在绘制一个图形之前，需要进行合计的数据，使用seaborn可以减少工作量。用seaborn来看每天的小费比例（图9-19是结果）：</p>
<pre><code class="language-python">In [83]: import seaborn as sns

In [84]: tips['tip_pct'] = tips['tip'] / (tips['total_bill'] - tips['tip'])

In [85]: tips.head()
Out[85]: 
   total_bill   tip smoker  day    time  size   tip_pct
0       16.99  1.01     No  Sun  Dinner     2  0.063204
1       10.34  1.66     No  Sun  Dinner     3  0.191244
2       21.01  3.50     No  Sun  Dinner     3  0.199886
3       23.68  3.31     No  Sun  Dinner     2  0.162494
4       24.59  3.61     No  Sun  Dinner     4  0.172069

In [86]: sns.barplot(x='tip_pct', y='day', data=tips, orient='h')
</code></pre>
<figure data-type="image" tabindex="24"><img src="http://upload-images.jianshu.io/upload_images/7178691-c33e8b3add99904b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-19 小费的每日比例，带有误差条" loading="lazy"></figure>
<p>seaborn的绘制函数使用data参数，它可能是pandas的DataFrame。其它的参数是关于列的名字。因为一天的每个值有多次观察，柱状图的值是tip_pct的平均值。绘制在柱状图上的黑线代表95%置信区间（可以通过可选参数配置）。</p>
<p>seaborn.barplot有颜色选项，使我们能够通过一个额外的值设置（见图9-20）：</p>
<pre><code class="language-python">In [88]: sns.barplot(x='tip_pct', y='day', hue='time', data=tips, orient='h')
</code></pre>
<figure data-type="image" tabindex="25"><img src="http://upload-images.jianshu.io/upload_images/7178691-06abe2f070222115.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-20 根据天和时间的小费比例" loading="lazy"></figure>
<p>注意，seaborn已经自动修改了图形的美观度：默认调色板，图形背景和网格线的颜色。你可以用seaborn.set在不同的图形外观之间切换：</p>
<pre><code class="language-python">In [90]: sns.set(style=&quot;whitegrid&quot;)
</code></pre>
<h2 id="直方图和密度图">直方图和密度图</h2>
<p>直方图（histogram）是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。再以前面那个小费数据为例，通过在Series使用plot.hist方法，我们可以生成一张“小费占消费总额百分比”的直方图（如图9-21所示）：</p>
<pre><code class="language-python">In [92]: tips['tip_pct'].plot.hist(bins=50)
</code></pre>
<figure data-type="image" tabindex="26"><img src="http://upload-images.jianshu.io/upload_images/7178691-255279376f7649a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-21 小费百分比的直方图" loading="lazy"></figure>
<p>与此相关的一种图表类型是密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态分布之类的较为简单的分布）。因此，密度图也被称作KDE（Kernel Density Estimate，核密度估计）图。使用plot.kde和标准混合正态分布估计即可生成一张密度图（见图9-22）：</p>
<pre><code class="language-python">In [94]: tips['tip_pct'].plot.density()
</code></pre>
<figure data-type="image" tabindex="27"><img src="http://upload-images.jianshu.io/upload_images/7178691-ee929d033159516a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-22  小费百分比的密度图" loading="lazy"></figure>
<p>seaborn的distplot方法绘制直方图和密度图更加简单，还可以同时画出直方图和连续密度估计图。作为例子，考虑一个双峰分布，由两个不同的标准正态分布组成（见图9-23）：</p>
<pre><code class="language-python">In [96]: comp1 = np.random.normal(0, 1, size=200)

In [97]: comp2 = np.random.normal(10, 2, size=200)

In [98]: values = pd.Series(np.concatenate([comp1, comp2]))

In [99]: sns.distplot(values, bins=100, color='k')
</code></pre>
<figure data-type="image" tabindex="28"><img src="http://upload-images.jianshu.io/upload_images/7178691-975f04d750c4efe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-23 标准混合密度估计的标准直方图" loading="lazy"></figure>
<h2 id="散布图或点图">散布图或点图</h2>
<p>点图或散布图是观察两个一维数据序列之间的关系的有效手段。在下面这个例子中，我加载了来自statsmodels项目的macrodata数据集，选择了几个变量，然后计算对数差：</p>
<pre><code class="language-python">In [100]: macro = pd.read_csv('examples/macrodata.csv')

In [101]: data = macro[['cpi', 'm1', 'tbilrate', 'unemp']]

In [102]: trans_data = np.log(data).diff().dropna()

In [103]: trans_data[-5:]
Out[103]: 
          cpi        m1  tbilrate     unemp
198 -0.007904  0.045361 -0.396881  0.105361
199 -0.021979  0.066753 -2.277267  0.139762
200  0.002340  0.010286  0.606136  0.160343
201  0.008419  0.037461 -0.200671  0.127339
202  0.008894  0.012202 -0.405465  0.042560
</code></pre>
<p>然后可以使用seaborn的regplot方法，它可以做一个散布图，并加上一条线性回归的线（见图9-24）：</p>
<pre><code class="language-python">In [105]: sns.regplot('m1', 'unemp', data=trans_data)
Out[105]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb613720be0&gt;

In [106]: plt.title('Changes in log %s versus log %s' % ('m1', 'unemp'))
</code></pre>
<figure data-type="image" tabindex="29"><img src="http://upload-images.jianshu.io/upload_images/7178691-2133d20739478a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-24 seaborn的回归/散布图" loading="lazy"></figure>
<p>在探索式数据分析工作中，同时观察一组变量的散布图是很有意义的，这也被称为散布图矩阵（scatter plot matrix）。纯手工创建这样的图表很费工夫，所以seaborn提供了一个便捷的pairplot函数，它支持在对角线上放置每个变量的直方图或密度估计（见图9-25）：</p>
<pre><code class="language-python">In [107]: sns.pairplot(trans_data, diag_kind='kde', plot_kws={'alpha': 0.2})
</code></pre>
<figure data-type="image" tabindex="30"><img src="http://upload-images.jianshu.io/upload_images/7178691-20aa530a44e06f61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-25 statsmodels macro data的散布图矩阵" loading="lazy"></figure>
<p>你可能注意到了plot_kws参数。它可以让我们传递配置选项到非对角线元素上的图形使用。对于更详细的配置选项，可以查阅seaborn.pairplot文档字符串。</p>
<p>##分面网格（facet grid）和类型数据<br>
要是数据集有额外的分组维度呢？有多个分类变量的数据可视化的一种方法是使用小面网格。seaborn有一个有用的内置函数factorplot，可以简化制作多种分面图（见图9-26）：</p>
<pre><code class="language-python"> In [108]: sns.factorplot(x='day', y='tip_pct', hue='time', col='smoker',
   .....:                kind='bar', data=tips[tips.tip_pct &lt; 1])
</code></pre>
<figure data-type="image" tabindex="31"><img src="http://upload-images.jianshu.io/upload_images/7178691-737ba19a0cbdd46f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-26 按照天/时间/吸烟者的小费百分比" loading="lazy"></figure>
<p>除了在分面中用不同的颜色按时间分组，我们还可以通过给每个时间值添加一行来扩展分面网格：</p>
<pre><code class="language-python">In [109]: sns.factorplot(x='day', y='tip_pct', row='time',
   .....:                col='smoker',
   .....:                kind='bar', data=tips[tips.tip_pct &lt; 1])
</code></pre>
<figure data-type="image" tabindex="32"><img src="http://upload-images.jianshu.io/upload_images/7178691-4e52192441c609f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-27 按天的tip_pct，通过time/smoker分面" loading="lazy"></figure>
<p>factorplot支持其它的绘图类型，你可能会用到。例如，盒图（它可以显示中位数，四分位数，和异常值）就是一个有用的可视化类型（见图9-28）：</p>
<pre><code class="language-python">In [110]: sns.factorplot(x='tip_pct', y='day', kind='box',
   .....:                data=tips[tips.tip_pct &lt; 0.5])
</code></pre>
<figure data-type="image" tabindex="33"><img src="http://upload-images.jianshu.io/upload_images/7178691-356fb27a7c658920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-28 按天的tip_pct的盒图" loading="lazy"></figure>
<p>使用更通用的seaborn.FacetGrid类，你可以创建自己的分面网格。请查阅seaborn的文档（https://seaborn.pydata.org/）。</p>
<h1 id="93-其它的python可视化工具">9.3 其它的Python可视化工具</h1>
<p>与其它开源库类似，Python创建图形的方式非常多（根本罗列不完）。自从2010年，许多开发工作都集中在创建交互式图形以便在Web上发布。利用工具如Boken（https://bokeh.pydata.org/en/latest/）和Plotly（https://github.com/plotly/plotly.py），现在可以创建动态交互图形，用于网页浏览器。</p>
<p>对于创建用于打印或网页的静态图形，我建议默认使用matplotlib和附加的库，比如pandas和seaborn。对于其它数据可视化要求，学习其它的可用工具可能是有用的。我鼓励你探索绘图的生态系统，因为它将持续发展。</p>
<h1 id="94-总结">9.4 总结</h1>
<p>本章的目的是熟悉一些基本的数据可视化操作，使用pandas，matplotlib，和seaborn。如果视觉显示数据分析的结果对你的工作很重要，我鼓励你寻求更多的资源来了解更高效的数据可视化。这是一个活跃的研究领域，你可以通过在线和纸质的形式学习许多优秀的资源。</p>
<p>下一章，我们将重点放在pandas的数据聚合和分组操作上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pycharm常用快捷键及技巧(macOS)]]></title>
        <id>https://bailingnan.github.io/post/pycharm-chang-yong-kuai-jie-jian-ji-ji-qiao-macos/</id>
        <link href="https://bailingnan.github.io/post/pycharm-chang-yong-kuai-jie-jian-ji-ji-qiao-macos/">
        </link>
        <updated>2020-01-31T16:42:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mac键盘符号和修饰键说明">Mac键盘符号和修饰键说明</h1>
<ul>
<li><code>⌘</code>:Command</li>
<li><code>⇧</code>:Shift</li>
<li><code>⌥</code>:Option</li>
<li><code>⌃</code>:Control</li>
<li><code>↩︎</code>:Return/Enter</li>
<li><code>⌫</code>:Delete</li>
<li><code>⌦</code>:向前删除键（Fn+Delete）</li>
<li><code>↑</code>:上箭头</li>
<li><code>↓</code>:下箭头</li>
<li><code>←</code>:左箭头</li>
<li><code>→</code>:右箭头</li>
<li><code>⇞</code>:Page Up（Fn+↑）</li>
<li><code>⇟</code>:Page Down（Fn+↓）</li>
<li><code>Home</code>:Fn + ←</li>
<li><code>End</code>:Fn + →</li>
<li><code>⇥</code>:右制表符（Tab键）</li>
<li><code>⇤</code>:左制表符（Shift+Tab）</li>
<li><code>⎋</code>:Escape (Esc)</li>
<li>一直按住<code>fn</code>可调出F1~F10</li>
</ul>
<h1 id="editing编辑">Editing（编辑）</h1>
<ul>
<li><code>⌘Z</code>:撤销操作</li>
<li><code>⌘Y</code>:删除整行</li>
<li><code>⇧F6</code>:重命名文件</li>
<li><code>⌘S</code>:保存所有</li>
<li><code>⌦</code>:删除文件（Fn+Delete）</li>
<li><code>⌘⌥L</code>:格式化代码</li>
<li><code>Home</code>:Fn + ←，跳转到行首</li>
<li><code>End</code>:Fn + →，跳转到行末</li>
<li><code>⇧↑/⇧↓</code>:向上/向下选中行</li>
<li><code>⌘D</code>: 复制当前行或选定的块</li>
<li><code>⌘/</code>:注释/取消注释与行注释</li>
<li><code>⌘⌥/</code>:注释/取消注释与块注释</li>
<li><code>⌘J</code>:插入自定义动态代码模板</li>
<li><code>⌃Space</code>:基本的代码补全（补全任何类、方法、变量）</li>
<li><code>⌃⇧Space</code>:智能代码补全（过滤器方法列表和变量的预期类型）</li>
<li><code>⇧↩</code>:开始新的一行</li>
<li><code>⌘⇧U</code>:大小写切换,光标在行内任意位置都能另起一行，且不破坏当行结构</li>
<li><code>⌘⇧↩</code>:自动结束代码，行末自动添加分号</li>
<li><code>⌘P</code>:显示方法的参数信息</li>
<li><code>⌃J</code>:快速查看文档</li>
<li><code>⇧F1</code>:查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li>
<li><code>⌘F1</code>:在错误或警告处显示具体描述信息</li>
<li><code>⌘N, ⌃↩, ⌃N</code>:生成代码（getter、setter、构造函数、hashCode/equals,toString）</li>
<li><code>⌥↑</code>:连续选中代码块</li>
<li><code>⌥↓</code>:减少当前选中的代码块</li>
<li><code>⌥↩</code>:显示意向动作和快速修复代码</li>
<li><code>⌘⇧] / ⌘⇧[</code>:选择直到代码块结束/开始</li>
<li><code>⌘+ / ⌘-</code>:展开 / 折叠代码块</li>
<li><code>⌘⇧+</code>:展开所有代码块</li>
<li><code>⌘⇧-</code>:折叠所有代码块</li>
</ul>
<h1 id="searchreplace查询替换">Search/Replace（查询/替换）</h1>
<ul>
<li><code>Double ⇧</code>:查询任何东西</li>
<li><code>⌘F</code>:文件内查找</li>
</ul>
<h1 id="compile-and-run编译和运行">Compile and Run（编译和运行）</h1>
<ul>
<li><code>⌃⇧F10</code>:Run</li>
<li><code>⌃⇧F9</code>:Debug</li>
</ul>
<h1 id="navigation导航">Navigation（导航）</h1>
<ul>
<li><code>⌘B</code>:进入光标所在的方法/变量的接口或是定义处</li>
<li><code>⌘⌥B</code>:跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li>
<li><code>⌥ Space, ⌘Y</code>:快速打开光标所在方法、类的定义</li>
<li><code>⌃⇧B</code>:跳转到类型声明处</li>
<li><code>⌘U</code>:前往当前光标所在方法的父类的方法 / 接口定义</li>
<li><code>⌃H</code>:显示当前类的层次结构</li>
<li><code>⌘⇧H</code>:显示方法层次结构</li>
<li><code>⌃⌥H</code>:显示调用层次结构</li>
</ul>
<h1 id="调试">调试</h1>
<ul>
<li><code>step over</code>:在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，<strong>程序代码越过子函数，但子函数会执行，且不进入</strong>。</li>
<li><code>step into</code>:在单步执行时，遇到子函数就进入并且继续单步执行，<strong>有的会跳到源代码里面去执行</strong>。</li>
<li><code>step into my code</code>:在单步执行时，遇到子函数就进入并且继续单步执行，<strong>不会进入到源码中</strong>。</li>
<li><code>step out</code>:假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</li>
<li><code>Resume program</code>:继续恢复程序，直接运行到下一断点处。跳过不想看的地方，直接设置下一个断点，然后<code>Resume program</code>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PyTorch常用代码段]]></title>
        <id>https://bailingnan.github.io/post/pytorch-chang-yong-dai-ma-duan/</id>
        <link href="https://bailingnan.github.io/post/pytorch-chang-yong-dai-ma-duan/">
        </link>
        <updated>2020-01-30T19:09:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1基本配置">1.基本配置</h1>
<h2 id="导入包和版本查询">导入包和版本查询</h2>
<pre><code class="language-Python">import torch
import torch.nn as nn
import torchvision
print(torch.__version__)# PyTorch version
print(torch.version.cuda)#Corresponding CUDA version
print(torch.backends.cudnn.version())#Corresponding cuDNN version
print(torch.cuda.get_device_name(0))#GPU type
</code></pre>
<h2 id="可复现性">可复现性</h2>
<p>在硬件设备（CPU、GPU）不同时，完全的可复现性无法保证，即使随机种子相同。但是，在同一个设备上，应该保证可复现性。具体做法是，在程序开始的时候固定torch的随机种子，同时也把numpy的随机种子固定。</p>
<pre><code class="language-Python">np.random.seed(0)
torch.manual_seed(0)
torch.cuda.manual_seed_all(0)
</code></pre>
<h2 id="显卡设置">显卡设置</h2>
<p>如果只需要一张显卡</p>
<pre><code class="language-Python"># Device configuration
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
</code></pre>
<p>如果需要指定多张显卡，比如0，1号显卡。</p>
<pre><code class="language-Python">import os
os.environ['CUDA_VISIBLE_DEVICES'] = '0,1'
</code></pre>
<p>也可以在命令行运行代码时设置显卡：</p>
<pre><code>CUDA_VISIBLE_DEVICES=0,1 python train.py
</code></pre>
<p>清除显存:</p>
<pre><code class="language-Python">torch.cuda.empty_cache()
</code></pre>
<p>也可以使用在命令行重置GPU的指令：</p>
<pre><code>nvidia-smi --gpu-reset -i [gpu_id]
</code></pre>
<p>或在命令行可以先使用ps找到程序的PID，再使用kill结束该进程</p>
<pre><code class="language-python">ps aux | grep python
kill -9 [pid]
</code></pre>
<h2 id="设置为cudnn-benchmark模式">设置为cuDNN benchmark模式</h2>
<p>Benchmark模式会提升计算速度，但是由于计算中有随机性，每次网络前馈结果略有差异。</p>
<pre><code class="language-python">torch.backends.cudnn.benchmark = True
</code></pre>
<p>如果想要避免这种结果波动，设置</p>
<pre><code class="language-python">torch.backends.cudnn.deterministic = True
</code></pre>
<h1 id="2张量tensor处理">2.张量(Tensor)处理</h1>
<h2 id="创建张量">创建张量</h2>
<pre><code class="language-python">#data只能是已知的数据，不能是数据的维度
torch.tensor(data)
#可以是data，也可以是维度
#data:
torch.Tensor(data)
#维度,维度为(1,2,3)
torch.Tensor(1,2,3)
</code></pre>
<h2 id="张量基本信息">张量基本信息</h2>
<pre><code class="language-Python">tensor = torch.randn(3,4,5)
print(tensor.type())  # 数据类型
print(tensor.size())  # 张量的shape，是个元组
print(tensor.dim())   # 维度的数量
</code></pre>
<h2 id="切片与索引">切片与索引</h2>
<p>将图片设定为[batch_size, channel, height, width]的四维矩阵。</p>
<pre><code class="language-python">a = torch.rand(4, 3, 28, 28)
</code></pre>
<p>对第一维进行索引,可以认为是第一个图片的三个维度通道的28*28的像素点。:</p>
<pre><code class="language-python">print(a[0].size())
torch.Size([3, 28, 28])
</code></pre>
<p>第一个图片的第一个维度通道的28*28的像素点:</p>
<pre><code class="language-python">print(a[0, 0].size())
torch.Size([28, 28])
</code></pre>
<p>具体到某一个像素点时:</p>
<pre><code class="language-python">print(a[0, 0, 2, 3])
tensor(0.4736)
</code></pre>
<p>取连续的索引:</p>
<pre><code class="language-python">print(a[:2].shape)
torch.Size([2, 3, 28, 28])
</code></pre>
<p>同理：</p>
<pre><code class="language-python"># 1写在：前面，表明从1个通道开始到末尾，,不包括1
print(a[:2, 1:, :, :].shape)
</code></pre>
<p>当索引出现-1时，要提到一个知识点:</p>
<pre><code class="language-python"># 默认索引的顺序为[0, 1, 2]，当倒着写时变为[-3, -2, -1]。由于这里取-1，因此为最后一位。
print(a[:2, -1:, :, :].shape)
torch.Size([2, 1, 28, 28])
</code></pre>
<p>当想隔点取样输出时:</p>
<pre><code class="language-python">#输出全部batch和channel，对每个高和宽间隔2个点采样
print(a[:, :, 0:28:2, 0:28:2].shape)
torch.Size([4, 3, 14, 14])
#可简化为：
print(a[:, :, ::2, ::2].shape)
</code></pre>
<h2 id="命名变量">命名变量</h2>
<pre><code class="language-Python"># 在PyTorch 1.3之前，需要使用注释
# Tensor[N, C, H, W]
images = torch.randn(32, 3, 56, 56)
images.sum(dim=1)
images.select(dim=1, index=0)

# PyTorch 1.3之后
NCHW = [‘N’, ‘C’, ‘H’, ‘W’]
images = torch.randn(32, 3, 56, 56, names=NCHW)
images.sum('C')
images.select('C', index=0)
# 也可以这么设置
tensor = torch.rand(3,4,1,2,names=('C', 'N', 'H', 'W'))
# 使用align_to可以对维度方便地排序
tensor = tensor.align_to('N', 'C', 'H', 'W')
</code></pre>
<h2 id="数据类型转换">数据类型转换</h2>
<pre><code class="language-Python"># 设置默认类型，pytorch中的FloatTensor远远快于DoubleTensor
torch.set_default_tensor_type(torch.FloatTensor)

# 类型转换
tensor = tensor.cuda()
tensor = tensor.cpu()
tensor = tensor.float()
tensor = tensor.long()
</code></pre>
<h2 id="torchtensor与npndarray转换">torch.Tensor与np.ndarray转换</h2>
<p>除了CharTensor，其他所有CPU上的张量都支持转换为numpy格式然后再转换回来。</p>
<pre><code class="language-Python">ndarray = tensor.cpu().numpy()
tensor = torch.from_numpy(ndarray).float()
tensor = torch.from_numpy(ndarray.copy()).float() # If ndarray has negative stride.
</code></pre>
<h2 id="从只包含一个元素的张量中提取值">从只包含一个元素的张量中提取值</h2>
<p><code>value = torch.rand(1).item()</code></p>
<h2 id="张量形变">张量形变</h2>
<pre><code class="language-Python"># 在将卷积层输入全连接层的情况下通常需要对张量做形变处理，
# 相比torch.view，torch.reshape可以自动处理输入张量不连续的情况。
tensor = torch.rand(2,3,4)
shape = (6, 4)
tensor = torch.reshape(tensor, shape)
</code></pre>
<h2 id="张量复制">张量复制</h2>
<pre><code class="language-Python"># Operation                 |  New/Shared memory | Still in computation graph |
tensor.clone()            # |        New         |          Yes               |
tensor.detach()           # |      Shared        |          No                |
tensor.detach.clone()()   # |        New         |          No                |
</code></pre>
<h2 id="张量拼接">张量拼接</h2>
<pre><code class="language-Python">'''
注意torch.cat和torch.stack的区别在于torch.cat沿着给定的维度拼接，
而torch.stack会新增一维。例如当参数是3个10x5的张量，torch.cat的结果是30x5的张量，
而torch.stack的结果是3x10x5的张量。
'''
tensor = torch.cat(list_of_tensors, dim=0)
tensor = torch.stack(list_of_tensors, dim=0)
</code></pre>
<h2 id="将整数标签转为one-hot编码">将整数标签转为one-hot编码</h2>
<pre><code class="language-python"># pytorch的标记默认从0开始
tensor = torch.tensor([0, 2, 1, 3])
N = tensor.size(0)
num_classes = 4
one_hot = torch.zeros(N, num_classes).long()
one_hot.scatter_(dim=1, index=torch.unsqueeze(tensor, dim=1), src=torch.ones(N, num_classes).long())
</code></pre>
<h2 id="得到非零元素">得到非零元素</h2>
<pre><code class="language-python">torch.nonzero(tensor)               # index of non-zero elements,包含点坐标的列表向量
torch.nonzero(tensor==0)            # index of zero elements
torch.nonzero(tensor).size(0)       # number of non-zero elements
torch.nonzero(tensor == 0).size(0)  # number of zero elements
</code></pre>
<h2 id="判断两个张量相等">判断两个张量相等</h2>
<pre><code class="language-Python">torch.allclose(tensor1, tensor2)  # float tensor
torch.equal(tensor1, tensor2)     # int tensor
</code></pre>
<h2 id="张量扩展">张量扩展</h2>
<pre><code class="language-python"># Expand tensor of shape 64*512 to shape 64*512*7*7.
tensor = torch.rand(64,512)
torch.reshape(tensor, (64, 512, 1, 1)).expand(64, 512, 7, 7)
</code></pre>
<h2 id="矩阵乘法">矩阵乘法</h2>
<pre><code class="language-python"># Matrix multiplcation: (m*n) * (n*p) * -&gt; (m*p).
result = torch.mm(tensor1, tensor2)

# Batch matrix multiplication: (b*m*n) * (b*n*p) -&gt; (b*m*p)
result = torch.bmm(tensor1, tensor2)

# Element-wise multiplication.
result = tensor1 * tensor2
</code></pre>
<h2 id="计算两组数据之间的两两欧式距离">计算两组数据之间的两两欧式距离</h2>
<p>利用broadcast机制</p>
<pre><code class="language-python">dist = torch.sqrt(torch.sum((X1[:,None,:] - X2) ** 2, dim=2))
</code></pre>
<h1 id="3模型定义和操作">3.模型定义和操作</h1>
<h2 id="计算模型整体参数量">计算模型整体参数量</h2>
<pre><code class="language-python">num_parameters = sum(torch.numel(parameter) for parameter in model.parameters())
</code></pre>
<h2 id="查看网络中的参数">查看网络中的参数</h2>
<p>可以通过model.state_dict()或者model.named_parameters()函数查看现在的全部可训练参数（包括通过继承得到的父类中的参数）</p>
<pre><code class="language-python">params = list(model.named_parameters())
(name, param) = params[28]
print(name)
print(param.grad)
print('-------------------------------------------------')
(name2, param2) = params[29]
print(name2)
print(param2.grad)
print('----------------------------------------------------')
(name1, param1) = params[30]
print(name1)
print(param1.grad)
</code></pre>
<h2 id="类似-keras-的-modelsummary-输出模型信息使用pytorch-summary">类似 Keras 的 model.summary() 输出模型信息（使用pytorch-summary ）</h2>
<h2 id="模型权重初始化">模型权重初始化</h2>
<p>注意 model.modules() 和 model.children() 的区别：model.modules() 会迭代地遍历模型的所有子层，而 model.children() 只会遍历模型下的一层。</p>
<pre><code class="language-python"># Common practise for initialization.
for layer in model.modules():
    if isinstance(layer, torch.nn.Conv2d):
        torch.nn.init.kaiming_normal_(layer.weight, mode='fan_out',
                                      nonlinearity='relu')
        if layer.bias is not None:
            torch.nn.init.constant_(layer.bias, val=0.0)
    elif isinstance(layer, torch.nn.BatchNorm2d):
        torch.nn.init.constant_(layer.weight, val=1.0)
        torch.nn.init.constant_(layer.bias, val=0.0)
    elif isinstance(layer, torch.nn.Linear):
        torch.nn.init.xavier_normal_(layer.weight)
        if layer.bias is not None:
            torch.nn.init.constant_(layer.bias, val=0.0)

# Initialization with given tensor.
layer.weight = torch.nn.Parameter(tensor)
</code></pre>
<h2 id="提取模型中的某一层">提取模型中的某一层</h2>
<p>modules()会返回模型中所有模块的迭代器，它能够访问到最内层，比如self.layer1.conv1这个模块，还有一个与它们相对应的是name_children()属性以及named_modules(),这两个不仅会返回模块的迭代器，还会返回网络层的名字。</p>
<pre><code class="language-python"># 取模型中的前两层
new_model = nn.Sequential(*list(model.children())[:2] 
# 如果希望提取出模型中的所有卷积层，可以像下面这样操作：
for layer in model.named_modules():
    if isinstance(layer[1],nn.Conv2d):
         conv_model.add_module(layer[0],layer[1])
</code></pre>
<h2 id="部分层使用预训练模型">部分层使用预训练模型</h2>
<p>注意如果保存的模型是 torch.nn.DataParallel，则当前的模型也需要是</p>
<pre><code class="language-python">model.load_state_dict(torch.load('model.pth'), strict=False)
</code></pre>
<h1 id="4模型训练和测试">4.模型训练和测试</h1>
<h2 id="modeleval和with-torchno_grad的区别"><code>model.eval()</code>和<code>with torch.no_grad()</code>的区别</h2>
<p>在PyTorch中进行validation时，会使用<code>model.eval()</code>切换到测试模式，在该模式下，</p>
<ul>
<li>主要用于通知dropout层和batchnorm层在train和val模式间切换<br>
在train模式下，dropout网络层会按照设定的参数p设置保留激活单元的概率（保留概率=p); batchnorm层会继续计算数据的mean和var等参数并更新。<br>
在val模式下，dropout层会让所有的激活单元都通过，而batchnorm层会停止计算和更新mean和var，直接使用在训练阶段已经学出的mean和var值。</li>
<li>该模式不会影响各层的gradient计算行为，即gradient计算和存储与training模式一样，只是不进行反传（backprobagation）<br>
而<code>with torch.zero_grad()</code>则主要是用于停止autograd模块的工作，以起到加速和节省显存的作用，具体行为就是停止gradient计算，从而节省了GPU算力和显存，但是并不会影响dropout和batchnorm层的行为。</li>
</ul>
<h3 id="使用场景">使用场景</h3>
<p>如果不在意显存大小和计算时间的话，仅仅使用<code>model.eval()</code>已足够得到正确的validation的结果；而<code>with torch.zero_grad()</code>则是更进一步加速和节省gpu空间（因为不用计算和存储gradient），从而可以更快计算，也可以跑更大的batch来测试。</p>
<h2 id="自定义loss">自定义loss</h2>
<p>继承torch.nn.Module类写自己的loss。</p>
<pre><code class="language-python">class MyLoss(torch.nn.Moudle):
    def __init__(self):
        super(MyLoss, self).__init__()
        
    def forward(self, x, y):
        loss = torch.mean((x - y) ** 2)
        return loss
</code></pre>
<h2 id="标签平滑label-smoothing">标签平滑（label smoothing）</h2>
<p>写一个label_smoothing.py的文件，然后在训练代码里引用，用LSR代替交叉熵损失即可。label_smoothing.py内容如下：</p>
<pre><code class="language-python">import torch
import torch.nn as nn


class LSR(nn.Module):

    def __init__(self, e=0.1, reduction='mean'):
        super().__init__()

        self.log_softmax = nn.LogSoftmax(dim=1)
        self.e = e
        self.reduction = reduction
    
    def _one_hot(self, labels, classes, value=1):
        &quot;&quot;&quot;
            Convert labels to one hot vectors
        
        Args:
            labels: torch tensor in format [label1, label2, label3, ...]
            classes: int, number of classes
            value: label value in one hot vector, default to 1
        
        Returns:
            return one hot format labels in shape [batchsize, classes]
        &quot;&quot;&quot;

        one_hot = torch.zeros(labels.size(0), classes)

        #labels and value_added  size must match
        labels = labels.view(labels.size(0), -1)
        value_added = torch.Tensor(labels.size(0), 1).fill_(value)

        value_added = value_added.to(labels.device)
        one_hot = one_hot.to(labels.device)

        one_hot.scatter_add_(1, labels, value_added)

        return one_hot

    def _smooth_label(self, target, length, smooth_factor):
        &quot;&quot;&quot;convert targets to one-hot format, and smooth
        them.
        Args:
            target: target in form with [label1, label2, label_batchsize]
            length: length of one-hot format(number of classes)
            smooth_factor: smooth factor for label smooth
        
        Returns:
            smoothed labels in one hot format
        &quot;&quot;&quot;
        one_hot = self._one_hot(target, length, value=1 - smooth_factor)
        one_hot += smooth_factor / (length - 1)

        return one_hot.to(target.device)

    def forward(self, x, target):

        if x.size(0) != target.size(0):
            raise ValueError('Expected input batchsize ({}) to match target batch_size({})'
                    .format(x.size(0), target.size(0)))

        if x.dim() &lt; 2:
            raise ValueError('Expected input tensor to have least 2 dimensions(got {})'
                    .format(x.size(0)))

        if x.dim() != 2:
            raise ValueError('Only 2 dimension tensor are implemented, (got {})'
                    .format(x.size()))


        smoothed_target = self._smooth_label(target, x.size(1), self.e)
        x = self.log_softmax(x)
        loss = torch.sum(- x * smoothed_target, dim=1)

        if self.reduction == 'none':
            return loss
        
        elif self.reduction == 'sum':
            return torch.sum(loss)
        
        elif self.reduction == 'mean':
            return torch.mean(loss)
        
        else:
            raise ValueError('unrecognized option, expect reduction to be one of none, mean, sum')
</code></pre>
<p>或者直接在训练文件里做label smoothing</p>
<pre><code class="language-python">for images, labels in train_loader:
    images, labels = images.cuda(), labels.cuda()
    N = labels.size(0)
    # C is the number of classes.
    smoothed_labels = torch.full(size=(N, C), fill_value=0.1 / (C - 1)).cuda()
    smoothed_labels.scatter_(dim=1, index=torch.unsqueeze(labels, dim=1), value=0.9)

    score = model(images)
    log_prob = torch.nn.functional.log_softmax(score, dim=1)
    loss = -torch.sum(log_prob * smoothed_labels) / N
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()    
</code></pre>
<h2 id="l1-正则化">L1 正则化</h2>
<pre><code class="language-python">l1_regularization = torch.nn.L1Loss(reduction='sum')
loss = ...  # Standard cross-entropy loss
for param in model.parameters():
    loss += torch.sum(torch.abs(param))
loss.backward()
</code></pre>
<h2 id="不对偏置项进行权重衰减weight-decay">不对偏置项进行权重衰减（weight decay）</h2>
<p>pytorch里的weight decay相当于l2正则</p>
<pre><code class="language-python">bias_list = (param for name, param in model.named_parameters() if name[-4:] == 'bias')
others_list = (param for name, param in model.named_parameters() if name[-4:] != 'bias')
parameters = [{'parameters': bias_list, 'weight_decay': 0},                
              {'parameters': others_list}]
optimizer = torch.optim.SGD(parameters, lr=1e-2, momentum=0.9, weight_decay=1e-4)
</code></pre>
<h2 id="梯度裁剪gradient-clipping">梯度裁剪（gradient clipping）</h2>
<pre><code class="language-python">torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=20)
</code></pre>
<h2 id="得到当前学习率">得到当前学习率</h2>
<pre><code class="language-python"># If there is one global learning rate (which is the common case).
lr = next(iter(optimizer.param_groups))['lr']

# If there are multiple learning rates for different layers.
all_lr = []
for param_group in optimizer.param_groups:
    all_lr.append(param_group['lr'])
</code></pre>
<p>另一种方法，在一个batch训练代码里，当前的lr是</p>
<pre><code class="language-python">optimizer.param_groups[0]['lr']
</code></pre>
<h2 id="学习率衰减">学习率衰减</h2>
<pre><code class="language-python"># Reduce learning rate when validation accuarcy plateau.
scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', patience=5, verbose=True)
for t in range(0, 80):
    train(...)
    val(...)
    scheduler.step(val_acc)

# Cosine annealing learning rate.
scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=80)
# Reduce learning rate by 10 at given epochs.
scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[50, 70], gamma=0.1)
for t in range(0, 80):
    scheduler.step()    
    train(...)
    val(...)

# Learning rate warmup by 10 epochs.
scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda t: t / 10)
for t in range(0, 10):
    scheduler.step()
    train(...)
    val(...)
</code></pre>
<h2 id="优化器链式更新">优化器链式更新</h2>
<p>从1.4版本开始，<code>torch.optim.lr_scheduler</code> 支持链式更新（chaining），即用户可以定义两个 schedulers，并交替在训练中使用。</p>
<pre><code class="language-python">import torch
from torch.optim import SGD
from torch.optim.lr_scheduler import ExponentialLR, StepLR
model = [torch.nn.Parameter(torch.randn(2, 2, requires_grad=True))]
optimizer = SGD(model, 0.1)
scheduler1 = ExponentialLR(optimizer, gamma=0.9)
scheduler2 = StepLR(optimizer, step_size=3, gamma=0.1)
for epoch in range(4):
    print(epoch, scheduler2.get_last_lr()[0])
    optimizer.step()
    scheduler1.step()
    scheduler2.step()
</code></pre>
<h2 id="模型训练可视化">模型训练可视化</h2>
<p>PyTorch可以使用tensorboard来可视化训练过程。<br>
安装和运行TensorBoard。</p>
<pre><code class="language-python">pip install tensorboard
tensorboard --logdir=runs
</code></pre>
<p>使用SummaryWriter类来收集和可视化相应的数据，放了方便查看，可以使用不同的文件夹，比如'Loss/train'和'Loss/test'。</p>
<pre><code class="language-python">from torch.utils.tensorboard import SummaryWriter
import numpy as np

writer = SummaryWriter()

for n_iter in range(100):
    writer.add_scalar('Loss/train', np.random.random(), n_iter)
    writer.add_scalar('Loss/test', np.random.random(), n_iter)
    writer.add_scalar('Accuracy/train', np.random.random(), n_iter)
    writer.add_scalar('Accuracy/test', np.random.random(), n_iter)
</code></pre>
<h2 id="保存与加载断点">保存与加载断点</h2>
<p>注意为了能够恢复训练，我们需要同时保存模型和优化器的状态，以及当前的训练轮数。</p>
<pre><code class="language-python">start_epoch = 0
# Load checkpoint.
if resume: # resume为参数，第一次训练时设为0，中断再训练时设为1
    model_path = os.path.join('model', 'best_checkpoint.pth.tar')
    assert os.path.isfile(model_path)
    checkpoint = torch.load(model_path)
    best_acc = checkpoint['best_acc']
    start_epoch = checkpoint['epoch']
    model.load_state_dict(checkpoint['model'])
    optimizer.load_state_dict(checkpoint['optimizer'])
    print('Load checkpoint at epoch {}.'.format(start_epoch))
    print('Best accuracy so far {}.'.format(best_acc))

# Train the model
for epoch in range(start_epoch, num_epochs): 
    ... 

    # Test the model
    ...
        
    # save checkpoint
    is_best = current_acc &gt; best_acc
    best_acc = max(current_acc, best_acc)
    checkpoint = {
        'best_acc': best_acc,
        'epoch': epoch + 1,
        'model': model.state_dict(),
        'optimizer': optimizer.state_dict(),
    }
    model_path = os.path.join('model', 'checkpoint.pth.tar')
    best_model_path = os.path.join('model', 'best_checkpoint.pth.tar')
    torch.save(checkpoint, model_path)
    if is_best:
        shutil.copy(model_path, best_model_path)
</code></pre>
<h1 id="5其他注意事项">5.其他注意事项</h1>
<h2 id="数据读取">数据读取</h2>
<p>使用<code>read_csv</code>读取一次原始文件，将<code>dataframe</code>存储为<code>HDF</code>或者<code>feather</code>格式。一般情况下<code>HDF</code>的读取比读取<code>csv</code>文件快几十倍，但<code>HDF</code>文件在大小上会稍微大一些。</p>
<h2 id="tricks">Tricks</h2>
<ol>
<li>建议有参数的层和汇合（pooling）层使用<code>torch.nn</code>模块定义，激活函数直接使用<code>torch.nn.functional。torch.nn</code>模块和<code>torch.nn.functional</code>的区别在于，<code>torch.nn</code>模块在计算时底层调用了<code>torch.nn.functional</code>，但<code>torch.nn</code>模块包括该层参数，还可以应对训练和测试两种网络状态。使用<code>torch.nn.functional</code>时要注意网络状态，如</li>
</ol>
<pre><code class="language-python">def forward(self, x):
  ...
  x = torch.nn.functional.dropout(x, p=0.5, training=self.training)
</code></pre>
<ol start="2">
<li>不要使用太大的线性层。因为nn.Linear(m,n)使用的是O(mn)的内存，线性层太大很容易超出现有显存。</li>
<li>不要在太长的序列上使用RNN。因为RNN反向传播使用的是BPTT算法，其需要的内存和输入序列的长度呈线性关系。</li>
<li>model(x) 前用 <code>model.train()</code> 和 <code>model.eval()</code> 切换网络状态。</li>
<li>不需要计算梯度的代码块用 with torch.no_grad() 包含起来。</li>
<li><code>model.eval()</code> 和 <code>torch.no_grad()</code> 的区别在于，<code>model.eval()</code> 是将网络切换为测试状态，例如 BN 和dropout在训练和测试阶段使用不同的计算方法。<code>torch.no_grad()</code>是关闭 PyTorch 张量的自动求导机制，以减少存储使用和加速计算，得到的结果无法进行 <code>loss.backward()</code>。</li>
<li><code>model.zero_grad()</code>会把整个模型的参数的梯度都归零, 而<code>optimizer.zero_grad()</code>只会把传入其中的参数的梯度归零。</li>
<li>torch.nn.CrossEntropyLoss 的输入不需要经过 Softmax。torch.nn.CrossEntropyLoss 等价于 torch.nn.functional.log_softmax + torch.nn.NLLLoss。</li>
<li><code>loss.backward()</code>前用 <code>optimizer.zero_grad()</code> 清除累积梯度。</li>
<li><code>torch.utils.data.DataLoader</code> 中尽量设置 <code>pin_memory=True</code>，对特别小的数据集如 MNIST 设置 <code>pin_memory=False</code> 反而更快一些。<code>num_workers</code> 的设置需要在实验中找到最快的取值。</li>
<li>用 <code>del</code>及时删除不用的中间变量，节约 GPU 存储。</li>
<li>使用 <code>inplace</code> 操作可节约 GPU 存储，如</li>
</ol>
<pre><code class="language-python">x = torch.nn.functional.relu(x, inplace=True)
</code></pre>
<ol start="13">
<li>减少 CPU 和 GPU 之间的数据传输。例如如果你想知道一个 epoch 中每个 mini-batch 的 loss 和准确率，先将它们累积在 GPU 中等一个 epoch 结束之后一起传输回 CPU 会比每个 mini-batch 都进行一次 GPU 到 CPU 的传输更快。</li>
<li>使用半精度浮点数 <code>half()</code>会有一定的速度提升，具体效率依赖于 GPU 型号。需要小心数值精度过低带来的稳定性问题。</li>
<li>时常使用 <code>assert tensor.size() == (N, D, H, W)</code> 作为调试手段，确保张量维度和你设想中一致。</li>
<li>除了标记 y 外，尽量少使用一维张量，使用 n*1 的二维张量代替，可以避免一些意想不到的一维张量计算结果。</li>
<li>统计代码各部分耗时</li>
</ol>
<pre><code class="language-python">with torch.autograd.profiler.profile(enabled=True, use_cuda=False) as profile:
    ...
print(profile)

# 或者在命令行运行
python -m torch.utils.bottleneck main.py
</code></pre>
<ol start="18">
<li>使用TorchSnooper来调试PyTorch代码，程序在执行的时候，就会自动 print 出来每一行的执行结果的 tensor 的形状、数据类型、设备、是否需要梯度的信息。</li>
</ol>
<pre><code class="language-python"># pip install torchsnooper
import torchsnooper

# 对于函数，使用修饰器
@torchsnooper.snoop()

# 如果不是函数，使用 with 语句来激活 TorchSnooper，把训练的那个循环装进 with 语句中去。
with torchsnooper.snoop():
    原本的代码
</code></pre>
<ol start="19">
<li>训练过程记录及可视化:</li>
</ol>
<ul>
<li><code>wandb</code></li>
<li><code>comet_ml</code></li>
<li><code>mlflow</code></li>
</ul>
<ol start="20">
<li>一些扩展包：</li>
</ol>
<ul>
<li><code>torch-optimizer</code>:实现了最新的一些优化器.</li>
<li><code>fastai</code>:有一些评价指标</li>
<li><code>numba</code>:<code>import numba as nb</code>,纯<code>python</code>或<code>numpy</code>函数加装饰器,加速计算，加@nb.njit或@nb.jit(nopython=True)</li>
<li><code>swifter</code>:<code>df.apply()</code>→<code>df.swifter.apply()</code>，加速<code>pandas</code></li>
<li><code>captum</code>:可解释性</li>
<li><code>cupy</code>:加速<code>pandas</code>,1000万以上数据更快</li>
<li><code>modin</code>:<code>import modin.pandas as mdpd</code>,用<code>mdpd</code>代替<code>pd</code>即可，加速<code>pandas</code>,加载数据和查询数据更快,统计方法<code>pandas</code>更快</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令]]></title>
        <id>https://bailingnan.github.io/post/linux-chang-yong-ming-ling/</id>
        <link href="https://bailingnan.github.io/post/linux-chang-yong-ming-ling/">
        </link>
        <updated>2020-01-22T08:16:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-linux文件与目录">一、Linux文件与目录</h1>
<ul>
<li>
<h2 id="11-linux文件权限概念">1.1 Linux文件权限概念</h2>
<ul>
<li>切换至root身份:<code>su -</code></li>
<li>离开root身份:<code>exit</code></li>
<li>文件名第一个字符为.的文件为隐藏文件</li>
</ul>
</li>
<li>
<h2 id="12-linux目录配置">1.2 Linux目录配置</h2>
</li>
<li>
<p>FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义：</p>
<ul>
<li><code>/</code>（root, 根目录）:与开机系统有关；</li>
<li><code>/usr</code> （unix software resource）:与软件安装/执行有关；</li>
<li><code>/var</code>（variable）:与系统运行过程有关。</li>
</ul>
</li>
<li>
<p>FHS要求根目录中必须存在的目录:</p>
<ul>
<li>
<p><code>/bin</code>:系统有很多放置可执行文件的目录，但<code>/bin</code>比较特殊。因为<code>/bin</code>放置的是在 单人维护模式下还能够被操作的指令。 在<code>/bin</code>下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</p>
</li>
<li>
<p><code>/boot</code>:主要在放置开机会使用到的文件，包括 Linux 核心文件以及开机菜单与开机所需配置文件等等Linux kernel 常用的文件名为：vmlinuz，如果使用的是 grub2 这个开机管理程序， 则还会存在<code>/boot/grub2/</code>这个目录。</p>
</li>
<li>
<p><code>/dev</code>:存放硬件相关的文件。在 Linux 系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。你只要通过存取这个目录下面的某个文件，就等于存取某个设备。比要重要的文件有<code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code>, <code>/dev/loop</code>, <code>/dev/sd</code>等等。</p>
</li>
<li>
<p><code>/etc</code>:存放配置文件的目录。系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，但是只有 root 有权力修改。FHS建议不要放置可执行文件 （binary）在这个目录中喔。比较重要的文件有： <code>/etc/modprobe.d/</code>, <code>/etc/passwd</code>, <code>/etc/fstab</code>, <code>/etc/issue</code>等等。另外 FHS 还规范几个重要的目录最好要存在 <code>/etc/</code>目录下：</p>
<ul>
<li><code>/etc/opt</code>（必要）：这个目录在放置第三方协力软件 <code>/opt</code> 的相关配置文件。</li>
<li><code>/etc/X11/</code>（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</li>
<li><code>/etc/sgml/</code>（建议）：与 SGML 格式有关的各项配置文件。</li>
<li><code>/etc/xml/</code>（建议）：与 XML 格式有关的各项配置文件。</li>
</ul>
</li>
<li>
<p><code>/lib</code>:系统的函数库非常的多，而<code>/lib</code>放置的则是在开机时会用到的函数库， 以及 在<code>/bin</code>或<code>/sbin</code>下面的指令会调用的函数库而已。 什么是函数库呢？你可以将 他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行 之意。 另外 FSH 还要求下面的目录必须要存在：<code>/lib/modules/</code>：这个目录 主要放置可抽换式的核心相关模块（驱动程序）</p>
</li>
<li>
<p><code>/media</code>:media是“媒体”的英文，顾名思义，这个<code>/media</code>下面放置的就是可移除的设备！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名 有：<code>/media/floppy</code>, <code>/media/cdrom</code>等等。</p>
</li>
<li>
<p><code>/mnt</code>:如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与<code>/media</code>相同啦！只是有了<code>/media</code>之后，这个 目录就用来暂时挂载用了。</p>
</li>
<li>
<p><code>/opt</code>:这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE 这个桌面管理系统是一个独立的计划，不过他可以安装到 Linux 系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的 distribution 提供的），那么也能够将你的软件安装到这里来。 不过，以前的 Linux 系统中，我们还是习惯放置在<code>/usr/local</code>目录下呢！</p>
</li>
<li>
<p><code>/run</code>:早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 <code>/var/run</code> 目录下，新版的 FHS 则规范到 <code>/run</code> 下面。 由于 <code>/run</code> 可以使用内存来仿真，因此性能上会好很多！</p>
</li>
<li>
<p><code>/sbin</code>:存放管理员root可以执行的命令。Linux 有非常多指令是用来设置系统环境的，这些指令只有 root 才能够利用 来“设置”系统，其他使用者最多只能用来“查询”而已。放在<code>/sbin</code>下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些服务器软件程序，一般则放置到<code>/usr/sbin/</code>当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到<code>/usr/local/sbin/</code> 当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</p>
</li>
<li>
<p><code>/srv</code>:srv 可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如 WWW, FTP 等等。举例来说，WWW 服务器需要的网页数据就可以放置在<code>/srv/www/</code>里面。 不过，系统的服务数据 如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 <code>/var/lib</code>下面即可。</p>
</li>
<li>
<p><code>tem</code>:这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将<code>/tmp</code>下的数据都删除唷!</p>
</li>
<li>
<p><code>/var</code>:第二层 FHS 设置，主要为放置变动性的数据，后续介绍。</p>
</li>
<li>
<p><code>/usr</code>:第二层 FHS 设置，后续介绍。</p>
</li>
</ul>
</li>
<li>
<p>FHS 建议根目录中可以存在的目录：</p>
<ul>
<li><code>/home</code>：这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使 用者帐号时，默认的使用者主文件夹都会规范到这里来。</li>
<li><code>/lib&lt;equal&gt;</code>:用来存放与 <code>/lib</code> 不同的格式的二进制函数库，例如支持 64 位的 <code>/lib64</code> 函数库等。</li>
<li><code>/root</code>:系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有 root 的主文件夹，所以我们会 希望 root 的主文件夹与根目录放置在同一个分区中。</li>
<li><code>/lost+found</code>:这个目录是使用标准的 ext2/ext3/ext4 文件系统格式才会产生的一个目录， 目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。 不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li>
<li><code>/proc</code>:这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>, <code>/proc/interrupts</code>, <code>/proc/ioports</code>, <code>/proc/net/*</code> 等等。</li>
<li><code>/sys</code>:这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录 核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li>
</ul>
</li>
<li>
<p>因为是所有系统默认的软件（distribution发布者提供的软件）都会放置到<code>/usr</code>下面，因此这个目录有点类似 Windows 系统的“C:\Windows\ （当中的一部份） + C:\Program files\”这两个目 录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，<code>/usr</code>的次目录 建议有下面这些：</p>
</li>
<li>
<p>FHS 要求必须要存在的目录:</p>
<ul>
<li><code>/usr/bin/</code>:所有一般用户能够使用的指令都放在这里！<code>/usr/bin</code> 与 <code>/bin</code> 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</li>
<li><code>/usr/lib/</code>:基本上，与 <code>/lib</code> 功能相同，所以 <code>/lib</code> 就是链接到此目录中的！</li>
<li><code>/usr/local/</code>:系统管理员在本机自行安装自己下载的软件（非 distribution 默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的 distribution 提供的软件较旧，你想安装较新的软件但又不想移除旧版，此时你可以将新版软件安装于<code>/usr/local/</code>目录下，可与原先的旧版软件有分别啦！ 你可以自行到<code>/usr/local</code>去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！</li>
<li><code>/usr/sbin/</code>:非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件 的服务指令（daemon）啰！不过基本功能与 <code>/sbin</code> 也差不多， 因此目前 <code>/sbin</code> 就是链接到此目录中的。</li>
<li><code>/usr/share/</code>:主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：
<ul>
<li><code>/usr/share/man</code>：线上说明文档。</li>
<li><code>/usr/share/doc</code>：软件杂项的文件说明。</li>
<li><code>/usr/share/zoneinfo</code>：与时区有关的时区文件。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>FHS 建议可以存在的目录：</p>
<ul>
<li><code>/usr/games/</code>:与游戏比较相关的数据放置处。</li>
<li><code>/usr/include/</code>:c/c++等程序语言的文件开始（header）与包含档（include）放置处， 当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</li>
<li><code>/usr/libexec/</code>:某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放 置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</li>
<li><code>/usr/lib&lt;qual&gt;/</code>:与 <code>/lib&lt;qual&gt;/</code>功能相同，因此目前 <code>/lib&lt;qual&gt;</code> 就是链接到此目录中。</li>
<li><code>/usr/src/</code>:一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到<code>/usr/src/linux/</code>目录下。</li>
</ul>
</li>
<li>
<p>如果<code>/usr</code>是安装时会占用较大硬盘容量的目录，那么<code>/var</code>就是在系统运行后才会渐渐占用硬盘容量的目录。 因为<code>/var</code>目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件 （log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如 MySQL数据库的文件等等。常见的次目录有：</p>
</li>
<li>
<p>FHS 要求必须要存在的目录:</p>
<ul>
<li><code>/var/cache/</code>:应用程序本身运行过程中会产生的一些暂存盘；</li>
<li><code>/var/lib/</code>:程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。举例来说，MySQL的数据库放置 到<code>/var/lib/mysql/</code>而rpm的数据库则放到<code>/var/lib/rpm</code>去！</li>
<li><code>/var/lock/</code>:某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。目前此目录也已经挪到 <code>/run/lock</code>中！</li>
<li><code>/var/log/</code>:重要到不行！这是登录文件放置的目录！里面比较重要的文件 如<code>/var/log/messages</code>, <code>/var/log/wtmp</code>（记录登陆者的信息）等。</li>
<li><code>/var/mail/</code>:放置个人电子邮件信箱的目录，不过这个目录也被放置到<code>/var/spool/mail/</code> 目录中！ 通常这两个目录是互为链接文件啦！</li>
<li><code>/var/run/</code>:某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于 PID的意义我们会在后续章节提到的。与 <code>/run</code> 相同，这个目录链接到 <code>/run</code> 去了！</li>
<li><code>/var/spool/</code>:这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到<code>/var/spool/mail/</code>中， 但使用者收下该信件后该封信原则上就会 被删除。信件如果暂时寄不出去会被放到<code>/var/spool/mqueue/</code>中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到<code>/var/spool/cron/</code>目录中！</li>
</ul>
</li>
<li>
<h2 id="13-文件与目录管理">1.3 文件与目录管理</h2>
<ul>
<li>
<p>网络文件常常提到类似“./run.sh”之类的数据，这个指令的意义为何？答：由于指令的执行需要变量（bash章节才会提到）的支持，若你的可执行文件放置在本目录，并且本目录并非正规的可执行文件目录（/bin, /usr/bin等为正规），此时要执行指令就得要严格指定该可执行文件。“./”代表“本目录”的意思，所以“./run.sh”代表“执行本目录下，名为run.sh的文件”。</p>
</li>
<li>
<p>cd （change directory, 变换目录）</p>
<ul>
<li><code>cd ~dmtsai</code>: 代表去到 dmtsai 这个使用者的主文件夹，亦即 <code>/home/dmtsai</code></li>
<li><code>cd ~</code>:表示回到自己的主文件夹，亦即是 <code>/root</code> 这个目录</li>
<li><code>cd</code>:没有加上任何路径，也还是代表回到自己主文件夹的意思</li>
<li><code>cd ..</code>:表示去到目前的上层目录</li>
<li><code>cd -</code>:表示回到刚刚的那个目录</li>
<li><code>cd ../postfix</code>:由<code>/var/spool/mail</code> 去到<code>/var/spool/postfix</code></li>
</ul>
</li>
<li>
<p>一登陆Linux系统后，每个帐号都会在自己帐号的主文件夹中(<code>/home</code>)。</p>
</li>
<li>
<p>pwd （显示目前所在的目录）</p>
<ul>
<li><code>pwd [-P]</code>😛 ：显示出确实的路径，而非使用链接 （link） 路径。加上 <code>pwd -P</code> 的选项后，会不以链接文件的数据显示，而是显示正确的完整路径。</li>
<li><code>pwd</code>:单纯显示出目前的工作目录。</li>
</ul>
</li>
<li>
<p>mkdir （创建新目录）</p>
<ul>
<li><code>mkdir [-mp] 目录名称</code>:
<ul>
<li><code>-m</code> ：设置文件的权限喔！直接设置，不需要看默认权限 （umask） 的脸色～</li>
<li><code>-p</code> ：帮助你直接将所需要的目录（包含上层目录）递回创建起来！</li>
<li>示例:
<ul>
<li><code>mkdir test1/test2/test3/test4</code>:错误。mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory</li>
<li><code>mkdir -p test1/test2/test3/test4</code>:正确。</li>
</ul>
</li>
</ul>
</li>
<li>rmdir （删除“空”的目录）
<ul>
<li><code>rmdir [-p] 目录名称</code>:
<ul>
<li><code>-p</code> ：连同“上层”“空的”目录也一起删除。</li>
</ul>
</li>
<li>示例:
<ul>
<li><code>rmdir test1</code>:rmdir: failed to remove ‘test1’: Directory not empty</li>
<li><code>rmdir -p test1/test2/test3/test4</code>:利用 <code>-p</code> 这个选项，立刻就可以将 <code>test1/test2/test3/test4</code> 一次删除,包括test1</li>
<li>如果要将非空目录下的东西都杀掉呢？！ 这个时候就必须使用<code>rm -r 目录名称</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件与目录的检视： ls</p>
<ul>
<li><code>ls [-aAdfFhilnrRSt] 文件名或目录名称</code>
<ul>
<li><code>-a</code> ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</li>
<li><code>-d</code> ：仅列出目录本身，而不是列出目录内的文件数据（常用）</li>
<li><code>-l</code> ：长数据串行出，包含文件的属性与权限等等数据（常用）</li>
<li>示例：
<ul>
<li><code>ls -al ~</code>: 将主文件夹下的所有文件列出来（含属性与隐藏文件）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>cp （复制文件或目录）</p>
<ul>
<li><code>cp [-adfilprsu] 来源文件（source） 目标文件（destination）</code></li>
<li><code>cp [options] source1 source2 source3 .... directory</code>
<ul>
<li><code>-a</code> ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li>
<li><code>-i</code> ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li>
<li><code>-r</code> ：递回持续复制，用于目录的复制行为；（常用）</li>
<li><code>-p</code> ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li>
<li><code>--preserve=all</code> ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。</li>
<li>如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li>
<li>如果目标目录或者目标文件不存在，则相当于重命名。</li>
<li>示例
<ul>
<li><code>cp ~/.bashrc /tmp/bashrc</code>:将主文件夹下的 .bashrc 复制到 <code>/tmp</code> 下，并更名为 bashrc</li>
<li><code>cp -i ~/.bashrc /tmp/bashrc</code>:cp: overwrite <code>/tmp/bashrc'? n不覆盖，y为覆盖，重复作两次动作，由于</code>/tmp<code>下面已经存在 bashrc 了，加上</code>-i` 选项后，则在覆盖前会询问使用者是否确定！可以按下 n 或者 y 来二次确认</li>
<li><code>cp /var/log/wtmp .</code>:复制到当前目录</li>
<li><code>cp /etc/ /tmp</code>:复制 <code>/etc/</code> 这个目录下的所有内容到 <code>/tmp</code> 下面，cp: omitting directory <code>/etc</code>，如果是目录则不能直接复制，要加上 <code>-r</code> 的选项</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>rm （移除文件或目录）</p>
<ul>
<li><code>rm [-fir] 文件或目录</code>：
<ul>
<li><code>-f</code> ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li>
<li><code>-r</code> ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
<li><code>-rf</code>: 如子目录里面还有子目录时，那就要使用 -r 这个选项</li>
<li><code>-rf/</code>: 会将系统文件全部删除，非常危险  <s>删库跑路</s></li>
<li>示例：
<ul>
<li><code>rm bashrc*</code>:通过万用字符*的帮忙，将<code>/tmp</code>下面开头为bashrc的文件名通通删除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>mv （移动文件与目录，或更名）</p>
<ul>
<li><code>mv [-fiu] source destination</code></li>
<li><code>mv [options] source1 source2 source3 .... directory</code>
<ul>
<li><code>-f</code> ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><code>-i</code> ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li>
<li><code>-u</code> ：若目标文件已经存在，且 source 比较新，才会更新 （update）</li>
<li>示例:
<ul>
<li>复制一文件，创建一目录，将文件移动到目录中：
<ul>
<li><code>cd /tmp</code></li>
<li><code>cp ~/.bashrc bashrc</code></li>
<li><code>mkdir mvtest</code></li>
<li><code>mv bashrc mvtest</code></li>
</ul>
</li>
<li>文件改名：
<ul>
<li><code>mv mvtest mvtest2</code></li>
</ul>
</li>
<li>再创建两个文件，再全部移动到 <code>/tmp/mvtest2</code> 当中:
<ul>
<li><code>cp ~/.bashrc bashrc1</code></li>
<li><code>cp ~/.bashrc bashrc2</code></li>
<li><code>mv bashrc1 bashrc2 mvtest2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>find（指定目录查找文件）</p>
<ul>
<li><code>find path -option</code> <code>path</code>是你要查找的路径，<code>-option</code>是选项，例如 <code>-name</code>就是根据名称来找。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二-pip">二、pip</h1>
<ul>
<li><code>pip install --upgrade pip</code>或<code>pip install -U pip</code>:升级pip自身</li>
<li><code>pip list</code>：查看已经通过pip安装的包</li>
<li><code>pip install &lt;包名&gt; --upgrade</code>或<code>pip install -U &lt;包名&gt;</code>:升级包</li>
<li><code>pip install &lt;包名&gt; -i https://mirrors.aliyun.com/pypi/simple</code>:指定单次安装源</li>
<li><code>pip install SomePackage==1.0.4</code>:指定版本</li>
<li><code>pip-review --auto/pip-review --local --interactive</code>:自动更新所有包</li>
</ul>
<h1 id="三-conda">三、conda</h1>
<ul>
<li><code>conda --version</code>:查看conda版本，验证是否安装</li>
<li><code>conda update conda</code>:更新至最新版本，也会更新其它相关包</li>
<li><code>conda update --all</code>:更新所有包</li>
<li><code>conda update package_name</code>:更新指定的包</li>
<li><code>conda create -n env_name package_name</code>:创建名为 env_name 的新环境，并在该环境下安装名为 package_name 的包，可以指定新环境的版本号，例如：<code>conda create -n python2 python=python2.7 numpy pandas</code>，创建了python2环境，python版本为2.7，同时还安装了numpy pandas包</li>
<li><code>conda activate env_name</code>:切换至env_name环境</li>
<li><code>conda deactivate</code>:退出环境</li>
<li><code>conda info -e</code>:显示所有已经创建的环</li>
<li><code>conda create -n new_env_name --clone old_env_name</code>:复制old_env_name为new_env_name</li>
<li><code>conda remove -n env_name –-all</code>:删除环境</li>
<li><code>conda list</code>:查看所有已经安装的包</li>
<li><code>conda install -n env_name package_name</code>:在指定环境中安装包</li>
<li><code>conda remove -n env_name package</code>:删除指定环境中的包</li>
<li><code>rm -rf 虚拟环境所在路径</code>:删除空环境</li>
</ul>
<h1 id="四-vim">四、Vim</h1>
<ul>
<li><code>shift+g</code>:移至文件末尾</li>
</ul>
<h1 id="五-其他">五、其他</h1>
<ul>
<li><code>sudo nautilus /home</code>:打开图形化文件夹</li>
<li><code>top</code>或<code>htop</code>：查看当前进程</li>
<li><code>ifconfig</code>：查看IP地址</li>
<li><code>kill 进程号</code>:终止进程</li>
<li><code>kill -9 进程号</code>:强制终止进程</li>
<li><code>tar -zxvf xxx.tar.gz</code>:解压缩</li>
<li><code>chmod u+x file</code>:对文件 file 增加文件主可执行权限（u表示文件主）</li>
<li><code>sudo apt-get install package</code>:安装包</li>
<li><code>sudo apt-get install package --reinstall</code>:重新安装包</li>
<li><code>sudo apt-get -f install</code>:修复安装</li>
<li><code>sudo apt-get remove package</code>:删除包</li>
<li><code>sudo apt-get remove package --purge</code>:删除包，包括删除配置文件等</li>
<li><code>sudo apt-get update</code>:更新源</li>
<li><code>sudo apt-get upgrade</code>:更新已安装的包</li>
<li><code>sudo apt-get dist-upgrade</code>:`升级系统</li>
<li><code>sudo apt-get autoclean</code>:清理旧版本软件缓存</li>
<li><code>sudo dpkg -i package.deb</code>:所有deb文件的安装</li>
<li><code>sudo dpkg -r package</code>：所有deb文件的卸载</li>
<li><code>sudo dpkg -P package</code>:彻底的卸载，包括软件的配置文件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!]]></title>
        <id>https://bailingnan.github.io/post/hello-world/</id>
        <link href="https://bailingnan.github.io/post/hello-world/">
        </link>
        <updated>2019-12-22T17:10:09.000Z</updated>
        <content type="html"><![CDATA[<p>New begin!</p>
]]></content>
    </entry>
</feed>