<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bailingnan.github.io/</id>
    <title>白凌南</title>
    <updated>2020-03-22T07:25:52.821Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bailingnan.github.io/"/>
    <link rel="self" href="https://bailingnan.github.io/atom.xml"/>
    <subtitle>DL/RecSys/Python/Java/INTJ</subtitle>
    <logo>https://bailingnan.github.io/images/avatar.png</logo>
    <icon>https://bailingnan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 白凌南</rights>
    <entry>
        <title type="html"><![CDATA[Python笔记]]></title>
        <id>https://bailingnan.github.io/post/python-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/python-bi-ji/">
        </link>
        <updated>2020-03-22T07:24:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python笔记"><code>Python</code>笔记</h1>
<h2 id="编码规范">编码规范</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318181309.png" alt="" loading="lazy"></figure>
<h2 id="对象">对象</h2>
<h3 id="可变与不可变对象">可变与不可变对象</h3>
<ul>
<li><code>Python</code>中的大多数对象，比如列表、字典、<code>NumPy</code>数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改。</li>
<li>字符串和元组，是不可变的。</li>
</ul>
<pre><code class="language-python">a= 'abc'
b = a.replace('a', 'A')
print(b)
'Abc'
</code></pre>
<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象，有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：<br>
当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了。<br>
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<ul>
<li>变量可以连续赋值:</li>
</ul>
<pre><code class="language-python">a=b=c=1
</code></pre>
<h3 id="元组">元组</h3>
<ul>
<li>如果要定义一个空的tuple，可以写成()：</li>
</ul>
<pre><code class="language-python">t = ()
print(t)
()
</code></pre>
<ul>
<li>但是，要定义一个只有1个元素的<code>tuple</code>，如果这么定义：</li>
</ul>
<pre><code class="language-python">t = (1)
print(t)
1
</code></pre>
<p>定义的不是<code>tuple</code>，是<code>1</code>这个数！这是因为括号()既可以表示<code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>
所以，只有1个元素的<code>tuple</code>定义时必须加一个逗号,，来消除歧义：</p>
<pre><code class="language-python">t = (1,)
print(t）
(1,)
</code></pre>
<p><code>Python</code>在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<ul>
<li>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</li>
</ul>
<pre><code class="language-python">tup = tuple(['foo', [1, 2], True])
tup[1].append(3)
print(tup)
('foo', [1, 2, 3], True)
</code></pre>
<h4 id="拆分元组">拆分元组</h4>
<ul>
<li>使用特殊的语法<code>*rest</code>，函数签名中以抓取任意长度列表的位置参数：</li>
</ul>
<pre><code class="language-python">values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a, b)
(1, 2)
print(rest)
[3, 4, 5]
</code></pre>
<ul>
<li><code>rest</code>的部分是想要舍弃的部分:</li>
</ul>
<pre><code class="language-python">a, b, *_ = values
</code></pre>
<h4 id="tuple方法"><code>tuple</code>方法</h4>
<ul>
<li>统计值出现频率：</li>
</ul>
<pre><code class="language-python">a = (1, 2, 2, 2, 3, 4, 2)
print(a.count(2))
4
</code></pre>
<h4 id="常用函数">常用函数</h4>
<ul>
<li><code>len(tuple)</code>:计算元组元素个数。</li>
<li><code>max(tuple)</code>:返回元组中元素最大值。</li>
<li><code>min(tuple)</code>:返回元组中元素最小值。</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="添加和删除元素">添加和删除元素</h4>
<ul>
<li><code>insert</code>在特定的位置插入元素：</li>
</ul>
<pre><code class="language-python">b_list=['foo', 'bar', 'baz']
b_list.insert(1, 'red')
print(b_list)
['foo', 'red', 'peekaboo', 'baz', 'dwarf']
</code></pre>
<p>与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，使用<code>collections.deque</code>，一个双尾部队列。</p>
<ul>
<li><code>insert</code>的逆运算是<code>pop</code>，它移除并返回指定位置的元素,<code>pop()</code>默认删除最后一个元素：</li>
</ul>
<pre><code class="language-python">print(b_list.pop(2))
'peekaboo'
print(b_list)
['foo', 'red', 'baz', 'dwarf']
</code></pre>
<ul>
<li><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</li>
</ul>
<pre><code class="language-python">b_list.append('foo')
print(b_list)
['foo', 'red', 'baz', 'dwarf', 'foo']
b_list.remove('foo')
print(b_list)
['red', 'baz', 'dwarf', 'foo']
</code></pre>
<h4 id="串联和组合列表">串联和组合列表</h4>
<ul>
<li>可以用加号将两个列表串联起来,如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</li>
</ul>
<pre><code class="language-python">x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>
<ul>
<li>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</li>
</ul>
<pre><code class="language-python">#快
everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
#慢
everything = []
for chunk in list_of_lists:
    everything = everything + chunk
</code></pre>
<p>考虑下列代码片段：</p>
<pre><code class="language-python">list = [ [ ] ] * 5
list  # output?
list[0].append(10)
list  # output?
list[1].append(20)
list  # output?
list.append(30)
list  # output?
</code></pre>
<p>2,4,6,8行将输出什么结果？试解释。<br>
输出的结果如下：</p>
<pre><code class="language-python">[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>
<p>解释如下：<br>
第一行的输出结果直觉上很容易理解，例如 <code>list = [ [ ] ] * 5</code> 就是简单的创造了5个空列表。然而，理解表达式<code>list=[ [ ] ] * 5</code>的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个创建了包含对同一个列表五次引用的列表。只有了解了这一点，我们才能更好的理解接下来的输出结果。<br>
<code>list[0].append(10)</code> 将10附加在第一个列表上。<br>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：</p>
<pre><code class="language-python">[[10], [10], [10], [10], [10]]
</code></pre>
<p>同理，<code>list[1].append(20)</code>将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：</p>
<pre><code class="language-python">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
</code></pre>
<p>作为对比， <code>list.append(30)</code>是将整个新的元素附加在外列表上，因此产生的结果是： <code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</code>。</p>
<h4 id="排序">排序</h4>
<ul>
<li><code>sort</code>函数将一个列表原地排序（不创建新的对象）</li>
</ul>
<pre><code class="language-python">a = [7, 2, 5, 1, 3]
a.sort()
print(a)
[1, 2, 3, 5, 7]
</code></pre>
<ul>
<li><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序<code>key</code>，可以用这个<code>key</code>进行排序。例如，我们可以按长度对字符串进行排序：</li>
</ul>
<pre><code class="language-python">b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)
print(b)
['He', 'saw', 'six', 'small', 'foxes']
</code></pre>
<h4 id="二分搜索和维护已排序的列表">二分搜索和维护已排序的列表</h4>
<ul>
<li><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值:</li>
</ul>
<pre><code class="language-python">import bisect
c = [1, 2, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 2))
4
print(bisect.bisect(c, 5))
6
print(bisect.insort(c, 6))
print(c)
[1, 2, 2, 2, 3, 4, 6, 7]
</code></pre>
<h4 id="zip函数">zip函数</h4>
<ul>
<li><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</li>
</ul>
<pre><code class="language-python">seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
print(list(zipped))
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</code></pre>
<ul>
<li><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</li>
</ul>
<pre><code class="language-python">seq3 = [False, True]
print(list(zip(seq1, seq2, seq3)))
[('foo', 'one', False), ('bar', 'two', True)]
</code></pre>
<ul>
<li><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</li>
</ul>
<pre><code class="language-python">for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
0: foo, one
1: bar, two
2: baz, three
</code></pre>
<ul>
<li>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。</li>
</ul>
<pre><code class="language-python">pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'),('Schilling', 'Curt')]
first_names, last_names = zip(*pitchers)
print(first_names)
('Nolan', 'Roger', 'Schilling')
print(last_names)
('Ryan', 'Clemens', 'Curt')
</code></pre>
<h4 id="reversed函数">reversed函数</h4>
<p><code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或<code>for</code>循环）之后才能创建翻转的序列。</p>
<pre><code class="language-python">print(list(reversed(range(10))))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<h4 id="常用函数-2">常用函数</h4>
<ul>
<li><code>max(list)</code>:返回列表元素最大值</li>
<li><code>min(list)</code>:返回列表元素最小值</li>
<li><code>list.count(obj)</code>:统计某个元素在列表中出现的次数</li>
<li><code>list.extend(seq)</code>:在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li><code>list.index(obj)</code>:从列表中找出某个值第一个匹配项的索引位置</li>
<li><code>list.reverse()</code>:反向列表中元素</li>
</ul>
<h3 id="字典">字典</h3>
<pre><code class="language-python">d = dict(name='Bob', age=20, score=88)
```python
`pickle.dumps()`方法把任意对象序列化成一个`bytes`，然后，就可以把这个`bytes`写入文件。或者用另一个方法`pickle.dump()`直接把对象序列化后写入一个`file-like Object`：
```python
f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个<code>Python</code>命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
print(d)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。<br>
要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<h4 id="删除值">删除值</h4>
<ul>
<li>用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</li>
</ul>
<pre><code class="language-python">d1={'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer',5: 'some value','dummy': 'another value'}
del d1[5]
print(d1)
{'a': 'some value',
 'b': [1, 2, 3, 4],
 7: 'an integer',
 'dummy': 'another value'}
ret = d1.pop('dummy')
print(ret)
'another value'
print(d1)
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
</code></pre>
<ul>
<li>`popitem():返回并删除字典中的最后一对键和值。</li>
</ul>
<h4 id="更新字典">更新字典</h4>
<ul>
<li>用<code>update</code>方法可以将一个字典与另一个融合,<code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</li>
</ul>
<pre><code class="language-python">d1.update({'b' : 'foo', 'c' : 12})
print(d1)
{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}
</code></pre>
<h4 id="用序列创建字典">用序列创建字典</h4>
<pre><code class="language-python">mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value
</code></pre>
<ul>
<li>因为字典本质上是2元元组的集合，<code>dict</code>可以接受2元元组的列表：</li>
</ul>
<pre><code class="language-python">mapping = dict(zip(range(5), reversed(range(5))))
print(mapping)
{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre>
<h4 id="默认值">默认值</h4>
<pre><code class="language-python">if key in some_dict:
    value = some_dict[key]
else:
    value = default_value
</code></pre>
<ul>
<li><code>dict</code>的方法<code>get</code>和<code>pop</code>可以取默认值进行返回，上面的<code>if-else</code>语句可以简写成下面：</li>
</ul>
<pre><code class="language-python">value = some_dict.get(key, default_value)
</code></pre>
<ul>
<li><code>get</code>默认会返回<code>None</code>，如果不存在键，<code>pop</code>会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</li>
</ul>
<pre><code class="language-python">words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)
print(by_letter)
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
</code></pre>
<ul>
<li>使用<code>setdefault</code>方法：</li>
</ul>
<pre><code class="language-python">for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
</code></pre>
<ul>
<li><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</li>
</ul>
<pre><code class="language-python">from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
</code></pre>
<p>给定以下字典的子类，下面的代码能够运行么？为什么？</p>
<pre><code class="language-python">class DefaultDict(dict):
  def __missing__(self, key):
    return []
d = DefaultDict()
d['florp'] = 127
</code></pre>
<p>能够运行。<br>
当<code>key</code>缺失时，执行<code>DefaultDict</code>类，字典的实例将自动实例化这个数列。</p>
<h4 id="有效的键类型">有效的键类型</h4>
<ul>
<li>字典的值可以是任意<code>Python</code>对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</li>
</ul>
<pre><code class="language-python">print(hash('string'))
5023931463650008331
print(hash((1, 2, (2, 3))))
1097636502276347782
print(hash((1, 2, [2, 3]))) # fails because lists are mutable
---------------------------------------------------------------------------
TypeError                                 
Traceback (most recent call last)
&lt;ipython-input-129-800cd14ba8be&gt; in &lt;module&gt;()
----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable
TypeError: unhashable type: 'list'
</code></pre>
<h4 id="按键值排序">按键值排序</h4>
<ul>
<li>键：</li>
</ul>
<pre><code class="language-python">sorted(dict.keys())
</code></pre>
<ul>
<li>值：</li>
</ul>
<pre><code class="language-python">sorted(dict.items(),key=lamda:item:item[1])
</code></pre>
<h3 id="集合">集合</h3>
<ul>
<li>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过<code>set</code>函数或使用尖括号<code>set</code>语句：</li>
</ul>
<pre><code class="language-python">print(set([2, 2, 2, 1, 3, 3]))
{1, 2, 3}
print({2, 2, 2, 1, 3, 3})
{1, 2, 3}
</code></pre>
<ul>
<li>通过<code>add(key)</code>方法可以添加元素到set中</li>
<li>通过<code>remove(key)</code>方法可以删除元素：</li>
<li>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</li>
</ul>
<pre><code class="language-python">a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a.union(b))
{1, 2, 3, 4, 5, 6, 7, 8}
print(a | b)
{1, 2, 3, 4, 5, 6, 7, 8}
</code></pre>
<ul>
<li>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</li>
</ul>
<pre><code class="language-python">print(a.intersection(b))
{3, 4, 5}
print(a &amp; b)
{3, 4, 5}
</code></pre>
<ul>
<li>
<p>常用集合方法</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317202703.png" alt="" loading="lazy"></figure>
</li>
<li>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
</li>
</ul>
<pre><code class="language-python">c = a.copy()
c |= b
print(c)
{1, 2, 3, 4, 5, 6, 7, 8}
d = a.copy()
d &amp;= b
print(d)
{3, 4, 5}
</code></pre>
<ul>
<li>检测一个集合是否是另一个集合的子集或父集：</li>
</ul>
<pre><code class="language-python">a_set = {1, 2, 3, 4, 5}
print({1, 2, 3}.issubset(a_set))
True
print(a_set.issuperset({1, 2, 3}))
True
</code></pre>
<h3 id="列表-集合和字典推导式">列表、集合和字典推导式</h3>
<pre><code class="language-python">[expr for val in collection if condition]
</code></pre>
<p>等同于：</p>
<pre><code class="language-python">result = []
for val in collection:
    if condition:
        result.append(expr)
</code></pre>
<ul>
<li>字典:</li>
</ul>
<pre><code class="language-python">dict_comp = {key-expr : value-expr for value in collection if condition}
</code></pre>
<ul>
<li>集合</li>
</ul>
<pre><code class="language-python">set_comp = {expr for value in collection if condition}
</code></pre>
<ul>
<li><code>map</code>函数可以进一步简化：</li>
</ul>
<pre><code class="language-python">print(set(map(len, strings)))
{1, 2, 3, 4, 6}
</code></pre>
<h4 id="嵌套列表推导式">嵌套列表推导式</h4>
<pre><code class="language-python">all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'],['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]
names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') &gt;= 2]
    names_of_interest.extend(enough_es)
</code></pre>
<p>嵌套列表推导式：</p>
<pre><code class="language-python">result = [name for names in all_data for name in names if name.count('e') &gt;= 2]
print(result)
result=['Steven']
</code></pre>
<p>以下代码正常输出偶数：</p>
<pre><code class="language-python">[x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
</code></pre>
<p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p>
<pre><code class="language-python">[x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？<br>
另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p>
<pre><code class="language-python">[x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>:</p>
<pre><code class="language-python">[x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。<br>
可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<pre><code class="language-python">print([[x for x in tup] for tup in some_tuples])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<h3 id="函数">函数</h3>
<h4 id="参数">参数</h4>
<ul>
<li>对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容:</li>
</ul>
<pre><code class="language-python">def append_element(some_list, element):
    some_list.append(element)
data = [1, 2, 3]
append_element(data, 4)
print(data)
[1, 2, 3, 4]
</code></pre>
<ul>
<li>函数可以有一些位置参数(<code>positional</code>)和一些关键字参数(<code>keyword</code>)。关键字参数通常用于指定默认值或可选参数</li>
</ul>
<h4 id="默认参数">默认参数</h4>
<pre><code class="language-python">def add_end(L=[]):
    L.append('END')
    return L
print(add_end())
['END']
print(add_end())
['END', 'END']
</code></pre>
<ul>
<li>Python函数在定义的时候，默认参数L的值就被计算出来了，即<code>[]</code>，因为默认参数L也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。<br>
<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></li>
<li>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</li>
</ul>
<pre><code class="language-python">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>举例：</p>
<pre><code class="language-python">def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')

print &quot;list1 = %s&quot; % list1
print &quot;list2 = %s&quot; % list2
print &quot;list3 = %s&quot; % list3

list1 = [10, 'a']
list2 = [123]
list3 = [10, 'a']
</code></pre>
<p>很多人都会误认为<code>list1=[10]</code>，<code>list3=[‘a’]</code>,因为他们以为每次<code>extendList</code>被调用时，列表参数的默认值都将被设置为<code>[]</code>.但实际上的情况是，新的默认列表只在函数被定义的那一刻创建一次。<br>
当<code>extendList</code>被没有指定特定参数<code>list</code>调用时，这组<code>list</code>的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。因此<code>list1</code>和<code>list3</code>是在同一个默认列表上进行操作（计算）的。而<code>list2</code>是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。<br>
<code>extendList</code>的定义可以作如下修改。<br>
尽管，创建一个新的列表，没有特定的列表参数。<br>
下面这段代码可能能够产生想要的结果。</p>
<pre><code class="language-python">def extendList(val, list=None):
  if list is None:
    list = []
  list.append(val)
  return list
</code></pre>
<p>通过上面的修改，输出结果将变成：</p>
<pre><code class="language-python">list1 = [10]
list2 = [123]
list3 = ['a']
</code></pre>
<ul>
<li>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</li>
</ul>
<h4 id="可变参数">可变参数</h4>
<pre><code class="language-python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括<code>0</code>个参数。<br>
如果已经有一个<code>list</code>或者<code>tuple</code>：</p>
<pre><code class="language-python">nums = [1, 2, 3]
print(calc(*nums))
14
</code></pre>
<h4 id="关键字参数">关键字参数</h4>
<ul>
<li>关键字参数允许你传入<code>0</code>个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</li>
</ul>
<pre><code class="language-python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</li>
</ul>
<pre><code class="language-python">person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<ul>
<li>也可以传入任意个数的关键字参数：</li>
</ul>
<pre><code class="language-python">person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p>关键字参数可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<br>
和可变参数类似，也可以先组装出一个<code>dict</code>，然后，把该<code>dict</code>转换为关键字参数传进去：</p>
<pre><code class="language-python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>上面复杂的调用可以用简化的写法：</p>
<pre><code>extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把<code>extra</code>这个<code>dict</code>的所有<code>key-value</code>用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个<code>dict</code>，注意``kw<code>获得的</code>dict<code>是</code>extra<code>的一份拷贝，对</code>kw<code>的改动不会影响到函数外的</code>extra`。</p>
<h4 id="命名关键字参数">命名关键字参数</h4>
<ul>
<li>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。<br>
仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</li>
</ul>
<pre><code class="language-python">def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</li>
</ul>
<pre><code class="language-python">def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>和关键字参数<code>**kw不同</code>，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>
调用方式如下：</li>
</ul>
<pre><code class="language-python">person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</li>
</ul>
<pre><code class="language-python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<ul>
<li>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</li>
</ul>
<pre><code class="language-python">person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<ul>
<li>由于调用时缺少参数名<code>city</code>和<code>job</code>，<code>Python</code>解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。<br>
命名关键字参数可以有缺省值，从而简化调用：</li>
</ul>
<pre><code class="language-python">def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</li>
</ul>
<pre><code class="language-python">person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，<code>Python</code>解释器将无法识别位置参数和命名关键字参数：</li>
</ul>
<pre><code class="language-python">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h4 id="强制位置参数">强制位置参数</h4>
<p><code>Python3.8</code> 新增了一个函数形参语法<code>/</code>用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。<br>
在以下的例子中，形参 <code>a</code> 和 <code>b</code> 必须使用指定位置参数，<code>c</code> 或 <code>d</code> 可以是位置形参或关键字形参，而 <code>e</code> 或 <code>f</code> 要求为关键字形参:</p>
<pre><code class="language-python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>
<p>以下使用方法是正确的:</p>
<pre><code class="language-python">f(10, 20, 30, d=40, e=50, f=60)
</code></pre>
<p>以下使用方法会发生错误:</p>
<pre><code class="language-python">f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
</code></pre>
<h4 id="参数组合">参数组合</h4>
<ul>
<li>在<code>Python</code>中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</li>
</ul>
<pre><code class="language-python">def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<ul>
<li>在函数调用的时候，<code>Python</code>解释器自动按照参数位置和参数名把对应的参数传进去。</li>
</ul>
<pre><code class="language-python">f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<ul>
<li>通过一个<code>tuple</code>和<code>dict</code>，你也可以调用上述函数：</li>
</ul>
<pre><code class="language-python">args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<ul>
<li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。<br>
<strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
</ul>
<h4 id="匿名lambda函数">匿名(lambda)函数</h4>
<ul>
<li><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然<code>lambda</code>函数看起来只能写一行，却不等同于<code>C</code>或<code>C++</code>的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<pre><code class="language-python">strings = ['foo', 'card', 'bar', 'aaaa', 'abab']
strings.sort(key=lambda x: len(set(list(x))))
print(strings)
['aaaa', 'foo', 'abab', 'bar', 'card']
</code></pre>
<h4 id="柯里化部分参数应用">柯里化：部分参数应用</h4>
<ul>
<li>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数:</li>
</ul>
<pre><code class="language-python">def add_numbers(x, y):
    return x + y
add_five = lambda y: add_numbers(5, y)
</code></pre>
<p><code>add_numbers</code>的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的<code>functools</code>模块可以用<code>partial</code>函数将此过程简化：</p>
<pre><code class="language-python">from functools import partial
add_five = partial(add_numbers, 5)
</code></pre>
<h4 id="生成器">生成器</h4>
<ul>
<li>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是<code>Python</code>的一个重要特点。这是通过一种叫做迭代器协议(<code>iterator protocol</code>，它是一种使对象可迭代的通用方式)的方式实现的，一个原生的使对象可迭代的方法。</li>
<li>生成器(<code>generator</code>)是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的<code>return</code>替换为<code>yeild</code>即可：</li>
</ul>
<pre><code class="language-python">def squares(n=10):
    print('Generating squares from 1 to {0}'.format(n ** 2))
    for i in range(1, n + 1):
        yield i ** 2
</code></pre>
<ul>
<li>调用该生成器时，没有任何代码会被立即执行：</li>
</ul>
<pre><code class="language-python">gen = squares()
print(gen)
&lt;generator object squares at 0x7fbbd5ab4570&gt;
</code></pre>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<pre><code class="language-python">for x in gen:
    print(x, end=' ')
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100
</code></pre>
<h4 id="生成器表达式">生成器表达式</h4>
<pre><code class="language-python">另一种更简洁的构造生成器的方法是使用生成器表达式(`generator expression`)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：
```python
gen = (x ** 2 for x in range(100))
print(gen)
&lt;generator object &lt;genexpr&gt; at 0x7fbbd5ab29e8&gt;
</code></pre>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<pre><code class="language-python">def _make_gen():
    for x in range(100):
        yield x ** 2
gen = _make_gen()
</code></pre>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<pre><code class="language-python">print(sum(x ** 2 for x in range(100)))
328350
print(dict((i, i **2) for i in range(5)))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>
<h4 id="迭代器">迭代器</h4>
<ul>
<li>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。<br>
可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</li>
</ul>
<pre><code class="language-python">from collections.abc import Iterator
isinstance((x for x in range(10)), Iterator)
True
isinstance([], Iterator)
False
isinstance({}, Iterator)
False
isinstance('abc', Iterator)
False
</code></pre>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<pre><code class="language-python">isinstance(iter([]), Iterator)
True
isinstance(iter('abc'), Iterator)
True
</code></pre>
<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>
<p>这是因为<code>Python</code>的<code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>
<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用<code>list</code>是永远不可能存储全体自然数的。</p>
<h5 id="类作为迭代器">类作为迭代器</h5>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。<br>
如果你已经了解的面向对象编程，就知道类都有一个构造函数，<code>Python</code> 的构造函数为 <code>__init__()</code>, 它会在对象初始化的时候执行。<br>
<code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。<br>
<code>__next__()</code> 方法（Python 2 里是 <code>next()</code>）会返回下一个迭代器对象。<br>
创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code class="language-python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
1
2
3
4
5
</code></pre>
<p><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。<br>
在 20 次迭代后停止执行：</p>
<pre><code>class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
  print(x)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre>
<h4 id="函数式编程">函数式编程</h4>
<h5 id="高阶函数">高阶函数</h5>
<h6 id="map函数"><code>map</code>函数</h6>
<ul>
<li><code>map()</code> 会根据提供的函数对指定序列做映射。第一个参数 <code>function</code> 以参数序列中的每一个元素调用 <code>function</code> 函数，返回包含每次 <code>function</code> 函数返回值的新列表。</li>
</ul>
<pre><code class="language-python">map(function, iterable, ...)
</code></pre>
<ul>
<li><code>function</code>:函数</li>
<li><code>iterable</code>:一个或多个序列</li>
</ul>
<pre><code class="language-python">def square(x) :            # 计算平方数
    return x ** 2
print(map(square, [1,2,3,4,5]))   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
# 提供了两个列表，对相同位置的列表数据进行相加
print(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
</code></pre>
<h6 id="reduce函数"><code>reduce</code>函数</h6>
<ul>
<li><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是:</li>
</ul>
<pre><code class="language-python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数13579，reduce就可以派上用场：</p>
<pre><code class="language-python">from functools import reduce
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))
13579
</code></pre>
<p>考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<pre><code class="language-python">from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<h6 id="filter函数"><code>filter</code>函数</h6>
<ul>
<li><code>Python</code>内建的<code>filter()</code>函数用于过滤序列。<br>
和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。<br>
注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回<code>list</code>。<br>
筛法求素数：</li>
</ul>
<pre><code>def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
def _not_divisible(n):
    return lambda x: x % n &gt; 0
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<h6 id="sorted函数"><code>sorted</code>函数</h6>
<ul>
<li><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</li>
</ul>
<pre><code class="language-python">print(sorted([7, 1, 2, 6, 0, 3, 2]))
[0, 1, 2, 2, 3, 6, 7]
print(sorted('horse race'))
[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']
</code></pre>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<pre><code class="language-python">sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>进行反向排序，不必改动<code>key</code>函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-python">sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h5 id="返回函数">返回函数</h5>
<pre><code class="language-python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="language-python">f = lazy_sum(1, 3, 5, 7, 9)
f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code class="language-python">f()
25
</code></pre>
<p>函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p>
<h6 id="闭包">闭包</h6>
<ul>
<li>返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</li>
</ul>
<pre><code class="language-python">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>
你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是1，4，9，但实际结果是：</p>
<pre><code class="language-python">f1()
9
f2()
9
f3()
9
</code></pre>
<p>全部都是9！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了3，因此最终结果为9。<br>
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>
<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<pre><code class="language-python"> f1, f2, f3 = count()
f1()
1
f2()
4
f3()
9
</code></pre>
<pre><code class="language-python">下面这段代码的输出结果将是什么？请解释。
```python
def multipliers():
  return [lambda x : i * x for i in range(4)]
print [m(2) for m in multipliers()]
</code></pre>
<p>你如何修改上面的<code>multipliers</code>的定义产生想要的结果？<br>
上面代码输出的结果是<code>[6, 6, 6, 6]</code>(不是我们想的<code>[0, 2, 4, 6]</code>)。<br>
上述问题产生的原因是<code>Python</code>闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。因此，当任何由<code>multipliers()</code>返回的函数被调用时，<code>i</code>的值将在附近的范围进行查找。那时，不管返回的函数是否被调用，for循环已经完成，<code>i</code>被赋予了最终的值3。<br>
因此，每次返回的函数乘以传递过来的值3，因为上段代码传过来的值是2，它们最终返回的都是6(3*2)。碰巧的是，《The Hitchhiker’s Guide to Python》也指出，在与<code>lambdas</code>函数相关也有一个被广泛被误解的知识点，不过跟这个<code>case</code>不一样。由<code>lambda</code>表达式创造的函数没有什么特殊的地方，它其实是和def创造的函数式一样的。<br>
下面是解决这一问题的一些方法。<br>
一种解决方法就是用<code>Python</code>生成器。</p>
<pre><code class="language-python">def multipliers():
  for i in range(4): yield lambda x : i * x
</code></pre>
<p>另外一个解决方案就是创造一个闭包，利用默认函数立即绑定。</p>
<pre><code class="language-python">def multipliers():
  return [lambda x, i=i : i * x for i in range(4)]
</code></pre>
<p>还有种替代的方案是，使用偏函数：</p>
<pre><code class="language-python">from functools import partial
from operator import mul
def multipliers():
  return [partial(mul, i) for i in range(4)]
</code></pre>
<h5 id="装饰器">装饰器</h5>
<ul>
<li>在代码运行期间动态增加功能的方式，称之为“装饰器”(<code>Decorator</code>)。<br>
本质上，<code>decorator</code>就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的<code>decorator</code>，可以定义如下：</li>
</ul>
<pre><code class="language-python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
now()
call now():
2015-3-25
</code></pre>
<p>由于<code>log()</code>是一个<code>decorator</code>，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。<br>
<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。<br>
如果<code>decorator</code>本身需要传入参数，那就需要编写一个返回<code>decorator</code>的高阶函数，写出来会更复杂。比如，要自定义<code>log</code>的文本：</p>
<pre><code class="language-python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
@log('execute')
def now():
    print('2015-3-25')
now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="language-python">now = log('execute')(now)
</code></pre>
<p>首先执行<code>log('execute')</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p>
<p>以上两种<code>decorator</code>的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过<code>decorator</code>装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>：</p>
<pre><code class="language-python">now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个<code>wrapper()</code>函数名字就是<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，<code>Python</code>内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的<code>decorator</code>的写法如下：</p>
<pre><code class="language-pythoh">import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的<code>decorator</code>：</p>
<pre><code>import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>在面向对象(OOP)的设计模式中，<code>decorator</code>被称为装饰模式。<code>OOP</code>的装饰模式需要通过继承和组合来实现，而<code>Python</code>除了能支持<code>OOP</code>的<code>decorator</code>外，直接从语法层次支持<code>decorator</code>。<code>Python</code>的<code>decorator</code>可以用函数实现，也可以用类实现。<br>
<code>decorator</code>可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h6 id="property"><code>@property</code></h6>
<p><code>Python</code>内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<pre><code class="language-python">class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="language-python">s = Student()
s.score = 60 # OK，实际转化为s.set_score(60)
s.score # OK，实际转化为s.get_score()
60
s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过<code>getter</code>和<code>setter</code>方法来实现的。</p>
<p>还可以定义只读属性，只定义<code>getter</code>方法，不定义<code>setter</code>方法就是一个只读属性：</p>
<pre><code class="language-python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<h6 id="classmethod"><code>@classmethod</code></h6>
<p><code>@classmethod</code>对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。<br>
<code>@classmethod</code>因为持有<code>cls</code>参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>
<pre><code class="language-python">class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 foo 方法
 
A.func2()               # 不需要实例化
</code></pre>
<h6 id="staticmethod"><code>@staticmethod</code></h6>
<p>将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。<br>
<code>@staticmethod</code>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。<br>
如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接<code>类名.属性名</code>或<code>类名.方法名</code>。</p>
<pre><code class="language-python">class TestClass:
    name = &quot;test&quot;
    def __init__(self, name):
        self.name = name
    @staticmethod
    def fun(self, x, y):
        return  x + y
cls = TestClass(&quot;felix&quot;)
print &quot;通过实例引用方法&quot;
print cls.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
print &quot;类名直接引用静态方法&quot;
print TestClass.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
</code></pre>
<h6 id="dataclass"><code>@dataclass</code></h6>
<pre><code class="language-python">class MyClass:
    def __init__(self, var_a, var_b):
        self.var_a = var_a
        self.var_b = var_b
@dataclass
class MyClass:
    var_a: str
    var_b: str
@dataclass
class Number:
    val:int = 0
</code></pre>
<h5 id="偏函数">偏函数</h5>
<ul>
<li><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换。<br>
但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入<code>base</code>参数，就可以做N进制的转换：<br>
<code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</li>
</ul>
<pre><code>import functools
int2 = functools.partial(int, base=2)
int2('1000000')
64
int2('1010101')
85
</code></pre>
<ul>
<li>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>
注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为2，但也可以在函数调用时传入其他值：</li>
</ul>
<pre><code class="language-python">int2('1000000', base=10)
1000000
</code></pre>
<ul>
<li>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</li>
</ul>
<pre><code class="language-python">int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了<code>int()</code>函数的关键字参数<code>base</code>，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code class="language-python">max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>
<pre><code class="language-python">max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code class="language-python">args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。<br>
当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
<h4 id="itertools模块"><code>itertools</code>模块</h4>
<ul>
<li>标准库<code>itertools</code>模块中有一组用于许多常见数据算法的生成器。例如，<code>groupby</code>可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</li>
</ul>
<pre><code class="language-python">import itertools
first_letter = lambda x: x[0]
names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
for letter, names in itertools.groupby(names, first_letter):
    print(letter, list(names)) # names is a generator
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']
</code></pre>
<ul>
<li>常用<code>itertools</code>函数:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373137383639312d313131383233643837363761313034642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f77.png" alt="" loading="lazy"></li>
</ul>
<h3 id="字符串">字符串</h3>
<pre><code class="language-python"> a= 'ABC'
</code></pre>
<p>在内存中创建了一个<code>'ABC'</code>的字符串；<br>
在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。<br>
也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p>
<pre><code class="language-python">a = 'ABC'
b = a
a = 'XYZ'
print(b)
'ABC`
</code></pre>
<h4 id="分割">分割</h4>
<pre><code class="language-python">s = 'python'
list(s)
['p', 'y', 't', 'h', 'o', 'n']
</code></pre>
<h4 id="模板化或格式化">模板化或格式化</h4>
<pre><code class="language-python">template = '{0:.2f} {1:s} are worth US${2:d}'
</code></pre>
<ul>
<li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>{1:s}</code>表示格式化第二个参数为字符串。</li>
<li><code>{2:d}</code>表示格式化第三个参数为一个整数。<br>
在括号中的数字用于指向传入对象在 <code>format()</code> 中的位置，如下所示：</li>
</ul>
<pre><code class="language-python">print('{0} 和 {1}'.format('Google', 'Runoob'))
Google 和 Runoob
print('{1} 和 {0}'.format('Google', 'Runoob'))
Runoob 和 Google
</code></pre>
<p>如果在<code>format()</code> 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code class="language-python">print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
菜鸟教程网址： www.runoob.com
</code></pre>
<p>位置及关键字参数可以任意的结合:</p>
<pre><code class="language-python">print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
站点列表 Google, Runoob, 和 Taobao。
</code></pre>
<p>可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 <code>Pi</code> 保留到小数点后三位：</p>
<pre><code class="language-python">import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre>
<p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。<br>
最简单的就是传入一个字典, 然后使用方括号 <code>[]</code> 来访问键值 :</p>
<pre><code class="language-python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<p>也可以通过在 <code>table</code> 变量前使用 <code>**</code> 来实现相同的功能：</p>
<pre><code class="language-python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<h4 id="常用操作">常用操作</h4>
<ul>
<li><code>str.join(iterable)</code>:返回一个由 <code>iterable</code> 中的字符串拼接而成的字符串。比<code>+</code>效率要高。</li>
<li><code>eval(str)</code>:用来计算在字符串中的有效<code>Python</code>表达式,并返回一个对象</li>
<li><code>str.center(width[, fillchar])</code>:返回长度为 <code>width</code> 的字符串，原字符串在其正中。 使用指定的 <code>fillchar</code> 填充两边的空位（默认使用 <code>ASCII</code> 空格符）。 如果 <code>width</code> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</li>
<li><code>str.count(str, beg= 0,end=len(string))</code>:返回 <code>str</code> 在 <code>string</code> 里面出现的次数，如果 <code>beg</code> 或者 <code>end</code>指定则返回指定范围内 <code>str</code> 出现的次数</li>
<li><code>str.find(str, beg=0, end=len(string))</code>:检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code> ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回<code>-1</code></li>
<li><code>str.upper()</code>:转换字符串中的小写字母为大写</li>
<li><code>str.lower()</code>:转换字符串中所有大写字符为小写</li>
<li><code>str.replace(old, new [, max])</code>:将字符串中的 <code>str1</code> 替换成 <code>str2</code>,如果<code>max</code>指定，则替换不超过<code>max</code>次。</li>
<li><code>str.split(str=&quot;&quot;, num=string.count(str))</code>:<code>num=string.count(str))</code> 以<code>str</code>为分隔符截取字符串，如果<code>num</code>有指定值，则仅截取<code>num+1</code>个子字符串</li>
<li><code>str.strip([chars])</code>:截掉字符串两边的空格或指定字符。</li>
</ul>
<h3 id="运算符">运算符</h3>
<h4 id="和is"><code>==</code>和<code>is</code></h4>
<ul>
<li>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法:</li>
</ul>
<pre><code class="language-python">a = [1, 2, 3]
b = a
c = list(a)
print(a is b)
True
# 因为list总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。
print(a is not c)
True
print(a == c)
True
</code></pre>
<h4 id="any和all"><code>any()</code>和<code>all()</code></h4>
<p><code>any()</code>, <code>all()</code>很好理解，就是字面意思，即参数中任何一个为 <code>true</code> 或者全部为 <code>true</code> 则返回 <code>true</code>。</p>
<h4 id="十进制转二进制">十进制转二进制</h4>
<pre><code class="language-python">bin(10)
'0b1010'
</code></pre>
<h2 id="模块">模块</h2>
<ul>
<li>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，<code>Python</code>就把这个目录当成普通目录，而不是一个包。</li>
<li>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</li>
<li>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。<br>
<code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该``.py文件的名称，例如：<br>
运行<code>python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；<br>
运行<code>python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael]</code>。<br>
注意当使用 <code>from package import item</code> 这种形式的时候，对应的 <code>item</code> 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。<br>
<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。<br>
反之，如果使用形如 <code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</li>
<li>内置的函数 <code>dir()</code> 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</li>
<li><code>sys.argv</code> 是一个包含命令行参数的列表。<code>sys.path</code> 包含了一个 <code>Python</code> 解释器自动查找所需模块的路径的列表。</li>
<li>搜索路径是由一系列目录名组成的，<code>Python</code>解释器就依次从这些目录中去寻找所引入的模块。<br>
搜索路径是在<code>Python</code>编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在<code>sys</code>模块中的<code>path</code>变量，做一个简单的实验，在交互式解释器中，输入以下代码：</li>
</ul>
<pre><code class="language-python">import sys
sys.path
['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']
</code></pre>
<p><code>sys.path</code> 输出是一个列表，其中第一项是空串<code>''</code>，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行<code>python</code>解释器的目录（对于脚本的话就是运行的脚本所在的目录）。<br>
因此若在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。<br>
了解了搜索路径的概念，就可以在脚本中修改<code>sys.path</code>来引入一些不在搜索路径中的模块。<br>
如果我们要添加自己的搜索目录，有两种方法：<br>
一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<pre><code class="language-python">import sys
sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是在运行时修改，运行结束后失效。<br>
第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，<code>Python</code>自己本身的搜索路径不受影响。<br>
现在，在解释器的当前目录或者 <code>sys.path</code>中的一个目录里面来创建一个<code>fibo.py</code>的文件，代码如下：</p>
<pre><code class="language-python"># 斐波那契(fibonacci)数列模块
def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre>
<p>然后进入<code>Python</code>解释器，使用下面的命令导入这个模块：</p>
<pre><code class="language-python">import fibo
</code></pre>
<p>这样做并没有把直接定义在<code>fibo</code>中的函数名称写入到当前符号表里，只是把模块<code>fibo</code>的名字写到了那里。</p>
<h3 id="name属性"><code>name</code>属性</h3>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code class="language-python3"># Filename: using_name.py
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<pre><code class="language-shell">$ python using_name.py
程序自身在运行
$ python
&gt;&gt;&gt; import using_name
我来自另一模块
</code></pre>
<p>说明： 每个模块都有一个<code>__name_</code>_属性，当其值是<code>'__main__'</code>时，表明该模块自身在运行，否则是被引入。</p>
<h4 id="包">包</h4>
<ul>
<li>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</li>
</ul>
<pre><code class="language-python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<p>如果 <code>__all__</code>真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 <code>sound.effects</code> 里的任何子模块。他只是把包<code>sound.effects</code>和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。<br>
这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code class="language-python">import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre>
<p>这个例子中，在执行 <code>from...import</code> 前，包 <code>sound.effects</code> 中的 <code>echo</code> 和 <code>surround</code> 模块都被导入到当前的命名空间中了。（当然如果定义了 <code>__all__</code> 就更没问题了）</p>
<h2 id="oop">OOP</h2>
<h3 id="访问限制">访问限制</h3>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在<code>Python</code>中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量(<code>private</code>)，只有内部可以访问，外部不能访问:</p>
<pre><code class="language-python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
<pre><code class="language-python">bart = Student('Bart Simpson', 59)
bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>外部代码要获取<code>name</code>和<code>score</code>,修改属性,可以给<code>Student</code>类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<pre><code class="language-python">class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
    def set_score(self, score):
        self.__score = score
</code></pre>
<p>那种直接通过<code>bart.score = 99</code>也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code class="language-python">class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>在<code>Python</code>中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是<code>private</code>变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。<br>
下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为<code>Python</code>解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name来访问__name</code>变量：</p>
<pre><code class="language-python">bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的<code>Python</code>解释器可能会把<code>__name</code>改成不同的变量名。<br>
总的来说就是，<code>Python</code>本身没有任何机制阻止你干坏事，一切全靠自觉。<br>
最后注意下面的这种错误写法：</p>
<pre><code class="language-python">bart = Student('Bart Simpson', 59)
bart.get_name()
'Bart Simpson'
bart.__name = 'New Name' # 设置__name变量！
bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和<code>class</code>内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被<code>Python</code>解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<pre><code class="language-python">bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<h3 id="继承和多态">继承和多态</h3>
<pre><code class="language-python">#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
</code></pre>
<pre><code class="language-python">class Animal(object):
    def run(self):
        print('Animal is running...')
class Dog(Animal):
    def run(self):
        print('Dog is running...')
</code></pre>
<p>子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。]</p>
<pre><code class="language-python">a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
isinstance(a, list)
True
isinstance(b, Animal)
True
isinstance(c, Dog)
True
</code></pre>
<p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p>
<pre><code class="language-python">isinstance(c, Animal)
True
</code></pre>
<p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！<br>
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p>
<pre><code class="language-python">def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<pre><code class="language-python">run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>多态的好处就是，当我们需要传入<code>Dog</code>时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>还是<code>Dog</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>
对扩展开放：允许新增<code>Animal</code>子类；<br>
对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>
对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>
对于<code>Python</code>这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<pre><code class="language-python">class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>
<code>Python</code>的<code>“file-like object“</code>就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为<code>“file-like object“</code>。许多函数接收的参数就是<code>“file-like object“</code>，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。<br>
下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-python">class Parent(object):
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass
print Parent.x, Child1.x, Child2.x
Child1.x = 2
print Parent.x, Child1.x, Child2.x
Parent.x = 3
print Parent.x, Child1.x, Child2.x
1 1 1
1 2 1
3 2 3
</code></pre>
<p>让很多人困惑或惊讶的是最后一行输出为什么是3 2 3 而不是 3 2 1.为什么在改变<code>parent.x</code>的同时也改变了<code>child2.x</code>的值？但与此同时没有改变<code>Child1.x</code>的值？<br>
此答案的关键是，在<code>Python</code>中，类变量在内部是以字典的形式进行传递。<br>
如果一个变量名没有在当前类下的字典中发现。则在更高级的类（如它的父类）中尽心搜索直到引用的变量名被找到。（如果引用变量名在自身类和更高级类中没有找到，将会引发一个属性错误。）<br>
因此,在父类中设定<code>x = 1</code>,让变量<code>x</code>类(带有值1)能够在其类和其子类中被引用到。这就是为什么第一个打印语句输出结果是1 1 1<br>
因此，如果它的任何一个子类被覆写了值（例如说，当我们执行语句<code>Child1.x = 2</code>）,这个值只在子类中进行了修改。这就是为什么第二个打印语句输出结果是1 2 1<br>
最终，如果这个值在父类中进行了修改，（例如说，当我们执行语句<code>Parent.x = 3</code>）,这个改变将会影响那些还没有覆写子类的值（在这个例子中就是<code>Child2</code>）这就是为什么第三打印语句输出结果是3 2 3</p>
<h3 id="获取对象信息">获取对象信息</h3>
<h4 id="使用type">使用<code>type()</code></h4>
<p>判断对象类型，使用<code>type()</code>函数：</p>
<pre><code class="language-python">type(123)
&lt;class 'int'&gt;
type('str')
&lt;class 'str'&gt;
type(None)
&lt;type(None) 'NoneType'&gt;
type(abs)
&lt;class 'builtin_function_or_method'&gt;
type(a)
&lt;class '__main__.Animal'&gt;
&gt;&gt;&gt; import types
def fn():
    pass
type(fn)==types.FunctionType
True
type(abs)==types.BuiltinFunctionType
True
type(lambda x: x)==types.LambdaType
True
type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h4 id="使用isinstance">使用<code>isinstance()</code></h4>
<p>判断<code>class</code>的类型，可以使用<code>isinstance()</code>函数。</p>
<pre><code class="language-python">isinstance([1, 2, 3], (list, tuple))
True
isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</strong></p>
<h4 id="使用dir">使用dir()</h4>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个<code>str</code>对象的所有属性和方法：</p>
<pre><code class="language-python">dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p>类似<code>__xxx__</code>的属性和方法在<code>Python</code>中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在<code>Python</code>中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<pre><code class="language-python">len('ABC')
3
'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<pre><code class="language-python">class MyDog(object):
    def __len__(self):
        return 100
dog = MyDog()
len(dog)
100
</code></pre>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p>
<pre><code class="language-python">'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<pre><code class="language-python">class MyObject(object):
    def __init__(self):
        self.x = 9
    def power(self):
        return self.x * self.x
obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code class="language-python">hasattr(obj, 'x') # 有属性'x'吗？
True
obj.x
9
hasattr(obj, 'y') # 有属性'y'吗？
False
setattr(obj, 'y', 19) # 设置一个属性'y'
hasattr(obj, 'y') # 有属性'y'吗？
True
getattr(obj, 'y') # 获取属性'y'
19
obj.y # 获取属性'y'
19
</code></pre>
<p>如果试图获取不存在的属性，会抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-python">getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个<code>default</code>参数，如果属性不存在，就返回默认值：</p>
<pre><code>getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code class="language-python">hasattr(obj, 'power') # 有属性'power'吗？
True
getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<h4 id="实例属性和类属性">实例属性和类属性</h4>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>直接在<code>class</code>中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<pre><code class="language-python">class Student(object):
    name = 'Student'
</code></pre>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<pre><code class="language-python">class Student(object):
    name = 'Student'
s = Student() # 创建实例s
print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
print(Student.name) # 打印类的name属性
Student
s.name = 'Michael' # 给实例绑定name属性
print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
del s.name # 如果删除实例的name属性
print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>
实例属性属于各个实例所有，互不干扰；<br>
类属性属于类所有，所有实例共享一个属性；<br>
不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h4 id="使用__slots__">使用<code>__slots__</code></h4>
<p>给实例绑定一个方法：</p>
<pre><code class="language-python">def set_age(self, age): # 定义一个函数作为实例方法
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25) # 调用实例方法
s.age # 测试结果
25
</code></pre>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<pre><code class="language-python">s2 = Student() # 创建新的实例
s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p>为了给所有实例都绑定方法，可以给class绑定方法：</p>
<pre><code class="language-python">def set_score(self, score):
    self.score = score
Student.set_score = set_score
</code></pre>
<p>给class绑定方法后，所有实例均可调用.<br>
通常情况下，上面的<code>set_score</code>方法可以直接定义在<code>class</code>中，但动态绑定允许我们在程序运行的过程中动态给<code>class</code>加上功能，这在静态语言中很难实现。<br>
限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。<br>
为了达到限制的目的，<code>Python</code>允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>
<pre><code class="language-python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```python
s = Student() # 创建新的实例
s.name = 'Michael' # 绑定属性'name'
s.age = 25 # 绑定属性'age'
s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>由于<code>'score'</code>没有被放到_<code>_slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<pre><code class="language-python">class GraduateStudent(Student):
    pass
g = GraduateStudent()
g.score = 9999
</code></pre>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h4 id="多重继承">多重继承</h4>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318023741.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">class Animal(object):
    pass
# 大类:
class Mammal(Animal):
    pass
class Bird(Animal):
    pass
# 各种动物:
class Dog(Mammal):
    pass
class Bat(Mammal):
    pass
class Parrot(Bird):
    pass
class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上<code>Runnable</code>和<code>Flyable</code>的功能，只需要先定义好<code>Runnable</code>和<code>Flyable</code>的类：</p>
<pre><code class="language-python">class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要<code>Runnable</code>功能的动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p>
<pre><code class="language-python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要<code>Flyable</code>功能的动物，就多继承一个<code>Flyable</code>，例如<code>Bat</code>：</p>
<pre><code class="language-python">class Bat(Mammal, Flyable):
    pass
</code></pre>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。<br>
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>为了更好地看出继承关系，我们把<code>Runnable</code>和<code>Flyable</code>改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让某个动物同时拥有好几个<code>MixIn</code>：</p>
<pre><code class="language-python">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><code>MixIn</code>的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个<code>MixIn</code>的功能，而不是设计多层次的复杂的继承关系。</p>
<p><code>Python</code>自带的很多库也使用了<code>MixIn</code>。举个例子，<code>Python</code>自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的<code>TCP</code>服务，定义如下：</p>
<pre><code class="language-python">class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的<code>UDP</code>服务，定义如下：</p>
<pre><code class="language-python">class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个<code>CoroutineMixIn</code>：</p>
<pre><code class="language-python">class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br>
由于<code>Python</code>允许使用多重继承，因此，<code>MixIn</code>就是一种常见的设计。<br>
只允许单一继承的语言（如<code>Java</code>）不能使用<code>MixIn</code>的设计。</p>
<ul>
<li>若是父类中有相同的方法名，而在子类使用时未指定，<code>python</code>从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
</ul>
<pre><code class="language-python">#类定义
class people:
    #定义基本属性
    name = ''
    age = 0
    #定义私有属性,私有属性在类外部无法直接进行访问
    __weight = 0
    #定义构造方法
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
 
#单继承示例
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
        #调用父类的构函
        people.__init__(self,n,a,w)
        self.grade = g
    #覆写父类的方法
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
 
#另一个类，多重继承之前的准备
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
 
#多重继承
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<ul>
<li><code>super()</code><br>
如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</li>
</ul>
<pre><code class="language-python">class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
调用子类方法
调用父类方法
</code></pre>
<p>如果重写了<code>__init__</code>时，要继承父类的构造方法，可以使用 <code>super</code> 关键字：</p>
<pre><code class="language-python">super(子类，self).__init__(参数1，参数2，....)
</code></pre>
<h4 id="定制类">定制类</h4>
<h5 id="__str__"><code>__str__</code></h5>
<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。<br>
怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name: %s)' % self.name
print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>
但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p>
<pre><code class="language-python">s = Student('Michael')
s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h5 id="__iter__"><code>__iter__</code></h5>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，<code>Python</code>的<code>for</code>循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br>
我们以斐波那契数列为例，写一个<code>Fib</code>类，可以作用于<code>for</code>循环：</p>
<pre><code class="language-python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把<code>Fib</code>实例作用于<code>for</code>循环：</p>
<pre><code class="language-python">for n in Fib():
    print(n)
1
1
2
3
5
...
46368
75025
</code></pre>
<h5 id="__getitem__"><code>__getitem__</code></h5>
<p><code>Fib</code>实例虽然能作用于<code>for</code>循环，看起来和<code>list</code>有点像，但是，把它当成<code>list</code>来使用还是不行,要表现得像<code>list</code>那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<pre><code class="language-python">class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
f = Fib()
f[0]
1
f[1]
1
f[2]
2
f[3]
3
f[10]
89
f[100]
573147844013817084101
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
f = Fib()
f[0:5]
[1, 1, 2, 3, 5]
f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作<code>key</code>的<code>object</code>，例如<code>str</code>。<br>
与之对应的是<code>__setitem__()</code>方法，把对象视作<code>list</code>或<code>dict</code>来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。<br>
总之，通过上面的方法，我们自己定义的类表现得和<code>Python</code>自带的<code>list</code>、<code>tuple</code>、<code>dict</code>没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h5 id="__getattr__"><code>__getattr__</code></h5>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p>
<pre><code class="language-python">s = Student()
print(s.name)
Michael
print(s.score)
Traceback (most recent call last):
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个<code>attribute</code>。</p>
<p>要避免这个错误，除了可以加上一个<code>score</code>属性外，<code>Python</code>还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p>
<pre><code class="language-python">class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如<code>score</code>，<code>Python</code>解释器会试图调用<code>__getattr__(self, 'score')</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值。<br>
返回函数也是完全可以的：</p>
<pre><code class="language-oython">class Student(object):
    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="language-python">s.age()
25
</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在_<code>_getattr__</code>中查找。<br>
此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让<code>class</code>只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-python">class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<h5 id="__call__"><code>__call__</code></h5>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在<code>Python</code>中，答案是肯定的。<br>
任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="language-python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
调用方式如下：
```python
s = Student('Michael')
s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。<br>
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。<br>
那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例。<br>
通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h4 id="枚举类">枚举类</h4>
<pre><code class="language-python">from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="language-python">for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从1开始计数。<br>
如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<pre><code class="language-python">from enum import Enum, unique
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。<br>
访问这些枚举类型可以有若干种方法：</p>
<pre><code class="language-python">day1 = Weekday.Mon
print(day1)
Weekday.Mon
print(Weekday.Tue)
Weekday.Tue
print(Weekday['Tue'])
Weekday.Tue
print(Weekday.Tue.value)
2
rint(day1 == Weekday.Mon)
True
print(day1 == Weekday.Tue)
False
rint(Weekday(1))
Weekday.Mon
print(day1 == Weekday(1))
True
Weekday(7)
Traceback (most recent call last):
ValueError: 7 is not a valid Weekday
for name, member in Weekday.__members__.items():
    print(name, '=&gt;', member)
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据<code>value</code>的值获得枚举常量。<br>
<code>Enum</code>可以把一组相关常量定义在一个<code>class</code>中，且<code>class</code>不可变，而且成员可以直接比较。</p>
<h4 id="使用元类">使用元类</h4>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。<br>
比方说我们要定义一个<code>Hello</code>的<code>class</code>，就写一个<code>hello.py</code>模块：</p>
<pre><code class="language-python">class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当<code>Python</code>解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的<code>class</code>对象，测试如下：</p>
<pre><code class="language-python">from hello import Hello
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个<code>class</code>，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</p>
<p>我们说<code>class</code>的定义是运行时动态创建的，而创建<code>class</code>的方法就是使用<code>type()</code>函数。</p>
<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)</code>...的定义：</p>
<pre><code class="language-python">def fn(self, name='world'): # 先定义函数
    print('Hello, %s.' % name)
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个<code>class</code>对象，<code>type()</code>函数依次传入3个参数：<br>
<code>class</code>的名称；<br>
继承的父类集合，注意<code>Python</code>支持多重继承，如果只有一个父类，别忘了<code>tuple</code>的单元素写法；<br>
class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。<br>
通过<code>type()</code>函数创建的类和直接写<code>class</code>是完全一样的，因为<code>Python</code>解释器遇到<code>class</code>定义时，仅仅是扫描一下<code>class</code>定义的语法，然后调用<code>type()</code>函数创建出<code>class</code>。<br>
正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。<br>
<code>metaclass</code><br>
除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用<code>metaclass</code>。<br>
<code>metaclass</code>，直译为元类，简单的解释就是：<br>
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>
但是如果我们想创建出类呢？那就必须根据<code>metaclass</code>创建出类，所以：先定义<code>metaclass</code>，然后创建类。<br>
连接起来就是：先定义<code>metaclass</code>，就可以创建类，最后创建实例。<br>
所以，<code>metaclass</code>允许你创建类或者修改类。换句话说，你可以把类看成是<code>metaclass</code>创建出来的“实例”。</p>
<p><code>metaclass</code>是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用<code>metaclass</code>的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。<br>
我们先看一个简单的例子，这个<code>metaclass</code>可以给我们自定义的<code>MyList</code>增加一个<code>add</code>方法：</p>
<p>定义<code>ListMetaclass</code>，按照默认习惯，<code>metaclass</code>的类名总是以<code>Metaclass</code>结尾，以便清楚地表示这是一个<code>metaclass</code>：</p>
<pre><code class="language-python"># metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
有了`ListMetaclass`，我们在定义类的时候还要指示使用`ListMetaclass`来定制类，传入关键字参数`metaclass`：
```python
class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示<code>Python</code>解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<br>
<code>__new__()</code>方法接收到的参数依次是：<br>
当前准备创建的类的对象；<br>
类的名字；<br>
类继承的父类集合；<br>
类的方法集合。<br>
测试一下MyList是否可以调用add()方法：</p>
<pre><code class="language-python">L = MyList()
L.add(1)
L
[1]
</code></pre>
<p>而普通的list没有<code>add()</code>方法：</p>
<pre><code class="language-python">L2 = list()
L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过<code>metaclass</code>修改纯属变态。</p>
<h2 id="命名空间和作用域">命名空间和作用域</h2>
<h3 id="三种命名空间">三种命名空间：</h3>
<ul>
<li>内置名称(<code>built-in names</code>)， <code>Python</code> 语言内置的名称，比如函数名 <code>abs</code>、<code>char</code> 和异常名称 <code>BaseException</code>、<code>Exception</code> 等等。</li>
<li>全局名称(<code>global names</code>)，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li>
<li>局部名称(<code>local names</code>)，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）<br>
<code>Python</code> 的查找顺序为：<strong>局部的命名空间</strong> -&gt; <strong>全局命名空间</strong> -&gt; <strong>内置命名空间</strong>。</li>
</ul>
<h4 id="四种作用域">四种作用域：</h4>
<ul>
<li>L(Local)：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li>E(Enclosing)：包含了非局部(<code>non-local</code>)也非全局(<code>non-global</code>)的变量。比如两个嵌套函数，一个函数（或类） <code>A</code> 里面又包含了一个函数 <code>B</code> ，那么对于<code>B</code> 中的名称来说 <code>A</code> 中的作用域就为 <code>nonlocal</code>。</li>
<li>G(<code>Global</code>)：当前脚本的最外层，比如当前模块的全局变量。</li>
<li>B(<code>Built-in</code>)： 包含了内建的变量/关键字等。最后被搜索。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200320015425.png" alt="" loading="lazy"><br>
<code>Python</code> 中只有模块(<code>module</code>)，类(<code>class</code>)以及函数(<code>def</code>、<code>lambda</code>)才会引入新的作用域，其它的代码块(如 <code>if</code>/<code>elif</code>/<code>else</code>/、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</li>
</ul>
<pre><code class="language-python">if True:
    msg = 'I am from Runoob'
msg
'I am from Runoob'
</code></pre>
<p>实例中 <code>msg</code> 变量定义在 <code>if</code> 语句块中，但外部还是可以访问的。<br>
如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<pre><code class="language-python">def test():
    msg_inner = 'I am from Runoob'
msg_inner
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'msg_inner' is not defined
</code></pre>
<p>从报错的信息上看，说明了 <code>msg_inner</code> 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="global-和-nonlocal关键字"><code>global</code> 和 <code>nonlocal</code>关键字</h4>
<pre><code class="language-python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
fun1()
print(num)
1
123
123
</code></pre>
<p>如果要修改嵌套作用域(<code>enclosing</code> 作用域，外层非全局作用域)中的变量则需要 <code>nonlocal</code> 关键字了，如下实例：</p>
<pre><code class="language-python">def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
100
100
</code></pre>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<pre><code class="language-python">a = 10
def test():
    a = a + 1
    print(a)
test()
Traceback (most recent call last):
  File &quot;test.py&quot;, line 7, in &lt;module&gt;
    test()
  File &quot;test.py&quot;, line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>错误信息为局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。<br>
修改 <code>a</code> 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<pre><code class="language-python">a = 10
def test(a):
    a = a + 1
    print(a)
test(a)
11
</code></pre>
<h2 id="错误和异常处理">错误和异常处理</h2>
<pre><code class="language-python">def attempt_float(x):
    try:
        return float(x)
    except ValueError:
        return x
</code></pre>
<p>某些情况下，你可能不想抑制异常，你想无论<code>try</code>部分的代码是否成功，都执行一段代码。可以使用<code>finally</code>：</p>
<pre><code class="language-python">f = open(path, 'w')

try:
    write_to_file(f)
finally:
    f.close()
</code></pre>
<p>这里，文件处理<code>f</code>总会被关闭。相似的，你可以用<code>else</code>让只在<code>try</code>部分成功的情况下，才执行代码：</p>
<pre><code class="language-python">f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
</code></pre>
<ul>
<li>可以有多个<code>except</code>来捕获不同类型的错误：</li>
</ul>
<pre><code class="language-python">try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<ul>
<li>Python的错误其实也是<code>class</code>，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</li>
</ul>
<pre><code class="language-python">try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
第二个`except`永远也捕获不到`UnicodeError`，因为`UnicodeError`是`ValueError`的子类，如果有，也被第一个`except`给捕获了。
</code></pre>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>
<pre><code class="language-python">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
</code></pre>
<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>
<pre><code class="language-python">def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise
bar()
</code></pre>
<p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去。<br>
这种错误处理方式相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个<code>Error</code>，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="language-python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p>
<ul>
<li><code>Python</code> 使用 <code>raise</code> 语句抛出一个指定的异常。<br>
<code>raise</code>语法格式如下：</li>
</ul>
<pre><code class="language-python">raise [Exception [, args [, traceback]]]
</code></pre>
<p>以下实例如果 x 大于 5 就触发异常:</p>
<pre><code>x = 10
if x &gt; 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
</code></pre>
<p>执行以上代码会触发异常：</p>
<pre><code class="language-python">Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre>
<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<br>
如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <code>raise</code> 语句就可以再次把它抛出。</p>
<pre><code class="language-python">try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre>
<h3 id="调试">调试</h3>
<ul>
<li>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>(assert)</code>来替代：</li>
</ul>
<pre><code class="language-python">def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n
def main():
    foo('0')
</code></pre>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>
如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>
<pre><code class="language-shell">$ python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
</code></pre>
<ul>
<li><code>logging</code><br>
把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</li>
</ul>
<pre><code class="language-python">import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
</code></pre>
<pre><code class="language-shell">$ python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。<br>
<code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如<code>console</code>和文件。</p>
<h2 id="文件和操作系统">文件和操作系统</h2>
<ul>
<li>为了打开一个文件以便读写，可以使用内置的<code>open</code>函数以及一个相对或绝对的文件路径：</li>
</ul>
<pre><code class="language-python">path = 'examples/segismundo.txt'
f = open(path)
</code></pre>
<ul>
<li>默认情况下，文件是以只读模式<code>('r')</code>打开的。然后，我们就可以像处理列表那样来处理这个文件句柄<code>f</code>了，比如对行进行迭代：</li>
</ul>
<pre><code class="language-python">for line in f:
    pass
</code></pre>
<ul>
<li>如果使用<code>open</code>创建文件对象，一定要用<code>close</code>关闭它。关闭文件可以返回操作系统资源：</li>
</ul>
<pre><code class="language-python">f.close()
</code></pre>
<ul>
<li>用<code>with</code>语句可以可以更容易地清理打开的文件,这样可以在退出代码块时，自动关闭文件：</li>
</ul>
<pre><code>with open(path) as f:
    lines = [x.rstrip() for x in f]
</code></pre>
<ul>
<li>读写模式：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211525.png" alt="" loading="lazy"></li>
<li>向文件写入，可以使用文件的<code>write</code>或<code>writelines</code>方法。例如，我们可以创建一个无空行版的<code>prof_mod.py</code>：</li>
</ul>
<pre><code class="language-python">with open('tmp.txt', 'w') as handle:
    handle.writelines(x for x in open(path) if len(x) &gt; 1)
with open('tmp.txt') as f:
    lines = f.readlines()
</code></pre>
<pre><code class="language-python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。<br>
以<code>'w'</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>'a'</code>以追加<code>(append)</code>模式写入。</p>
<ul>
<li>调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。</li>
<li>常用文件方法<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211726.png" alt="" loading="lazy"></li>
</ul>
<h3 id="操作文件和目录">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<ul>
<li>查看当前目录的绝对路径:</li>
</ul>
<pre><code class="language-python">os.path.abspath('.')
'/Users/michael'
- 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
````python
os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
</code></pre>
<ul>
<li>创建一个目录:</li>
</ul>
<pre><code class="language-python">os.mkdir('/Users/michael/testdir')
</code></pre>
<ul>
<li>删掉一个目录:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>os.rmdir('/Users/michael/testdir')<br>
把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符.<br>
同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-python">os.path.split('/Users/michael/testdir/file.txt')

('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<pre><code class="language-python">os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。<br>
文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<ul>
<li>对文件重命名:</li>
</ul>
<pre><code>os.rename('test.txt', 'test.py')
</code></pre>
<ul>
<li>删掉文件:</li>
</ul>
<pre><code class="language-python">os.remove('test.py')
</code></pre>
<p><code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<h3 id="序列化">序列化</h3>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。</p>
<p>要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-python"> json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><code>Python</code>的<code>dict</code>对象可以直接序列化为<code>JSON</code>的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>
<pre><code class="language-python">import json
class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p>
<pre><code class="language-python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<code>Student</code>对象不是一个可序列化为<code>JSON</code>的对象。<br>
前面的代码之所以无法把<code>Student</code>类实例序列化为<code>JSON</code>，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个<code>JSON</code>的<code>{}</code>对象。<br>
可选参数<code>default</code>就是把任意一个对象变成一个可序列为<code>JSON</code>的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="language-python">def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>：</p>
<pre><code class="language-python">print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p>
<pre><code class="language-python">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的<code>class</code>。<br>
同样的道理，如果我们要把<code>JSON</code>反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="language-python">def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的<code>Student</code>实例对象。</p>
<h2 id="标准库">标准库</h2>
<h3 id="collections"><code>collections</code></h3>
<h4 id="namedtuple"><code>namedtuple</code></h4>
<pre><code class="language-python">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
p.x
1
p.y
2
</code></pre>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>
这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<h4 id="deque"><code>deque</code></h4>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<pre><code class="language-python">from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
# 清除所有元素
q.clear()
# 计算x的个数
q.count(x)
#移除找到的第一个 value。
q.remove(value)
#逆序排列
q.reverse()
`deque`除了实现`list`的`append()`和`pop()`外，还支持`appendleft()`和`popleft()`，这样就可以非常高效地往头部添加或删除元素。
#### `defaultdict`
使用`dict`时，如果引用的`Key`不存在，就会抛出`KeyError`。如果希望`key`不存在时，返回一个默认值，就可以用`defaultdict`：
```python
from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
dd['key1'] # key1存在
'abc'
dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<p>默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="ordereddict"><code>OrderedDict</code></h4>
<p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。<br>
如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>：</p>
<pre><code class="language-python">from collections import OrderedDict
d = dict([('a', 1), ('b', 2), ('c', 3)])
d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，<code>OrderedDict的Key</code>会按照插入的顺序排列，不是<code>Key</code>本身排序：</p>
<pre><code class="language-python">od = OrderedDict()
od['z'] = 1
od['y'] = 2
od['x'] = 3
list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p><code>OrderedDict</code>可以实现一个<code>FIFO</code>（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的<code>Key</code>：</p>
<pre><code class="language-python">from collections import OrderedDict
class LastUpdatedOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity
    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h4 id="chainmap"><code>ChainMap</code></h4>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。<br>
什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。<br>
下面的代码演示了如何查找user和color这两个参数：</p>
<pre><code class="language-python">from collections import ChainMap
import os, argparse
# 构造缺省参数:
defaults = {
    'color': 'red',
    'user': 'guest'
}
# 构造命令行参数:
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }
# 组合成ChainMap:
combined = ChainMap(command_line_args, os.environ, defaults)
# 打印参数:
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
</code></pre>
<p>没有任何参数时，打印出默认参数：</p>
<pre><code class="language-shell">$ python3 use_chainmap.py 
color=red
user=guest
</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code class="language-shell">$ python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<pre><code class="language-shell">$ user=admin color=green python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<h4 id="counter"><code>Counter</code></h4>
<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code class="language-python">from collections import Counter
c = Counter()
for ch in 'programming':
c[ch] = c[ch] + 1
c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
c.update('hello') # 也可以一次性update
c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<ul>
<li><code>elements()</code>:返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，<code>elements()</code> 将会忽略它。</li>
</ul>
<pre><code class="language-python">c = Counter(a=4, b=2, c=0, d=-2)
sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']
</code></pre>
<ul>
<li><code>most_common([n])</code>:返回一个列表，其中包含<code>n</code> 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 <code>n</code> 被省略或为 <code>None</code>，<code>most_common()</code> 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序：</li>
</ul>
<pre><code class="language-python">Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
</code></pre>
<pre><code class="language-python">c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
c &amp; d                       # intersection:  min(c[x], d[x]) 
Counter({'a': 1, 'b': 1})
c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
</code></pre>
<ul>
<li><code>heap</code><br>
这个模块提供了堆队列算法的实现，也称为优先队列算法。<br>
堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <code>k</code> ，都有 <code>heap[k]</code> &lt;= <code>heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。<br>
这个<code>API</code>与教材的堆算法实现有所不同，具体区别有两方面：（a）我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 <code>Python</code> 使用从零开始的索引。 （b）我们的 <code>pop</code> 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。但是可以通过取反来实现最大堆。<br>
要创建一个堆，可以使用<code>list</code>来初始化为 <code>[]</code> ，或者你可以通过一个函数 <code>heapify()</code> ，来把一个<code>list</code>转换成堆。</li>
<li><code>heapq.heappush(heap, item)</code>:将 <code>item</code> 的值加入 <code>heap</code> 中，保持堆的不变性。</li>
<li><code>heapq.heappop(heap)</code>:弹出并返回 <code>heap</code> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <code>IndexError</code> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</li>
<li><code>heapq.heappushpop(heap, item)</code>:将 <code>item</code> 放入堆中，然后弹出并返回 <code>heap</code> 的最小元素。该组合操作比先调用  <code>heappush()</code> 再调用 <code>heappop()</code> 运行起来更有效率。</li>
<li><code>heapq.heapify(x)</code>:将<code>list x</code> 转换成堆，原地，线性时间内。</li>
<li><code>heapq.heapreplace(heap, item)</code>:弹出并返回 <code>heap</code> 中最小的一项，同时推入新的 <code>item</code>。 堆的大小不变。 如果堆为空则引发 <code>IndexError</code>。<br>
这个单步骤操作比 <code>heappop()</code> 加 <code>heappush()</code> 更高效，并且在使用固定大小的堆时更为适宜。 <code>pop/push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>
返回的值可能会比添加的 <code>item</code> 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。<br>
-<code>heapq.merge(*iterables, key=None, reverse=False)</code><br>
将多个已排序的输入合并为一个已排序的输出。返回已排序值的<code>iterator</code>。<br>
类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</li>
<li><code>heapq.nlargest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code>个最大元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</li>
<li><code>heapq.nsmallest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code> 个最小元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。<br>
两个函数在 <code>n</code> 值较小时性能最好。 对于更大的值，使用 <code>sorted()</code> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <code>min()</code> 和 <code>max()</code> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。<br>
堆排序:<br>
堆排序 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</li>
</ul>
<pre><code class="language-python">def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]
heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>如果我们想要<code>heapq</code>排序的是一个对象。那么heapq并不知道应该依据对象当中的哪个参数来作为排序的衡量标准，所以这个时候，需要我们自己定义一个获取关键字的函数，传递给<code>heapq</code>，这样才可以完成排序。<br>
比如说，我们现在有一批电脑，我们希望<code>heapq</code>能够根据电脑的价格排序：</p>
<pre><code class="language-python">laptops = [
    {'name': 'ThinkPad', 'amount': 100, 'price': 91.1},
    {'name': 'Mac', 'amount': 50, 'price': 543.22},
    {'name': 'Surface', 'amount': 200, 'price': 21.09},
    {'name': 'Alienware', 'amount': 35, 'price': 31.75},
    {'name': 'Lenovo', 'amount': 45, 'price': 16.35},
    {'name': 'Huawei', 'amount': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>在调用<code>nlargest</code>和<code>nsmallest</code>的时候，我们额外传递了一个参数<code>key</code>，我们传入的是一个匿名函数，它返回的结果是这个对象的<code>price</code>，也就是说我们希望<code>heapq</code>根据对象的<code>price</code>来进行排序。<br>
这类似于 <code>sorted(iterable)</code>，但与 <code>sorted()</code> 不同的是这个实现是不稳定的。</p>
<h3 id="bisect"><code>bisect</code></h3>
<ul>
<li><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code><br>
在 <code>a</code> 中找到 <code>x</code> 合适的插入点以维持有序。参数 <code>lo</code> 和 <code>hi</code> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <code>x</code> 已经在 <code>a</code> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <code>a</code> 是列表（<code>list</code>）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code>，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</li>
<li><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.bisect(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>bisect_left()</code>，但是返回的插入点是 <code>a</code> 中已存在元素 <code>x</code> 的右侧。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi]) for the right side</code>。</li>
<li><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code><br>
将 <code>x</code> 插入到一个有序序列 <code>a</code> 里，并维持其有序。如果 <code>a</code> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 <code>O(log n)</code> 的，插入却是 <code>O(n)</code> 的。</li>
<li><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.insort(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>insort_left()</code>，但是把 <code>x</code> 插入到 <code>a</code> 中已存在元素 <code>x</code>的右侧。<br>
函数 <code>bisect()</code> 还可以用于数字表查询。这个例子是使用 <code>bisect()</code> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：<code>90</code> 分及以上是 <code>'A'</code>，<code>80</code> 到 <code>89</code> 是 <code>'B'</code>，以此类推</li>
</ul>
<pre><code class="language-python">def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']
</code></pre>
<h3 id="itertools"><code>itertools</code></h3>
<ul>
<li><code>itertools.count(start=0,step=1)</code>:创建一个迭代器，生成从 <code>n</code> 开始的连续整数，如果忽略 <code>n</code>，则从 <code>0</code> 开始计算。</li>
</ul>
<pre><code class="language-python">for n in itertools.count():
    if 100000 &lt; n &lt; 100010:
        print n
    if n &gt; 1000000:
        break
100001
100002
100003
100004
100005
100006
100007
100008
100009
</code></pre>
<ul>
<li><code>itertools.cycle(iterable)</code>:把传入的一个序列无限重复下去。</li>
</ul>
<pre><code class="language-python">for c in itertools.cycle(&quot;AB&quot;):
    if count &gt; 4:
        break
    print c
   count += 1     
A
B
A
B
A
</code></pre>
<ul>
<li><code>itertools.repeat(object [,times])</code>:创建一个迭代器，重复生成 <code>object</code>，<code>times</code>（如果已提供）指定重复计数，如果未提供 <code>times</code>，将无止尽返回该对象。</li>
</ul>
<pre><code class="language-python">for x in itertools.repeat(&quot;hello world&quot;, 5):
    print x    
hello world
hello world
hello world
hello world
hello world
</code></pre>
<ul>
<li><code>itertools.chain(*iterables)</code>:把一组迭代对象串联起来，形成一个更大的迭代器。</li>
</ul>
<pre><code class="language-python">for c in itertools.chain('ABC', 'XYZ'):
    print c    
A
B
C
X
Y
Z
</code></pre>
<ul>
<li><code>itertools.permutations(iterable[, r])：返回</code>iterable<code>中任意取</code>r<code>个元素做排列的元组的迭代器，如果不指定</code>r<code>，那么序列的长度与</code>iterable` 中的项目数量相同。</li>
</ul>
<pre><code class="language-python">for elem in itertools.permutations('abc', 2):
    print elem
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
for elem in itertools.permutations('abc'):
    print elem
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
</code></pre>
<ul>
<li><code>itertools.combinations(iterable, r)</code>:组合，如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，<code>ab</code> 和 <code>ba</code> 则视为重复，此时只放回 <code>ab</code>. 示例：</li>
</ul>
<pre><code class="language-python">for elem in itertools.combinations('abc', 2):
    print elem   
('a', 'b')
('a', 'c')
('b', 'c')
</code></pre>
<ul>
<li><code>itertools.combinations_with_replacement(iterable, r)</code>:与 <code>combinations</code> 类似，但允许重复值，即如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，会多出 <code>aa</code>, <code>bb</code>, <code>cc</code>。</li>
<li><code>itertools.compress(data, selectors)</code>:<br>
相当于 <code>bool</code> 选取，只有当 <code>selectors</code> 对应位置的元素为 <code>true</code> 时，才保留 <code>data</code> 中相应位置的元素，否则去除。</li>
</ul>
<pre><code class="language-python">list(itertools.compress('abcdef', [1, 1, 0, 1, 0, 1]))
['a', 'b', 'd', 'f']
list(itertools.compress('abcdef', [True, False, True]))
['a', 'c']
</code></pre>
<ul>
<li><code>itertools.groupby(iterable[, keyfunc])</code>:对<code>iterable</code>中的元素进行分组。<code>keyfunc</code> 是分组函数，用于对 <code>iterable</code> 的连续项进行分组，如果不指定，则默认对 <code>iterable</code> 中的连续相同项进行分组，返回一个 <code>(key, sub-iterator)</code> 的迭代器。</li>
</ul>
<pre><code class="language-python">for key, value_iter in itertools.groupby('aaabbbaaccd'):
    print key, list(value_iter)  
a ['a', 'a', 'a']
b ['b', 'b', 'b']
a ['a', 'a']
c ['c', 'c']
d ['d']
data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f']
for key, value_iter in itertools.groupby(data, len):
    print key, list(value_iter)   
1 ['a']
2 ['bb', 'cc']
3 ['ddd', 'eee']
1 ['f']
</code></pre>
<p>注意，注意，注意：必须先排序后才能分组，因为<code>groupby</code>是通过比较相邻元素来分组的。可以看第二个例子，因为 <code>a</code> 和<code>f</code> 没有排在一起，所以最后没有分组到同一个列表中。</p>
<ul>
<li><code>itertools.islice(iterable, [start,] stop [, step])</code>:切片选择，<code>start</code> 是开始索引，<code>stop</code> 是结束索引，<code>step</code> 是步长，<code>start</code>和 <code>step</code> 可选。</li>
</ul>
<pre><code class="language-python">list(itertools.islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
list(itertools.islice(itertools.count(), 6))
[0, 1, 2, 3, 4, 5]
list(itertools.islice(itertools.count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
list(itertools.islice(itertools.count(), 3, 10, 2))
[3, 5, 7, 9]
</code></pre>
<ul>
<li><code>itertools.tee(iterable, n=2)</code>:从 <code>iterable</code> 创建 <code>n</code> 个独立的迭代器，以元组的形式返回。</li>
</ul>
<pre><code class="language-python">itertools.tee(&quot;abcedf&quot;)
(&lt;itertools.tee at 0x7fed7b8f59e0&gt;, &lt;itertools.tee at 0x7fed7b8f56c8&gt;)
iter1, iter2 = itertools.tee(&quot;abcedf&quot;)
list(iter1)
['a', 'b', 'c', 'e', 'd', 'f']
list(iter2)
['a', 'b', 'c', 'e', 'd', 'f']
</code></pre>
<ul>
<li><code>itertools.product(*iterables, repeat=1)</code>:<br>
大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。<br>
嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。<br>
要计算可迭代对象自身的笛卡尔积，将可选参数 <code>repeat</code> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</li>
<li><code>itertools.dropwhile</code></li>
</ul>
<pre><code class="language-python"> x = itertools.dropwhile(lambda e: e &lt; 5, range(10))
print(list(x))
[5, 6, 7, 8, 9]
</code></pre>
<ul>
<li><code>itertools.filterfalse</code>:<br>
保留对应真值为<code>False</code>的元素</li>
</ul>
<pre><code class="language-python">x = itertools.filterfalse(lambda e: e &lt; 5, (1, 5, 3, 6, 9, 4))
print(list(x))
[5, 6, 9]
</code></pre>
<h3 id="math"><code>math</code></h3>
<ul>
<li><code>math.ceil(x)</code>:返回 <code>x</code> 的上限，即大于或者等于 <code>x</code> 的最小整数。</li>
<li><code>math.comb(n, k)</code>:返回不重复且无顺序地从 <code>n</code> 项中选择 <code>k</code> 项的方式总数。</li>
<li><code>math.fabs(x)</code>:返回 <code>x</code> 的绝对值。</li>
<li><code>math.floor(x)</code>:返回 <code>x</code> 的向下取整，小于或等于 <code>x</code> 的最大整数。</li>
<li><code>math.gcd(a, b)</code>:最大公约数</li>
<li><code>math.exp(x)</code>:返回 <code>e</code> 次 <code>x</code> 幂</li>
<li><code>math.pow(x, y)</code>:将返回 <code>x</code> 的 <code>y</code> 次幂。</li>
<li><code>math.sqrt(x)</code>:返回 <code>x</code> 的平方根。</li>
<li><code>math.pi</code>:数学常数 π = 3.141592...，精确到可用精度。</li>
<li><code>math.e</code>:数学常数 e = 2.718281...，精确到可用精度。</li>
<li><code>math.inf</code>:浮点正无穷大。</li>
</ul>
<h3 id="time"><code>time</code></h3>
<p>在 <code>Python</code> 中，用三种方式来表示时间，分别是时间戳、格式化时间字符串和结构化时间</p>
<ul>
<li>时间戳（<code>timestamp</code>）：也就是 1970 年 1 月 1 日之后的秒，例如 1506388236.216345，可以通过<code>time.time()</code>获得。时间戳是一个浮点数，可以进行加减运算，但请注意不要让结果超出取值范围。</li>
<li>格式化的时间字符串（<code>string_time</code>）：也就是年月日时分秒这样的我们常见的时间字符串，例如2017-09-26 09:12:48，可以通过<code>time.strftime('%Y-%m-%d')</code>获得;<br>
结构化时间（<code>struct_time</code>）：一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code>，可以通过<code>time.localtime()</code>获得。</li>
<li>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>等方法可以获得一个格式化时间字符串。</li>
</ul>
<pre><code class="language-python">time.strftime('%Y-%m-%d %H:%M:%S')
'2017-09-26 10:04:28'
</code></pre>
<p><code>time.strptime(string[,format])</code><br>
将格式化时间字符串转化成结构化时间。该方法是<code>time.strftime()</code>方法的逆操作。<code>time.strptime()</code>方法根据指定的格式把一个时间字符串解析为时间元组。要注意的是，你提供的字符串要和 <code>format</code> 参数的格式一一对应，如果 <code>string</code> 中日期间使用<code>“-”</code>分隔，<code>format</code> 中也必须使用<code>“-”</code>分隔，时间中使用冒号<code>“:”</code>分隔，后面也必须使用冒号分隔，否则会报格式不匹配的错误。并且值也要在合法的区间范围内。</p>
<pre><code class="language-python">stime = &quot;2017-09-26 12:11:30&quot;
st = time.strptime(stime,&quot;%Y-%m-%d %H:%M:%S&quot;)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321211914.png" alt="" loading="lazy"></figure>
<ul>
<li><code>time.time()</code>:返回当前系统时间戳。时间戳可以做算术运算。</li>
</ul>
<pre><code class="language-python">time.time()
1506391907.020303
该方法经常用于计算程序运行时间：
```python
import time
def func():
    time.sleep(1.14)
    pass

t1 = time.time()
func()
t2 = time.time()
print(t2 - t1)
</code></pre>
<h3 id="datetime"><code>datetime</code></h3>
<pre><code class="language-python">from datetime import datetime, date, time
dt = datetime(2011, 10, 29, 20, 30, 21)
dt.day
29
dt.minute
30
</code></pre>
<ul>
<li>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</li>
</ul>
<pre><code class="language-python">dt.date()
datetime.date(2011, 10, 29)
dt.time()
datetime.time(20, 30, 21)
</code></pre>
<ul>
<li><code>strftime</code>方法可以将<code>datetime</code>格式化为字符串：</li>
</ul>
<pre><code class="language-python">dt.strftime('%m/%d/%Y %H:%M')
'10/29/2011 20:30'
</code></pre>
<ul>
<li><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</li>
</ul>
<pre><code class="language-python">datetime.strptime('20091031', '%Y%m%d')
datetime.datetime(2009, 10, 31, 0, 0)
</code></pre>
<ul>
<li>计算差值</li>
</ul>
<pre><code class="language-python">now = date.today()
birthday = date(1964, 7, 31)
age = now - birthday
age.days
14368
</code></pre>
<ul>
<li>格式化命令</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317190745.png" alt="" loading="lazy"></figure>
<h2 id="os"><code>os</code></h2>
<ul>
<li><code>os.path.exists(path)</code>:路径存在则返回<code>True</code>,路径损坏返回<code>False</code></li>
<li><code>os.path.join(path1[, path2[, ...]])</code>:把目录和文件名合成一个路径</li>
<li><code>os.system('mkdir today')</code>:命令行命令</li>
<li><code>os.environ</code>:<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;7&quot;</code></li>
</ul>
<h2 id="path"><code>Path</code></h2>
<p>在过去，文件的路径是纯字符串，现在它会是一个<code>pathlib.Path</code>对象:</p>
<pre><code class="language-python">from pathlib import Path
p = Path('/home/ubuntu')
PosixPath('/home/ubuntu')
str(p)
'/home/ubuntu'
</code></pre>
<p>过去路径拼接最正确的方法是用<code>os.path.join</code>:</p>
<pre><code class="language-python">os.path.join('/', 'home', 'dongwm/code')
'/home/dongwm/code'
os.path.join('/home', 'dongwm/code')
'/home/dongwm/code'
现在可以用`pathlib.Path`提供的`joinpath`来拼接:
```python
Path('/').joinpath('home', 'dongwm/code')
PosixPath('/home/dongwm/code')
但是更简单和方便的方法是用`/`运算符:
```python
Path('/') / 'home' / 'dongwm/code'
PosixPath('/home/dongwm/code')
Path('/') / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
'/' / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
</code></pre>
<p>使用<code>Path</code>对象的<code>parents</code>属性可以拿到各级目录列表(索引值越大越接近<code>root</code>)，而<code>parent</code>就表示父级目录:</p>
<pre><code class="language-python">p = Path('/Users/dongweiming/test')
p.parents[0]
PosixPath('/Users/dongweiming')
p.parents[1]
PosixPath('/Users')
p.parents[2]
PosixPath('/')
p.parent
PosixPath('/Users/dongweiming')
p.parent.parent
PosixPath('/Users')
</code></pre>
<p>获得文件后缀名:</p>
<pre><code class="language-python">p = Path('/usr/local/etc/my.cnf')
p.suffix, p.stem
('.cnf', 'my')
</code></pre>
<p>当文件有多个后缀，可以用<code>suffixes</code>返回文件所有后缀列表:</p>
<pre><code class="language-python">Path('my.tar.bz2').suffixes
['.tar', '.bz2']
Path('my.tar').suffixes
['.tar']
Path('my').suffixes
[]
</code></pre>
<p>Python语言没有内置创建文件的方法(<code>linux</code>下的<code>touch</code>命令)，过去这么做:</p>
<pre><code class="language-python">with open('new.txt', 'a') as f:
</code></pre>
<p>现在可以直接用<code>Path</code>的<code>touch</code>方法:</p>
<pre><code class="language-python">Path('new.txt').touch()
</code></pre>
<p><code>touch</code>接受<code>mode</code>参数，能够在创建时确认文件权限，还能通过<code>exist_ok</code>参数方式确认是否可以重复<code>touch</code>(默认可以重复创建，会更新文件的<code>mtime</code>)</p>
<ul>
<li><code>filename.exists()</code>；路径是否存在</li>
<li>打开文件：</li>
</ul>
<pre><code class="language-python">data_folder = Path(&quot;source_data/text_files/&quot;)
file_to_open = data_folder / &quot;raw_data.txt&quot;
print(file_to_open.read_text())
</code></pre>
<ul>
<li>与<code>os</code>模块对比<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321202526.png" alt="" loading="lazy"></li>
</ul>
<h2 id="第三方库">第三方库</h2>
<h3 id="h5py"><code>h5py</code></h3>
<p>h5py文件是存放两类对象的容器，数据集(<code>dataset</code>)和组(<code>group</code>)，<code>dataset</code>类似数组类的数据集合，和<code>numpy</code>的数组差不多。<code>group</code>是像文件夹一样的容器，它好比<code>python</code>中的字典，有键(<code>key</code>)和值(<code>value</code>)。<code>group</code>中可以存放<code>dataset</code>或者其他的<code>group</code>。”键”就是组成员的名称，”值”就是组成员对象本身(组或者数据集)</p>
<pre><code class="language-python">import h5py
</code></pre>
<h4 id="创建">创建</h4>
<pre><code class="language-python">with h5py.File('test.h5','w') as f:
</code></pre>
<h4 id="读取">读取</h4>
<pre><code class="language-python">with h5py.File('test.h5','r') as f:
</code></pre>
<p><code>h5py</code>文件就像一个 <code>Python</code> 字典，因此我们可以检查<code>key</code>,</p>
<pre><code class="language-python">list(f.keys())
['mydataset']
</code></pre>
<p>文件中有一个数据集，即<code>mydataset</code>:</p>
<pre><code class="language-python">dset = f['mydataset']
dset.shape
(100,)
dset.dtype
dtype('int32')
dset[...] = np.arange(100)
dset[0]
0
dset[10]
10
dset[0:100:10]
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
data = f['mydataset'][:]
</code></pre>
<h4 id="创建数据集">创建数据集：</h4>
<pre><code class="language-python">d1=f.create_dataset(&quot;dset1&quot;, (20,), 'i')
for key in f.keys():
    print(key)
    print(f[key].name)
    print(f[key].shape)
    print(f[key].value)
dset1
/dset1
(20,)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</code></pre>
<pre><code class="language-python">dset3 = f.create_dataset('subgroup2/dataset_three', (10,), dtype='i')
</code></pre>
<h4 id="赋值">赋值</h4>
<pre><code class="language-python">d1=f.create_dataset(&quot;dset1&quot;,(20,),'i')
d1[...]=np.arange(20)
#或者我们可以直接按照下面的方式创建数据集并赋值
f[&quot;dset2&quot;]=np.arange(15)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<p>如果我们有现成的<code>numpy</code>数组，那么可以在创建数据集的时候就赋值，这个时候就不必指定数据的类型和形状了，只需要把数组名传给参数<code>data</code>。</p>
<pre><code class="language-python">a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
</code></pre>
<h4 id="综合示例1">综合示例1</h4>
<pre><code class="language-python">#分别创建dset1,dset2,dset3这三个数据集
a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)

d2=f.create_dataset(&quot;dset2&quot;,(3,4),'i')
d2[...]=np.arange(12).reshape((3,4))

f[&quot;dset3&quot;]=np.arange(15)

for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
/dset3
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<h4 id="创建group需要首先以append模式打开文件">创建<code>group</code>,需要首先以<code>append</code>模式打开文件</h4>
<pre><code class="language-python">f = h5py.File('mydataset.hdf5', 'a')
grp = f.create_group(&quot;subgroup&quot;)
</code></pre>
<pre><code class="language-python">g1=f.create_group(&quot;bar&quot;)
#在bar这个组里面分别创建name为dset1,dset2的数据集并赋值。
g1[&quot;dset1&quot;]=np.arange(10)
g1[&quot;dset2&quot;]=np.arange(12).reshape((3,4))

for key in g1.keys():
    print(g1[key].name)
    print(g1[key].value)
/bar/dset1
[0 1 2 3 4 5 6 7 8 9]
/bar/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>
<p>注意观察数据集<code>dset1</code>和<code>dset2</code>的名字是不是有点和前面的不一样，如果是直接创建的数据集，不在任何组里面，那么它的名字就是<code>/+名字</code>，现在这两个数据集都在<code>bar</code>这个<code>group</code>(组)里面，名字就变成了<code>/bar+/</code>名字，是不是有点文件夹的感觉！继续看下面的代码，你会对<code>group</code>和<code>dataset</code>的关系进一步了解。</p>
<pre><code class="language-python">#创建组bar1,组bar2，数据集dset
g1=f.create_group(&quot;bar1&quot;)
g2=f.create_group(&quot;bar2&quot;)
d=f.create_dataset(&quot;dset&quot;,data=np.arange(10))

#在bar1组里面创建一个组car1和一个数据集dset1。
c1=g1.create_group(&quot;car1&quot;)
d1=g1.create_dataset(&quot;dset1&quot;,data=np.arange(10))

#在bar2组里面创建一个组car2和一个数据集dset2
c2=g2.create_group(&quot;car2&quot;)
d2=g2.create_dataset(&quot;dset2&quot;,data=np.arange(10))

#根目录下的组和数据集
for key in f.keys():
    print(f[key].name)
/bar1
/bar2
/dset

#bar1这个组下面的组和数据集
for key in g1.keys():
    print(g1[key].name)
/bar1/car1
/bar1/dset1
#bar2这个组下面的组和数据集
for key in g2.keys():
    print(g2[key].name)
/bar2/car2
/bar2/dset2
#顺便看下car1组和car2组下面都有什么，估计你都猜到了为空。
print(c1.keys())
print(c2.keys())
[]
[]
</code></pre>
<ul>
<li>综合示例2</li>
</ul>
<pre><code class="language-python">#遍历文件中的一级组
for group in f.keys():
    print (group)
    #根据一级组名获得其下面的组
    group_read = f[group]
    #遍历该一级组下面的子组
    for subgroup in group_read.keys():
        print subgroup     
        #根据一级组和二级组名获取其下面的dataset          
        dset_read = f[group+'/'+subgroup]                           
        #遍历该子组下所有的dataset
        for dset in dset_read.keys():
            #获取dataset数据
            dset1 = f[group+'/'+subgroup+'/'+dset]
            print dset1.name
            data = np.array(dset1)
            print data.shape
            x = data[...,0]
            y = data[...,1]        
</code></pre>
<h4 id="pandas对h5py的操作"><code>Pandas</code>对<code>h5py</code>的操作</h4>
<h5 id="写出">写出</h5>
<ul>
<li><code>path</code>：字符型输入，用于指定<code>h5</code>文件的名称（不在当前工作目录时需要带上完整路径信息）</li>
<li><code>mode</code>：用于指定<code>IO</code>操作的模式，与<code>Python</code>内建的<code>open()</code>中的参数一致，默认为<code>'a'</code>，即当指定文件已存在时不影响原有数据写入，指定文件不存在时则新建文件；<code>'r'</code>，只读模式；<code>'w'</code>，创建新文件（会覆盖同名旧文件）；<code>'r+'</code>，与<code>'a'</code>作用相似，但要求文件必须已经存在；</li>
<li><code>complevel</code>：<code>int</code>型，用于控制<code>h5</code>文件的压缩水平，取值范围在0-9之间，越大则文件的压缩程度越大，占用的空间越小，但相对应的在读取文件时需要付出更多解压缩的时间成本，默认为<code>0</code>，代表不压缩<br>
创建一个<code>HDF5 IO</code>对象<code>store</code>：</li>
</ul>
<pre><code class="language-python">store = pd.HDFStore('demo.h5')
s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
df = pd.DataFrame(np.random.randn(8, 3),
                 columns=['A', 'B', 'C'])
store['s'],store['df'] = s,df
</code></pre>
<p>从<code>pandas</code>中的数据结构直接导出到本地<code>h5</code>文件中：</p>
<pre><code class="language-python">#创建新的数据框
df_ = pd.DataFrame(np.random.randn(5,5))
#导出到已存在的h5文件中，这里需要指定key
df_.to_hdf(path_or_buf='demo.h5',key='df_')
#创建于本地demo.h5进行IO连接的store对象
store = pd.HDFStore('demo.h5')
#查看指定h5对象中的所有键
print(store.keys())
</code></pre>
<p>利用store对象的<code>put()</code>方法，其主要参数如下：</p>
<ul>
<li><code>key</code>：指定<code>h5</code>文件中待写入数据的<code>key</code></li>
<li><code>value</code>：指定与<code>key</code>对应的待写入的数据</li>
<li><code>format</code>：字符型输入，用于指定写出的模式，<code>'fixed'</code>对应的模式速度快，但是不支持追加也不支持检索；<code>'table'</code>对应的模式以表格的模式写出，速度稍慢，但是支持直接通过<code>store</code>对象进行追加和表格查询操作<br>
使用<code>put()</code>方法将数据存入<code>store</code>对象中：</li>
</ul>
<pre><code class="language-python">store.put(key='s',value=s);store.put(key='df',value=df)
</code></pre>
<p>既然是键值对的格式，那么可以查看<code>store</code>的<code>items</code>属性（注意这里<code>store</code>对象只有<code>items</code>和<code>keys</code>属性，没有<code>values</code>属性）：</p>
<pre><code class="language-python">store.items
</code></pre>
<p>调用<code>store</code>对象中的数据直接用对应的键名来索引即可：</p>
<pre><code class="language-python">store['df']
</code></pre>
<p>删除<code>store</code>对象中指定数据的方法有两种，一是使用<code>remove()</code>方法，传入要删除数据对应的键：</p>
<pre><code class="language-python">store.remove('s')
print(store.keys())
</code></pre>
<p>二是使用<code>Python</code>中的关键词<code>del</code>来删除指定数据：</p>
<pre><code class="language-python">del store['s']
</code></pre>
<h5 id="读取-2">读取</h5>
<pre><code class="language-python">store = pd.HDFStore('demo.h5')
'''方式1'''
df1 = store['df']
'''方式2'''
df2 = store.get('df')
</code></pre>
<pre><code class="language-python">df = pd.read_hdf('demo.h5',key='df')
</code></pre>
<ul>
<li>删除对象</li>
</ul>
<pre><code class="language-python">del subgroup[&quot;MyDataset&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode26. 删除排序数组中的重复项]]></title>
        <id>https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</id>
        <link href="https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/">
        </link>
        <updated>2020-02-22T08:23:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python3">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        cnt=len(set(nums))
        j=0
        for i in range(len(nums)):
            if i!=0:
                if(nums[i]==nums[i-1]):
                    continue
            nums[j]=nums[i]
            j+=1
        if(j&lt;len(nums)):
            del(nums[j:len(nums)])
        return j
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Numpy笔记]]></title>
        <id>https://bailingnan.github.io/post/numpy-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/numpy-bi-ji/">
        </link>
        <updated>2020-02-15T14:58:47.000Z</updated>
        <content type="html"><![CDATA[<p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p>
<p>NumPy的部分功能如下：</p>
<ul>
<li>ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。</li>
<li>用于对整组数据进行快速运算的标准数学函数（无需编写循环）。</li>
<li>用于读写磁盘数据的工具以及用于操作内存映射文件的工具。</li>
<li>线性代数、随机数生成以及傅里叶变换功能。</li>
<li>用于集成由C、C++、Fortran等语言编写的代码的A C API。</li>
</ul>
<p>由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C/C++/Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口。</p>
<p>NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。因为NumPy是一个很大的题目，我会在附录A中介绍更多NumPy高级功能，比如广播。</p>
<p>对于大部分数据分析应用而言，我最关注的功能主要集中在：</p>
<ul>
<li>用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。</li>
<li>常用的数组算法，如排序、唯一化、集合运算等。</li>
<li>高效的描述统计和数据聚合/摘要运算。</li>
<li>用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。</li>
<li>将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。</li>
<li>数据的分组运算（聚合、转换、函数应用等）。。</li>
</ul>
<p>虽然NumPy提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将pandas作为统计和分析工作的基础，尤其是处理表格数据时。pandas还提供了一些NumPy所没有的领域特定的功能，如时间序列处理等。</p>
<blockquote>
<p>笔记：Python的面向数组计算可以追溯到1995年，Jim Hugunin创建了Numeric库。接下来的10年，许多科学编程社区纷纷开始使用Python的数组编程，但是进入21世纪，库的生态系统变得碎片化了。2005年，Travis Oliphant从Numeric和Numarray项目整合出了NumPy项目，进而所有社区都集合到了这个框架下。</p>
</blockquote>
<p>NumPy之于数值计算特别重要的原因之一，是因为它可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<p>要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：</p>
<pre><code class="language-python">In [7]: import numpy as np

In [8]: my_arr = np.arange(1000000)

In [9]: my_list = list(range(1000000))
</code></pre>
<p>各个序列分别乘以2：</p>
<pre><code class="language-python">In [10]: %time for _ in range(10): my_arr2 = my_arr * 2
CPU times: user 20 ms, sys: 50 ms, total: 70 ms
Wall time: 72.4 ms

In [11]: %time for _ in range(10): my_list2 = [x * 2 for x in my_list]
CPU times: user 760 ms, sys: 290 ms, total: 1.05 s
Wall time: 1.05 s
</code></pre>
<p>基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。</p>
<h1 id="41-numpy的ndarray一种多维数组对象">4.1 NumPy的ndarray：一种多维数组对象</h1>
<p>NumPy最重要的一个特点就是其N维数组对象（即ndarray），该对象是一个快速而灵活的大数据集容器。你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样。</p>
<p>要明白Python是如何利用与标量值类似的语法进行批次计算，我先引入NumPy，然后生成一个包含随机数据的小数组：</p>
<pre><code class="language-python">In [12]: import numpy as np

# Generate some random data
In [13]: data = np.random.randn(2, 3)

In [14]: data
Out[14]: 
array([[-0.2047,  0.4789, -0.5194],
       [-0.5557,  1.9658,  1.3934]])
</code></pre>
<p>然后进行数学运算：</p>
<pre><code class="language-python">In [15]: data * 10
Out[15]: 
array([[ -2.0471,   4.7894,  -5.1944],
       [ -5.5573,  19.6578,  13.9341]])

In [16]: data + data
Out[16]: 
array([[-0.4094,  0.9579, -1.0389],
       [-1.1115,  3.9316,  2.7868]])
</code></pre>
<p>第一个例子中，所有的元素都乘以10。第二个例子中，每个元素都与自身相加。</p>
<blockquote>
<p>笔记：在本章及全书中，我会使用标准的NumPy惯用法<code>import numpy as np</code>。你当然也可以在代码中使用<code>from numpy import *</code>，但不建议这么做。<code>numpy</code>的命名空间很大，包含许多函数，其中一些的名字与Python的内置函数重名（比如min和max）。</p>
</blockquote>
<p>ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape（一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：</p>
<pre><code class="language-python">In [17]: data.shape
Out[17]: (2, 3)

In [18]: data.dtype
Out[18]: dtype('float64')
</code></pre>
<p>本章将会介绍NumPy数组的基本用法，这对于本书后面各章的理解基本够用。虽然大多数数据分析工作不需要深入理解NumPy，但是精通面向数组的编程和思维方式是成为Python科学计算牛人的一大关键步骤。</p>
<blockquote>
<p>笔记：当你在本书中看到“数组”、“NumPy数组”、&quot;ndarray&quot;时，基本上都指的是同一样东西，即ndarray对象。</p>
</blockquote>
<h2 id="创建ndarray">创建ndarray</h2>
<p>创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组。以一个列表的转换为例：</p>
<pre><code class="language-python">In [19]: data1 = [6, 7.5, 8, 0, 1]

In [20]: arr1 = np.array(data1)

In [21]: arr1
Out[21]: array([ 6. ,  7.5,  8. ,  0. ,  1. ])
</code></pre>
<p>嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</p>
<pre><code class="language-python">In [22]: data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]

In [23]: arr2 = np.array(data2)

In [24]: arr2
Out[24]: 
array([[1, 2, 3, 4],
       [5, 6, 7, 8]])
</code></pre>
<p>因为data2是列表的列表，NumPy数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证：</p>
<pre><code class="language-python">In [25]: arr2.ndim
Out[25]: 2

In [26]: arr2.shape
Out[26]: (2, 4)
</code></pre>
<p>除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。数据类型保存在一个特殊的dtype对象中。比如说，在上面的两个例子中，我们有：</p>
<pre><code class="language-python">In [27]: arr1.dtype
Out[27]: dtype('float64')

In [28]: arr2.dtype
Out[28]: dtype('int64')
</code></pre>
<p>除np.array之外，还有一些函数也可以新建数组。比如，zeros和ones分别可以创建指定长度或形状的全0或全1数组。empty可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可：</p>
<pre><code class="language-python">In [29]: np.zeros(10)
Out[29]: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])

In [30]: np.zeros((3, 6))
Out[30]: 
array([[ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.],
       [ 0.,  0.,  0.,  0.,  0.,  0.]])

In [31]: np.empty((2, 3, 2))
Out[31]: 
array([[[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]],
       [[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]]])
</code></pre>
<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
</blockquote>
<p>arange是Python内置函数range的数组版：</p>
<pre><code class="language-python">In [32]: np.arange(15)
Out[32]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>
<p>表4-1列出了一些数组创建函数。由于NumPy关注的是数值计算，因此，如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表4-1 数组创建函数" loading="lazy"></figure>
<h2 id="ndarray的数据类型">ndarray的数据类型</h2>
<p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<pre><code class="language-python">In [33]: arr1 = np.array([1, 2, 3], dtype=np.float64)

In [34]: arr2 = np.array([1, 2, 3], dtype=np.int32)

In [35]: arr1.dtype
Out[35]: dtype('float64')

In [36]: arr2.dtype
Out[36]: dtype('int32')
</code></pre>
<p>dtype是NumPy灵活交互其它系统的源泉之一。多数情况下，它们直接映射到相应的机器表示，这使得“读写磁盘上的二进制数据流”以及“集成低级语言代码（如C、Fortran）”等工作变得更加简单。数值型dtype的命名方式相同：一个类型名（如float或int），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即Python中的float对象）需要占用8字节（即64位）。因此，该类型在NumPy中就记作float64。表4-2列出了NumPy所支持的全部数据类型。</p>
<blockquote>
<p>笔记：记不住这些NumPy的dtype也没关系，新手更是如此。通常只需要知道你所处理的数据的大致类型是浮点数、复数、整数、布尔值、字符串，还是普通的Python对象即可。当你需要控制数据在内存和磁盘中的存储方式时（尤其是对大数据集），那就得了解如何控制存储类型。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="http://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="http://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>你可以通过ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype：</p>
<pre><code class="language-python">In [37]: arr = np.array([1, 2, 3, 4, 5])

In [38]: arr.dtype
Out[38]: dtype('int64')

In [39]: float_arr = arr.astype(np.float64)

In [40]: float_arr.dtype
Out[40]: dtype('float64')
</code></pre>
<p>在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除：</p>
<pre><code class="language-python">In [41]: arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])

In [42]: arr
Out[42]: array([  3.7,  -1.2,  -2.6,   0.5,  12.9,  10.1])

In [43]: arr.astype(np.int32)
Out[43]: array([ 3, -1, -2,  0, 12, 10], dtype=int32)
</code></pre>
<p>如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式：</p>
<pre><code class="language-python">In [44]: numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)

In [45]: numeric_strings.astype(float)
Out[45]: array([  1.25,  -9.6 ,  42.  ])
</code></pre>
<blockquote>
<p>注意：使用numpy.string_类型时，一定要小心，因为NumPy的字符串数据是大小固定的，发生截取时，不会发出警告。pandas提供了更多非数值数据的便利的处理方法。</p>
</blockquote>
<p>如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，写的是float而不是np.float64；NumPy很聪明，它会将Python类型映射到等价的dtype上。</p>
<p>数组的dtype还有另一个属性：</p>
<pre><code class="language-python">In [46]: int_array = np.arange(10)

In [47]: calibers = np.array([.22, .270, .357, .380, .44, .50], dtype=np.float64)

In [48]: int_array.astype(calibers.dtype)
Out[48]: array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])
</code></pre>
<p>你还可以用简洁的类型代码来表示dtype：</p>
<pre><code class="language-python">In [49]: empty_uint32 = np.empty(8, dtype='u4')

In [50]: empty_uint32
Out[50]: 
array([         0, 1075314688,          0, 1075707904,          0,
       1075838976,          0, 1072693248], dtype=uint32)
</code></pre>
<blockquote>
<p>笔记：调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同。</p>
</blockquote>
<h2 id="numpy数组的运算">NumPy数组的运算</h2>
<p>数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy用户称其为矢量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：</p>
<pre><code class="language-python">In [51]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])

In [52]: arr
Out[52]: 
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])

In [53]: arr * arr
Out[53]: 
array([[  1.,   4.,   9.],
       [ 16.,  25.,  36.]])

In [54]: arr - arr
Out[54]: 
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
</code></pre>
<p>数组与标量的算术运算会将标量值传播到各个元素：</p>
<pre><code class="language-python">In [55]: 1 / arr
Out[55]: 
array([[ 1.    ,  0.5   ,  0.3333],
       [ 0.25  ,  0.2   ,  0.1667]])

In [56]: arr ** 0.5
Out[56]: 
array([[ 1.    ,  1.4142,  1.7321],
       [ 2.    ,  2.2361,  2.4495]])
</code></pre>
<p>大小相同的数组之间的比较会生成布尔值数组：</p>
<pre><code class="language-python">In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])

In [58]: arr2
Out[58]: 
array([[  0.,   4.,   1.],
       [  7.,   2.,  12.]])

In [59]: arr2 &gt; arr
Out[59]:
array([[False,  True, False],
       [ True, False,  True]], dtype=bool)
</code></pre>
<p>不同大小的数组之间的运算叫做广播（broadcasting），将在附录A中对其进行详细讨论。本书的内容不需要对广播机制有多深的理解。</p>
<h2 id="基本的索引和切片">基本的索引和切片</h2>
<p>NumPy数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟Python列表的功能差不多：</p>
<pre><code class="language-python">In [60]: arr = np.arange(10)

In [61]: arr
Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [62]: arr[5]
Out[62]: 5

In [63]: arr[5:8]
Out[63]: array([5, 6, 7])

In [64]: arr[5:8] = 12

In [65]: arr
Out[65]: array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</code></pre>
<p>如上所示，当你将一个标量值赋值给一个切片时（如arr[5:8]=12），该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。跟列表最重要的区别在于，数组切片是原始数组的视图。这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。</p>
<p>作为例子，先创建一个arr的切片：</p>
<pre><code class="language-python">In [66]: arr_slice = arr[5:8]

In [67]: arr_slice
Out[67]: array([12, 12, 12])
</code></pre>
<p>现在，当我修稿arr_slice中的值，变动也会体现在原始数组arr中：</p>
<pre><code class="language-python">In [68]: arr_slice[1] = 12345

In [69]: arr
Out[69]: array([    0,     1,     2,     3,     4,    12, 12345,    12,     8,   
  9])
</code></pre>
<p>切片[ : ]会给数组中的所有值赋值：</p>
<pre><code class="language-python">In [70]: arr_slice[:] = 64

In [71]: arr
Out[71]: array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])
</code></pre>
<p>如果你刚开始接触NumPy，可能会对此感到惊讶（尤其是当你曾经用过其他热衷于复制数组数据的编程语言）。由于NumPy的设计目的是处理大数据，所以你可以想象一下，假如NumPy坚持要将数据复制来复制去的话会产生何等的性能和内存问题。</p>
<blockquote>
<p>注意：如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作，例如<code>arr[5:8].copy()</code>。</p>
</blockquote>
<p>对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组：</p>
<pre><code class="language-python">In [72]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

In [73]: arr2d[2]
Out[73]: array([7, 8, 9])
</code></pre>
<p>因此，可以对各个元素进行递归访问，但这样需要做的事情有点多。你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：</p>
<pre><code class="language-python">In [74]: arr2d[0][2]
Out[74]: 3

In [75]: arr2d[0, 2]
Out[75]: 3
</code></pre>
<p>图4-1说明了二维数组的索引方式。轴0作为行，轴1作为列。</p>
<figure data-type="image" tabindex="4"><img src="http://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-1 NumPy数组中的元素索引" loading="lazy"></figure>
<p>在多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）。因此，在2×2×3数组arr3d中：</p>
<pre><code class="language-python">In [76]: arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])

In [77]: arr3d
Out[77]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],
       [[ 7,  8,  9],
        [10, 11, 12]]])
</code></pre>
<p>arr3d[0]是一个2×3数组：</p>
<pre><code class="language-python">In [78]: arr3d[0]
Out[78]: 
array([[1, 2, 3],
       [4, 5, 6]])
</code></pre>
<p>标量值和数组都可以被赋值给arr3d[0]：</p>
<pre><code class="language-python">In [79]: old_values = arr3d[0].copy()

In [80]: arr3d[0] = 42

In [81]: arr3d
Out[81]: 
array([[[42, 42, 42],
        [42, 42, 42]],
       [[ 7,  8,  9],
        [10, 11, 12]]])

In [82]: arr3d[0] = old_values

In [83]: arr3d
Out[83]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],
       [[ 7,  8,  9],
        [10, 11, 12]]])
</code></pre>
<p>相似的，arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）：</p>
<pre><code class="language-python">In [84]: arr3d[1, 0]
Out[84]: array([7, 8, 9])
</code></pre>
<p>虽然是用两步进行索引的，表达式是相同的：</p>
<pre><code class="language-python">In [85]: x = arr3d[1]

In [86]: x
Out[86]: 
array([[ 7,  8,  9],
       [10, 11, 12]])

In [87]: x[0]
Out[87]: array([7, 8, 9])
</code></pre>
<p>注意，在上面所有这些选取数组子集的例子中，返回的数组都是视图。</p>
<h2 id="切片索引">切片索引</h2>
<p>ndarray的切片语法跟Python列表这样的一维对象差不多：</p>
<pre><code class="language-python">In [88]: arr
Out[88]: array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])

In [89]: arr[1:6]
Out[89]: array([ 1,  2,  3,  4, 64])
</code></pre>
<p>对于之前的二维数组arr2d，其切片方式稍显不同：</p>
<pre><code class="language-python">In [90]: arr2d
Out[90]: 
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])

In [91]: arr2d[:2]
Out[91]: 
array([[1, 2, 3],
       [4, 5, 6]])
</code></pre>
<p>可以看出，它是沿着第0轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。表达式arr2d[:2]可以被认为是“选取arr2d的前两行”。</p>
<p>你可以一次传入多个切片，就像传入多个索引那样：</p>
<pre><code class="language-python">In [92]: arr2d[:2, 1:]
Out[92]: 
array([[2, 3],
       [5, 6]])
</code></pre>
<p>像这样进行切片时，只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<p>例如，我可以选取第二行的前两列：</p>
<pre><code class="language-python">In [93]: arr2d[1, :2]
Out[93]: array([4, 5])
</code></pre>
<p>相似的，还可以选择第三列的前两行：</p>
<pre><code class="language-python">In [94]: arr2d[:2, 2]
Out[94]: array([3, 6])
</code></pre>
<p>图4-2对此进行了说明。注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片：</p>
<pre><code class="language-python">In [95]: arr2d[:, :1]
Out[95]: 
array([[1],
       [4],
       [7]])
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-2 二维数组切片" loading="lazy"></figure>
<p>自然，对切片表达式的赋值操作也会被扩散到整个选区：</p>
<pre><code class="language-python">In [96]: arr2d[:2, 1:] = 0

In [97]: arr2d
Out[97]: 
array([[1, 0, 0],
       [4, 0, 0],
       [7, 8, 9]])
</code></pre>
<h2 id="布尔型索引">布尔型索引</h2>
<p>来看这样一个例子，假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）。在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：</p>
<pre><code class="language-python">In [98]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])

In [99]: data = np.random.randn(7, 4)

In [100]: names
Out[100]: 
array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
      dtype='&lt;U4')

In [101]: data
Out[101]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 1.669 , -0.4386, -0.5397,  0.477 ],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre>
<p>假设每个名字都对应data数组中的一行，而我们想要选出对应于名字&quot;Bob&quot;的所有行。跟算术运算一样，数组的比较运算（如==）也是矢量化的。因此，对names和字符串&quot;Bob&quot;的比较运算将会产生一个布尔型数组：</p>
<pre><code class="language-python">In [102]: names == 'Bob'
Out[102]: array([ True, False, False,  True, False, False, False], dtype=bool)
</code></pre>
<p>这个布尔型数组可用于数组索引：</p>
<pre><code class="language-python">In [103]: data[names == 'Bob']
Out[103]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.669 , -0.4386, -0.5397,  0.477 ]])
</code></pre>
<p>布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：</p>
<pre><code class="language-python">In [103]: data[names == 'Bob']
Out[103]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.669 , -0.4386, -0.5397,  0.477 ]])
</code></pre>
<blockquote>
<p>注意：如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心。</p>
</blockquote>
<p>下面的例子，我选取了<code>names == 'Bob'</code>的行，并索引了列：</p>
<pre><code class="language-python">In [104]: data[names == 'Bob', 2:]
Out[104]: 
array([[ 0.769 ,  1.2464],
       [-0.5397,  0.477 ]])

In [105]: data[names == 'Bob', 3]
Out[105]: array([ 1.2464,  0.477 ])
</code></pre>
<p>要选择除&quot;Bob&quot;以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定：</p>
<pre><code class="language-python">In [106]: names != 'Bob'
Out[106]: array([False,  True,  True, False,  True,  True,  True], dtype=bool)

In [107]: data[~(names == 'Bob')]
Out[107]:
array([[ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre>
<p>~操作符用来反转条件很好用：</p>
<pre><code class="language-python">In [108]: cond = names == 'Bob'

In [109]: data[~cond]
Out[109]: 
array([[ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
</code></pre>
<p>选取这三个名字中的两个需要组合应用多个布尔条件，使用&amp;（和）、|（或）之类的布尔算术运算符即可：</p>
<pre><code class="language-python">In [110]: mask = (names == 'Bob') | (names == 'Will')

In [111]: mask
Out[111]: array([ True, False,  True,  True,  True, False, False], dtype=bool)

In [112]: data[mask]
Out[112]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 1.669 , -0.4386, -0.5397,  0.477 ],
       [ 3.2489, -1.0212, -0.5771,  0.1241]])
</code></pre>
<p>通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。</p>
<blockquote>
<p>注意：Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</p>
</blockquote>
<p>通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为0，我们只需：</p>
<pre><code class="language-python">In [113]: data[data &lt; 0] = 0

In [114]: data
Out[114]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.0072,  0.    ,  0.275 ,  0.2289],
       [ 1.3529,  0.8864,  0.    ,  0.    ],
       [ 1.669 ,  0.    ,  0.    ,  0.477 ],
       [ 3.2489,  0.    ,  0.    ,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [ 0.    ,  0.    ,  0.    ,  0.    ]])
</code></pre>
<p>通过一维布尔数组设置整行或列的值也很简单：</p>
<pre><code class="language-python">In [115]: data[names != 'Joe'] = 7

In [116]: data
Out[116]: 
array([[ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 1.0072,  0.    ,  0.275 ,  0.2289],
       [ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 7.    ,  7.    ,  7.    ,  7.    ],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [ 0.    ,  0.    ,  0.    ,  0.    ]])
</code></pre>
<p>后面会看到，这类二维数据的操作也可以用pandas方便的来做。</p>
<h2 id="花式索引">花式索引</h2>
<p>花式索引（Fancy indexing）是一个NumPy术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组：</p>
<pre><code class="language-python">In [117]: arr = np.empty((8, 4))

In [118]: for i in range(8):
   .....:     arr[i] = i

In [119]: arr
Out[119]: 
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])
</code></pre>
<p>为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：</p>
<pre><code class="language-python">In [120]: arr[[4, 3, 0, 6]]
Out[120]: 
array([[ 4.,  4.,  4.,  4.],
       [ 3.,  3.,  3.,  3.],
       [ 0.,  0.,  0.,  0.],
       [ 6.,  6.,  6.,  6.]])
</code></pre>
<p>这段代码确实达到我们的要求了！使用负数索引将会从末尾开始选取行：</p>
<pre><code class="language-python">In [121]: arr[[-3, -5, -7]]
Out[121]: 
array([[ 5.,  5.,  5.,  5.],
       [ 3.,  3.,  3.,  3.],
       [ 1.,  1.,  1.,  1.]])
</code></pre>
<p>一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：</p>
<pre><code class="language-python">In [122]: arr = np.arange(32).reshape((8, 4))

In [123]: arr
Out[123]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

In [124]: arr[[1, 5, 7, 2], [0, 3, 1, 2]]
Out[124]: array([ 4, 23, 29, 10])
</code></pre>
<p>附录A中会详细介绍reshape方法。</p>
<p>最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的。</p>
<p>这个花式索引的行为可能会跟某些用户的预期不一样（包括我在内），选取矩阵的行列子集应该是矩形区域的形式才对。下面是得到该结果的一个办法：</p>
<pre><code class="language-python">In [125]: arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
Out[125]: 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
</code></pre>
<p>记住，花式索引跟切片不一样，它总是将数据复制到新数组中。</p>
<h2 id="数组转置和轴对换">数组转置和轴对换</h2>
<p>转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性：</p>
<pre><code class="language-python">In [126]: arr = np.arange(15).reshape((3, 5))

In [127]: arr
Out[127]: 
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])

In [128]: arr.T
Out[128]: 
array([[ 0,  5, 10],
       [ 1,  6, 11],
       [ 2,  7, 12],
       [ 3,  8, 13],
       [ 4,  9, 14]])
</code></pre>
<p>在进行矩阵计算时，经常需要用到该操作，比如利用np.dot计算矩阵内积：</p>
<pre><code class="language-python">In [129]: arr = np.random.randn(6, 3)

In [130]: arr
Out[130]: 
array([[-0.8608,  0.5601, -1.2659],
       [ 0.1198, -1.0635,  0.3329],
       [-2.3594, -0.1995, -1.542 ],
       [-0.9707, -1.307 ,  0.2863],
       [ 0.378 , -0.7539,  0.3313],
       [ 1.3497,  0.0699,  0.2467]])

In [131]: np.dot(arr.T, arr)
Out[131]:
array([[ 9.2291,  0.9394,  4.948 ],
       [ 0.9394,  3.7662, -1.3622],
       [ 4.948 , -1.3622,  4.3437]])
</code></pre>
<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置（比较费脑子）：</p>
<pre><code class="language-python">In [132]: arr = np.arange(16).reshape((2, 2, 4))

In [133]: arr
Out[133]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],
       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [134]: arr.transpose((1, 0, 2))
Out[134]: 
array([[[ 0,  1,  2,  3],
        [ 8,  9, 10, 11]],
       [[ 4,  5,  6,  7],
        [12, 13, 14, 15]]])
</code></pre>
<p>这里，第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变。</p>
<p>简单的转置可以使用.T，它其实就是进行轴对换而已。ndarray还有一个swapaxes方法，它需要接受一对轴编号：</p>
<pre><code class="language-python">In [135]: arr
Out[135]: 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7]],
       [[ 8,  9, 10, 11],
        [12, 13, 14, 15]]])

In [136]: arr.swapaxes(1, 2)
Out[136]: 
array([[[ 0,  4],
        [ 1,  5],
        [ 2,  6],
        [ 3,  7]],
       [[ 8, 12],
        [ 9, 13],
        [10, 14],
        [11, 15]]])
</code></pre>
<p>swapaxes也是返回源数据的视图（不会进行任何复制操作）。</p>
<h1 id="42-通用函数快速的元素级数组函数">4.2 通用函数：快速的元素级数组函数</h1>
<p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的矢量化包装器。</p>
<p>许多ufunc都是简单的元素级变体，如sqrt和exp：</p>
<pre><code class="language-python">In [137]: arr = np.arange(10)

In [138]: arr
Out[138]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [139]: np.sqrt(arr)
Out[139]: 
array([ 0.    ,  1.    ,  1.4142,  1.7321,  2.    ,  2.2361,  2.4495,
        2.6458,  2.8284,  3.    ])

In [140]: np.exp(arr)
Out[140]: 
array([    1.    ,     2.7183,     7.3891,    20.0855,    54.5982,
         148.4132,   403.4288,  1096.6332,  2980.958 ,  8103.0839])
</code></pre>
<p>这些都是一元（unary）ufunc。另外一些（如add或maximum）接受2个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：</p>
<pre><code class="language-python">In [141]: x = np.random.randn(8)

In [142]: y = np.random.randn(8)

In [143]: x
Out[143]: 
array([-0.0119,  1.0048,  1.3272, -0.9193, -1.5491,  0.0222,  0.7584,
       -0.6605])

In [144]: y
Out[144]: 
array([ 0.8626, -0.01  ,  0.05  ,  0.6702,  0.853 , -0.9559, -0.0235,
       -2.3042])

In [145]: np.maximum(x, y)
Out[145]: 
array([ 0.8626,  1.0048,  1.3272,  0.6702,  0.853 ,  0.0222,  0.7584,   
       -0.6605])
</code></pre>
<p>这里，numpy.maximum计算了x和y中元素级别最大的元素。</p>
<p>虽然并不常见，但有些ufunc的确可以返回多个数组。modf就是一个例子，它是Python内置函数divmod的矢量化版本，它会返回浮点数数组的小数和整数部分：</p>
<pre><code class="language-python">In [146]: arr = np.random.randn(7) * 5

In [147]: arr
Out[147]: array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])

In [148]: remainder, whole_part = np.modf(arr)

In [149]: remainder
Out[149]: array([-0.2623, -0.0915, -0.663 ,  0.3731,
0.6182,  0.45  ,  0.0077])

In [150]: whole_part
Out[150]: array([-3., -6., -6.,  5.,  3.,  3.,  5.])
</code></pre>
<p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：</p>
<pre><code class="language-python">In [151]: arr
Out[151]: array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])

In [152]: np.sqrt(arr)
Out[152]: array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])

In [153]: np.sqrt(arr, arr)
Out[153]: array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])

In [154]: arr
Out[154]: array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])
</code></pre>
<p>表4-3和表4-4分别列出了一些一元和二元ufunc。</p>
<figure data-type="image" tabindex="6"><img src="http://upload-images.jianshu.io/upload_images/7178691-1d494e73b61c7ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="http://upload-images.jianshu.io/upload_images/7178691-2be79faf68ab6ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="http://upload-images.jianshu.io/upload_images/7178691-4e38d02a66481530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="http://upload-images.jianshu.io/upload_images/7178691-eff1e61e5464159f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="http://upload-images.jianshu.io/upload_images/7178691-236dba83b6a420cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="43-利用数组进行数据处理">4.3 利用数组进行数据处理</h1>
<p>NumPy数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为矢量化。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多），尤其是各种数值计算。在后面内容中（见附录A）我将介绍广播，这是一种针对矢量化计算的强大手段。</p>
<p>作为简单的例子，假设我们想要在一组值（网格型）上计算函数<code>sqrt(x^2+y^2)</code>。np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）：</p>
<pre><code class="language-python">In [155]: points = np.arange(-5, 5, 0.01) # 1000 equally spaced points

In [156]: xs, ys = np.meshgrid(points, points)
In [157]: ys
Out[157]: 
array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ..., 
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])
</code></pre>
<p>现在，对该函数的求值运算就好办了，把这两个数组当做两个浮点数那样编写表达式即可：</p>
<pre><code class="language-python">In [158]: z = np.sqrt(xs ** 2 + ys ** 2)

In [159]: z
Out[159]: 
array([[ 7.0711,  7.064 ,  7.0569, ...,  7.0499,  7.0569,  7.064 ],
       [ 7.064 ,  7.0569,  7.0499, ...,  7.0428,  7.0499,  7.0569],
       [ 7.0569,  7.0499,  7.0428, ...,  7.0357,  7.0428, 7.0499],
       ..., 
       [ 7.0499,  7.0428,  7.0357, ...,  7.0286,  7.0357,  7.0428],
       [ 7.0569,  7.0499,  7.0428, ...,  7.0357,  7.0428,  7.0499],
       [ 7.064 ,  7.0569,  7.0499, ...,  7.0428,  7.0499,  7.0569]])
</code></pre>
<p>作为第9章的先导，我用matplotlib创建了这个二维数组的可视化：</p>
<pre><code class="language-python">In [160]: import matplotlib.pyplot as plt

In [161]: plt.imshow(z, cmap=plt.cm.gray); plt.colorbar()
Out[161]: &lt;matplotlib.colorbar.Colorbar at 0x7f715e3fa630&gt;

In [162]: plt.title(&quot;Image plot of $\sqrt{x^2 + y^2}$ for a grid of values&quot;)
Out[162]: &lt;matplotlib.text.Text at 0x7f715d2de748&gt;
</code></pre>
<p>见图4-3。这张图是用matplotlib的imshow函数创建的。</p>
<figure data-type="image" tabindex="11"><img src="http://upload-images.jianshu.io/upload_images/7178691-3b22000d4cd38650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-3 根据网格对函数求值的结果" loading="lazy"></figure>
<h2 id="将条件逻辑表述为数组运算">将条件逻辑表述为数组运算</h2>
<p>numpy.where函数是三元表达式x if condition else y的矢量化版本。假设我们有一个布尔数组和两个值数组：</p>
<pre><code class="language-python">In [165]: xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])

In [166]: yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])

In [167]: cond = np.array([True, False, True, True, False])
</code></pre>
<p>假设我们想要根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示：</p>
<pre><code class="language-python">In [168]: result = [(x if c else y)
   .....:           for x, y, c in zip(xarr, yarr, cond)]

In [169]: result
Out[169]: [1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]
</code></pre>
<p>这有几个问题。第一，它对大数组的处理速度不是很快（因为所有工作都是由纯Python完成的）。第二，无法用于多维数组。若使用np.where，则可以将该功能写得非常简洁：</p>
<pre><code class="language-python">In [170]: result = np.where(cond, xarr, yarr)

In [171]: result
Out[171]: array([ 1.1,  2.2,  1.3,  1.4,  2.5])
</code></pre>
<p>np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组。假设有一个由随机数据组成的矩阵，你希望将所有正值替换为2，将所有负值替换为－2。若利用np.where，则会非常简单：</p>
<pre><code class="language-python">In [172]: arr = np.random.randn(4, 4)

In [173]: arr
Out[173]: 
array([[-0.5031, -0.6223, -0.9212, -0.7262],
       [ 0.2229,  0.0513, -1.1577,  0.8167],
       [ 0.4336,  1.0107,  1.8249, -0.9975],
       [ 0.8506, -0.1316,  0.9124,  0.1882]])

In [174]: arr &gt; 0
Out[174]: 
array([[False, False, False, False],
       [ True,  True, False,  True],
       [ True,  True,  True, False],
       [ True, False,  True,  True]], dtype=bool)

In [175]: np.where(arr &gt; 0, 2, -2)
Out[175]: 
array([[-2, -2, -2, -2],
       [ 2,  2, -2,  2],
       [ 2,  2,  2, -2],
       [ 2, -2,  2,  2]])
</code></pre>
<p>使用np.where，可以将标量和数组结合起来。例如，我可用常数2替换arr中所有正的值：</p>
<pre><code class="language-python">In [176]: np.where(arr &gt; 0, 2, arr) # set only positive values to 2
Out[176]: 
array([[-0.5031, -0.6223, -0.9212, -0.7262],
       [ 2.    ,  2.    , -1.1577,  2.    ],
       [ 2.    ,  2.    ,  2.    , -0.9975],
       [ 2.    , -0.1316,  2.    ,  2.    ]])
</code></pre>
<p>传递给where的数组大小可以不相等，甚至可以是标量值。</p>
<h2 id="数学和统计方法">数学和统计方法</h2>
<p>可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<p>这里，我生成了一些正态分布随机数据，然后做了聚类统计：</p>
<pre><code class="language-python">In [177]: arr = np.random.randn(5, 4)

In [178]: arr
Out[178]: 
array([[ 2.1695, -0.1149,  2.0037,  0.0296],
       [ 0.7953,  0.1181, -0.7485,  0.585 ],
       [ 0.1527, -1.5657, -0.5625, -0.0327],
       [-0.929 , -0.4826, -0.0363,  1.0954],
       [ 0.9809, -0.5895,  1.5817, -0.5287]])

In [179]: arr.mean()
Out[179]: 0.19607051119998253

In [180]: np.mean(arr)
Out[180]: 0.19607051119998253

In [181]: arr.sum()
Out[181]: 3.9214102239996507
</code></pre>
<p>mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组：</p>
<pre><code class="language-python">In [182]: arr.mean(axis=1)
Out[182]: array([ 1.022 ,  0.1875, -0.502 , -0.0881,  0.3611])

In [183]: arr.sum(axis=0)
Out[183]: array([ 3.1693, -2.6345,  2.2381,  1.1486])
</code></pre>
<p>这里，arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。</p>
<p>其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组：</p>
<pre><code class="language-python">In [184]: arr = np.array([0, 1, 2, 3, 4, 5, 6, 7])

In [185]: arr.cumsum()
Out[185]: array([ 0,  1,  3,  6, 10, 15, 21, 28])
</code></pre>
<p>在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：</p>
<pre><code class="language-python">In [186]: arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])

In [187]: arr
Out[187]: 
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

In [188]: arr.cumsum(axis=0)
Out[188]: 
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

In [189]: arr.cumprod(axis=1)
Out[189]: 
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
</code></pre>
<p>表4-5列出了全部的基本数组统计方法。后续章节中有很多例子都会用到这些方法。</p>
<figure data-type="image" tabindex="12"><img src="http://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="http://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h2 id="用于布尔型数组的方法">用于布尔型数组的方法</h2>
<p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）。因此，sum经常被用来对布尔型数组中的True值计数：</p>
<pre><code class="language-python">In [190]: arr = np.random.randn(100)

In [191]: (arr &gt; 0).sum() # Number of positive values
Out[191]: 42
</code></pre>
<p>另外还有两个方法any和all，它们对布尔型数组非常有用。any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True：</p>
<pre><code class="language-python">In [192]: bools = np.array([False, False, True, False])

In [193]: bools.any()
Out[193]: True

In [194]: bools.all()
Out[194]: False
</code></pre>
<p>这两个方法也能用于非布尔型数组，所有非0元素将会被当做True。</p>
<h2 id="排序">排序</h2>
<p>跟Python内置的列表类型一样，NumPy数组也可以通过sort方法就地排序：</p>
<pre><code class="language-python">In [195]: arr = np.random.randn(6)

In [196]: arr
Out[196]: array([ 0.6095, -0.4938,  1.24  , -0.1357,  1.43  , -0.8469])

In [197]: arr.sort()

In [198]: arr
Out[198]: array([-0.8469, -0.4938, -0.1357,  0.6095,  1.24  ,  1.43  ])
</code></pre>
<p>多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可：</p>
<pre><code class="language-python">In [199]: arr = np.random.randn(5, 3)

In [200]: arr
Out[200]: 
array([[ 0.6033,  1.2636, -0.2555],
       [-0.4457,  0.4684, -0.9616],
       [-1.8245,  0.6254,  1.0229],
       [ 1.1074,  0.0909, -0.3501],
       [ 0.218 , -0.8948, -1.7415]])

In [201]: arr.sort(1)

In [202]: arr
Out[202]: 
array([[-0.2555,  0.6033,  1.2636],
       [-0.9616, -0.4457,  0.4684],
       [-1.8245,  0.6254,  1.0229],
       [-0.3501,  0.0909,  1.1074],
       [-1.7415, -0.8948,  0.218 ]])
</code></pre>
<p>顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值：</p>
<pre><code class="language-python">In [203]: large_arr = np.random.randn(1000)

In [204]: large_arr.sort()

In [205]: large_arr[int(0.05 * len(large_arr))] # 5% quantile
Out[205]: -1.5311513550102103
</code></pre>
<p>更多关于NumPy排序方法以及诸如间接排序之类的高级技术，请参阅附录A。在pandas中还可以找到一些其他跟排序有关的数据操作（比如根据一列或多列对表格型数据进行排序）。</p>
<h2 id="唯一化以及其它的集合逻辑">唯一化以及其它的集合逻辑</h2>
<p>NumPy提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果：</p>
<pre><code class="language-python">numpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)
#返回：
unique_indices:return_index=True时，原始数组中唯一值首次出现的索引。
unique_inverse:return_inverse=True时，从唯一数组重建原始数组的索引。
unique_counts:return_counts=True时，每个唯一值在原始数组中出现的次数。

</code></pre>
<pre><code class="language-python">In [206]: names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])

In [207]: np.unique(names)
Out[207]: 
array(['Bob', 'Joe', 'Will'],
      dtype='&lt;U4')

In [208]: ints = np.array([3, 3, 3, 2, 2, 1, 1, 4, 4])

In [209]: np.unique(ints)
Out[209]: array([1, 2, 3, 4])
</code></pre>
<p>拿跟np.unique等价的纯Python代码来对比一下：</p>
<pre><code class="language-python">In [210]: sorted(set(names))
Out[210]: ['Bob', 'Joe', 'Will']
</code></pre>
<p>另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组：</p>
<pre><code class="language-python">In [211]: values = np.array([6, 0, 0, 3, 2, 5, 6])

In [212]: np.in1d(values, [2, 3, 6])
Out[212]: array([ True, False, False,  True,  True, False,  True], dtype=bool)
</code></pre>
<p>NumPy中的集合函数请参见表4-6。<br>
<img src="http://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></p>
<h1 id="44-用于数组的文件输入输出">4.4 用于数组的文件输入输出</h1>
<p>NumPy能够读写磁盘上的文本数据或二进制数据。这一小节只讨论NumPy的内置二进制格式，因为更多的用户会使用pandas或其它工具加载文本或表格数据（见第6章）。</p>
<p>np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的：</p>
<pre><code class="language-python">In [213]: arr = np.arange(10)

In [214]: np.save('some_array', arr)
</code></pre>
<p>如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组：</p>
<pre><code class="language-python">In [215]: np.load('some_array.npy')
Out[215]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre>
<p>通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可：</p>
<pre><code class="language-python">In [216]: np.savez('array_archive.npz', a=arr, b=arr)
</code></pre>
<p>加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载：</p>
<pre><code class="language-python">In [217]: arch = np.load('array_archive.npz')

In [218]: arch['b']
Out[218]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</code></pre>
<p>如果要将数据压缩，可以使用numpy.savez_compressed：</p>
<pre><code class="language-python">In [219]: np.savez_compressed('arrays_compressed.npz', a=arr, b=arr)
</code></pre>
<h1 id="45-线性代数">4.5 线性代数</h1>
<p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。不像某些语言（如MATLAB），通过*对两个二维数组相乘得到的是一个元素级的积，而不是一个矩阵点积。因此，NumPy提供了一个用于矩阵乘法的dot函数（既是一个数组方法也是numpy命名空间中的一个函数）：</p>
<pre><code class="language-python">In [223]: x = np.array([[1., 2., 3.], [4., 5., 6.]])

In [224]: y = np.array([[6., 23.], [-1, 7], [8, 9]])

In [225]: x
Out[225]: 
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])

In [226]: y
Out[226]: 
array([[  6.,  23.],
       [ -1.,   7.],
       [  8.,   9.]])

In [227]: x.dot(y)
Out[227]: 
array([[  28.,   64.],
       [  67.,  181.]])
</code></pre>
<p>x.dot(y)等价于np.dot(x, y)：</p>
<pre><code class="language-python">In [228]: np.dot(x, y)
Out[228]: 
array([[  28.,   64.],
       [  67.,  181.]])
</code></pre>
<p>一个二维数组跟一个大小合适的一维数组的矩阵点积运算之后将会得到一个一维数组：</p>
<pre><code class="language-python">In [229]: np.dot(x, np.ones(3))
Out[229]: array([  6.,  15.])
</code></pre>
<p>@符（类似Python 3.5）也可以用作中缀运算符，进行矩阵乘法：</p>
<pre><code class="language-python">In [230]: x @ np.ones(3)
Out[230]: array([  6.,  15.])
</code></pre>
<p>numpy.linalg中有一组标准的矩阵分解运算以及诸如求逆和行列式之类的东西。它们跟MATLAB和R等语言所使用的是相同的行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于你的NumPy版本）等：</p>
<pre><code class="language-python">In [231]: from numpy.linalg import inv, qr

In [232]: X = np.random.randn(5, 5)

In [233]: mat = X.T.dot(X)

In [234]: inv(mat)
Out[234]: 
array([[  933.1189,   871.8258, -1417.6902, -1460.4005,  1782.1391],
       [  871.8258,   815.3929, -1325.9965, -1365.9242,  1666.9347],
       [-1417.6902, -1325.9965,  2158.4424,  2222.0191, -2711.6822],
       [-1460.4005, -1365.9242,  2222.0191,  2289.0575, -2793.422 ],
       [ 1782.1391,  1666.9347, -2711.6822, -2793.422 ,  3409.5128]])

In [235]: mat.dot(inv(mat))
Out[235]: 
array([[ 1.,  0., -0., -0., -0.],
       [-0.,  1.,  0.,  0.,  0.],
       [ 0.,  0.,  1.,  0.,  0.],
       [-0.,  0.,  0.,  1., -0.],
       [-0.,  0.,  0.,  0.,  1.]])

In [236]: q, r = qr(mat)

In [237]: r
Out[237]: 
array([[-1.6914,  4.38  ,  0.1757,  0.4075, -0.7838],
       [ 0.    , -2.6436,  0.1939, -3.072 , -1.0702],
       [ 0.    ,  0.    , -0.8138,  1.5414,  0.6155],
       [ 0.    ,  0.    ,  0.    , -2.6445, -2.1669],
       [ 0.    ,  0.    ,  0.    ,  0.    ,  0.0002]])
</code></pre>
<p>表达式X.T.dot(X)计算X和它的转置X.T的点积。</p>
<p>表4-7中列出了一些最常用的线性代数函数。</p>
<figure data-type="image" tabindex="14"><img src="http://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="46-伪随机数生成">4.6 伪随机数生成</h1>
<p>numpy.random模块对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。例如，你可以用normal来得到一个标准正态分布的4×4样本数组：</p>
<pre><code class="language-python">In [238]: samples = np.random.normal(size=(4, 4))

In [239]: samples
Out[239]: 
array([[ 0.5732,  0.1933,  0.4429,  1.2796],
       [ 0.575 ,  0.4339, -0.7658, -1.237 ],
       [-0.5367,  1.8545, -0.92  , -0.1082],
       [ 0.1525,  0.9435, -1.0953, -0.144 ]])
</code></pre>
<p>而Python内置的random模块则只能一次生成一个样本值。从下面的测试结果中可以看出，如果需要产生大量样本值，numpy.random快了不止一个数量级：</p>
<pre><code class="language-python">In [240]: from random import normalvariate

In [241]: N = 1000000

In [242]: %timeit samples = [normalvariate(0, 1) for _ in range(N)]
1.77 s +- 126 ms per loop (mean +- std. dev. of 7 runs, 1 loop each)

In [243]: %timeit np.random.normal(size=N)
61.7 ms +- 1.32 ms per loop (mean +- std. dev. of 7 runs, 10 loops each)
</code></pre>
<p>我们说这些都是伪随机数，是因为它们都是通过算法基于随机数生成器种子，在确定性的条件下生成的。你可以用NumPy的np.random.seed更改随机数生成种子：</p>
<pre><code class="language-python">In [244]: np.random.seed(1234)
</code></pre>
<p>numpy.random的数据生成函数使用了全局的随机种子。要避免全局状态，你可以使用numpy.random.RandomState，创建一个与其它隔离的随机数生成器：</p>
<pre><code class="language-python">In [245]: rng = np.random.RandomState(1234)

In [246]: rng.randn(10)
Out[246]: 
array([ 0.4714, -1.191 ,  1.4327, -0.3127, -0.7206,  0.8872,  0.8596,
       -0.6365,  0.0157, -2.2427])
</code></pre>
<p>表4-8列出了numpy.random中的部分函数。在下一节中，我将给出一些利用这些函数一次性生成大量样本值的范例。</p>
<figure data-type="image" tabindex="15"><img src="http://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="http://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<h1 id="47-示例随机漫步">4.7 示例：随机漫步</h1>
<p>我们通过模拟随机漫步来说明如何运用数组运算。先来看一个简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<p>下面是一个通过内置的random模块以纯Python的方式实现1000步的随机漫步：</p>
<pre><code class="language-python">In [247]: import random
   .....: position = 0
   .....: walk = [position]
   .....: steps = 1000
   .....: for i in range(steps):
   .....:     step = 1 if random.randint(0, 1) else -1
   .....:     position += step
   .....:     walk.append(position)
   .....:
</code></pre>
<p>图4-4是根据前100个随机漫步值生成的折线图：</p>
<pre><code class="language-python">In [249]: plt.plot(walk[:100])
</code></pre>
<figure data-type="image" tabindex="17"><img src="http://upload-images.jianshu.io/upload_images/7178691-0833621694f6dda0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4-4 简单的随机漫步" loading="lazy"></figure>
<p>不难看出，这其实就是随机漫步中各步的累计和，可以用一个数组运算来实现。因此，我用np.random模块一次性随机产生1000个“掷硬币”结果（即两个数中任选一个），将其分别设置为1或－1，然后计算累计和：</p>
<pre><code class="language-python">In [251]: nsteps = 1000

In [252]: draws = np.random.randint(0, 2, size=nsteps)

In [253]: steps = np.where(draws &gt; 0, 1, -1)

In [254]: walk = steps.cumsum()
</code></pre>
<p>有了这些数据之后，我们就可以沿着漫步路径做一些统计工作了，比如求取最大值和最小值：</p>
<pre><code class="language-python">In [255]: walk.min()
Out[255]: -3

In [256]: walk.max()
Out[256]: 31
</code></pre>
<p>现在来看一个复杂点的统计任务——首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设我们想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：</p>
<pre><code class="language-python">In [257]: (np.abs(walk) &gt;= 10).argmax()
Out[257]: 37
</code></pre>
<p>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</p>
<h2 id="一次模拟多个随机漫步">一次模拟多个随机漫步</h2>
<p>如果你希望模拟多个随机漫步过程（比如5000个），只需对上面的代码做一点点修改即可生成所有的随机漫步过程。只要给numpy.random的函数传入一个二元元组就可以产生一个二维数组，然后我们就可以一次性计算5000个随机漫步过程（一行一个）的累计和了：</p>
<pre><code class="language-python">In [258]: nwalks = 5000

In [259]: nsteps = 1000

In [260]: draws = np.random.randint(0, 2, size=(nwalks, nsteps)) # 0 or 1

In [261]: steps = np.where(draws &gt; 0, 1, -1)

In [262]: walks = steps.cumsum(1)

In [263]: walks
Out[263]: 
array([[  1,   0,   1, ...,   8,   7,   8],
       [  1,   0,  -1, ...,  34,  33,  32],
       [  1,   0,  -1, ...,   4,   5,   4],
       ..., 
       [  1,   2,   1, ...,  24,  25,  26],
       [  1,   2,   3, ...,  14,  13,  14],
       [ -1,  -2,  -3, ..., -24, -23, -22]])
</code></pre>
<p>现在，我们来计算所有随机漫步过程的最大值和最小值：</p>
<pre><code class="language-python">In [264]: walks.max()
Out[264]: 138

In [265]: walks.min()
Out[265]: -133
</code></pre>
<p>得到这些数据之后，我们来计算30或－30的最小穿越时间。这里稍微复杂些，因为不是5000个过程都到达了30。我们可以用any方法来对此进行检查：</p>
<pre><code class="language-python">In [266]: hits30 = (np.abs(walks) &gt;= 30).any(1)

In [267]: hits30
Out[267]: array([False,  True, False, ..., False,  True, False], dtype=bool)

In [268]: hits30.sum() # Number that hit 30 or -30
Out[268]: 3410
</code></pre>
<p>然后我们利用这个布尔型数组选出那些穿越了30（绝对值）的随机漫步（行），并调用argmax在轴1上获取穿越时间：</p>
<pre><code class="language-python">In [269]: crossing_times = (np.abs(walks[hits30]) &gt;= 30).argmax(1)

In [270]: crossing_times.mean()
Out[270]: 498.88973607038122
</code></pre>
<p>请尝试用其他分布方式得到漫步数据。只需使用不同的随机数生成函数即可，如normal用于生成指定均值和标准差的正态分布数据：</p>
<pre><code class="language-python">In [271]: steps = np.random.normal(loc=0, scale=0.25,
   .....:                          size=(nwalks, nsteps))
</code></pre>
<h1 id="48-结论">4.8 结论</h1>
<p>虽然本书剩下的章节大部分是用pandas规整数据，我们还是会用到相似的基于数组的计算。在附录A中，我们会深入挖掘NumPy的特点，进一步学习数组的技巧。</p>
<h1 id="49-numpy高级应用">4.9 Numpy高级应用</h1>
<p>在这篇附录中，我会深入NumPy库的数组计算。这会包括ndarray更内部的细节，和更高级的数组操作和算法。</p>
<p>本章包括了一些杂乱的章节，不需要仔细研究。</p>
<h1 id="a1-ndarray对象的内部机理">A.1 ndarray对象的内部机理</h1>
<p>NumPy的ndarray提供了一种将同质数据块（可以是连续或跨越）解释为多维数组对象的方式。正如你之前所看到的那样，数据类型（dtype）决定了数据的解释方式，比如浮点数、整数、布尔值等。</p>
<p>ndarray如此强大的部分原因是所有数组对象都是数据块的一个跨度视图（strided view）。你可能想知道数组视图arr[::2,::-1]不复制任何数据的原因是什么。简单地说，ndarray不只是一块内存和一个dtype，它还有跨度信息，这使得数组能以各种步幅（step size）在内存中移动。更准确地讲，ndarray内部由以下内容组成：</p>
<ul>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（shape）的元组。</li>
<li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。</li>
</ul>
<p>图A-1简单地说明了ndarray的内部结构。</p>
<figure data-type="image" tabindex="18"><img src="https://upload-images.jianshu.io/upload_images/7178691-43452f2f413e5094.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-1 Numpy的ndarray对象" loading="lazy"></figure>
<p>例如，一个10×5的数组，其形状为(10,5)：</p>
<pre><code class="language-python">In [10]: np.ones((10, 5)).shape
Out[10]: (10, 5)
</code></pre>
<p>一个典型的（C顺序，稍后将详细讲解）3×4×5的float64（8个字节）数组，其跨度为(160,40,8) —— 知道跨度是非常有用的，通常，跨度在一个轴上越大，沿这个轴进行计算的开销就越大：</p>
<pre><code class="language-python">In [11]: np.ones((3, 4, 5), dtype=np.float64).strides
Out[11]: (160, 40, 8)
</code></pre>
<p>虽然NumPy用户很少会对数组的跨度信息感兴趣，但它们却是构建非复制式数组视图的重要因素。跨度甚至可以是负数，这样会使数组在内存中后向移动，比如在切片obj[::-1]或obj[:,::-1]中就是这样的。</p>
<h2 id="numpy数据类型体系">NumPy数据类型体系</h2>
<p>你可能偶尔需要检查数组中所包含的是否是整数、浮点数、字符串或Python对象。因为浮点数的种类很多（从float16到float128），判断dtype是否属于某个大类的工作非常繁琐。幸运的是，dtype都有一个超类（比如np.integer和np.floating），它们可以跟np.issubdtype函数结合使用：</p>
<pre><code class="language-python">In [12]: ints = np.ones(10, dtype=np.uint16)

In [13]: floats = np.ones(10, dtype=np.float32)

In [14]: np.issubdtype(ints.dtype, np.integer)
Out[14]: True

In [15]: np.issubdtype(floats.dtype, np.floating)
Out[15]: True
</code></pre>
<p>调用dtype的mro方法即可查看其所有的父类：</p>
<pre><code class="language-python">In [16]: np.float64.mro()
Out[16]:
[numpy.float64,
 numpy.floating,
 numpy.inexact,
 numpy.number,
 numpy.generic,
 float,
 object]
</code></pre>
<p>然后得到：</p>
<pre><code class="language-python">In [17]: np.issubdtype(ints.dtype, np.number)
Out[17]: True
</code></pre>
<p>大部分NumPy用户完全不需要了解这些知识，但是这些知识偶尔还是能派上用场的。图A-2说明了dtype体系以及父子类关系。</p>
<figure data-type="image" tabindex="19"><img src="http://upload-images.jianshu.io/upload_images/7178691-b8996bf943a06ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-2 NumPy的dtype体系" loading="lazy"></figure>
<h1 id="a2-高级数组操作">A.2 高级数组操作</h1>
<p>除花式索引、切片、布尔条件取子集等操作之外，数组的操作方式还有很多。虽然pandas中的高级函数可以处理数据分析工作中的许多重型任务，但有时你还是需要编写一些在现有库中找不到的数据算法。</p>
<h2 id="数组重塑">数组重塑</h2>
<p>多数情况下，你可以无需复制任何数据，就将数组从一个形状转换为另一个形状。只需向数组的实例方法reshape传入一个表示新形状的元组即可实现该目的。例如，假设有一个一维数组，我们希望将其重新排列为一个矩阵（结果见图A-3）：</p>
<pre><code class="language-python">In [18]: arr = np.arange(8)

In [19]: arr
Out[19]: array([0, 1, 2, 3, 4, 5, 6, 7])

In [20]: arr.reshape((4, 2))
Out[20]: 
array([[0, 1],
       [2, 3],
       [4, 5],
       [6, 7]])
</code></pre>
<figure data-type="image" tabindex="20"><img src="http://upload-images.jianshu.io/upload_images/7178691-95bbca6d8d04e4c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-3 按C顺序（按行）和按Fortran顺序（按列）进行重塑" loading="lazy"></figure>
<p>多维数组也能被重塑：</p>
<pre><code class="language-python">In [21]: arr.reshape((4, 2)).reshape((2, 4))
Out[21]: 
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
</code></pre>
<p>作为参数的形状的其中一维可以是－1，它表示该维度的大小由数据本身推断而来：</p>
<pre><code class="language-python">In [22]: arr = np.arange(15)

In [23]: arr.reshape((5, -1))
Out[23]: 
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])
</code></pre>
<p>与reshape将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化（flattening）或散开（raveling）：</p>
<pre><code class="language-python">In [27]: arr = np.arange(15).reshape((5, 3))

In [28]: arr
Out[28]: 
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11],
       [12, 13, 14]])

In [29]: arr.ravel()
Out[29]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>
<p>如果结果中的值与原始数组相同，ravel不会产生源数据的副本。flatten方法的行为类似于ravel，只不过它总是返回数据的副本：</p>
<pre><code class="language-python">In [30]: arr.flatten()
Out[30]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])
</code></pre>
<p>数组可以被重塑或散开为别的顺序。这对NumPy新手来说是一个比较微妙的问题，所以在下一小节中我们将专门讲解这个问题。</p>
<h2 id="c和fortran顺序">C和Fortran顺序</h2>
<p>NumPy允许你更为灵活地控制数据在内存中的布局。默认情况下，NumPy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。另一种顺序是列优先顺序，它意味着每列中的数据项是被存放在相邻内存位置上的。</p>
<p>由于一些历史原因，行和列优先顺序又分别称为C和Fortran顺序。在FORTRAN 77中，矩阵全都是列优先的。</p>
<p>像reshape和reval这样的函数，都可以接受一个表示数组数据存放顺序的order参数。一般可以是'C'或'F'（还有'A'和'K'等不常用的选项，具体请参考NumPy的文档）。图A-3对此进行了说明：</p>
<pre><code class="language-python">In [31]: arr = np.arange(12).reshape((3, 4))

In [32]: arr
Out[32]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])

In [33]: arr.ravel()
Out[33]: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])

In [34]: arr.ravel('F')
Out[34]: array([ 0,  4,  8,  1,  5,  9,  2,  6, 10,  3,  7, 11])
</code></pre>
<figure data-type="image" tabindex="21"><img src="http://upload-images.jianshu.io/upload_images/7178691-f486e7c41d7e0eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-3 按C（行优先）或Fortran（列优先）顺序进行重塑" loading="lazy"></figure>
<p>二维或更高维数组的重塑过程比较令人费解（见图A-3）。C和Fortran顺序的关键区别就是维度的行进顺序：</p>
<ul>
<li>C/行优先顺序：先经过更高的维度（例如，轴1会先于轴0被处理）。</li>
<li>Fortran/列优先顺序：后经过更高的维度（例如，轴0会先于轴1被处理）。</li>
</ul>
<h2 id="数组的合并和拆分">数组的合并和拆分</h2>
<p>numpy.concatenate可以按指定轴将一个由数组组成的序列（如元组、列表等）连接到一起：</p>
<pre><code class="language-python">In [35]: arr1 = np.array([[1, 2, 3], [4, 5, 6]])

In [36]: arr2 = np.array([[7, 8, 9], [10, 11, 12]])

In [37]: np.concatenate([arr1, arr2], axis=0)
Out[37]: 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])

In [38]: np.concatenate([arr1, arr2], axis=1)
Out[38]: 
array([[ 1,  2,  3,  7,  8,  9],
       [ 4,  5,  6, 10, 11, 12]])
</code></pre>
<p>对于常见的连接操作，NumPy提供了一些比较方便的方法（如vstack和hstack）。因此，上面的运算还可以表达为：</p>
<pre><code class="language-python">In [39]: np.vstack((arr1, arr2))
Out[39]: 
array([[ 1,  2,  3],
       [ 4,  5,  6],
       [ 7,  8,  9],
       [10, 11, 12]])

In [40]: np.hstack((arr1, arr2))
Out[40]: 
array([[ 1,  2,  3,  7,  8,  9],
[ 4,  5,  6, 10, 11, 12]])
</code></pre>
<p>与此相反，split用于将一个数组沿指定轴拆分为多个数组：</p>
<pre><code class="language-python">In [41]: arr = np.random.randn(5, 2)

In [42]: arr
Out[42]: 
array([[-0.2047,  0.4789],
       [-0.5194, -0.5557],
       [ 1.9658,  1.3934],
       [ 0.0929,  0.2817],
       [ 0.769 ,  1.2464]])

In [43]: first, second, third = np.split(arr, [1, 3])

In [44]: first
Out[44]: array([[-0.2047,  0.4789]])

In [45]: second
Out[45]: 
array([[-0.5194, -0.5557],
       [ 1.9658,  1.3934]])
In [46]: third
Out[46]: 
array([[ 0.0929,  0.2817],
       [ 0.769 ,  1.2464]])
</code></pre>
<p>传入到np.split的值[1,3]指示在哪个索引处分割数组。</p>
<p>表A-1中列出了所有关于数组连接和拆分的函数，其中有些是专门为了方便常见的连接运算而提供的。</p>
<figure data-type="image" tabindex="22"><img src="http://upload-images.jianshu.io/upload_images/7178691-c597246722a6bb01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A-1 数组连接函数" loading="lazy"></figure>
<h2 id="堆叠辅助类r_和c_">堆叠辅助类：r_和c_</h2>
<p>NumPy命名空间中有两个特殊的对象——r_和c_，它们可以使数组的堆叠操作更为简洁：</p>
<pre><code class="language-python">In [47]: arr = np.arange(6)

In [48]: arr1 = arr.reshape((3, 2))

In [49]: arr2 = np.random.randn(3, 2)

In [50]: np.r_[arr1, arr2]
Out[50]: 
array([[ 0.    ,  1.    ],
       [ 2.    ,  3.    ],
       [ 4.    ,  5.    ],
       [ 1.0072, -1.2962],
       [ 0.275 ,  0.2289],
       [ 1.3529,  0.8864]])

In [51]: np.c_[np.r_[arr1, arr2], arr]
Out[51]: 
array([[ 0.    ,  1.    ,  0.    ],
       [ 2.    ,  3.    ,  1.    ],
       [ 4.    ,  5.    ,  2.    ],
       [ 1.0072, -1.2962,  3.    ],
       [ 0.275 ,  0.2289,  4.    ],
       [ 1.3529,  0.8864,  5.    ]])
</code></pre>
<p>它还可以将切片转换成数组：</p>
<pre><code class="language-python">In [52]: np.c_[1:6, -10:-5]
Out[52]: 
array([[  1, -10],
       [  2,  -9],
       [  3,  -8],
       [  4,  -7],
       [  5,  -6]])
</code></pre>
<p>r_和c_的具体功能请参考其文档。</p>
<h2 id="元素的重复操作tile和repeat">元素的重复操作：tile和repeat</h2>
<p>对数组进行重复以产生更大数组的工具主要是repeat和tile这两个函数。repeat会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p>
<pre><code class="language-python">In [53]: arr = np.arange(3)

In [54]: arr
Out[54]: array([0, 1, 2])

In [55]: arr.repeat(3)
Out[55]: array([0, 0, 0, 1, 1, 1, 2, 2, 2])
</code></pre>
<blockquote>
<p>笔记：跟其他流行的数组编程语言（如MATLAB）不同，NumPy中很少需要对数组进行重复（replicate）。这主要是因为广播（broadcasting，我们将在下一节中讲解该技术）能更好地满足该需求。</p>
</blockquote>
<p>默认情况下，如果传入的是一个整数，则各元素就都会重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数：</p>
<pre><code class="language-python">In [56]: arr.repeat([2, 3, 4])
Out[56]: array([0, 0, 1, 1, 1, 2, 2, 2, 2])
</code></pre>
<p>对于多维数组，还可以让它们的元素沿指定轴重复：</p>
<pre><code class="language-python">In [57]: arr = np.random.randn(2, 2)

In [58]: arr
Out[58]: 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386]])

In [59]: arr.repeat(2, axis=0)
Out[59]: 
array([[-2.0016, -0.3718],
       [-2.0016, -0.3718],
       [ 1.669 , -0.4386],
       [ 1.669 , -0.4386]])
</code></pre>
<p>注意，如果没有设置轴向，则数组会被扁平化，这可能不会是你想要的结果。同样，在对多维进行重复时，也可以传入一组整数，这样就会使各切片重复不同的次数：</p>
<pre><code class="language-python">In [60]: arr.repeat([2, 3], axis=0)
Out[60]: 
array([[-2.0016, -0.3718],
       [-2.0016, -0.3718],
       [ 1.669 , -0.4386],
       [ 1.669 , -0.4386],
       [ 1.669 , -0.4386]])

In [61]: arr.repeat([2, 3], axis=1)
Out[61]: 
array([[-2.0016, -2.0016, -0.3718, -0.3718, -0.3718],
       [ 1.669 ,  1.669 , -0.4386, -0.4386, -0.4386]])
</code></pre>
<p>tile的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p>
<pre><code class="language-python">In [62]: arr
Out[62]: 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386]])

In [63]: np.tile(arr, 2)
Out[63]: 
array([[-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386]])
</code></pre>
<p>第二个参数是瓷砖的数量。对于标量，瓷砖是水�����铺设的，而不是垂直铺设。它可以是一个表示“铺设”布局的元组：</p>
<pre><code class="language-python">In [64]: arr
Out[64]: 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386]])

In [65]: np.tile(arr, (2, 1))
Out[65]: 
array([[-2.0016, -0.3718],
       [ 1.669 , -0.4386],
       [-2.0016, -0.3718],
       [ 1.669 , -0.4386]])

In [66]: np.tile(arr, (3, 2))
Out[66]: 
array([[-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386],
       [-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386],
       [-2.0016, -0.3718, -2.0016, -0.3718],
       [ 1.669 , -0.4386,  1.669 , -0.4386]])
</code></pre>
<h2 id="花式索引的等价函数take和put">花式索引的等价函数：take和put</h2>
<p>在第4章中我们讲过，获取和设置数组子集的一个办法是通过整数数组使用花式索引：</p>
<pre><code class="language-python">In [67]: arr = np.arange(10) * 100

In [68]: inds = [7, 1, 2, 6]

In [69]: arr[inds]
Out[69]: array([700, 100, 200, 600])
</code></pre>
<p>ndarray还有其它方法用于获取单个轴向上的选区：</p>
<pre><code class="language-python">In [70]: arr.take(inds)
Out[70]: array([700, 100, 200, 600])

In [71]: arr.put(inds, 42)

In [72]: arr
Out[72]: array([  0,  42,  42, 300, 400, 500,  42,  42,800, 900])

In [73]: arr.put(inds, [40, 41, 42, 43])

In [74]: arr
Out[74]: array([  0,  41,  42, 300, 400, 500,  43,  40, 800, 900])
</code></pre>
<p>要在其它轴上使用take，只需传入axis关键字即可：</p>
<pre><code class="language-python">In [75]: inds = [2, 0, 2, 1]

In [76]: arr = np.random.randn(2, 4)

In [77]: arr
Out[77]: 
array([[-0.5397,  0.477 ,  3.2489, -1.0212],
       [-0.5771,  0.1241,  0.3026,  0.5238]])

In [78]: arr.take(inds, axis=1)
Out[78]: 
array([[ 3.2489, -0.5397,  3.2489,  0.477 ],
       [ 0.3026, -0.5771,  0.3026,  0.1241]])
</code></pre>
<p>put不接受axis参数，它只会在数组的扁平化版本（一维，C顺序）上进行索引。因此，在需要用其他轴向的索引设置元素时，最好还是使用花式索引。</p>
<h1 id="a3-广播">A.3 广播</h1>
<p>广播（broadcasting）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：</p>
<pre><code class="language-python">In [79]: arr = np.arange(5)

In [80]: arr
Out[80]: array([0, 1, 2, 3, 4])

In [81]: arr * 4
Out[81]: array([ 0,  4,  8, 12, 16])
</code></pre>
<p>这里我们说：在这个乘法运算中，标量值4被广播到了其他所有的元素上。<br>
Broadcast（广播）的规则：</p>
<ol>
<li>让所有输入数组都向其中shape最长的数组看齐，shape中不足的部分都通过在前面加1补齐</li>
<li>输出数组的shape是输入数组shape的各个轴上的最大值</li>
<li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</li>
<li>当输入数组的某个轴的长度为1时，沿着此轴运算时都用此轴上的第一组值<br>
两个array的shape长度与shape的每个对应值都相等的时候，那么结果就是对应元素逐元素运算，运算的结果shape不变。shape长度不相等时，先把短的shape前面一直补1，直到与长的shape长度相等时，此时，两个array的shape对应位置上的值 ：</li>
<li>相等;</li>
<li>其中一个为1;<br>
满足其一才能进行广播。<br>
譬如：</li>
</ol>
<pre><code class="language-python">#可以广播
A      (4d array):  8 x 1 x 6 x 1
B      (3d array):      7 x 1 x 5
Result (4d array):  8 x 7 x 6 x 5
#不可以广播
A  (2d array):      2 x 1
B  (3d array):  8 x 4 x 3（倒数第二维不匹配）
</code></pre>
<p>看一个例子，我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：</p>
<pre><code class="language-python">In [82]: arr = np.random.randn(4, 3)

In [83]: arr.mean(0)
Out[83]: array([-0.3928, -0.3824, -0.8768])

In [84]: demeaned = arr - arr.mean(0)

In [85]: demeaned
Out[85]: 
array([[ 0.3937,  1.7263,  0.1633],
       [-0.4384, -1.9878, -0.9839],
       [-0.468 ,  0.9426, -0.3891],
       [ 0.5126, -0.6811,  1.2097]])

In [86]: demeaned.mean(0)
Out[86]: array([-0.,  0., -0.])
</code></pre>
<p>图A-4形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。</p>
<figure data-type="image" tabindex="23"><img src="http://upload-images.jianshu.io/upload_images/7178691-6aaf022ab88452a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-4 一维数组在轴0上的广播" loading="lazy"></figure>
<p>于是就得到了：</p>
<figure data-type="image" tabindex="24"><img src="http://upload-images.jianshu.io/upload_images/7178691-fcaba8455960862a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<p>虽然我是一名经验丰富的NumPy老手，但经常还是得停下来画张图并想想广播的原则。再来看一下最后那个例子，假设你希望对各行减去那个平均值。由于arr.mean(0)的长度为3，所以它可以在0轴向上进行广播：因为arr的后缘维度是3，所以它们是兼容的。根据该原则，要在1轴向上做减法（即各行减去行平均值），较小的那个数组的形状必须是(4,1)：</p>
<pre><code class="language-python">In [87]: arr
Out[87]: 
array([[ 0.0009,  1.3438, -0.7135],
       [-0.8312, -2.3702, -1.8608],
       [-0.8608,  0.5601, -1.2659],
       [ 0.1198, -1.0635,  0.3329]])

In [88]: row_means = arr.mean(1)

In [89]: row_means.shape
Out[89]: (4,)

In [90]: row_means.reshape((4, 1))
Out[90]: 
array([[ 0.2104],
       [-1.6874],
       [-0.5222],
       [-0.2036]])

In [91]: demeaned = arr - row_means.reshape((4, 1))

In [92]: demeaned.mean(1)
Out[92]: array([ 0., -0.,  0.,  0.])
</code></pre>
<p>图A-5说明了该运算的过程。</p>
<figure data-type="image" tabindex="25"><img src="http://upload-images.jianshu.io/upload_images/7178691-9b0310d6773c3d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-5 二维数组在轴1上的广播" loading="lazy"></figure>
<p>图A-6展示了另外一种情况，这次是在一个三维数组上沿0轴向加上一个二维数组。</p>
<figure data-type="image" tabindex="26"><img src="http://upload-images.jianshu.io/upload_images/7178691-965eb28b60046cd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-6 三维数组在轴0上的广播" loading="lazy"></figure>
<h2 id="沿其它轴向广播">沿其它轴向广播</h2>
<p>高维度数组的广播似乎更难以理解，而实际上它也是遵循广播原则的。如果不然，你就会得到下面这样一个错误：</p>
<pre><code class="language-python">In [93]: arr - arr.mean(1)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-93-7b87b85a20b2&gt; in &lt;module&gt;()
----&gt; 1 arr - arr.mean(1)
ValueError: operands could not be broadcast together with shapes (4,3) (4,)
</code></pre>
<p>人们经常需要通过算术运算过程将较低维度的数组在除0轴以外的其他轴向上广播。根据广播的原则，较小数组的“广播维”必须为1。在上面那个行距平化的例子中，这就意味着要将行平均值的形状变成(4,1)而不是(4,)：</p>
<pre><code class="language-python">In [94]: arr - arr.mean(1).reshape((4, 1))
Out[94]: 
array([[-0.2095,  1.1334, -0.9239],
       [ 0.8562, -0.6828, -0.1734],
       [-0.3386,  1.0823, -0.7438],
       [ 0.3234, -0.8599,  0.5365]])
</code></pre>
<p>对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。图A-7说明了要在三维数组各维度上广播的形状需求。</p>
<figure data-type="image" tabindex="27"><img src="http://upload-images.jianshu.io/upload_images/7178691-b40936aab8e757d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图A-7：能在该三维数组上广播的二维数组的形状" loading="lazy"></figure>
<p>于是就有了一个非常普遍的问题（尤其是在通用算法中），即专门为了广播而添加一个长度为1的新轴。虽然reshape是一个办法，但插入轴需要构造一个表示新形状的元组。这是一个很郁闷的过程。因此，NumPy数组提供了一种通过索引机制插入轴的特殊语法。下面这段代码通过特殊的np.newaxis属性以及“全”切片来插入新轴：</p>
<pre><code class="language-python">In [95]: arr = np.zeros((4, 4))

In [96]: arr_3d = arr[:, np.newaxis, :]

In [97]: arr_3d.shape
Out[97]: (4, 1, 4)

In [98]: arr_1d = np.random.normal(size=3)

In [99]: arr_1d[:, np.newaxis]
Out[99]: 
array([[-2.3594],
       [-0.1995],
       [-1.542 ]])

In [100]: arr_1d[np.newaxis, :]
Out[100]: array([[-2.3594, -0.1995, -1.542 ]])
</code></pre>
<p>因此，如果我们有一个三维数组，并希望对轴2进行距平化，那么只需要编写下面这样的代码就可以了：</p>
<pre><code class="language-python">In [101]: arr = np.random.randn(3, 4, 5)

In [102]: depth_means = arr.mean(2)

In [103]: depth_means
Out[103]: 
array([[-0.4735,  0.3971, -0.0228,  0.2001],
       [-0.3521, -0.281 , -0.071 , -0.1586],
       [ 0.6245,  0.6047,  0.4396, -0.2846]])

In [104]: depth_means.shape
Out[104]: (3, 4)

In [105]: demeaned = arr - depth_means[:, :, np.newaxis]

In [106]: demeaned.mean(2)
Out[106]: 
array([[ 0.,  0., -0., -0.],
       [ 0.,  0., -0.,  0.],
       [ 0.,  0., -0., -0.]])
</code></pre>
<p>有些读者可能会想，在对指定轴进行距平化时，有没有一种既通用又不牺牲性能的方法呢？实际上是有的，但需要一些索引方面的技巧：</p>
<pre><code class="language-python">def demean_axis(arr, axis=0):
    means = arr.mean(axis)

    # This generalizes things like [:, :, np.newaxis] to N dimensions
    indexer = [slice(None)] * arr.ndim#slice(None)等价于:,
    indexer[axis] = np.newaxis
    return arr - means[indexer]
</code></pre>
<h2 id="通过广播设置数组的值">通过广播设置数组的值</h2>
<p>算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作。对于最简单的情况，我们可以这样做：</p>
<pre><code class="language-python">In [107]: arr = np.zeros((4, 3))

In [108]: arr[:] = 5

In [109]: arr
Out[109]: 
array([[ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.]])
</code></pre>
<p>但是，假设我们想要用一个一维数组来设置目标数组的各列，只要保证形状兼容就可以了：</p>
<pre><code class="language-python">In [110]: col = np.array([1.28, -0.42, 0.44, 1.6])
In [111]: arr[:] = col[:, np.newaxis]

In [112]: arr
Out[112]: 
array([[ 1.28,  1.28,  1.28],
       [-0.42, -0.42, -0.42],
       [ 0.44,  0.44,  0.44],
       [ 1.6 ,  1.6 ,  1.6 ]])

In [113]: arr[:2] = [[-1.37], [0.509]]

In [114]: arr
Out[114]: 
array([[-1.37 , -1.37 , -1.37 ],
       [ 0.509,  0.509,  0.509],
       [ 0.44 ,  0.44 ,  0.44 ],
       [ 1.6  ,  1.6  ,  1.6  ]])
</code></pre>
<h1 id="a4-ufunc高级应用">A.4 ufunc高级应用</h1>
<p>虽然许多NumPy用户只会用到通用函数所提供的快速的元素级运算，但通用函数实际上还有一些高级用法能使我们丢开循环而编写出更为简洁的代码。</p>
<h2 id="ufunc实例方法">ufunc实例方法</h2>
<p>NumPy的各个二元ufunc都有一些用于执行特定矢量化运算的特殊方法。表A-2汇总了这些方法，下面我将通过几个具体的例子对它们进行说明。</p>
<p>reduce接受一个数组参数，并通过一系列的二元运算对其值进行聚合（可指明轴向）。例如，我们可以用np.add.reduce对数组中各个元素进行求和：</p>
<pre><code class="language-python">In [115]: arr = np.arange(10)

In [116]: np.add.reduce(arr)
Out[116]: 45

In [117]: arr.sum()
Out[117]: 45
</code></pre>
<p>起始值取决于ufunc（对于add的情况，就是0）。如果设置了轴号，约简运算就会沿该轴向执行。这就使你能用一种比较简洁的方式得到某些问题的答案。在下面这个例子中，我们用np.logical_and检查数组各行中的值是否是有序的：</p>
<pre><code class="language-python">In [118]: np.random.seed(12346)  # for reproducibility

In [119]: arr = np.random.randn(5, 5)

In [120]: arr[::2].sort(1) # sort a few rows

In [121]: arr[:, :-1] &lt; arr[:, 1:]
Out[121]: 
array([[ True,  True,  True,  True],
       [False,  True, False, False],
       [ True,  True,  True,  True],
       [ True, False,  True,  True],
       [ True,  True,  True,  True]], dtype=bool)

In [122]: np.logical_and.reduce(arr[:, :-1] &lt; arr[:, 1:], axis=1)
Out[122]: array([ True, False,  True, False,  True], dtype=bool)
</code></pre>
<p>注意，logical_and.reduce跟all方法是等价的。</p>
<p>ccumulate跟reduce的关系就像cumsum跟sum的关系那样。它产生一个跟原数组大小相同的中间“累计”值数组：</p>
<pre><code class="language-python">In [123]: arr = np.arange(15).reshape((3, 5))

In [124]: np.add.accumulate(arr, axis=1)
Out[124]: 
array([[ 0,  1,  3,  6, 10],
       [ 5, 11, 18, 26, 35],
       [10, 21, 33, 46, 60]])
</code></pre>
<p>outer用于计算两个数组的叉积：</p>
<pre><code class="language-python">In [125]: arr = np.arange(3).repeat([1, 2, 2])

In [126]: arr
Out[126]: array([0, 1, 1, 2, 2])

In [127]: np.multiply.outer(arr, np.arange(5))
Out[127]: 
array([[0, 0, 0, 0, 0],
       [0, 1, 2, 3, 4],
       [0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8],
       [0, 2, 4, 6, 8]])
</code></pre>
<p>outer输出结果的维度是两个输入数据的维度之和：</p>
<pre><code class="language-python">In [128]: x, y = np.random.randn(3, 4), np.random.randn(5)

In [129]: result = np.subtract.outer(x, y)

In [130]: result.shape
Out[130]: (3, 4, 5)
</code></pre>
<p>最后一个方法reduceat用于计算“局部约简”，其实就是一个对数据各切片进行聚合的groupby运算。它接受一组用于指示如何对值进行拆分和聚合的“面元边界”：</p>
<pre><code class="language-python">In [131]: arr = np.arange(10)

In [132]: np.add.reduceat(arr, [0, 5, 8])
Out[132]: array([10, 18, 17])
</code></pre>
<p>最终结果是在arr[0:5]、arr[5:8]以及arr[8:]上执行的约简。跟其他方法一样，这里也可以传入一个axis参数：</p>
<pre><code class="language-python">In [133]: arr = np.multiply.outer(np.arange(4), np.arange(5))

In [134]: arr
Out[134]: 
array([[ 0,  0,  0,  0,  0],
       [ 0,  1,  2,  3,  4],
       [ 0,  2,  4,  6,  8],
       [ 0,  3,  6,  9, 12]])

In [135]: np.add.reduceat(arr, [0, 2, 4], axis=1)
Out[135]: 
array([[ 0,  0,  0],
       [ 1,  5,  4],
       [ 2, 10,  8],
       [ 3, 15, 12]])
</code></pre>
<p>表A-2总结了部分的ufunc方法。</p>
<figure data-type="image" tabindex="28"><img src="http://upload-images.jianshu.io/upload_images/7178691-c997bd45000f7b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A ufunc方法" loading="lazy"></figure>
<h2 id="编写新的ufunc">编写新的ufunc</h2>
<p>有多种方法可以让你编写自己的NumPy ufuncs。最常见的是使用NumPy C API，但它超越了本书的范围。在本节，我们讲纯粹的Python ufunc。</p>
<p>numpy.frompyfunc接受一个Python函数以及两个分别表示输入输出参数数量的参数。例如，下面是一个能够实现元素级加法的简单函数：</p>
<pre><code class="language-python">In [136]: def add_elements(x, y):
   .....:     return x + y

In [137]: add_them = np.frompyfunc(add_elements, 2, 1)

In [138]: add_them(np.arange(8), np.arange(8))
Out[138]: array([0, 2, 4, 6, 8, 10, 12, 14], dtype=object)
</code></pre>
<p>用frompyfunc创建的函数总是返回Python对象数组，这一点很不方便。幸运的是，还有另一个办法，即numpy.vectorize。虽然没有frompyfunc那么强大，但可以让你指定输出类型：</p>
<pre><code class="language-python">In [139]: add_them = np.vectorize(add_elements, otypes=[np.float64])

In [140]: add_them(np.arange(8), np.arange(8))
Out[140]: array([  0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.])
</code></pre>
<p>虽然这两个函数提供了一种创建ufunc型函数的手段，但它们非常慢，因为它们在计算每个元素时都要执行一次Python函数调用，这就会比NumPy自带的基于C的ufunc慢很多：</p>
<pre><code class="language-python">In [141]: arr = np.random.randn(10000)

In [142]: %timeit add_them(arr, arr)
4.12 ms +- 182 us per loop (mean +- std. dev. of 7 runs, 100 loops each)

In [143]: %timeit np.add(arr, arr)
6.89 us +- 504 ns per loop (mean +- std. dev. of 7 runs, 100000 loops each)
</code></pre>
<p>本章的后面，我会介绍使用Numba（http://numba.pydata.org/），创建快速Python ufuncs。</p>
<h1 id="a5-结构化和记录式数组">A.5 结构化和记录式数组</h1>
<p>你可能已经注意到了，到目前为止我们所讨论的ndarray都是一种同质数据容器，也就是说，在它所表示的内存块中，各元素占用的字节数相同（具体根据dtype而定）。从表面上看，它似乎不能用于表示异质或表格型的数据。结构化数组是一种特殊的ndarray，其中的各个元素可以被看做C语言中的结构体（struct，这就是“结构化”的由来）或SQL表中带有多个命名字段的行：</p>
<pre><code class="language-python">In [144]: dtype = [('x', np.float64), ('y', np.int32)]

In [145]: sarr = np.array([(1.5, 6), (np.pi, -2)], dtype=dtype)

In [146]: sarr
Out[146]: 
array([( 1.5   ,  6), ( 3.1416, -2)],
      dtype=[('x', '&lt;f8'), ('y', '&lt;i4')])
</code></pre>
<p>定义结构化dtype（请参考NumPy的在线文档）的方式有很多。最典型的办法是元组列表，各元组的格式为(field_name,field_data_type)。这样，数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：</p>
<pre><code class="language-python">In [147]: sarr[0]
Out[147]: ( 1.5, 6)

In [148]: sarr[0]['y']
Out[148]: 6
</code></pre>
<p>字段名保存在dtype.names属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制：</p>
<pre><code class="language-python">In [149]: sarr['x']
Out[149]: array([ 1.5   ,  3.1416])
</code></pre>
<h2 id="嵌套dtype和多维字段">嵌套dtype和多维字段</h2>
<p>在定义结构化dtype时，你可以再设置一个形状（可以是一个整数，也可以是一个元组）：</p>
<pre><code class="language-python">In [150]: dtype = [('x', np.int64, 3), ('y', np.int32)]

In [151]: arr = np.zeros(4, dtype=dtype)

In [152]: arr
Out[152]: 
array([([0, 0, 0], 0), ([0, 0, 0], 0), ([0, 0, 0], 0), ([0, 0, 0], 0)],
      dtype=[('x', '&lt;i8', (3,)), ('y', '&lt;i4')])
</code></pre>
<p>在这种情况下，各个记录的x字段所表示的是一个长度为3的数组：</p>
<pre><code class="language-python">In [153]: arr[0]['x']
Out[153]: array([0, 0, 0])
</code></pre>
<p>这样，访问arr['x']即可得到一个二维数组，而不是前面那个例子中的一维数组：</p>
<pre><code class="language-python">In [154]: arr['x']
Out[154]: 
array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
</code></pre>
<p>这就使你能用单个数组的内存块存放复杂的嵌套结构。你还可以嵌套dtype，作出更复杂的结构。下面是一个简单的例子：</p>
<pre><code class="language-python">In [155]: dtype = [('x', [('a', 'f8'), ('b', 'f4')]), ('y', np.int32)]

In [156]: data = np.array([((1, 2), 5), ((3, 4), 6)], dtype=dtype)

In [157]: data['x']
Out[157]: 
array([( 1.,  2.), ( 3.,  4.)],
      dtype=[('a', '&lt;f8'), ('b', '&lt;f4')])

In [158]: data['y']
Out[158]: array([5, 6], dtype=int32)

In [159]: data['x']['a']
Out[159]: array([ 1.,  3.])
</code></pre>
<p>pandas的DataFrame并不直接支持该功能，但它的分层索引机制跟这个差不多。</p>
<h2 id="为什么要用结构化数组">为什么要用结构化数组</h2>
<p>跟pandas的DataFrame相比，NumPy的结构化数组是一种相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套列的表格型结构。由于数组中的每个元素在内存中都被表示为固定的字节数，所以结构化数组能够提供非常快速高效的磁盘数据读写（包括内存映像）、网络传输等功能。</p>
<p>结构化数组的另一个常见用法是，将数据文件写成定长记录字节流，这是C和C++代码中常见的数据序列化手段（业界许多历史系统中都能找得到）。只要知道文件的格式（记录的大小、元素的顺序、字节数以及数据类型等），就可以用np.fromfile将数据读入内存。这种用法超出了本书的范围，知道这点就可以了。</p>
<h1 id="a6-更多有关排序的话题">A.6 更多有关排序的话题</h1>
<p>跟Python内置的列表一样，ndarray的sort实例方法也是就地排序。也就是说，数组内容的重新排列是不会产生新数组的：</p>
<pre><code class="language-python">In [160]: arr = np.random.randn(6)

In [161]: arr.sort()

In [162]: arr
Out[162]: array([-1.082 ,  0.3759,  0.8014,  1.1397,  1.2888,  1.8413])
</code></pre>
<p>在对数组进行就地排序时要注意一点，如果目标数组只是一个视图，则原始数组将会被修改：</p>
<pre><code class="language-python">In [163]: arr = np.random.randn(3, 5)

In [164]: arr
Out[164]: 
array([[-0.3318, -1.4711,  0.8705, -0.0847, -1.1329],
       [-1.0111, -0.3436,  2.1714,  0.1234, -0.0189],
       [ 0.1773,  0.7424,  0.8548,  1.038 , -0.329 ]])

In [165]: arr[:, 0].sort()  # Sort first column values in-place

In [166]: arr
Out[166]: 
array([[-1.0111, -1.4711,  0.8705, -0.0847, -1.1329],
       [-0.3318, -0.3436,  2.1714,  0.1234, -0.0189],
       [ 0.1773,  0.7424,  0.8548,  1.038 , -0.329 ]])
</code></pre>
<p>相反，numpy.sort会为原数组创建一个已排序副本。另外，它所接受的参数（比如kind）跟ndarray.sort一样：</p>
<pre><code class="language-python">In [167]: arr = np.random.randn(5)

In [168]: arr
Out[168]: array([-1.1181, -0.2415, -2.0051,  0.7379, -1.0614])

In [169]: np.sort(arr)
Out[169]: array([-2.0051, -1.1181, -1.0614, -0.2415,  0.7379])

In [170]: arr
Out[170]: array([-1.1181, -0.2415, -2.0051,  0.7379, -1.0614])
</code></pre>
<p>这两个排序方法都可以接受一个axis参数，以便沿指定轴向对各块数据进行单独排序：</p>
<pre><code class="language-python">In [171]: arr = np.random.randn(3, 5)

In [172]: arr
Out[172]: 
array([[ 0.5955, -0.2682,  1.3389, -0.1872,  0.9111],
       [-0.3215,  1.0054, -0.5168,  1.1925, -0.1989],
       [ 0.3969, -1.7638,  0.6071, -0.2222, -0.2171]])

In [173]: arr.sort(axis=1)

In [174]: arr
Out[174]: 
array([[-0.2682, -0.1872,  0.5955,  0.9111,  1.3389],
       [-0.5168, -0.3215, -0.1989,  1.0054,  1.1925],
       [-1.7638, -0.2222, -0.2171,  0.3969,  0.6071]])
</code></pre>
<p>你可能注意到了，这两个排序方法都不可以被设置为降序。其实这也无所谓，因为数组切片会产生视图（也就是说，不会产生副本，也不需要任何其他的计算工作）。许多Python用户都很熟悉一个有关列表的小技巧：values[::-1]可以返回一个反序的列表。对ndarray也是如此：</p>
<pre><code class="language-python">In [175]: arr[:, ::-1]
Out[175]: 
array([[ 1.3389,  0.9111,  0.5955, -0.1872, -0.2682],
       [ 1.1925,  1.0054, -0.1989, -0.3215, -0.5168],
       [ 0.6071,  0.3969, -0.2171, -0.2222, -1.7638]])
</code></pre>
<h2 id="间接排序argsort和lexsort">间接排序：argsort和lexsort</h2>
<p>在数据分析工作中，常常需要根据一个或多个键对数据集进行排序。例如，一个有关学生信息的数据表可能需要以姓和名进行排序（先姓后名）。这就是间接排序的一个例子，如果你阅读过有关pandas的章节，那就已经见过不少高级例子了。给定一个或多个键，你就可以得到一个由整数组成的索引数组（我亲切地称之为索引器），其中的索引值说明了数据在新顺序下的位置。argsort和numpy.lexsort就是实现该功能的两个主要方法。下面是一个简单的例子：</p>
<pre><code class="language-python">In [176]: values = np.array([5, 0, 1, 3, 2])

In [177]: indexer = values.argsort()

In [178]: indexer
Out[178]: array([1, 2, 4, 3, 0])

In [179]: values[indexer]
Out[179]: array([0, 1, 2, 3, 5])
</code></pre>
<p>一个更复杂的例子，下面这段代码根据数组的第一行对其进行排序：</p>
<pre><code class="language-python">In [180]: arr = np.random.randn(3, 5)

In [181]: arr[0] = values

In [182]: arr
Out[182]: 
array([[ 5.    ,  0.    ,  1.    ,  3.    ,  2.    ],
       [-0.3636, -0.1378,  2.1777, -0.4728,  0.8356],
       [-0.2089,  0.2316,  0.728 , -1.3918,  1.9956]])

In [183]: arr[:, arr[0].argsort()]
Out[183]: 
array([[ 0.    ,  1.    ,  2.    ,  3.    ,  5.    ],
       [-0.1378,  2.1777,  0.8356, -0.4728, -0.3636],
       [ 0.2316,  0.728 ,  1.9956, -1.3918, -0.2089]])
</code></pre>
<p>lexsort跟argsort差不多，只不过它可以一次性对多个键数组执行间接排序（字典序）。假设我们想对一些以姓和名标识的数据进行排序：</p>
<pre><code class="language-python">In [184]: first_name = np.array(['Bob', 'Jane', 'Steve', 'Bill', 'Barbara'])

In [185]: last_name = np.array(['Jones', 'Arnold', 'Arnold', 'Jones', 'Walters'])

In [186]: sorter = np.lexsort((first_name, last_name))

In [187]: sorter
Out[187]: array([1, 2, 3, 0, 4])

In [188]: zip(last_name[sorter], first_name[sorter])
Out[188]: &lt;zip at 0x7fa203eda1c8&gt;
</code></pre>
<p>刚开始使用lexsort的时候可能会比较容易头晕，这是因为键的应用顺序是从最后一个传入的算起的。不难看出，last_name是先于first_name被应用的。</p>
<blockquote>
<p>笔记：Series和DataFrame的sort_index以及Series的order方法就是通过这些函数的变体（它们还必须考虑缺失值）实现的。</p>
</blockquote>
<h2 id="其他排序算法">其他排序算法</h2>
<p>稳定的（stable）排序算法会保持等价元素的相对位置。对于相对位置具有实际意义的那些间接排序而言，这一点非常重要：</p>
<pre><code class="language-python">In [189]: values = np.array(['2:first', '2:second', '1:first', '1:second',
.....:                    '1:third'])

In [190]: key = np.array([2, 2, 1, 1, 1])

In [191]: indexer = key.argsort(kind='mergesort')

In [192]: indexer
Out[192]: array([2, 3, 4, 0, 1])

In [193]: values.take(indexer)
Out[193]: 
array(['1:first', '1:second', '1:third', '2:first', '2:second'],
      dtype='&lt;U8')
</code></pre>
<p>mergesort（合并排序）是唯一的稳定排序，它保证有O(n log n)的性能（空间复杂度），但是其平均性能比默认的quicksort（快速排序）要差。表A-3列出了可用的排序算法及其相关的性能指标。大部分用户完全不需要知道这些东西，但了解一下总是好的。</p>
<figure data-type="image" tabindex="29"><img src="http://upload-images.jianshu.io/upload_images/7178691-970f54f58b6b3356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A-3 数组排序算法" loading="lazy"></figure>
<h2 id="部分排序数组">部分排序数组</h2>
<p>排序的目的之一可能是确定数组中最大或最小的元素。NumPy有两个优化方法，numpy.partition和np.argpartition，可以在第k个最小元素划分的数组：</p>
<pre><code class="language-python">In [194]: np.random.seed(12345)

In [195]: arr = np.random.randn(20)

In [196]: arr
Out[196]: 
array([-0.2047,  0.4789, -0.5194, -0.5557,  1.9658,  1.3934,  0.0929,
        0.2817,  0.769 ,  1.2464,  1.0072, -1.2962,  0.275 ,  0.2289,
        1.3529,  0.8864, -2.0016, -0.3718,  1.669 , -0.4386])

In [197]: np.partition(arr, 3)
Out[197]: 
array([-2.0016, -1.2962, -0.5557, -0.5194, -0.3718, -0.4386, -0.2047,
        0.2817,  0.769 ,  0.4789,  1.0072,  0.0929,  0.275 ,  0.2289,
        1.3529,  0.8864,  1.3934,  1.9658,  1.669 ,  1.2464])
</code></pre>
<p>当你调用partition(arr, 3)，结果中的头三个元素是最小的三个，没有特定的顺序。numpy.argpartition与numpy.argsort相似，会返回索引，重排数据为等价的顺序：</p>
<pre><code class="language-python">In [198]: indices = np.argpartition(arr, 3)

In [199]: indices
Out[199]: 
array([16, 11,  3,  2, 17, 19,  0,  7,  8,  1, 10,  6, 12, 13, 14, 15,  5,
        4, 18,  9])

In [200]: arr.take(indices)
Out[200]: 
array([-2.0016, -1.2962, -0.5557, -0.5194, -0.3718, -0.4386, -0.2047,
        0.2817,  0.769 ,  0.4789,  1.0072,  0.0929,  0.275 ,  0.2289,
        1.3529,  0.8864,  1.3934,  1.9658,  1.669 ,  1.2464])
</code></pre>
<h2 id="numpysearchsorted在有序数组中查找元素">numpy.searchsorted：在有序数组中查找元素</h2>
<p>searchsorted是一个在有序数组上执行二分查找的数组方法，只要将值插入到它返回的那个位置就能维持数组的有序性：</p>
<pre><code class="language-python">In [201]: arr = np.array([0, 1, 7, 12, 15])

In [202]: arr.searchsorted(9)
Out[202]: 3
</code></pre>
<p>你可以传入一组值就能得到一组索引：</p>
<pre><code class="language-python">In [203]: arr.searchsorted([0, 8, 11, 16])
Out[203]: array([0, 3, 3, 5])
</code></pre>
<p>从上面的结果中可以看出，对于元素0，searchsorted会返回0。这是因为其默认行为是返回相等值组的左侧索引：</p>
<pre><code class="language-python">In [204]: arr = np.array([0, 0, 0, 1, 1, 1, 1])

In [205]: arr.searchsorted([0, 1])
Out[205]: array([0, 3])

In [206]: arr.searchsorted([0, 1], side='right')
Out[206]: array([3, 7])
</code></pre>
<p>再来看searchsorted的另一个用法，假设我们有一个数据数组（其中的值在0到10000之间），还有一个表示“面元边界”的数组，我们希望用它将数据数组拆分开：</p>
<pre><code class="language-python">In [207]: data = np.floor(np.random.uniform(0, 10000, size=50))

In [208]: bins = np.array([0, 100, 1000, 5000, 10000])

In [209]: data
Out[209]: 
array([ 9940.,  6768.,  7908.,  1709.,   268.,  8003., 9037.,   246.,
        4917.,  5262.,  5963.,   519.,  8950.,  7282.,  8183.,  5002.,
        8101.,   959.,  2189.,  2587.,  4681.,  4593.,  7095.,  1780.,
        5314.,  1677.,  7688.,  9281.,  6094.,  1501.,  4896.,  3773.,
        8486.,  9110.,  3838.,  3154.,  5683.,  1878.,  1258.,  6875.,
        7996.,  5735.,  9732.,  6340.,  8884.,  4954.,  3516.,  7142.,
        5039.,  2256.])
</code></pre>
<p>然后，为了得到各数据点所属区间的编号（其中1表示面元[0,100)），我们可以直接使用searchsorted：</p>
<pre><code class="language-python">In [210]: labels = bins.searchsorted(data)

In [211]: labels
Out[211]: 
array([4, 4, 4, 3, 2, 4, 4, 2, 3, 4, 4, 2, 4, 4, 4, 4, 4, 2, 3, 3, 3, 3, 4,
       3, 4, 3, 4, 4, 4, 3, 3, 3, 4, 4, 3, 3, 4, 3, 3, 4, 4, 4, 4, 4, 4, 3,
       3, 4, 4, 3])
</code></pre>
<p>通过pandas的groupby使用该结果即可非常轻松地对原数据集进行拆分：</p>
<pre><code class="language-python">In [212]: pd.Series(data).groupby(labels).mean()
Out[212]: 
2     498.000000
3    3064.277778
4    7389.035714
dtype: float64
</code></pre>
<h1 id="a7-用numba编写快速numpy函数">A.7 用Numba编写快速NumPy函数</h1>
<p>Numba是一个开源项目，它可以利用CPUs、GPUs或其它硬件为类似NumPy的数据创建快速函数。它使用了LLVM项目（http://llvm.org/），将Python代码转换为机器代码。</p>
<p>为了介绍Numba，来考虑一个纯粹的Python函数，它使用for循环计算表达式(x - y).mean()：</p>
<pre><code class="language-python">import numpy as np

def mean_distance(x, y):
    nx = len(x)
    result = 0.0
    count = 0
    for i in range(nx):
        result += x[i] - y[i]
        count += 1
    return result / count
</code></pre>
<p>这个函数很慢：</p>
<pre><code class="language-python">In [209]: x = np.random.randn(10000000)

In [210]: y = np.random.randn(10000000)

In [211]: %timeit mean_distance(x, y)
1 loop, best of 3: 2 s per loop

In [212]: %timeit (x - y).mean()
100 loops, best of 3: 14.7 ms per loop
</code></pre>
<p>NumPy的版本要比它快过100倍。我们可以转换这个函数为编译的Numba函数，使用numba.jit函数：</p>
<pre><code class="language-python">In [213]: import numba as nb

In [214]: numba_mean_distance = nb.jit(mean_distance)
</code></pre>
<p>也可以写成装饰器：</p>
<pre><code class="language-python">@nb.jit
def mean_distance(x, y):
    nx = len(x)
    result = 0.0
    count = 0
    for i in range(nx):
        result += x[i] - y[i]
        count += 1
    return result / count
</code></pre>
<p>它要比矢量化的NumPy快：</p>
<pre><code class="language-python">In [215]: %timeit numba_mean_distance(x, y)
100 loops, best of 3: 10.3 ms per loop
</code></pre>
<p>Numba不能编译Python代码，但它支持纯Python写的一个部分，可以编写数值算法。</p>
<p>Numba是一个深厚的库，支持多种硬件、编译模式和用户插件。它还可以编译NumPy Python API的一部分，而不用for循环。Numba也可以识别可以便以为机器编码的结构体，但是若调用CPython API，它就不知道如何编译。Numba的jit函数有一个选项，nopython=True，它限制了可以被转换为Python代码的代码，这些代码可以编译为LLVM，但没有任何Python C API调用。jit(nopython=True)有一个简短的别名numba.njit。</p>
<p>前面的例子，我们还可以这样写：</p>
<pre><code class="language-python">from numba import float64, njit

@njit(float64(float64[:], float64[:]))
def mean_distance(x, y):
    return (x - y).mean()
</code></pre>
<p>我建议你学习Numba的线上文档（http://numba.pydata.org/）。下一节介绍一个创建自定义Numpy ufunc对象的例子。</p>
<h2 id="用numba创建自定义numpyufunc对象">用Numba创建自定义numpy.ufunc对象</h2>
<p>numba.vectorize创建了一个编译的NumPy ufunc，它与内置的ufunc很像。考虑一个numpy.add的Python例子：</p>
<pre><code class="language-python">from numba import vectorize

@vectorize
def nb_add(x, y):
    return x + y
</code></pre>
<p>现在有：</p>
<pre><code class="language-python">In [13]: x = np.arange(10)

In [14]: nb_add(x, x)
Out[14]: array([  0.,   2.,   4.,   6.,   8.,  10.,  12.,  14.,  16.,  18.])

In [15]: nb_add.accumulate(x, 0)
Out[15]: array([  0.,   1.,   3.,   6.,  10.,  15.,  21.,  28.,  36.,  45.])
</code></pre>
<h1 id="a8-高级数组输入输出">A.8 高级数组输入输出</h1>
<p>我在第4章中讲过，np.save和np.load可用于读写磁盘上以二进制格式存储的数组。其实还有一些工具可用于更为复杂的场景。尤其是内存映像（memory map），它使你能处理在内存中放不下的数据集。</p>
<h2 id="内存映像文件">内存映像文件</h2>
<p>内存映像文件是一种将磁盘上的非常大的二进制数据文件当做内存中的数组进行处理的方式。NumPy实现了一个类似于ndarray的memmap对象，它允许将大文件分成小段进行读写，而不是一次性将整个数组读入内存。另外，memmap也拥有跟普通数组一样的方法，因此，基本上只要是能用于ndarray的算法就也能用于memmap。</p>
<p>要创建一个内存映像，可以使用函数np.memmap并传入一个文件路径、数据类型、形状以及文件模式：</p>
<pre><code class="language-python">In [214]: mmap = np.memmap('mymmap', dtype='float64', mode='w+',
   .....:                  shape=(10000, 10000))

In [215]: mmap
Out[215]: 
memmap([[ 0.,  0.,  0., ...,  0.,  0.,  0.],
        [ 0.,  0.,  0., ...,  0.,  0.,  0.],
        [ 0.,  0.,  0., ...,  0.,  0.,  0.],
        ..., 
        [ 0.,  0.,  0., ...,  0.,  0.,  0.],
        [ 0.,  0.,  0., ...,  0.,  0.,  0.],
        [ 0.,  0.,  0., ...,  0.,  0.,  0.]])
</code></pre>
<p>对memmap切片将会返回磁盘上的数据的视图：</p>
<pre><code class="language-python">In [216]: section = mmap[:5]
</code></pre>
<p>如果将数据赋值给这些视图：数据会先被缓存在内存中（就像是Python的文件对象），调用flush即可将其写入磁盘：</p>
<pre><code class="language-python">In [217]: section[:] = np.random.randn(5, 10000)

In [218]: mmap.flush()

In [219]: mmap
Out[219]: 
memmap([[ 0.7584, -0.6605,  0.8626, ...,  0.6046, -0.6212,  2.0542],
        [-1.2113, -1.0375,  0.7093, ..., -1.4117, -0.1719, -0.8957],
        [-0.1419, -0.3375,  0.4329, ...,  1.2914, -0.752 , -0.44  ],
        ..., 
        [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
        [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
        [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ]])

In [220]: del mmap
</code></pre>
<p>只要某个内存映像超出了作用域，它就会被垃圾回收器回收，之前对其所做的任何修改都会被写入磁盘。当打开一个已经存在的内存映像时，仍然需要指明数据类型和形状，因为磁盘上的那个文件只是一块二进制数据而已，没有任何元数据：</p>
<pre><code class="language-python">In [221]: mmap = np.memmap('mymmap', dtype='float64', shape=(10000, 10000))

In [222]: mmap
Out[222]: 
memmap([[ 0.7584, -0.6605,  0.8626, ...,  0.6046, -0.6212,  2.0542],
        [-1.2113, -1.0375,  0.7093, ..., -1.4117, -0.1719, -0.8957],
        [-0.1419, -0.3375,  0.4329, ...,  1.2914, -0.752 , -0.44  ],
        ..., 
        [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
        [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ],
        [ 0.    ,  0.    ,  0.    , ...,  0.    ,  0.    ,  0.    ]])
</code></pre>
<p>内存映像可以使用前面介绍的结构化或嵌套dtype。</p>
<h2 id="hdf5及其他数组存储方式">HDF5及其他数组存储方式</h2>
<p>PyTables和h5py这两个Python项目可以将NumPy的数组数据存储为高效且可压缩的HDF5格式（HDF意思是“层次化数据格式”）。你可以安全地将好几百GB甚至TB的数据存储为HDF5格式。要学习Python使用HDF5，请参考pandas线上文档。</p>
<h1 id="a9-性能建议">A.9 性能建议</h1>
<p>使用NumPy的代码的性能一般都很不错，因为数组运算一般都比纯Python循环快得多。下面大致列出了一些需要注意的事项：</p>
<ul>
<li>将Python循环和条件逻辑转换为数组运算和布尔数组运算。</li>
<li>尽量使用广播。</li>
<li>避免复制数据，尽量使用数组视图（即切片）。</li>
<li>利用ufunc及其各种方法。</li>
</ul>
<p>如果单用NumPy无论如何都达不到所需的性能指标，就可以考虑一下用C、Fortran或Cython（等下会稍微介绍一下）来编写代码。我自己在工作中经常会用到Cython（http://cython.org），因为它不用花费我太多精力就能得到C语言那样的性能。</p>
<h2 id="连续内存的重要性">连续内存的重要性</h2>
<p>虽然这个话题有点超出本书的范围，但还是要提一下，因为在某些应用场景中，数组的内存布局可以对计算速度造成极大的影响。这是因为性能差别在一定程度上跟CPU的高速缓存（cache）体系有关。运算过程中访问连续内存块（例如，对以C顺序存储的数组的行求和）一般是最快的，因为内存子系统会将适当的内存块缓存到超高速的L1或L2CPU Cache中。此外，NumPy的C语言基础代码（某些）对连续存储的情况进行了优化处理，这样就能避免一些跨越式的内存访问。</p>
<p>一个数组的内存布局是连续的，就是说元素是以它们在数组中出现的顺序（即Fortran型（列优先）或C型（行优先））存储在内存中的。默认情况下，NumPy数组是以C型连续的方式创建的。列优先的数组（比如C型连续数组的转置）也被称为Fortran型连续。通过ndarray的flags属性即可查看这些信息：</p>
<pre><code class="language-python">In [225]: arr_c = np.ones((1000, 1000), order='C')

In [226]: arr_f = np.ones((1000, 1000), order='F')

In [227]: arr_c.flags

Out[227]: 
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False

In [228]: arr_f.flags
Out[228]: 
  C_CONTIGUOUS : False
  F_CONTIGUOUS : True
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False

In [229]: arr_f.flags.f_contiguous
Out[229]: True
</code></pre>
<p>在这个例子中，对两个数组的行进行求和计算，理论上说，arr_c会比arr_f快，因为arr_c的行在内存中是连续的。我们可以在IPython中用%timeit来确认一下：</p>
<pre><code class="language-python">In [230]: %timeit arr_c.sum(1)
784 us +- 10.4 us per loop (mean +- std. dev. of 7 runs, 1000 loops each)

In [231]: %timeit arr_f.sum(1)
934 us +- 29 us per loop (mean +- std. dev. of 7 runs, 1000 loops each)
</code></pre>
<p>如果想从NumPy中提升性能，这里就应该是下手的地方。如果数组的内存顺序不符合你的要求，使用copy并传入'C'或'F'即可解决该问题：</p>
<pre><code class="language-python">In [232]: arr_f.copy('C').flags
Out[232]: 
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : True
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
</code></pre>
<p>注意，在构造数组的视图时，其结果不一定是连续的：</p>
<pre><code class="language-python">In [233]: arr_c[:50].flags.contiguous
Out[233]: True

In [234]: arr_c[:, :50].flags
Out[234]: 
  C_CONTIGUOUS : False
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  UPDATEIFCOPY : False
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[待安装包]]></title>
        <id>https://bailingnan.github.io/post/dai-an-zhuang-bao/</id>
        <link href="https://bailingnan.github.io/post/dai-an-zhuang-bao/">
        </link>
        <updated>2020-02-07T02:42:25.000Z</updated>
        <content type="html"><![CDATA[<p>flake8<br>
SpeedTorch<br>
ohmyzsh<br>
pypy<br>
skorch<br>
<strong>tpot</strong><br>
<strong>wandb</strong><br>
<strong>FBLearner Flow</strong><br>
<strong>mlflow</strong><br>
<strong>Neptune.ai</strong><br>
<strong>nyaggle</strong><br>
<strong>fastai</strong>有协同过滤<br>
<strong>torch-optimizer</strong> 拓展pytorch优化器<br>
<strong>test tube</strong><br>
<strong>neptune-notebooks</strong><br>
<strong>comet_ml</strong><br>
<strong>tensorwatch</strong>notebook里可运行<br>
<strong>swifter</strong>加速pandas<br>
<strong>modin(加载数据和查询数据更快，统计方法pandas更快)</strong><br>
<strong>numba</strong><br>
<strong>cupy(1000万以上数据才更快)</strong><br>
Cython<br>
hyperparameter_hunter</p>
<p>DeepSpeed 微软分布式训练工具<br>
dvc<br>
<strong>hiddenlayer</strong><br>
syncthing<br>
ignite<br>
pytorch-lightning<br>
fastai<br>
prefetch_generator<br>
torchsummary<br>
apex<br>
dali<br>
optuna<br>
pip-review<br>
autogluon<br>
arthas<br>
greys-anatomy<br>
implicit<br>
eli5<br>
icecream<br>
stackprinter<br>
dlrm<br>
buffalo<br>
cupy<br>
acptum<br>
featuretools<br>
boruta_py<br>
Categorical-encoding<br>
Tsfresh<br>
Scikit-Optimize<br>
Hyperopt<br>
ray<br>
ENAS-pytorch<br>
MLBox<br>
h2o<br>
AutoKeras<br>
TPOT<br>
Auto-Sklearn</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matplotlib笔记]]></title>
        <id>https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi-di-09-zhang-hui-tu-he-ke-shi-hua/</id>
        <link href="https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi-di-09-zhang-hui-tu-he-ke-shi-hua/">
        </link>
        <updated>2020-02-04T09:09:53.000Z</updated>
        <content type="html"><![CDATA[<p>信息可视化（也叫绘图）是数据分析中最重要的工作之一。它可能是探索过程的一部分，例如，帮助我们找出异常值、必要的数据转换、得出有关模型的idea等。另外，做一个可交互的数据可视化也许是工作的最终目标。Python有许多库进行静态或动态的数据可视化，但我这里重要关注于matplotlib（http://matplotlib.org/）和基于它的库。</p>
<p>matplotlib是一个用于创建出版质量图表的桌面绘图包（主要是2D方面）。该项目是由John Hunter于2002年启动的，其目的是为Python构建一个MATLAB式的绘图接口。matplotlib和IPython社区进行合作，简化了从IPython shell（包括现在的Jupyter notebook）进行交互式绘图。matplotlib支持各种操作系统上许多不同的GUI后端，而且还能将图片导出为各种常见的矢量（vector）和光栅（raster）图：PDF、SVG、JPG、PNG、BMP、GIF等。除了几张，本书中的大部分图都是用它生成的。</p>
<p>随着时间的发展，matplotlib衍生出了多个数据可视化的工具集，它们使用matplotlib作为底层。其中之一是seaborn（http://seaborn.pydata.org/），本章后面会学习它。</p>
<p>学习本章代码案例的最简单方法是在Jupyter notebook进行交互式绘图。在Jupyter notebook中执行下面的语句：</p>
<pre><code class="language-python">%matplotlib notebook
</code></pre>
<h1 id="91-matplotlib-api入门">9.1 matplotlib API入门</h1>
<p>matplotlib的通常引入约定是：</p>
<pre><code class="language-python">In [11]: import matplotlib.pyplot as plt
</code></pre>
<p>在Jupyter中运行%matplotlib notebook（或在IPython中运行%matplotlib），就可以创建一个简单的图形。如果一切设置正确，会看到图9-1：</p>
<pre><code class="language-python">In [12]: import numpy as np

In [13]: data = np.arange(10)

In [14]: data
Out[14]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

In [15]: plt.plot(data)
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/7178691-7032e333a6ecdd37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-1 简单的线图" loading="lazy"></figure>
<p>虽然seaborn这样的库和pandas的内置绘图函数能够处理许多普通的绘图任务，但如果需要自定义一些高级功能的话就必须学习matplotlib API。</p>
<blockquote>
<p>笔记：虽然本书没有详细地讨论matplotlib的各种功能，但足以将你引入门。matplotlib的示例库和文档是学习高级特性的最好资源。</p>
</blockquote>
<h2 id="figure和subplot">Figure和Subplot</h2>
<p>matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure：</p>
<pre><code class="language-python">In [16]: fig = plt.figure()
</code></pre>
<p>如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。</p>
<p>不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：</p>
<pre><code class="language-python">In [17]: ax1 = fig.add_subplot(2, 2, 1)
</code></pre>
<p>这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个subplot中的第一个（编号从1开始）。如果再把后面两个subplot也创建出来，最终得到的图像如图9-2所示：</p>
<pre><code class="language-python">In [18]: ax2 = fig.add_subplot(2, 2, 2)

In [19]: ax3 = fig.add_subplot(2, 2, 3)
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://upload-images.jianshu.io/upload_images/7178691-b8cff158e64eae74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-2 带有三个subplot的Figure" loading="lazy"></figure>
<blockquote>
<p>提示：使用Jupyter notebook有一点不同，即每个小窗重新执行后，图形会被重置。因此，对于复杂的图形，，你必须将所有的绘图命令存在一个小窗里。</p>
</blockquote>
<p>这里，我们运行同一个小窗里的所有命令：</p>
<pre><code class="language-python">fig = plt.figure()
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3)
</code></pre>
<p>如果这时执行一条绘图命令（如plt.plot([1.5, 3.5, -2, 1.6])），matplotlib就会在最后一个用过的subplot（如果没有则创建一个）上进行绘制，隐藏创建figure和subplot的过程。因此，如果我们执行下列命令，你就会得到如图9-3所示的结果：</p>
<pre><code class="language-python">In [20]: plt.plot(np.random.randn(50).cumsum(), 'k--')
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://upload-images.jianshu.io/upload_images/7178691-7bcbd5e56fdbbd92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-3 绘制一次之后的图像" loading="lazy"></figure>
<p>&quot;k--&quot;是一个线型选项，用于告诉matplotlib绘制黑色虚线图。上面那些由fig.add_subplot所返回的对象是AxesSubplot对象，直接调用它们的实例方法就可以在其它空着的格子里面画图了，如图9-4所示：</p>
<pre><code class="language-python">In [21]: ax1.hist(np.random.randn(100), bins=20, color='k', alpha=0.3)

In [22]: ax2.scatter(np.arange(30), np.arange(30) + 3 * np.random.randn(30))
</code></pre>
<figure data-type="image" tabindex="4"><img src="http://upload-images.jianshu.io/upload_images/7178691-2297bcaf355db24c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-4 继续绘制两次之后的图像" loading="lazy"></figure>
<p>你可以在matplotlib的文档中找到各种图表类型。</p>
<p>创建包含subplot网格的figure是一个非常常见的任务，matplotlib有一个更为方便的方法plt.subplots，它可以创建一个新的Figure，并返回一个含有已创建的subplot对象的NumPy数组：</p>
<pre><code class="language-python">In [24]: fig, axes = plt.subplots(2, 3)

In [25]: axes
Out[25]: 
array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb626374048&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb62625db00&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6262f6c88&gt;],
       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6261a36a0&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb626181860&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6260fd4e0&gt;]], dtype
=object)
</code></pre>
<p>这是非常实用的，因为可以轻松地对axes数组进行索引，就好像是一个二维数组一样，例如axes[0,1]。你还可以通过sharex和sharey指定subplot应该具有相同的X轴或Y轴。在比较相同范围的数据时，这也是非常实用的，否则，matplotlib会自动缩放各图表的界限。有关该方法的更多信息，请参见表9-1。</p>
<pre><code class="language-python">matplotlib.pyplot.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)[source]
</code></pre>
<figure data-type="image" tabindex="5"><img src="http://upload-images.jianshu.io/upload_images/7178691-88bb55faca7d01ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-1 pyplot.subplots的选项" loading="lazy"></figure>
<h2 id="调整subplot周围的间距">调整subplot周围的间距</h2>
<p>默认情况下，matplotlib会在subplot外围留下一定的边距，并在subplot之间留下一定的间距。间距跟图像的高度和宽度有关，因此，如果你调整了图像大小（不管是编程还是手工），间距也会自动调整。利用Figure的subplots_adjust方法可以轻而易举地修改间距，此外，它也是个顶级函数：</p>
<pre><code class="language-python">subplots_adjust(left=None, bottom=None, right=None, top=None,
                wspace=None, hspace=None)
</code></pre>
<p>wspace和hspace用于控制宽度和高度的百分比，可以用作subplot之间的间距。下面是一个简单的例子，其中我将间距收缩到了0（如图9-5所示）：</p>
<pre><code class="language-python">fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
for i in range(2):
    for j in range(2):
        axes[i, j].hist(np.random.randn(500), bins=50, color='k', alpha=0.5)
plt.subplots_adjust(wspace=0, hspace=0)
</code></pre>
<figure data-type="image" tabindex="6"><img src="http://upload-images.jianshu.io/upload_images/7178691-80be7ffc3dec88a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-5 各subplot之间没有间距" loading="lazy"></figure>
<p>不难看出，其中的轴标签重叠了。matplotlib不会检查标签是否重叠，所以对于这种情况，你只能自己设定刻度位置和刻度标签。后面几节将会详细介绍该内容。</p>
<h2 id="颜色-标记和线型">颜色、标记和线型</h2>
<p>matplotlib的plot函数接受一组X和Y坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据x和y绘制绿色虚线，你可以执行如下代码：</p>
<pre><code class="language-python">ax.plot(x, y, 'g--')
</code></pre>
<p>这种在一个字符串中指定颜色和线型的方式非常方便。在实际中，如果你是用代码绘图，你可能不想通过处理字符串来获得想要的格式。通过下面这种更为明确的方式也能得到同样的效果：</p>
<pre><code class="language-python">ax.plot(x, y, linestyle='--', color='g')
</code></pre>
<p>常用的颜色可以使用颜色缩写，你也可以指定颜色码（例如，'#CECECE'）。你可以通过查看plot的文档字符串查看所有线型的合集（在IPython和Jupyter中使用plot?）。</p>
<p>可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle）。<br>
具体形式  fmt = '[color][marker][line]'</p>
<pre><code class="language-python">=============    ===============================
    character        color
    =============    ===============================
    ``'b'``          blue 蓝
    ``'g'``          green 绿
    ``'r'``          red 红
    ``'c'``          cyan 蓝绿
    ``'m'``          magenta 洋红
    ``'y'``          yellow 黄
    ``'k'``          black 黑
    ``'w'``          white 白
    =============    ===============================
=============    ===============================
    character        description
    =============    ===============================
    ``'.'``          point marker点标记
    ``','``          pixel marker像素标记（极小点）
    ``'o'``          circle marker实心圈标记
    ``'v'``          triangle_down marker倒三角标记
    ``'^'``          triangle_up marker上三角标记
    ``'&lt;'``          triangle_left marker
    ``'&gt;'``          triangle_right marker
    ``'1'``          tri_down marker
    ``'2'``          tri_up marker
    ``'3'``          tri_left marker
    ``'4'``          tri_right marker
    ``'s'``          square marker
    ``'p'``          pentagon marker
    ``'*'``          star marker
    ``'h'``          hexagon1 marker
    ``'H'``          hexagon2 marker
    ``'+'``          plus marker十字标记
    ``'x'``          x markerx标记
    ``'D'``          diamond marker
    ``'d'``          thin_diamond marker
    ``'|'``          vline marker
    ``'_'``          hline marker
    =============    ===============================
=============    ===============================
    character        description
    =============    ===============================
    ``'-'``          solid line style 实线
    ``'--'``         dashed line style 虚线
    ``'-.'``         dash-dot line style 点画线
    ``':'``          dotted line style 点线
    ``''``           无线条
    =============    ===============================
</code></pre>
<p>线图可以使用标记强调数据点。因为matplotlib可以创建连续线图，在点之间进行插值，因此有时可能不太容易看出真实数据点的位置。标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面（见图9-6）：</p>
<pre><code class="language-python">In [30]: from numpy.random import randn

In [31]: plt.plot(randn(30).cumsum(), 'ko--')
</code></pre>
<figure data-type="image" tabindex="7"><img src="http://upload-images.jianshu.io/upload_images/7178691-404d816f3e1d6621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-6 带有标记的线型图示例" loading="lazy"></figure>
<p>还可以将其写成更为明确的形式：</p>
<pre><code class="language-python">plot(randn(30).cumsum(), color='k', linestyle='dashed', marker='o')
</code></pre>
<p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过drawstyle选项修改（见图9-7）：</p>
<pre><code class="language-python">In [33]: data = np.random.randn(30).cumsum()

In [34]: plt.plot(data, 'k--', label='Default')
Out[34]: [&lt;matplotlib.lines.Line2D at 0x7fb624d86160&gt;]

In [35]: plt.plot(data, 'k-', drawstyle='steps-post', label='steps-post')
Out[35]: [&lt;matplotlib.lines.Line2D at 0x7fb624d869e8&gt;]

In [36]: plt.legend(loc='best')
</code></pre>
<figure data-type="image" tabindex="8"><img src="http://upload-images.jianshu.io/upload_images/7178691-3ec7642e1a592f08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-7 不同drawstyle选项的线型图" loading="lazy"></figure>
<p>你可能注意到运行上面代码时有输出&lt;matplotlib.lines.Line2D at ...&gt;。matplotlib会返回引用了新添加的子组件的对象。大多数时候，你可以放心地忽略这些输出。这里，因为我们传递了label参数到plot，我们可以创建一个plot图例，指明每条使用plt.legend的线。</p>
<blockquote>
<p>笔记：你必须调用plt.legend（或使用ax.legend，如果引用了轴的话）来创建图例，无论你绘图时是否传递label标签选项。</p>
</blockquote>
<h2 id="刻度-标签和图例">刻度、标签和图例</h2>
<p>对于大多数的图表装饰项，其主要实现方式有二：使用过程型的pyplot接口（例如，matplotlib.pyplot）以及更为面向对象的原生matplotlib API。</p>
<p>pyplot接口的设计目的就是交互式使用，含有诸如xlim、xticks和xticklabels之类的方法。它们分别控制图表的范围、刻度位置、刻度标签等。其使用方式有以下两种：</p>
<ul>
<li>调用时不带参数，则返回当前的参数值（例如，plt.xlim()返回当前的X轴绘图范围）。</li>
<li>调用时带参数，则设置参数值（例如，plt.xlim([0,10])会将X轴的范围设置为0到10）。</li>
</ul>
<p>所有这些方法都是对当前或最近创建的AxesSubplot起作用的。它们各自对应subplot对象上的两个方法，以xlim为例，就是ax.get_xlim和ax.set_xlim。我更喜欢使用subplot的实例方法（因为我喜欢明确的事情，而且在处理多个subplot时这样也更清楚一些）。当然你完全可以选择自己觉得方便的那个。</p>
<h2 id="设置标题-轴标签-刻度以及刻度标签">设置标题、轴标签、刻度以及刻度标签</h2>
<p>为了说明自定义轴，我将创建一个简单的图像并绘制一段随机漫步（如图9-8所示）：</p>
<pre><code class="language-python">In [37]: fig = plt.figure()

In [38]: ax = fig.add_subplot(1, 1, 1)

In [39]: ax.plot(np.random.randn(1000).cumsum())
</code></pre>
<figure data-type="image" tabindex="9"><img src="http://upload-images.jianshu.io/upload_images/7178691-caf9300dacb61fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-8 用于演示xticks的简单线型图（带有标签）" loading="lazy"></figure>
<p>要改变x轴刻度，最简单的办法是使用set_xticks和set_xticklabels。前者告诉matplotlib要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过set_xticklabels将任何其他的值用作标签：</p>
<pre><code class="language-python">In [40]: ticks = ax.set_xticks([0, 250, 500, 750, 1000])

In [41]: labels = ax.set_xticklabels(['one', 'two', 'three', 'four', 'five'],
   ....:                             rotation=30, fontsize='small')
</code></pre>
<p>rotation选项设定x刻度标签倾斜30度。最后，再用set_xlabel为X轴设置一个名称，并用set_title设置一个标题（见图9-9的结果）：</p>
<pre><code class="language-python">In [42]: ax.set_title('My first matplotlib plot')
Out[42]: &lt;matplotlib.text.Text at 0x7fb624d055f8&gt;

In [43]: ax.set_xlabel('Stages')
</code></pre>
<figure data-type="image" tabindex="10"><img src="http://upload-images.jianshu.io/upload_images/7178691-741f968323bd818f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-9 用于演示xticks的简单线型图" loading="lazy"></figure>
<p>Y轴的修改方式与此类似，只需将上述代码中的x替换为y即可。轴的类有集合方法，可以批量设定绘图选项。前面的例子，也可以写为：</p>
<pre><code class="language-python">props = {
    'title': 'My first matplotlib plot',
    'xlabel': 'Stages'
}
ax.set(**props)
</code></pre>
<h2 id="添加图例">添加图例</h2>
<p>图例（legend）是另一种用于标识图表元素的重要工具。添加图例的方式有多种。最简单的是在添加subplot的时候传入label参数：</p>
<pre><code class="language-python">In [44]: from numpy.random import randn

In [45]: fig = plt.figure(); ax = fig.add_subplot(1, 1, 1)

In [46]: ax.plot(randn(1000).cumsum(), 'k', label='one')
Out[46]: [&lt;matplotlib.lines.Line2D at 0x7fb624bdf860&gt;]

In [47]: ax.plot(randn(1000).cumsum(), 'k--', label='two')
Out[47]: [&lt;matplotlib.lines.Line2D at 0x7fb624be90f0&gt;]

In [48]: ax.plot(randn(1000).cumsum(), 'k.', label='three')
Out[48]: [&lt;matplotlib.lines.Line2D at 0x7fb624be9160&gt;]
</code></pre>
<p>在此之后，你可以调用ax.legend()或plt.legend()来自动创建图例（结果见图9-10）：</p>
<pre><code class="language-python">In [49]: ax.legend(loc='best')
</code></pre>
<figure data-type="image" tabindex="11"><img src="http://upload-images.jianshu.io/upload_images/7178691-651ff89750c0a89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-10 带有三条线以及图例的简单线型图" loading="lazy"></figure>
<p>legend方法有几个其它的loc位置参数选项。请查看文档字符串（使用ax.legend?）。</p>
<p>loc告诉matplotlib要将图例放在哪。如果你不是吹毛求疵的话，&quot;best&quot;是不错的选择，因为它会选择最不碍事的位置。要从图例中去除一个或多个元素，不传入label或传入label='<em>nolegend</em>'即可。（中文第一版这里把best错写成了beat）</p>
<h2 id="注解以及在subplot上绘图">注解以及在Subplot上绘图</h2>
<p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过text、arrow和annotate函数进行添加。text可以将文本绘制在图表的指定坐标(x,y)，还可以加上一些自定义格式：</p>
<pre><code class="language-python">ax.text(x, y, 'Hello world!',
        family='monospace', fontsize=10)
</code></pre>
<p>注解中可以既含有文本也含有箭头。例如，我们根据最近的标准普尔500指数价格（来自Yahoo!Finance）绘制一张曲线图，并标出2008年到2009年金融危机期间的一些重要日期。你可以在Jupyter notebook的一个小窗中试验这段代码（图9-11是结果）：</p>
<pre><code class="language-python">from datetime import datetime

fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)

data = pd.read_csv('examples/spx.csv', index_col=0, parse_dates=True)
spx = data['SPX']

spx.plot(ax=ax, style='k-')

crisis_data = [
    (datetime(2007, 10, 11), 'Peak of bull market'),
    (datetime(2008, 3, 12), 'Bear Stearns Fails'),
    (datetime(2008, 9, 15), 'Lehman Bankruptcy')
]

for date, label in crisis_data:
    ax.annotate(label, xy=(date, spx.asof(date) + 75),
                xytext=(date, spx.asof(date) + 225),
                arrowprops=dict(facecolor='black', headwidth=4, width=2,
                                headlength=4),
                horizontalalignment='left', verticalalignment='top')

# Zoom in on 2007-2010
ax.set_xlim(['1/1/2007', '1/1/2011'])
ax.set_ylim([600, 1800])

ax.set_title('Important dates in the 2008-2009 financial crisis')
</code></pre>
<figure data-type="image" tabindex="12"><img src="http://upload-images.jianshu.io/upload_images/7178691-3127eaa51f5e4c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-11 2008-2009年金融危机期间的重要日期" loading="lazy"></figure>
<p>这张图中有几个重要的点要强调：ax.annotate方法可以在指定的x和y坐标轴绘制标签。我们使用set_xlim和set_ylim人工设定起始和结束边界，而不使用matplotlib的默认方法。最后，用ax.set_title添加图标标题。</p>
<p>更多有关注解的示例，请访问matplotlib的在线示例库。</p>
<p>图形的绘制要麻烦一些。matplotlib有一些表示常见图形的对象。这些对象被称为块（patch）。其中有些（如Rectangle和Circle），可以在matplotlib.pyplot中找到，但完整集合位于matplotlib.patches。</p>
<p>要在图表中添加一个图形，你需要创建一个块对象shp，然后通过ax.add_patch(shp)将其添加到subplot中（如图9-12所示）：</p>
<pre><code class="language-python">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)

rect = plt.Rectangle((0.2, 0.75), 0.4, 0.15, color='k', alpha=0.3)
circ = plt.Circle((0.7, 0.2), 0.15, color='b', alpha=0.3)
pgon = plt.Polygon([[0.15, 0.15], [0.35, 0.4], [0.2, 0.6]],
                   color='g', alpha=0.5)

ax.add_patch(rect)
ax.add_patch(circ)
ax.add_patch(pgon)
</code></pre>
<figure data-type="image" tabindex="13"><img src="http://upload-images.jianshu.io/upload_images/7178691-1f8a3d7a3a02d7d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-12 由三个块图形组成的图" loading="lazy"></figure>
<p>如果查看许多常见图表对象的具体实现代码，你就会发现它们其实就是由块patch组装而成的。</p>
<h2 id="将图表保存到文件">将图表保存到文件</h2>
<p>利用plt.savefig可以将当前图表保存到文件。该方法相当于Figure对象的实例方法savefig。例如，要将图表保存为SVG文件，你只需输入：</p>
<pre><code class="language-python">plt.savefig('figpath.svg')
</code></pre>
<p>文件类型是通过文件扩展名推断出来的。因此，如果你使用的是.pdf，就会得到一个PDF文件。我在发布图片时最常用到两个重要的选项是dpi（控制“每英寸点数”分辨率）和bbox_inches（可以剪除当前图表周围的空白部分）。要得到一张带有最小白边且分辨率为400DPI的PNG图片，你可以：</p>
<pre><code class="language-python">plt.savefig('figpath.png', dpi=400, bbox_inches='tight')
</code></pre>
<p>savefig并非一定要写入磁盘，也可以写入任何文件型的对象，比如BytesIO：</p>
<pre><code class="language-python">from io import BytesIO
buffer = BytesIO()
plt.savefig(buffer)
plot_data = buffer.getvalue()
</code></pre>
<p>表9-2列出了savefig的其它选项。</p>
<figure data-type="image" tabindex="14"><img src="http://upload-images.jianshu.io/upload_images/7178691-4bee796bf7262423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-2 Figure.savefig的选项" loading="lazy"></figure>
<h2 id="matplotlib配置">matplotlib配置</h2>
<p>matplotlib自带一些配色方案，以及为生成出版质量的图片而设定的默认配置信息。幸运的是，几乎所有默认行为都能通过一组全局参数进行自定义，它们可以管理图像大小、subplot边距、配色方案、字体大小、网格类型等。一种Python编程方式配置系统的方法是使用rc方法。例如，要将全局的图像默认大小设置为10×10，你可以执行：</p>
<pre><code class="language-python">plt.rc('figure', figsize=(10, 10))
</code></pre>
<p>rc的第一个参数是希望自定义的对象，如'figure'、'axes'、'xtick'、'ytick'、'grid'、'legend'等。其后可以跟上一系列的关键字参数。一个简单的办法是将这些选项写成一个字典：</p>
<pre><code class="language-python">font_options = {'family' : 'monospace',
                'weight' : 'bold',
                'size'   : 'small'}
plt.rc('font', **font_options)
</code></pre>
<p>要了解全部的自定义选项，请查阅matplotlib的配置文件matplotlibrc（位于matplotlib/mpl-data目录中）。如果对该文件进行了自定义，并将其放在你自己的.matplotlibrc目录中，则每次使用matplotlib时就会加载该文件。</p>
<p>下一节，我们会看到，seaborn包有若干内置的绘图主题或类型，它们使用了matplotlib的内部配置。</p>
<h1 id="92-使用pandas和seaborn绘图">9.2 使用pandas和seaborn绘图</h1>
<p>matplotlib实际上是一种比较低级的工具。要绘制一张图表，你组装一些基本组件就行：数据展示（即图表类型：线型图、柱状图、盒形图、散布图、等值线图等）、图例、标题、刻度标签以及其他注解型信息。</p>
<p>在pandas中，我们有多列数据，还有行和列标签。pandas自身就有内置的方法，用于简化从DataFrame和Series绘制图形。另一个库seaborn（https://seaborn.pydata.org/），由Michael Waskom创建的静态图形库。Seaborn简化了许多常见可视类型的创建。</p>
<blockquote>
<p>提示：引入seaborn会修改matplotlib默认的颜色方案和绘图类型，以提高可读性和美观度。即使你不使用seaborn API，你可能也会引入seaborn，作为提高美观度和绘制常见matplotlib图形的简化方法。</p>
</blockquote>
<h2 id="线型图">线型图</h2>
<p>Series和DataFrame都有一个用于生成各类图表的plot方法。默认情况下，它们所生成的是线型图（如图9-13所示）：</p>
<pre><code class="language-python">In [60]: s = pd.Series(np.random.randn(10).cumsum(), index=np.arange(0, 100, 10))

In [61]: s.plot()
</code></pre>
<figure data-type="image" tabindex="15"><img src="http://upload-images.jianshu.io/upload_images/7178691-f28e5ab2ac94c7a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-13 简单的Series图表示例" loading="lazy"></figure>
<p>该Series对象的索引会被传给matplotlib，并用以绘制X轴。可以通过use_index=False禁用该功能。X轴的刻度和界限可以通过xticks和xlim选项进行调节，Y轴就用yticks和ylim。plot参数的完整列表请参见表9-3。我只会讲解其中几个，剩下的就留给读者自己去研究了。</p>
<figure data-type="image" tabindex="16"><img src="http://upload-images.jianshu.io/upload_images/7178691-6d9fbf863c09370a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="http://upload-images.jianshu.io/upload_images/7178691-44e50562aeb5eb49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-3 Series.plot方法的参数" loading="lazy"></figure>
<p>pandas的大部分绘图方法都有一个可选的ax参数，它可以是一个matplotlib的subplot对象。这使你能够在网格布局中更为灵活地处理subplot的位置。</p>
<p>DataFrame的plot方法会在一个subplot中为各列绘制一条线，并自动创建图例（如图9-14所示）：</p>
<pre><code class="language-python">In [62]: df = pd.DataFrame(np.random.randn(10, 4).cumsum(0),
   ....:                   columns=['A', 'B', 'C', 'D'],
   ....:                   index=np.arange(0, 100, 10))

In [63]: df.plot()
</code></pre>
<figure data-type="image" tabindex="18"><img src="http://upload-images.jianshu.io/upload_images/7178691-a1234d5e5ee41a40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-14 简单的DataFrame绘图" loading="lazy"></figure>
<p>plot属性包含一批不同绘图类型的方法。例如，df.plot()等价于df.plot.line()。后面会学习这些方法。</p>
<blockquote>
<p>笔记：plot的其他关键字参数会被传给相应的matplotlib绘图函数，所以要更深入地自定义图表，就必须学习更多有关matplotlib API的知识。</p>
</blockquote>
<p>DataFrame还有一些用于对列进行灵活处理的选项，例如，是要将所有列都绘制到一个subplot中还是创建各自的subplot。详细信息请参见表9-4。</p>
<figure data-type="image" tabindex="19"><img src="http://upload-images.jianshu.io/upload_images/7178691-96651ecaa90f1c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表9-4 专用于DataFrame的plot参数" loading="lazy"></figure>
<blockquote>
<p>注意： 有关时间序列的绘图，请见第11章。</p>
</blockquote>
<h2 id="柱状图">柱状图</h2>
<p>plot.bar()和plot.barh()分别绘制水平和垂直的柱状图。这时，Series和DataFrame的索引将会被用作X（bar）或Y（barh）刻度（如图9-15所示）：</p>
<pre><code class="language-python">In [64]: fig, axes = plt.subplots(2, 1)

In [65]: data = pd.Series(np.random.rand(16), index=list('abcdefghijklmnop'))

In [66]: data.plot.bar(ax=axes[0], color='k', alpha=0.7)
Out[66]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb62493d470&gt;

In [67]: data.plot.barh(ax=axes[1], color='k', alpha=0.7)
</code></pre>
<figure data-type="image" tabindex="20"><img src="http://upload-images.jianshu.io/upload_images/7178691-cd54c7ccfa3f0687.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-15 水平和垂直的柱状图" loading="lazy"></figure>
<p>color='k'和alpha=0.7设定了图形的颜色为黑色，并使用部分的填充透明度。对于DataFrame，柱状图会将每一行的值分为一组，并排显示，如图9-16所示：</p>
<pre><code class="language-python">In [69]: df = pd.DataFrame(np.random.rand(6, 4),
   ....:                   index=['one', 'two', 'three', 'four', 'five', 'six'],
   ....:                   columns=pd.Index(['A', 'B', 'C', 'D'], name='Genus'))

In [70]: df
Out[70]: 
Genus         A         B         C         D
one    0.370670  0.602792  0.229159  0.486744
two    0.420082  0.571653  0.049024  0.880592
three  0.814568  0.277160  0.880316  0.431326
four   0.374020  0.899420  0.460304  0.100843
five   0.433270  0.125107  0.494675  0.961825
six    0.601648  0.478576  0.205690  0.560547

In [71]: df.plot.bar()
</code></pre>
<figure data-type="image" tabindex="21"><img src="http://upload-images.jianshu.io/upload_images/7178691-bfc141acb37d99b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-16 DataFrame的柱状图" loading="lazy"></figure>
<p>注意，DataFrame各列的名称&quot;Genus&quot;被用作了图例的标题。</p>
<p>设置stacked=True即可为DataFrame生成堆积柱状图，这样每行的值就会被堆积在一起（如图9-17所示）：</p>
<pre><code class="language-python">In [73]: df.plot.barh(stacked=True, alpha=0.5)
</code></pre>
<figure data-type="image" tabindex="22"><img src="http://upload-images.jianshu.io/upload_images/7178691-c19e4246eb897978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-17 DataFrame的堆积柱状图" loading="lazy"></figure>
<blockquote>
<p>笔记：柱状图有一个非常不错的用法：利用value_counts图形化显示Series中各值的出现频率，比如s.value_counts().plot.bar()。</p>
</blockquote>
<p>再以本书前面用过的那个有关小费的数据集为例，假设我们想要做一张堆积柱状图以展示每天各种聚会规模的数据点的百分比。我用read_csv将数据加载进来，然后根据日期和聚会规模创建一张交叉表：</p>
<pre><code class="language-python">In [75]: tips = pd.read_csv('examples/tips.csv')

In [76]: party_counts = pd.crosstab(tips['day'], tips['size'])

In [77]: party_counts
Out[77]: 
size  1   2   3   4  5  6
day                      
Fri   1  16   1   1  0  0
Sat   2  53  18  13  1  0
Sun   0  39  15  18  3  1
Thur  1  48   4   5  1  3

# Not many 1- and 6-person parties
In [78]: party_counts = party_counts.loc[:, 2:5]
</code></pre>
<p>然后进行规格化，使得各行的和为1，并生成图表（如图9-18所示）：</p>
<pre><code class="language-python"># Normalize to sum to 1
In [79]: party_pcts = party_counts.div(party_counts.sum(1), axis=0)

In [80]: party_pcts
Out[80]: 
size         2         3         4         5
day                                         
Fri   0.888889  0.055556  0.055556  0.000000
Sat   0.623529  0.211765  0.152941  0.011765
Sun   0.520000  0.200000  0.240000  0.040000
Thur  0.827586  0.068966  0.086207  0.017241

In [81]: party_pcts.plot.bar()
</code></pre>
<figure data-type="image" tabindex="23"><img src="http://upload-images.jianshu.io/upload_images/7178691-2918f67936823834.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-18 每天各种聚会规模的比例" loading="lazy"></figure>
<p>于是，通过该数据集就可以看出，聚会规模在周末会变大。</p>
<p>对于在绘制一个图形之前，需要进行合计的数据，使用seaborn可以减少工作量。用seaborn来看每天的小费比例（图9-19是结果）：</p>
<pre><code class="language-python">In [83]: import seaborn as sns

In [84]: tips['tip_pct'] = tips['tip'] / (tips['total_bill'] - tips['tip'])

In [85]: tips.head()
Out[85]: 
   total_bill   tip smoker  day    time  size   tip_pct
0       16.99  1.01     No  Sun  Dinner     2  0.063204
1       10.34  1.66     No  Sun  Dinner     3  0.191244
2       21.01  3.50     No  Sun  Dinner     3  0.199886
3       23.68  3.31     No  Sun  Dinner     2  0.162494
4       24.59  3.61     No  Sun  Dinner     4  0.172069

In [86]: sns.barplot(x='tip_pct', y='day', data=tips, orient='h')
</code></pre>
<figure data-type="image" tabindex="24"><img src="http://upload-images.jianshu.io/upload_images/7178691-c33e8b3add99904b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-19 小费的每日比例，带有误差条" loading="lazy"></figure>
<p>seaborn的绘制函数使用data参数，它可能是pandas的DataFrame。其它的参数是关于列的名字。因为一天的每个值有多次观察，柱状图的值是tip_pct的平均值。绘制在柱状图上的黑线代表95%置信区间（可以通过可选参数配置）。</p>
<p>seaborn.barplot有颜色选项，使我们能够通过一个额外的值设置（见图9-20）：</p>
<pre><code class="language-python">In [88]: sns.barplot(x='tip_pct', y='day', hue='time', data=tips, orient='h')
</code></pre>
<figure data-type="image" tabindex="25"><img src="http://upload-images.jianshu.io/upload_images/7178691-06abe2f070222115.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-20 根据天和时间的小费比例" loading="lazy"></figure>
<p>注意，seaborn已经自动修改了图形的美观度：默认调色板，图形背景和网格线的颜色。你可以用seaborn.set在不同的图形外观之间切换：</p>
<pre><code class="language-python">In [90]: sns.set(style=&quot;whitegrid&quot;)
</code></pre>
<h2 id="直方图和密度图">直方图和密度图</h2>
<p>直方图（histogram）是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。再以前面那个小费数据为例，通过在Series使用plot.hist方法，我们可以生成一张“小费占消费总额百分比”的直方图（如图9-21所示）：</p>
<pre><code class="language-python">In [92]: tips['tip_pct'].plot.hist(bins=50)
</code></pre>
<figure data-type="image" tabindex="26"><img src="http://upload-images.jianshu.io/upload_images/7178691-255279376f7649a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-21 小费百分比的直方图" loading="lazy"></figure>
<p>与此相关的一种图表类型是密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态分布之类的较为简单的分布）。因此，密度图也被称作KDE（Kernel Density Estimate，核密度估计）图。使用plot.kde和标准混合正态分布估计即可生成一张密度图（见图9-22）：</p>
<pre><code class="language-python">In [94]: tips['tip_pct'].plot.density()
</code></pre>
<figure data-type="image" tabindex="27"><img src="http://upload-images.jianshu.io/upload_images/7178691-ee929d033159516a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-22  小费百分比的密度图" loading="lazy"></figure>
<p>seaborn的distplot方法绘制直方图和密度图更加简单，还可以同时画出直方图和连续密度估计图。作为例子，考虑一个双峰分布，由两个不同的标准正态分布组成（见图9-23）：</p>
<pre><code class="language-python">In [96]: comp1 = np.random.normal(0, 1, size=200)

In [97]: comp2 = np.random.normal(10, 2, size=200)

In [98]: values = pd.Series(np.concatenate([comp1, comp2]))

In [99]: sns.distplot(values, bins=100, color='k')
</code></pre>
<figure data-type="image" tabindex="28"><img src="http://upload-images.jianshu.io/upload_images/7178691-975f04d750c4efe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-23 标准混合密度估计的标准直方图" loading="lazy"></figure>
<h2 id="散布图或点图">散布图或点图</h2>
<p>点图或散布图是观察两个一维数据序列之间的关系的有效手段。在下面这个例子中，我加载了来自statsmodels项目的macrodata数据集，选择了几个变量，然后计算对数差：</p>
<pre><code class="language-python">In [100]: macro = pd.read_csv('examples/macrodata.csv')

In [101]: data = macro[['cpi', 'm1', 'tbilrate', 'unemp']]

In [102]: trans_data = np.log(data).diff().dropna()

In [103]: trans_data[-5:]
Out[103]: 
          cpi        m1  tbilrate     unemp
198 -0.007904  0.045361 -0.396881  0.105361
199 -0.021979  0.066753 -2.277267  0.139762
200  0.002340  0.010286  0.606136  0.160343
201  0.008419  0.037461 -0.200671  0.127339
202  0.008894  0.012202 -0.405465  0.042560
</code></pre>
<p>然后可以使用seaborn的regplot方法，它可以做一个散布图，并加上一条线性回归的线（见图9-24）：</p>
<pre><code class="language-python">In [105]: sns.regplot('m1', 'unemp', data=trans_data)
Out[105]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb613720be0&gt;

In [106]: plt.title('Changes in log %s versus log %s' % ('m1', 'unemp'))
</code></pre>
<figure data-type="image" tabindex="29"><img src="http://upload-images.jianshu.io/upload_images/7178691-2133d20739478a80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-24 seaborn的回归/散布图" loading="lazy"></figure>
<p>在探索式数据分析工作中，同时观察一组变量的散布图是很有意义的，这也被称为散布图矩阵（scatter plot matrix）。纯手工创建这样的图表很费工夫，所以seaborn提供了一个便捷的pairplot函数，它支持在对角线上放置每个变量的直方图或密度估计（见图9-25）：</p>
<pre><code class="language-python">In [107]: sns.pairplot(trans_data, diag_kind='kde', plot_kws={'alpha': 0.2})
</code></pre>
<figure data-type="image" tabindex="30"><img src="http://upload-images.jianshu.io/upload_images/7178691-20aa530a44e06f61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-25 statsmodels macro data的散布图矩阵" loading="lazy"></figure>
<p>你可能注意到了plot_kws参数。它可以让我们传递配置选项到非对角线元素上的图形使用。对于更详细的配置选项，可以查阅seaborn.pairplot文档字符串。</p>
<p>##分面网格（facet grid）和类型数据<br>
要是数据集有额外的分组维度呢？有多个分类变量的数据可视化的一种方法是使用小面网格。seaborn有一个有用的内置函数factorplot，可以简化制作多种分面图（见图9-26）：</p>
<pre><code class="language-python"> In [108]: sns.factorplot(x='day', y='tip_pct', hue='time', col='smoker',
   .....:                kind='bar', data=tips[tips.tip_pct &lt; 1])
</code></pre>
<figure data-type="image" tabindex="31"><img src="http://upload-images.jianshu.io/upload_images/7178691-737ba19a0cbdd46f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-26 按照天/时间/吸烟者的小费百分比" loading="lazy"></figure>
<p>除了在分面中用不同的颜色按时间分组，我们还可以通过给每个时间值添加一行来扩展分面网格：</p>
<pre><code class="language-python">In [109]: sns.factorplot(x='day', y='tip_pct', row='time',
   .....:                col='smoker',
   .....:                kind='bar', data=tips[tips.tip_pct &lt; 1])
</code></pre>
<figure data-type="image" tabindex="32"><img src="http://upload-images.jianshu.io/upload_images/7178691-4e52192441c609f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-27 按天的tip_pct，通过time/smoker分面" loading="lazy"></figure>
<p>factorplot支持其它的绘图类型，你可能会用到。例如，盒图（它可以显示中位数，四分位数，和异常值）就是一个有用的可视化类型（见图9-28）：</p>
<pre><code class="language-python">In [110]: sns.factorplot(x='tip_pct', y='day', kind='box',
   .....:                data=tips[tips.tip_pct &lt; 0.5])
</code></pre>
<figure data-type="image" tabindex="33"><img src="http://upload-images.jianshu.io/upload_images/7178691-356fb27a7c658920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图9-28 按天的tip_pct的盒图" loading="lazy"></figure>
<p>使用更通用的seaborn.FacetGrid类，你可以创建自己的分面网格。请查阅seaborn的文档（https://seaborn.pydata.org/）。</p>
<h1 id="93-其它的python可视化工具">9.3 其它的Python可视化工具</h1>
<p>与其它开源库类似，Python创建图形的方式非常多（根本罗列不完）。自从2010年，许多开发工作都集中在创建交互式图形以便在Web上发布。利用工具如Boken（https://bokeh.pydata.org/en/latest/）和Plotly（https://github.com/plotly/plotly.py），现在可以创建动态交互图形，用于网页浏览器。</p>
<p>对于创建用于打印或网页的静态图形，我建议默认使用matplotlib和附加的库，比如pandas和seaborn。对于其它数据可视化要求，学习其它的可用工具可能是有用的。我鼓励你探索绘图的生态系统，因为它将持续发展。</p>
<h1 id="94-总结">9.4 总结</h1>
<p>本章的目的是熟悉一些基本的数据可视化操作，使用pandas，matplotlib，和seaborn。如果视觉显示数据分析的结果对你的工作很重要，我鼓励你寻求更多的资源来了解更高效的数据可视化。这是一个活跃的研究领域，你可以通过在线和纸质的形式学习许多优秀的资源。</p>
<p>下一章，我们将重点放在pandas的数据聚合和分组操作上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pycharm常用快捷键及技巧(macOS)]]></title>
        <id>https://bailingnan.github.io/post/pycharm-chang-yong-kuai-jie-jian-ji-ji-qiao-macos/</id>
        <link href="https://bailingnan.github.io/post/pycharm-chang-yong-kuai-jie-jian-ji-ji-qiao-macos/">
        </link>
        <updated>2020-01-31T16:42:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mac键盘符号和修饰键说明">Mac键盘符号和修饰键说明</h1>
<ul>
<li><code>⌘</code>:Command</li>
<li><code>⇧</code>:Shift</li>
<li><code>⌥</code>:Option</li>
<li><code>⌃</code>:Control</li>
<li><code>↩︎</code>:Return/Enter</li>
<li><code>⌫</code>:Delete</li>
<li><code>⌦</code>:向前删除键（Fn+Delete）</li>
<li><code>↑</code>:上箭头</li>
<li><code>↓</code>:下箭头</li>
<li><code>←</code>:左箭头</li>
<li><code>→</code>:右箭头</li>
<li><code>⇞</code>:Page Up（Fn+↑）</li>
<li><code>⇟</code>:Page Down（Fn+↓）</li>
<li><code>Home</code>:Fn + ←</li>
<li><code>End</code>:Fn + →</li>
<li><code>⇥</code>:右制表符（Tab键）</li>
<li><code>⇤</code>:左制表符（Shift+Tab）</li>
<li><code>⎋</code>:Escape (Esc)</li>
<li>一直按住<code>fn</code>可调出F1~F10</li>
</ul>
<h1 id="editing编辑">Editing（编辑）</h1>
<ul>
<li><code>⌘Z</code>:撤销操作</li>
<li><code>⌘Y</code>:删除整行</li>
<li><code>⇧F6</code>:重命名文件</li>
<li><code>⌘S</code>:保存所有</li>
<li><code>⌦</code>:删除文件（Fn+Delete）</li>
<li><code>⌘⌥L</code>:格式化代码</li>
<li><code>Home</code>:Fn + ←，跳转到行首</li>
<li><code>End</code>:Fn + →，跳转到行末</li>
<li><code>⇧↑/⇧↓</code>:向上/向下选中行</li>
<li><code>⌘D</code>: 复制当前行或选定的块</li>
<li><code>⌘/</code>:注释/取消注释与行注释</li>
<li><code>⌘⌥/</code>:注释/取消注释与块注释</li>
<li><code>⌘J</code>:插入自定义动态代码模板</li>
<li><code>⌃Space</code>:基本的代码补全（补全任何类、方法、变量）</li>
<li><code>⌃⇧Space</code>:智能代码补全（过滤器方法列表和变量的预期类型）</li>
<li><code>⇧↩</code>:开始新的一行</li>
<li><code>⌘⇧U</code>:大小写切换,光标在行内任意位置都能另起一行，且不破坏当行结构</li>
<li><code>⌘⇧↩</code>:自动结束代码，行末自动添加分号</li>
<li><code>⌘P</code>:显示方法的参数信息</li>
<li><code>⌃J</code>:快速查看文档</li>
<li><code>⇧F1</code>:查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li>
<li><code>⌘F1</code>:在错误或警告处显示具体描述信息</li>
<li><code>⌘N, ⌃↩, ⌃N</code>:生成代码（getter、setter、构造函数、hashCode/equals,toString）</li>
<li><code>⌥↑</code>:连续选中代码块</li>
<li><code>⌥↓</code>:减少当前选中的代码块</li>
<li><code>⌥↩</code>:显示意向动作和快速修复代码</li>
<li><code>⌘⇧] / ⌘⇧[</code>:选择直到代码块结束/开始</li>
<li><code>⌘+ / ⌘-</code>:展开 / 折叠代码块</li>
<li><code>⌘⇧+</code>:展开所有代码块</li>
<li><code>⌘⇧-</code>:折叠所有代码块</li>
</ul>
<h1 id="searchreplace查询替换">Search/Replace（查询/替换）</h1>
<ul>
<li><code>Double ⇧</code>:查询任何东西</li>
<li><code>⌘F</code>:文件内查找</li>
</ul>
<h1 id="compile-and-run编译和运行">Compile and Run（编译和运行）</h1>
<ul>
<li><code>⌃⇧F10</code>:Run</li>
<li><code>⌃⇧F9</code>:Debug</li>
</ul>
<h1 id="navigation导航">Navigation（导航）</h1>
<ul>
<li><code>⌘B</code>:进入光标所在的方法/变量的接口或是定义处</li>
<li><code>⌘⌥B</code>:跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li>
<li><code>⌥ Space, ⌘Y</code>:快速打开光标所在方法、类的定义</li>
<li><code>⌃⇧B</code>:跳转到类型声明处</li>
<li><code>⌘U</code>:前往当前光标所在方法的父类的方法 / 接口定义</li>
<li><code>⌃H</code>:显示当前类的层次结构</li>
<li><code>⌘⇧H</code>:显示方法层次结构</li>
<li><code>⌃⌥H</code>:显示调用层次结构</li>
</ul>
<h1 id="调试">调试</h1>
<ul>
<li><code>step over</code>:在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，<strong>程序代码越过子函数，但子函数会执行，且不进入</strong>。</li>
<li><code>step into</code>:在单步执行时，遇到子函数就进入并且继续单步执行，<strong>有的会跳到源代码里面去执行</strong>。</li>
<li><code>step into my code</code>:在单步执行时，遇到子函数就进入并且继续单步执行，<strong>不会进入到源码中</strong>。</li>
<li><code>step out</code>:假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</li>
<li><code>Resume program</code>:继续恢复程序，直接运行到下一断点处。跳过不想看的地方，直接设置下一个断点，然后<code>Resume program</code>。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PyTorch常用代码段]]></title>
        <id>https://bailingnan.github.io/post/pytorch-chang-yong-dai-ma-duan/</id>
        <link href="https://bailingnan.github.io/post/pytorch-chang-yong-dai-ma-duan/">
        </link>
        <updated>2020-01-30T19:09:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1基本配置">1.基本配置</h1>
<h2 id="导入包和版本查询">导入包和版本查询</h2>
<pre><code class="language-Python">import torch
import torch.nn as nn
import torchvision
print(torch.__version__)# PyTorch version
print(torch.version.cuda)#Corresponding CUDA version
print(torch.backends.cudnn.version())#Corresponding cuDNN version
print(torch.cuda.get_device_name(0))#GPU type
</code></pre>
<h2 id="可复现性">可复现性</h2>
<p>在硬件设备（CPU、GPU）不同时，完全的可复现性无法保证，即使随机种子相同。但是，在同一个设备上，应该保证可复现性。具体做法是，在程序开始的时候固定torch的随机种子，同时也把numpy的随机种子固定。</p>
<pre><code class="language-Python">np.random.seed(0)
torch.manual_seed(0)
torch.cuda.manual_seed_all(0)
</code></pre>
<h2 id="显卡设置">显卡设置</h2>
<p>如果只需要一张显卡</p>
<pre><code class="language-Python"># Device configuration
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
</code></pre>
<p>如果需要指定多张显卡，比如0，1号显卡。</p>
<pre><code class="language-Python">import os
os.environ['CUDA_VISIBLE_DEVICES'] = '0,1'
</code></pre>
<p>也可以在命令行运行代码时设置显卡：</p>
<pre><code>CUDA_VISIBLE_DEVICES=0,1 python train.py
</code></pre>
<p>清除显存:</p>
<pre><code class="language-Python">torch.cuda.empty_cache()
</code></pre>
<p>也可以使用在命令行重置GPU的指令：</p>
<pre><code>nvidia-smi --gpu-reset -i [gpu_id]
</code></pre>
<p>或在命令行可以先使用ps找到程序的PID，再使用kill结束该进程</p>
<pre><code class="language-python">ps aux | grep python
kill -9 [pid]
</code></pre>
<h2 id="设置为cudnn-benchmark模式">设置为cuDNN benchmark模式</h2>
<p>Benchmark模式会提升计算速度，但是由于计算中有随机性，每次网络前馈结果略有差异。</p>
<pre><code class="language-python">torch.backends.cudnn.benchmark = True
</code></pre>
<p>如果想要避免这种结果波动，设置</p>
<pre><code class="language-python">torch.backends.cudnn.deterministic = True
</code></pre>
<h1 id="2张量tensor处理">2.张量(Tensor)处理</h1>
<h2 id="张量基本信息">张量基本信息</h2>
<pre><code class="language-Python">tensor = torch.randn(3,4,5)
print(tensor.type())  # 数据类型
print(tensor.size())  # 张量的shape，是个元组
print(tensor.dim())   # 维度的数量
</code></pre>
<h2 id="命名变量">命名变量</h2>
<pre><code class="language-Python"># 在PyTorch 1.3之前，需要使用注释
# Tensor[N, C, H, W]
images = torch.randn(32, 3, 56, 56)
images.sum(dim=1)
images.select(dim=1, index=0)

# PyTorch 1.3之后
NCHW = [‘N’, ‘C’, ‘H’, ‘W’]
images = torch.randn(32, 3, 56, 56, names=NCHW)
images.sum('C')
images.select('C', index=0)
# 也可以这么设置
tensor = torch.rand(3,4,1,2,names=('C', 'N', 'H', 'W'))
# 使用align_to可以对维度方便地排序
tensor = tensor.align_to('N', 'C', 'H', 'W')
</code></pre>
<h2 id="数据类型转换">数据类型转换</h2>
<pre><code class="language-Python"># 设置默认类型，pytorch中的FloatTensor远远快于DoubleTensor
torch.set_default_tensor_type(torch.FloatTensor)

# 类型转换
tensor = tensor.cuda()
tensor = tensor.cpu()
tensor = tensor.float()
tensor = tensor.long()
</code></pre>
<h2 id="torchtensor与npndarray转换">torch.Tensor与np.ndarray转换</h2>
<p>除了CharTensor，其他所有CPU上的张量都支持转换为numpy格式然后再转换回来。</p>
<pre><code class="language-Python">ndarray = tensor.cpu().numpy()
tensor = torch.from_numpy(ndarray).float()
tensor = torch.from_numpy(ndarray.copy()).float() # If ndarray has negative stride.
</code></pre>
<h2 id="从只包含一个元素的张量中提取值">从只包含一个元素的张量中提取值</h2>
<p><code>value = torch.rand(1).item()</code></p>
<h2 id="张量形变">张量形变</h2>
<pre><code class="language-Python"># 在将卷积层输入全连接层的情况下通常需要对张量做形变处理，
# 相比torch.view，torch.reshape可以自动处理输入张量不连续的情况。
tensor = torch.rand(2,3,4)
shape = (6, 4)
tensor = torch.reshape(tensor, shape)
</code></pre>
<h2 id="张量复制">张量复制</h2>
<pre><code class="language-Python"># Operation                 |  New/Shared memory | Still in computation graph |
tensor.clone()            # |        New         |          Yes               |
tensor.detach()           # |      Shared        |          No                |
tensor.detach.clone()()   # |        New         |          No                |
</code></pre>
<h2 id="张量拼接">张量拼接</h2>
<pre><code class="language-Python">'''
注意torch.cat和torch.stack的区别在于torch.cat沿着给定的维度拼接，
而torch.stack会新增一维。例如当参数是3个10x5的张量，torch.cat的结果是30x5的张量，
而torch.stack的结果是3x10x5的张量。
'''
tensor = torch.cat(list_of_tensors, dim=0)
tensor = torch.stack(list_of_tensors, dim=0)
</code></pre>
<h2 id="将整数标签转为one-hot编码">将整数标签转为one-hot编码</h2>
<pre><code class="language-python"># pytorch的标记默认从0开始
tensor = torch.tensor([0, 2, 1, 3])
N = tensor.size(0)
num_classes = 4
one_hot = torch.zeros(N, num_classes).long()
one_hot.scatter_(dim=1, index=torch.unsqueeze(tensor, dim=1), src=torch.ones(N, num_classes).long())
</code></pre>
<h2 id="得到非零元素">得到非零元素</h2>
<pre><code class="language-python">torch.nonzero(tensor)               # index of non-zero elements,包含点坐标的列表向量
torch.nonzero(tensor==0)            # index of zero elements
torch.nonzero(tensor).size(0)       # number of non-zero elements
torch.nonzero(tensor == 0).size(0)  # number of zero elements
</code></pre>
<h2 id="判断两个张量相等">判断两个张量相等</h2>
<pre><code class="language-Python">torch.allclose(tensor1, tensor2)  # float tensor
torch.equal(tensor1, tensor2)     # int tensor
</code></pre>
<h2 id="张量扩展">张量扩展</h2>
<pre><code class="language-python"># Expand tensor of shape 64*512 to shape 64*512*7*7.
tensor = torch.rand(64,512)
torch.reshape(tensor, (64, 512, 1, 1)).expand(64, 512, 7, 7)
</code></pre>
<h2 id="矩阵乘法">矩阵乘法</h2>
<pre><code class="language-python"># Matrix multiplcation: (m*n) * (n*p) * -&gt; (m*p).
result = torch.mm(tensor1, tensor2)

# Batch matrix multiplication: (b*m*n) * (b*n*p) -&gt; (b*m*p)
result = torch.bmm(tensor1, tensor2)

# Element-wise multiplication.
result = tensor1 * tensor2
</code></pre>
<h2 id="计算两组数据之间的两两欧式距离">计算两组数据之间的两两欧式距离</h2>
<p>利用broadcast机制</p>
<pre><code class="language-python">dist = torch.sqrt(torch.sum((X1[:,None,:] - X2) ** 2, dim=2))
</code></pre>
<h1 id="3模型定义和操作">3.模型定义和操作</h1>
<h2 id="计算模型整体参数量">计算模型整体参数量</h2>
<pre><code class="language-python">num_parameters = sum(torch.numel(parameter) for parameter in model.parameters())
</code></pre>
<h2 id="查看网络中的参数">查看网络中的参数</h2>
<p>可以通过model.state_dict()或者model.named_parameters()函数查看现在的全部可训练参数（包括通过继承得到的父类中的参数）</p>
<pre><code class="language-python">params = list(model.named_parameters())
(name, param) = params[28]
print(name)
print(param.grad)
print('-------------------------------------------------')
(name2, param2) = params[29]
print(name2)
print(param2.grad)
print('----------------------------------------------------')
(name1, param1) = params[30]
print(name1)
print(param1.grad)
</code></pre>
<h2 id="类似-keras-的-modelsummary-输出模型信息使用pytorch-summary">类似 Keras 的 model.summary() 输出模型信息（使用pytorch-summary ）</h2>
<h2 id="模型权重初始化">模型权重初始化</h2>
<p>注意 model.modules() 和 model.children() 的区别：model.modules() 会迭代地遍历模型的所有子层，而 model.children() 只会遍历模型下的一层。</p>
<pre><code class="language-python"># Common practise for initialization.
for layer in model.modules():
    if isinstance(layer, torch.nn.Conv2d):
        torch.nn.init.kaiming_normal_(layer.weight, mode='fan_out',
                                      nonlinearity='relu')
        if layer.bias is not None:
            torch.nn.init.constant_(layer.bias, val=0.0)
    elif isinstance(layer, torch.nn.BatchNorm2d):
        torch.nn.init.constant_(layer.weight, val=1.0)
        torch.nn.init.constant_(layer.bias, val=0.0)
    elif isinstance(layer, torch.nn.Linear):
        torch.nn.init.xavier_normal_(layer.weight)
        if layer.bias is not None:
            torch.nn.init.constant_(layer.bias, val=0.0)

# Initialization with given tensor.
layer.weight = torch.nn.Parameter(tensor)
</code></pre>
<h2 id="提取模型中的某一层">提取模型中的某一层</h2>
<p>modules()会返回模型中所有模块的迭代器，它能够访问到最内层，比如self.layer1.conv1这个模块，还有一个与它们相对应的是name_children()属性以及named_modules(),这两个不仅会返回模块的迭代器，还会返回网络层的名字。</p>
<pre><code class="language-python"># 取模型中的前两层
new_model = nn.Sequential(*list(model.children())[:2] 
# 如果希望提取出模型中的所有卷积层，可以像下面这样操作：
for layer in model.named_modules():
    if isinstance(layer[1],nn.Conv2d):
         conv_model.add_module(layer[0],layer[1])
</code></pre>
<h2 id="部分层使用预训练模型">部分层使用预训练模型</h2>
<p>注意如果保存的模型是 torch.nn.DataParallel，则当前的模型也需要是</p>
<pre><code class="language-python">model.load_state_dict(torch.load('model.pth'), strict=False)
</code></pre>
<h1 id="4模型训练和测试">4.模型训练和测试</h1>
<h2 id="自定义loss">自定义loss</h2>
<p>继承torch.nn.Module类写自己的loss。</p>
<pre><code class="language-python">class MyLoss(torch.nn.Moudle):
    def __init__(self):
        super(MyLoss, self).__init__()
        
    def forward(self, x, y):
        loss = torch.mean((x - y) ** 2)
        return loss
</code></pre>
<h2 id="标签平滑label-smoothing">标签平滑（label smoothing）</h2>
<p>写一个label_smoothing.py的文件，然后在训练代码里引用，用LSR代替交叉熵损失即可。label_smoothing.py内容如下：</p>
<pre><code class="language-python">import torch
import torch.nn as nn


class LSR(nn.Module):

    def __init__(self, e=0.1, reduction='mean'):
        super().__init__()

        self.log_softmax = nn.LogSoftmax(dim=1)
        self.e = e
        self.reduction = reduction
    
    def _one_hot(self, labels, classes, value=1):
        &quot;&quot;&quot;
            Convert labels to one hot vectors
        
        Args:
            labels: torch tensor in format [label1, label2, label3, ...]
            classes: int, number of classes
            value: label value in one hot vector, default to 1
        
        Returns:
            return one hot format labels in shape [batchsize, classes]
        &quot;&quot;&quot;

        one_hot = torch.zeros(labels.size(0), classes)

        #labels and value_added  size must match
        labels = labels.view(labels.size(0), -1)
        value_added = torch.Tensor(labels.size(0), 1).fill_(value)

        value_added = value_added.to(labels.device)
        one_hot = one_hot.to(labels.device)

        one_hot.scatter_add_(1, labels, value_added)

        return one_hot

    def _smooth_label(self, target, length, smooth_factor):
        &quot;&quot;&quot;convert targets to one-hot format, and smooth
        them.
        Args:
            target: target in form with [label1, label2, label_batchsize]
            length: length of one-hot format(number of classes)
            smooth_factor: smooth factor for label smooth
        
        Returns:
            smoothed labels in one hot format
        &quot;&quot;&quot;
        one_hot = self._one_hot(target, length, value=1 - smooth_factor)
        one_hot += smooth_factor / (length - 1)

        return one_hot.to(target.device)

    def forward(self, x, target):

        if x.size(0) != target.size(0):
            raise ValueError('Expected input batchsize ({}) to match target batch_size({})'
                    .format(x.size(0), target.size(0)))

        if x.dim() &lt; 2:
            raise ValueError('Expected input tensor to have least 2 dimensions(got {})'
                    .format(x.size(0)))

        if x.dim() != 2:
            raise ValueError('Only 2 dimension tensor are implemented, (got {})'
                    .format(x.size()))


        smoothed_target = self._smooth_label(target, x.size(1), self.e)
        x = self.log_softmax(x)
        loss = torch.sum(- x * smoothed_target, dim=1)

        if self.reduction == 'none':
            return loss
        
        elif self.reduction == 'sum':
            return torch.sum(loss)
        
        elif self.reduction == 'mean':
            return torch.mean(loss)
        
        else:
            raise ValueError('unrecognized option, expect reduction to be one of none, mean, sum')
</code></pre>
<p>或者直接在训练文件里做label smoothing</p>
<pre><code class="language-python">for images, labels in train_loader:
    images, labels = images.cuda(), labels.cuda()
    N = labels.size(0)
    # C is the number of classes.
    smoothed_labels = torch.full(size=(N, C), fill_value=0.1 / (C - 1)).cuda()
    smoothed_labels.scatter_(dim=1, index=torch.unsqueeze(labels, dim=1), value=0.9)

    score = model(images)
    log_prob = torch.nn.functional.log_softmax(score, dim=1)
    loss = -torch.sum(log_prob * smoothed_labels) / N
    optimizer.zero_grad()
    loss.backward()
    optimizer.step()    
</code></pre>
<h2 id="l1-正则化">L1 正则化</h2>
<pre><code class="language-python">l1_regularization = torch.nn.L1Loss(reduction='sum')
loss = ...  # Standard cross-entropy loss
for param in model.parameters():
    loss += torch.sum(torch.abs(param))
loss.backward()
</code></pre>
<h2 id="不对偏置项进行权重衰减weight-decay">不对偏置项进行权重衰减（weight decay）</h2>
<p>pytorch里的weight decay相当于l2正则</p>
<pre><code class="language-python">bias_list = (param for name, param in model.named_parameters() if name[-4:] == 'bias')
others_list = (param for name, param in model.named_parameters() if name[-4:] != 'bias')
parameters = [{'parameters': bias_list, 'weight_decay': 0},                
              {'parameters': others_list}]
optimizer = torch.optim.SGD(parameters, lr=1e-2, momentum=0.9, weight_decay=1e-4)
</code></pre>
<h2 id="梯度裁剪gradient-clipping">梯度裁剪（gradient clipping）</h2>
<pre><code class="language-python">torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=20)
</code></pre>
<h2 id="得到当前学习率">得到当前学习率</h2>
<pre><code class="language-python"># If there is one global learning rate (which is the common case).
lr = next(iter(optimizer.param_groups))['lr']

# If there are multiple learning rates for different layers.
all_lr = []
for param_group in optimizer.param_groups:
    all_lr.append(param_group['lr'])
</code></pre>
<p>另一种方法，在一个batch训练代码里，当前的lr是</p>
<pre><code class="language-python">optimizer.param_groups[0]['lr']
</code></pre>
<h2 id="学习率衰减">学习率衰减</h2>
<pre><code class="language-python"># Reduce learning rate when validation accuarcy plateau.
scheduler = torch.optim.lr_scheduler.ReduceLROnPlateau(optimizer, mode='max', patience=5, verbose=True)
for t in range(0, 80):
    train(...)
    val(...)
    scheduler.step(val_acc)

# Cosine annealing learning rate.
scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=80)
# Reduce learning rate by 10 at given epochs.
scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[50, 70], gamma=0.1)
for t in range(0, 80):
    scheduler.step()    
    train(...)
    val(...)

# Learning rate warmup by 10 epochs.
scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda t: t / 10)
for t in range(0, 10):
    scheduler.step()
    train(...)
    val(...)
</code></pre>
<h2 id="优化器链式更新">优化器链式更新</h2>
<p>从1.4版本开始，<code>torch.optim.lr_scheduler</code> 支持链式更新（chaining），即用户可以定义两个 schedulers，并交替在训练中使用。</p>
<pre><code class="language-python">import torch
from torch.optim import SGD
from torch.optim.lr_scheduler import ExponentialLR, StepLR
model = [torch.nn.Parameter(torch.randn(2, 2, requires_grad=True))]
optimizer = SGD(model, 0.1)
scheduler1 = ExponentialLR(optimizer, gamma=0.9)
scheduler2 = StepLR(optimizer, step_size=3, gamma=0.1)
for epoch in range(4):
    print(epoch, scheduler2.get_last_lr()[0])
    optimizer.step()
    scheduler1.step()
    scheduler2.step()
</code></pre>
<h2 id="模型训练可视化">模型训练可视化</h2>
<p>PyTorch可以使用tensorboard来可视化训练过程。<br>
安装和运行TensorBoard。</p>
<pre><code class="language-python">pip install tensorboard
tensorboard --logdir=runs
</code></pre>
<p>使用SummaryWriter类来收集和可视化相应的数据，放了方便查看，可以使用不同的文件夹，比如'Loss/train'和'Loss/test'。</p>
<pre><code class="language-python">from torch.utils.tensorboard import SummaryWriter
import numpy as np

writer = SummaryWriter()

for n_iter in range(100):
    writer.add_scalar('Loss/train', np.random.random(), n_iter)
    writer.add_scalar('Loss/test', np.random.random(), n_iter)
    writer.add_scalar('Accuracy/train', np.random.random(), n_iter)
    writer.add_scalar('Accuracy/test', np.random.random(), n_iter)
</code></pre>
<h2 id="保存与加载断点">保存与加载断点</h2>
<p>注意为了能够恢复训练，我们需要同时保存模型和优化器的状态，以及当前的训练轮数。</p>
<pre><code class="language-python">start_epoch = 0
# Load checkpoint.
if resume: # resume为参数，第一次训练时设为0，中断再训练时设为1
    model_path = os.path.join('model', 'best_checkpoint.pth.tar')
    assert os.path.isfile(model_path)
    checkpoint = torch.load(model_path)
    best_acc = checkpoint['best_acc']
    start_epoch = checkpoint['epoch']
    model.load_state_dict(checkpoint['model'])
    optimizer.load_state_dict(checkpoint['optimizer'])
    print('Load checkpoint at epoch {}.'.format(start_epoch))
    print('Best accuracy so far {}.'.format(best_acc))

# Train the model
for epoch in range(start_epoch, num_epochs): 
    ... 

    # Test the model
    ...
        
    # save checkpoint
    is_best = current_acc &gt; best_acc
    best_acc = max(current_acc, best_acc)
    checkpoint = {
        'best_acc': best_acc,
        'epoch': epoch + 1,
        'model': model.state_dict(),
        'optimizer': optimizer.state_dict(),
    }
    model_path = os.path.join('model', 'checkpoint.pth.tar')
    best_model_path = os.path.join('model', 'best_checkpoint.pth.tar')
    torch.save(checkpoint, model_path)
    if is_best:
        shutil.copy(model_path, best_model_path)
</code></pre>
<h1 id="5其他注意事项">5.其他注意事项</h1>
<ol>
<li>建议有参数的层和汇合（pooling）层使用<code>torch.nn</code>模块定义，激活函数直接使用<code>torch.nn.functional。torch.nn</code>模块和<code>torch.nn.functional</code>的区别在于，<code>torch.nn</code>模块在计算时底层调用了<code>torch.nn.functional</code>，但<code>torch.nn</code>模块包括该层参数，还可以应对训练和测试两种网络状态。使用<code>torch.nn.functional</code>时要注意网络状态，如</li>
</ol>
<pre><code class="language-python">def forward(self, x):
  ...
  x = torch.nn.functional.dropout(x, p=0.5, training=self.training)
</code></pre>
<ol start="2">
<li>不要使用太大的线性层。因为nn.Linear(m,n)使用的是O(mn)的内存，线性层太大很容易超出现有显存。</li>
<li>不要在太长的序列上使用RNN。因为RNN反向传播使用的是BPTT算法，其需要的内存和输入序列的长度呈线性关系。</li>
<li>model(x) 前用 <code>model.train()</code> 和 <code>model.eval()</code> 切换网络状态。</li>
<li>不需要计算梯度的代码块用 with torch.no_grad() 包含起来。</li>
<li><code>model.eval()</code> 和 <code>torch.no_grad()</code> 的区别在于，<code>model.eval()</code> 是将网络切换为测试状态，例如 BN 和dropout在训练和测试阶段使用不同的计算方法。<code>torch.no_grad()</code>是关闭 PyTorch 张量的自动求导机制，以减少存储使用和加速计算，得到的结果无法进行 <code>loss.backward()</code>。</li>
<li><code>model.zero_grad()</code>会把整个模型的参数的梯度都归零, 而<code>optimizer.zero_grad()</code>只会把传入其中的参数的梯度归零。</li>
<li>torch.nn.CrossEntropyLoss 的输入不需要经过 Softmax。torch.nn.CrossEntropyLoss 等价于 torch.nn.functional.log_softmax + torch.nn.NLLLoss。</li>
<li><code>loss.backward()</code>前用 <code>optimizer.zero_grad()</code> 清除累积梯度。</li>
<li><code>torch.utils.data.DataLoader</code> 中尽量设置 <code>pin_memory=True</code>，对特别小的数据集如 MNIST 设置 <code>pin_memory=False</code> 反而更快一些。<code>num_workers</code> 的设置需要在实验中找到最快的取值。</li>
<li>用 <code>del</code>及时删除不用的中间变量，节约 GPU 存储。</li>
<li>使用 <code>inplace</code> 操作可节约 GPU 存储，如</li>
</ol>
<pre><code class="language-python">x = torch.nn.functional.relu(x, inplace=True)
</code></pre>
<ol start="13">
<li>减少 CPU 和 GPU 之间的数据传输。例如如果你想知道一个 epoch 中每个 mini-batch 的 loss 和准确率，先将它们累积在 GPU 中等一个 epoch 结束之后一起传输回 CPU 会比每个 mini-batch 都进行一次 GPU 到 CPU 的传输更快。</li>
<li>使用半精度浮点数 <code>half()</code>会有一定的速度提升，具体效率依赖于 GPU 型号。需要小心数值精度过低带来的稳定性问题。</li>
<li>时常使用 <code>assert tensor.size() == (N, D, H, W)</code> 作为调试手段，确保张量维度和你设想中一致。</li>
<li>除了标记 y 外，尽量少使用一维张量，使用 n*1 的二维张量代替，可以避免一些意想不到的一维张量计算结果。</li>
<li>统计代码各部分耗时</li>
</ol>
<pre><code class="language-python">with torch.autograd.profiler.profile(enabled=True, use_cuda=False) as profile:
    ...
print(profile)

# 或者在命令行运行
python -m torch.utils.bottleneck main.py
</code></pre>
<ol start="18">
<li>使用TorchSnooper来调试PyTorch代码，程序在执行的时候，就会自动 print 出来每一行的执行结果的 tensor 的形状、数据类型、设备、是否需要梯度的信息。</li>
</ol>
<pre><code class="language-python"># pip install torchsnooper
import torchsnooper

# 对于函数，使用修饰器
@torchsnooper.snoop()

# 如果不是函数，使用 with 语句来激活 TorchSnooper，把训练的那个循环装进 with 语句中去。
with torchsnooper.snoop():
    原本的代码
</code></pre>
<ol start="19">
<li>模型可解释性，使用captum库</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令]]></title>
        <id>https://bailingnan.github.io/post/linux-chang-yong-ming-ling/</id>
        <link href="https://bailingnan.github.io/post/linux-chang-yong-ming-ling/">
        </link>
        <updated>2020-01-22T08:16:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-linux文件与目录">一、Linux文件与目录</h1>
<ul>
<li>
<h2 id="11-linux文件权限概念">1.1 Linux文件权限概念</h2>
<ul>
<li>切换至root身份:<code>su -</code></li>
<li>离开root身份:<code>exit</code></li>
<li>文件名第一个字符为.的文件为隐藏文件</li>
</ul>
</li>
<li>
<h2 id="12-linux目录配置">1.2 Linux目录配置</h2>
</li>
<li>
<p>FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已，分别是下面这三个目录的定义：</p>
<ul>
<li><code>/</code>（root, 根目录）:与开机系统有关；</li>
<li><code>/usr</code> （unix software resource）:与软件安装/执行有关；</li>
<li><code>/var</code>（variable）:与系统运行过程有关。</li>
</ul>
</li>
<li>
<p>FHS要求根目录中必须存在的目录:</p>
<ul>
<li>
<p><code>/bin</code>:系统有很多放置可执行文件的目录，但<code>/bin</code>比较特殊。因为<code>/bin</code>放置的是在 单人维护模式下还能够被操作的指令。 在<code>/bin</code>下面的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</p>
</li>
<li>
<p><code>/boot</code>:主要在放置开机会使用到的文件，包括 Linux 核心文件以及开机菜单与开机所需配置文件等等Linux kernel 常用的文件名为：vmlinuz，如果使用的是 grub2 这个开机管理程序， 则还会存在<code>/boot/grub2/</code>这个目录。</p>
</li>
<li>
<p><code>/dev</code>:存放硬件相关的文件。在 Linux 系统上，任何设备与周边设备都是以文件的型态存在于这个目录当中的。你只要通过存取这个目录下面的某个文件，就等于存取某个设备。比要重要的文件有<code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/tty</code>, <code>/dev/loop</code>, <code>/dev/sd</code>等等。</p>
</li>
<li>
<p><code>/etc</code>:存放配置文件的目录。系统主要的配置文件几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，但是只有 root 有权力修改。FHS建议不要放置可执行文件 （binary）在这个目录中喔。比较重要的文件有： <code>/etc/modprobe.d/</code>, <code>/etc/passwd</code>, <code>/etc/fstab</code>, <code>/etc/issue</code>等等。另外 FHS 还规范几个重要的目录最好要存在 <code>/etc/</code>目录下：</p>
<ul>
<li><code>/etc/opt</code>（必要）：这个目录在放置第三方协力软件 <code>/opt</code> 的相关配置文件。</li>
<li><code>/etc/X11/</code>（建议）：与 X Window 有关的各种配置文件都在这里，尤其是 xorg.conf 这个 X Server 的配置文件。</li>
<li><code>/etc/sgml/</code>（建议）：与 SGML 格式有关的各项配置文件。</li>
<li><code>/etc/xml/</code>（建议）：与 XML 格式有关的各项配置文件。</li>
</ul>
</li>
<li>
<p><code>/lib</code>:系统的函数库非常的多，而<code>/lib</code>放置的则是在开机时会用到的函数库， 以及 在<code>/bin</code>或<code>/sbin</code>下面的指令会调用的函数库而已。 什么是函数库呢？你可以将 他想成是“外挂”，某些指令必须要有这些“外挂”才能够顺利完成程序的执行 之意。 另外 FSH 还要求下面的目录必须要存在：<code>/lib/modules/</code>：这个目录 主要放置可抽换式的核心相关模块（驱动程序）</p>
</li>
<li>
<p><code>/media</code>:media是“媒体”的英文，顾名思义，这个<code>/media</code>下面放置的就是可移除的设备！ 包括软盘、光盘、DVD等等设备都暂时挂载于此。常见的文件名 有：<code>/media/floppy</code>, <code>/media/cdrom</code>等等。</p>
</li>
<li>
<p><code>/mnt</code>:如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在古早时候，这个目录的用途与<code>/media</code>相同啦！只是有了<code>/media</code>之后，这个 目录就用来暂时挂载用了。</p>
</li>
<li>
<p><code>/opt</code>:这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE 这个桌面管理系统是一个独立的计划，不过他可以安装到 Linux 系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的 distribution 提供的），那么也能够将你的软件安装到这里来。 不过，以前的 Linux 系统中，我们还是习惯放置在<code>/usr/local</code>目录下呢！</p>
</li>
<li>
<p><code>/run</code>:早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 <code>/var/run</code> 目录下，新版的 FHS 则规范到 <code>/run</code> 下面。 由于 <code>/run</code> 可以使用内存来仿真，因此性能上会好很多！</p>
</li>
<li>
<p><code>/sbin</code>:存放管理员root可以执行的命令。Linux 有非常多指令是用来设置系统环境的，这些指令只有 root 才能够利用 来“设置”系统，其他使用者最多只能用来“查询”而已。放在<code>/sbin</code>下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些服务器软件程序，一般则放置到<code>/usr/sbin/</code>当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到<code>/usr/local/sbin/</code> 当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</p>
</li>
<li>
<p><code>/srv</code>:srv 可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如 WWW, FTP 等等。举例来说，WWW 服务器需要的网页数据就可以放置在<code>/srv/www/</code>里面。 不过，系统的服务数据 如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 <code>/var/lib</code>下面即可。</p>
</li>
<li>
<p><code>tem</code>:这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将<code>/tmp</code>下的数据都删除唷!</p>
</li>
<li>
<p><code>/var</code>:第二层 FHS 设置，主要为放置变动性的数据，后续介绍。</p>
</li>
<li>
<p><code>/usr</code>:第二层 FHS 设置，后续介绍。</p>
</li>
</ul>
</li>
<li>
<p>FHS 建议根目录中可以存在的目录：</p>
<ul>
<li><code>/home</code>：这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使 用者帐号时，默认的使用者主文件夹都会规范到这里来。</li>
<li><code>/lib&lt;equal&gt;</code>:用来存放与 <code>/lib</code> 不同的格式的二进制函数库，例如支持 64 位的 <code>/lib64</code> 函数库等。</li>
<li><code>/root</code>:系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有 root 的主文件夹，所以我们会 希望 root 的主文件夹与根目录放置在同一个分区中。</li>
<li><code>/lost+found</code>:这个目录是使用标准的 ext2/ext3/ext4 文件系统格式才会产生的一个目录， 目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。 不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li>
<li><code>/proc</code>:这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：<code>/proc/cpuinfo</code>, <code>/proc/dma</code>, <code>/proc/interrupts</code>, <code>/proc/ioports</code>, <code>/proc/net/*</code> 等等。</li>
<li><code>/sys</code>:这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录 核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li>
</ul>
</li>
<li>
<p>因为是所有系统默认的软件（distribution发布者提供的软件）都会放置到<code>/usr</code>下面，因此这个目录有点类似 Windows 系统的“C:\Windows\ （当中的一部份） + C:\Program files\”这两个目 录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。一般来说，<code>/usr</code>的次目录 建议有下面这些：</p>
</li>
<li>
<p>FHS 要求必须要存在的目录:</p>
<ul>
<li><code>/usr/bin/</code>:所有一般用户能够使用的指令都放在这里！<code>/usr/bin</code> 与 <code>/bin</code> 是一模一样了！另外，FHS 要求在此目录下不应该有子目录！</li>
<li><code>/usr/lib/</code>:基本上，与 <code>/lib</code> 功能相同，所以 <code>/lib</code> 就是链接到此目录中的！</li>
<li><code>/usr/local/</code>:系统管理员在本机自行安装自己下载的软件（非 distribution 默认提供者），建议安装到此目录， 这样会比较便于管理。举例来说，你的 distribution 提供的软件较旧，你想安装较新的软件但又不想移除旧版，此时你可以将新版软件安装于<code>/usr/local/</code>目录下，可与原先的旧版软件有分别啦！ 你可以自行到<code>/usr/local</code>去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！</li>
<li><code>/usr/sbin/</code>:非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件 的服务指令（daemon）啰！不过基本功能与 <code>/sbin</code> 也差不多， 因此目前 <code>/sbin</code> 就是链接到此目录中的。</li>
<li><code>/usr/share/</code>:主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据，因为几乎都是文字文件嘛！在此目录下常见的还有这些次目录：
<ul>
<li><code>/usr/share/man</code>：线上说明文档。</li>
<li><code>/usr/share/doc</code>：软件杂项的文件说明。</li>
<li><code>/usr/share/zoneinfo</code>：与时区有关的时区文件。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>FHS 建议可以存在的目录：</p>
<ul>
<li><code>/usr/games/</code>:与游戏比较相关的数据放置处。</li>
<li><code>/usr/include/</code>:c/c++等程序语言的文件开始（header）与包含档（include）放置处， 当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！</li>
<li><code>/usr/libexec/</code>:某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放 置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。</li>
<li><code>/usr/lib&lt;qual&gt;/</code>:与 <code>/lib&lt;qual&gt;/</code>功能相同，因此目前 <code>/lib&lt;qual&gt;</code> 就是链接到此目录中。</li>
<li><code>/usr/src/</code>:一般源代码建议放置到这里，src有source的意思。至于核心源代码则建议放置到<code>/usr/src/linux/</code>目录下。</li>
</ul>
</li>
<li>
<p>如果<code>/usr</code>是安装时会占用较大硬盘容量的目录，那么<code>/var</code>就是在系统运行后才会渐渐占用硬盘容量的目录。 因为<code>/var</code>目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件 （log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如 MySQL数据库的文件等等。常见的次目录有：</p>
</li>
<li>
<p>FHS 要求必须要存在的目录:</p>
<ul>
<li><code>/var/cache/</code>:应用程序本身运行过程中会产生的一些暂存盘；</li>
<li><code>/var/lib/</code>:程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。举例来说，MySQL的数据库放置 到<code>/var/lib/mysql/</code>而rpm的数据库则放到<code>/var/lib/rpm</code>去！</li>
<li><code>/var/lock/</code>:某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时，就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。目前此目录也已经挪到 <code>/run/lock</code>中！</li>
<li><code>/var/log/</code>:重要到不行！这是登录文件放置的目录！里面比较重要的文件 如<code>/var/log/messages</code>, <code>/var/log/wtmp</code>（记录登陆者的信息）等。</li>
<li><code>/var/mail/</code>:放置个人电子邮件信箱的目录，不过这个目录也被放置到<code>/var/spool/mail/</code> 目录中！ 通常这两个目录是互为链接文件啦！</li>
<li><code>/var/run/</code>:某些程序或者是服务启动后，会将他们的PID放置在这个目录下喔！至于 PID的意义我们会在后续章节提到的。与 <code>/run</code> 相同，这个目录链接到 <code>/run</code> 去了！</li>
<li><code>/var/spool/</code>:这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到<code>/var/spool/mail/</code>中， 但使用者收下该信件后该封信原则上就会 被删除。信件如果暂时寄不出去会被放到<code>/var/spool/mqueue/</code>中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到<code>/var/spool/cron/</code>目录中！</li>
</ul>
</li>
<li>
<h2 id="13-文件与目录管理">1.3 文件与目录管理</h2>
<ul>
<li>
<p>网络文件常常提到类似“./run.sh”之类的数据，这个指令的意义为何？答：由于指令的执行需要变量（bash章节才会提到）的支持，若你的可执行文件放置在本目录，并且本目录并非正规的可执行文件目录（/bin, /usr/bin等为正规），此时要执行指令就得要严格指定该可执行文件。“./”代表“本目录”的意思，所以“./run.sh”代表“执行本目录下，名为run.sh的文件”。</p>
</li>
<li>
<p>cd （change directory, 变换目录）</p>
<ul>
<li><code>cd ~dmtsai</code>: 代表去到 dmtsai 这个使用者的主文件夹，亦即 <code>/home/dmtsai</code></li>
<li><code>cd ~</code>:表示回到自己的主文件夹，亦即是 <code>/root</code> 这个目录</li>
<li><code>cd</code>:没有加上任何路径，也还是代表回到自己主文件夹的意思</li>
<li><code>cd ..</code>:表示去到目前的上层目录</li>
<li><code>cd -</code>:表示回到刚刚的那个目录</li>
<li><code>cd ../postfix</code>:由<code>/var/spool/mail</code> 去到<code>/var/spool/postfix</code></li>
</ul>
</li>
<li>
<p>一登陆Linux系统后，每个帐号都会在自己帐号的主文件夹中(<code>/home</code>)。</p>
</li>
<li>
<p>pwd （显示目前所在的目录）</p>
<ul>
<li><code>pwd [-P]</code>😛 ：显示出确实的路径，而非使用链接 （link） 路径。加上 <code>pwd -P</code> 的选项后，会不以链接文件的数据显示，而是显示正确的完整路径。</li>
<li><code>pwd</code>:单纯显示出目前的工作目录。</li>
</ul>
</li>
<li>
<p>mkdir （创建新目录）</p>
<ul>
<li><code>mkdir [-mp] 目录名称</code>:
<ul>
<li><code>-m</code> ：设置文件的权限喔！直接设置，不需要看默认权限 （umask） 的脸色～</li>
<li><code>-p</code> ：帮助你直接将所需要的目录（包含上层目录）递回创建起来！</li>
<li>示例:
<ul>
<li><code>mkdir test1/test2/test3/test4</code>:错误。mkdir: cannot create directory ‘test1/test2/test3/test4’: No such file or directory</li>
<li><code>mkdir -p test1/test2/test3/test4</code>:正确。</li>
</ul>
</li>
</ul>
</li>
<li>rmdir （删除“空”的目录）
<ul>
<li><code>rmdir [-p] 目录名称</code>:
<ul>
<li><code>-p</code> ：连同“上层”“空的”目录也一起删除。</li>
</ul>
</li>
<li>示例:
<ul>
<li><code>rmdir test1</code>:rmdir: failed to remove ‘test1’: Directory not empty</li>
<li><code>rmdir -p test1/test2/test3/test4</code>:利用 <code>-p</code> 这个选项，立刻就可以将 <code>test1/test2/test3/test4</code> 一次删除,包括test1</li>
<li>如果要将非空目录下的东西都杀掉呢？！ 这个时候就必须使用<code>rm -r 目录名称</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件与目录的检视： ls</p>
<ul>
<li><code>ls [-aAdfFhilnrRSt] 文件名或目录名称</code>
<ul>
<li><code>-a</code> ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）</li>
<li><code>-d</code> ：仅列出目录本身，而不是列出目录内的文件数据（常用）</li>
<li><code>-l</code> ：长数据串行出，包含文件的属性与权限等等数据（常用）</li>
<li>示例：
<ul>
<li><code>ls -al ~</code>: 将主文件夹下的所有文件列出来（含属性与隐藏文件）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>cp （复制文件或目录）</p>
<ul>
<li><code>cp [-adfilprsu] 来源文件（source） 目标文件（destination）</code></li>
<li><code>cp [options] source1 source2 source3 .... directory</code>
<ul>
<li><code>-a</code> ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）</li>
<li><code>-i</code> ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）</li>
<li><code>-r</code> ：递回持续复制，用于目录的复制行为；（常用）</li>
<li><code>-p</code> ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；</li>
<li><code>--preserve=all</code> ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。</li>
<li>如果来源文件有两个以上，则最后一个目的文件一定要是“目录”才行！</li>
<li>如果目标目录或者目标文件不存在，则相当于重命名。</li>
<li>示例
<ul>
<li><code>cp ~/.bashrc /tmp/bashrc</code>:将主文件夹下的 .bashrc 复制到 <code>/tmp</code> 下，并更名为 bashrc</li>
<li><code>cp -i ~/.bashrc /tmp/bashrc</code>:cp: overwrite <code>/tmp/bashrc'? n不覆盖，y为覆盖，重复作两次动作，由于</code>/tmp<code>下面已经存在 bashrc 了，加上</code>-i` 选项后，则在覆盖前会询问使用者是否确定！可以按下 n 或者 y 来二次确认</li>
<li><code>cp /var/log/wtmp .</code>:复制到当前目录</li>
<li><code>cp /etc/ /tmp</code>:复制 <code>/etc/</code> 这个目录下的所有内容到 <code>/tmp</code> 下面，cp: omitting directory <code>/etc</code>，如果是目录则不能直接复制，要加上 <code>-r</code> 的选项</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>rm （移除文件或目录）</p>
<ul>
<li><code>rm [-fir] 文件或目录</code>：
<ul>
<li><code>-f</code> ：就是 force 的意思，忽略不存在的文件，不会出现警告讯息；</li>
<li><code>-r</code> ：递回删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
<li><code>-rf</code>: 如子目录里面还有子目录时，那就要使用 -r 这个选项</li>
<li><code>-rf/</code>: 会将系统文件全部删除，非常危险  <s>删库跑路</s></li>
<li>示例：
<ul>
<li><code>rm bashrc*</code>:通过万用字符*的帮忙，将<code>/tmp</code>下面开头为bashrc的文件名通通删除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>mv （移动文件与目录，或更名）</p>
<ul>
<li><code>mv [-fiu] source destination</code></li>
<li><code>mv [options] source1 source2 source3 .... directory</code>
<ul>
<li><code>-f</code> ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li><code>-i</code> ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！</li>
<li><code>-u</code> ：若目标文件已经存在，且 source 比较新，才会更新 （update）</li>
<li>示例:
<ul>
<li>复制一文件，创建一目录，将文件移动到目录中：
<ul>
<li><code>cd /tmp</code></li>
<li><code>cp ~/.bashrc bashrc</code></li>
<li><code>mkdir mvtest</code></li>
<li><code>mv bashrc mvtest</code></li>
</ul>
</li>
<li>文件改名：
<ul>
<li><code>mv mvtest mvtest2</code></li>
</ul>
</li>
<li>再创建两个文件，再全部移动到 <code>/tmp/mvtest2</code> 当中:
<ul>
<li><code>cp ~/.bashrc bashrc1</code></li>
<li><code>cp ~/.bashrc bashrc2</code></li>
<li><code>mv bashrc1 bashrc2 mvtest2</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>find（指定目录查找文件）</p>
<ul>
<li><code>find path -option</code> <code>path</code>是你要查找的路径，<code>-option</code>是选项，例如 <code>-name</code>就是根据名称来找。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二-pip">二、pip</h1>
<ul>
<li><code>pip install --upgrade pip</code>或<code>pip install -U pip</code>:升级pip自身</li>
<li><code>pip list</code>：查看已经通过pip安装的包</li>
<li><code>pip install &lt;包名&gt; --upgrade</code>或<code>pip install -U &lt;包名&gt;</code>:升级包</li>
<li><code>pip install &lt;包名&gt; -i https://mirrors.aliyun.com/pypi/simple</code>:指定单次安装源</li>
<li><code>pip install SomePackage==1.0.4</code>:指定版本</li>
<li><code>pip-review --auto/pip-review --local --interactive</code>:自动更新所有包</li>
</ul>
<h1 id="三-conda">三、conda</h1>
<ul>
<li><code>conda --version</code>:查看conda版本，验证是否安装</li>
<li><code>conda update conda</code>:更新至最新版本，也会更新其它相关包</li>
<li><code>conda update --all</code>:更新所有包</li>
<li><code>conda update package_name</code>:更新指定的包</li>
<li><code>conda create -n env_name package_name</code>:创建名为 env_name 的新环境，并在该环境下安装名为 package_name 的包，可以指定新环境的版本号，例如：<code>conda create -n python2 python=python2.7 numpy pandas</code>，创建了python2环境，python版本为2.7，同时还安装了numpy pandas包</li>
<li><code>conda activate env_name</code>:切换至env_name环境</li>
<li><code>conda deactivate</code>:退出环境</li>
<li><code>conda info -e</code>:显示所有已经创建的环</li>
<li><code>conda create -n new_env_name --clone old_env_name</code>:复制old_env_name为new_env_name</li>
<li><code>conda remove -n env_name –-all</code>:删除环境</li>
<li><code>conda list</code>:查看所有已经安装的包</li>
<li><code>conda install -n env_name package_name</code>:在指定环境中安装包</li>
<li><code>conda remove -n env_name package</code>:删除指定环境中的包</li>
<li><code>rm -rf 虚拟环境所在路径</code>:删除空环境</li>
</ul>
<h1 id="四-vim">四、Vim</h1>
<ul>
<li><code>shift+g</code>:移至文件末尾</li>
</ul>
<h1 id="五-其他">五、其他</h1>
<ul>
<li><code>sudo nautilus /home</code>:打开图形化文件夹</li>
<li><code>top</code>或<code>htop</code>：查看当前进程</li>
<li><code>ifconfig</code>：查看IP地址</li>
<li><code>kill 进程号</code>:终止进程</li>
<li><code>kill -9 进程号</code>:强制终止进程</li>
<li><code>tar -zxvf xxx.tar.gz</code>:解压缩</li>
<li><code>chmod u+x file</code>:对文件 file 增加文件主可执行权限（u表示文件主）</li>
<li><code>sudo apt-get install package</code>:安装包</li>
<li><code>sudo apt-get install package --reinstall</code>:重新安装包</li>
<li><code>sudo apt-get -f install</code>:修复安装</li>
<li><code>sudo apt-get remove package</code>:删除包</li>
<li><code>sudo apt-get remove package --purge</code>:删除包，包括删除配置文件等</li>
<li><code>sudo apt-get update</code>:更新源</li>
<li><code>sudo apt-get upgrade</code>:更新已安装的包</li>
<li><code>sudo apt-get dist-upgrade</code>:`升级系统</li>
<li><code>sudo apt-get autoclean</code>:清理旧版本软件缓存</li>
<li><code>sudo dpkg -i package.deb</code>:所有deb文件的安装</li>
<li><code>sudo dpkg -r package</code>：所有deb文件的卸载</li>
<li><code>sudo dpkg -P package</code>:彻底的卸载，包括软件的配置文件</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!]]></title>
        <id>https://bailingnan.github.io/post/hello-world/</id>
        <link href="https://bailingnan.github.io/post/hello-world/">
        </link>
        <updated>2019-12-22T17:10:09.000Z</updated>
        <content type="html"><![CDATA[<p>New begin!</p>
]]></content>
    </entry>
</feed>