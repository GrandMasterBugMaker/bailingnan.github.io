<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://bailingnan.github.io/</id>
    <title>白凌南</title>
    <updated>2020-04-09T19:07:46.945Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://bailingnan.github.io/"/>
    <link rel="self" href="https://bailingnan.github.io/atom.xml"/>
    <subtitle>DM/DL/RecSys/Python/XJTU/INTJ</subtitle>
    <logo>https://bailingnan.github.io/images/avatar.png</logo>
    <icon>https://bailingnan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 白凌南</rights>
    <entry>
        <title type="html"><![CDATA[利用Python进行数据分析]]></title>
        <id>https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi/</id>
        <link href="https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi/">
        </link>
        <updated>2020-04-09T19:07:04.000Z</updated>
        <content type="html"><![CDATA[<!-- TOC -->
<ul>
<li><a href="#%E5%88%A9%E7%94%A8python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">利用<code>Python</code>进行数据分析</a>
<ul>
<li><a href="#%E5%85%A5%E9%97%A8">入门</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D">数据结构介绍</a>
<ul>
<li><a href="#series"><code>Series</code></a></li>
<li><a href="#dataframe"><code>DataFrame</code></a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E5%AF%B9%E8%B1%A1">索引对象</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">基本功能</a>
<ul>
<li><a href="#%E9%87%8D%E6%96%B0%E7%B4%A2%E5%BC%95">重新索引</a></li>
<li><a href="#%E4%B8%A2%E5%BC%83%E6%8C%87%E5%AE%9A%E8%BD%B4%E4%B8%8A%E7%9A%84%E9%A1%B9">丢弃指定轴上的项</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E9%80%89%E5%8F%96%E5%92%8C%E8%BF%87%E6%BB%A4">索引、选取和过滤</a></li>
<li><a href="#%E7%94%A8loc%E5%92%8Ciloc%E8%BF%9B%E8%A1%8C%E9%80%89%E5%8F%96">用<code>loc</code>和<code>iloc</code>进行选取</a></li>
<li><a href="#%E6%95%B4%E6%95%B0%E7%B4%A2%E5%BC%95">整数索引</a></li>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90">算术运算和数据对齐</a></li>
<li><a href="#%E5%9C%A8%E7%AE%97%E6%9C%AF%E6%96%B9%E6%B3%95%E4%B8%AD%E5%A1%AB%E5%85%85%E5%80%BC">在算术方法中填充值</a></li>
<li><a href="#dataframe%E5%92%8Cseries%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97"><code>DataFrame</code>和<code>Series</code>之间的运算</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%92%8C%E6%98%A0%E5%B0%84">函数应用和映射</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8E%92%E5%90%8D">排序和排名</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E6%A0%87%E7%AD%BE%E7%9A%84%E8%BD%B4%E7%B4%A2%E5%BC%95">带有重复标签的轴索引</a></li>
</ul>
</li>
<li><a href="#%E6%B1%87%E6%80%BB%E5%92%8C%E8%AE%A1%E7%AE%97%E6%8F%8F%E8%BF%B0%E7%BB%9F%E8%AE%A1">汇总和计算描述统计</a>
<ul>
<li><a href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0%E4%B8%8E%E5%8D%8F%E6%96%B9%E5%B7%AE">相关系数与协方差</a></li>
<li><a href="#%E5%94%AF%E4%B8%80%E5%80%BC%E5%80%BC%E8%AE%A1%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%88%90%E5%91%98%E8%B5%84%E6%A0%BC">唯一值、值计数以及成员资格</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%AD%98%E5%82%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">数据加载、存储与文件格式</a>
<ul>
<li><a href="#%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE">读写文本格式的数据</a>
<ul>
<li><a href="#%E9%80%90%E5%9D%97%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6">逐块读取文本文件</a></li>
<li><a href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%86%99%E5%87%BA%E5%88%B0%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F">将数据写出到文本格式</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E5%88%86%E9%9A%94%E7%AC%A6%E6%A0%BC%E5%BC%8F">处理分隔符格式</a></li>
<li><a href="#json%E6%95%B0%E6%8D%AE"><code>JSON</code>数据</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F">二进制数据格式</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8hdf5%E6%A0%BC%E5%BC%8F">使用<code>HDF5</code>格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E5%92%8C%E5%87%86%E5%A4%87">数据清洗和准备</a>
<ul>
<li><a href="#%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">处理缺失数据</a>
<ul>
<li><a href="#%E6%BB%A4%E9%99%A4%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">滤除缺失数据</a></li>
<li><a href="#%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE">填充缺失数据</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2">数据转换</a>
<ul>
<li><a href="#%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE">移除重复数据</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E6%88%96%E6%98%A0%E5%B0%84%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2">利用函数或映射进行数据转换</a></li>
<li><a href="#%E6%9B%BF%E6%8D%A2%E5%80%BC">替换值</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E8%BD%B4%E7%B4%A2%E5%BC%95">重命名轴索引</a></li>
<li><a href="#%E7%A6%BB%E6%95%A3%E5%8C%96%E5%92%8C%E9%9D%A2%E5%85%83%E5%88%92%E5%88%86">离散化和面元划分</a></li>
<li><a href="#%E6%A3%80%E6%B5%8B%E5%92%8C%E8%BF%87%E6%BB%A4%E5%BC%82%E5%B8%B8%E5%80%BC">检测和过滤异常值</a></li>
<li><a href="#%E6%8E%92%E5%88%97%E5%92%8C%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7">排列和随机采样</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%8C%87%E6%A0%87%E5%93%91%E5%8F%98%E9%87%8F">计算指标/哑变量</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C">字符串操作</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95">字符串对象方法</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%E8%81%9A%E5%90%88%E5%90%88%E5%B9%B6%E5%92%8C%E9%87%8D%E5%A1%91">数据规整：聚合、合并和重塑</a>
<ul>
<li><a href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E7%B4%A2%E5%BC%95">层次化索引</a></li>
<li><a href="#%E9%87%8D%E6%8E%92%E4%B8%8E%E5%88%86%E7%BA%A7%E6%8E%92%E5%BA%8F">重排与分级排序</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E7%BA%A7%E5%88%AB%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1">根据级别汇总统计</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8dataframe%E7%9A%84%E5%88%97%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95">使用<code>DataFrame</code>的列进行索引</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E6%95%B0%E6%8D%AE%E9%9B%86">合并数据集</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A3%8E%E6%A0%BC%E7%9A%84dataframe%E5%90%88%E5%B9%B6">数据库风格的<code>DataFrame</code>合并</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E4%B8%8A%E7%9A%84%E5%90%88%E5%B9%B6">索引上的合并</a></li>
<li><a href="#%E8%BD%B4%E5%90%91%E8%BF%9E%E6%8E%A5">轴向连接</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E9%87%8D%E5%8F%A0%E6%95%B0%E6%8D%AE">合并重叠数据</a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E5%A1%91%E5%92%8C%E8%BD%B4%E5%90%91%E6%97%8B%E8%BD%AC">重塑和轴向旋转</a>
<ul>
<li><a href="#%E9%87%8D%E5%A1%91%E5%B1%82%E6%AC%A1%E5%8C%96%E7%B4%A2%E5%BC%95">重塑层次化索引</a></li>
<li><a href="#%E5%B0%86%E9%95%BF%E6%A0%BC%E5%BC%8F%E6%97%8B%E8%BD%AC%E4%B8%BA%E5%AE%BD%E6%A0%BC%E5%BC%8F">将“长格式”旋转为“宽格式”</a></li>
<li><a href="#%E5%B0%86%E5%AE%BD%E6%A0%BC%E5%BC%8F%E6%97%8B%E8%BD%AC%E4%B8%BA%E9%95%BF%E6%A0%BC%E5%BC%8F">将“宽格式”旋转为“长格式”</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97">数据聚合与分组运算</a>
<ul>
<li><a href="#groupby%E6%9C%BA%E5%88%B6"><code>GroupBy</code>机制</a>
<ul>
<li><a href="#%E5%AF%B9%E5%88%86%E7%BB%84%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3">对分组进行迭代</a></li>
<li><a href="#%E9%80%89%E5%8F%96%E4%B8%80%E5%88%97%E6%88%96%E5%88%97%E7%9A%84%E5%AD%90%E9%9B%86">选取一列或列的子集</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E7%BA%A7%E5%88%AB%E5%88%86%E7%BB%84">根据索引级别分组</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88">数据聚合</a></li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%88%97%E7%9A%84%E5%A4%9A%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8">面向列的多函数应用</a></li>
<li><a href="#%E4%BB%A5%E6%B2%A1%E6%9C%89%E8%A1%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%BF%94%E5%9B%9E%E8%81%9A%E5%90%88%E6%95%B0%E6%8D%AE">以“没有行索引”的形式返回聚合数据</a></li>
</ul>
</li>
<li><a href="#apply%E4%B8%80%E8%88%AC%E6%80%A7%E7%9A%84%E6%8B%86%E5%88%86%E5%BA%94%E7%94%A8%E5%90%88%E5%B9%B6"><code>apply</code>：一般性的“拆分－应用－合并”</a>
<ul>
<li><a href="#%E7%A6%81%E6%AD%A2%E5%88%86%E7%BB%84%E9%94%AE">禁止分组键</a></li>
<li><a href="#%E5%88%86%E4%BD%8D%E6%95%B0%E5%92%8C%E6%A1%B6%E5%88%86%E6%9E%90">分位数和桶分析</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E7%94%A8%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%88%86%E7%BB%84%E7%9A%84%E5%80%BC%E5%A1%AB%E5%85%85%E7%BC%BA%E5%A4%B1%E5%80%BC">示例：用特定于分组的值填充缺失值</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7%E5%92%8C%E6%8E%92%E5%88%97">示例：随机采样和排列</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E5%88%86%E7%BB%84%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E6%95%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0">示例：分组加权平均数和相关系数</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B%E7%BB%84%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">示例：组级别的线性回归</a></li>
</ul>
</li>
<li><a href="#%E9%80%8F%E8%A7%86%E8%A1%A8%E5%92%8C%E4%BA%A4%E5%8F%89%E8%A1%A8">透视表和交叉表</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97">时间序列</a>
<ul>
<li><a href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%B7%A5%E5%85%B7">日期和时间数据类型及工具</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8Cdatetime%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2">字符串和<code>datetime</code>的相互转换</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%9F%BA%E7%A1%80">时间序列基础</a>
<ul>
<li><a href="#%E7%B4%A2%E5%BC%95%E9%80%89%E5%8F%96%E5%AD%90%E9%9B%86%E6%9E%84%E9%80%A0">索引、选取、子集构造</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97">带有重复索引的时间序列</a></li>
</ul>
</li>
<li><a href="#%E6%97%A5%E6%9C%9F%E7%9A%84%E8%8C%83%E5%9B%B4%E9%A2%91%E7%8E%87%E4%BB%A5%E5%8F%8A%E7%A7%BB%E5%8A%A8">日期的范围、频率以及移动</a>
<ul>
<li><a href="#%E7%94%9F%E6%88%90%E6%97%A5%E6%9C%9F%E8%8C%83%E5%9B%B4">生成日期范围</a></li>
<li><a href="#%E9%A2%91%E7%8E%87%E5%92%8C%E6%97%A5%E6%9C%9F%E5%81%8F%E7%A7%BB%E9%87%8F">频率和日期偏移量</a></li>
<li><a href="#wom%E6%97%A5%E6%9C%9F"><code>WOM</code>日期</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E8%B6%85%E5%89%8D%E5%92%8C%E6%BB%9E%E5%90%8E%E6%95%B0%E6%8D%AE">移动（超前和滞后）数据</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%81%8F%E7%A7%BB%E9%87%8F%E5%AF%B9%E6%97%A5%E6%9C%9F%E8%BF%9B%E8%A1%8C%E4%BD%8D%E7%A7%BB">通过偏移量对日期进行位移</a></li>
</ul>
</li>
<li><a href="#%E6%97%B6%E6%9C%9F%E5%8F%8A%E5%85%B6%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97">时期及其算术运算</a>
<ul>
<li><a href="#%E6%97%B6%E6%9C%9F%E7%9A%84%E9%A2%91%E7%8E%87%E8%BD%AC%E6%8D%A2">时期的频率转换</a></li>
<li><a href="#%E6%8C%89%E5%AD%A3%E5%BA%A6%E8%AE%A1%E7%AE%97%E7%9A%84%E6%97%B6%E6%9C%9F%E9%A2%91%E7%8E%87">按季度计算的时期频率</a></li>
<li><a href="#%E5%B0%86timestamp%E8%BD%AC%E6%8D%A2%E4%B8%BAperiod%E5%8F%8A%E5%85%B6%E5%8F%8D%E5%90%91%E8%BF%87%E7%A8%8B">将<code>Timestamp</code>转换为<code>Period</code>（及其反向过程）</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BAperiodindex">通过数组创建<code>PeriodIndex</code></a></li>
</ul>
</li>
<li><a href="#%E9%87%8D%E9%87%87%E6%A0%B7%E5%8F%8A%E9%A2%91%E7%8E%87%E8%BD%AC%E6%8D%A2">重采样及频率转换</a></li>
<li><a href="#%E9%99%8D%E9%87%87%E6%A0%B7">降采样</a></li>
<li><a href="#ohlc%E9%87%8D%E9%87%87%E6%A0%B7">OHLC重采样</a></li>
<li><a href="#%E5%8D%87%E9%87%87%E6%A0%B7%E5%92%8C%E6%8F%92%E5%80%BC">升采样和插值</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E6%97%B6%E6%9C%9F%E8%BF%9B%E8%A1%8C%E9%87%8D%E9%87%87%E6%A0%B7">通过时期进行重采样</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">移动窗口函数</a>
<ul>
<li><a href="#%E6%8C%87%E6%95%B0%E5%8A%A0%E6%9D%83%E5%87%BD%E6%95%B0">指数加权函数</a></li>
<li><a href="#%E4%BA%8C%E5%85%83%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">二元移动窗口函数</a></li>
<li><a href="#%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0">用户定义的移动窗口函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><code>pandas</code>高级应用</a>
<ul>
<li><a href="#%E5%88%86%E7%B1%BB%E6%95%B0%E6%8D%AE">分类数据</a>
<ul>
<li><a href="#pandas%E7%9A%84%E5%88%86%E7%B1%BB%E7%B1%BB%E5%9E%8B"><code>pandas</code>的分类类型</a></li>
<li><a href="#%E7%94%A8%E5%88%86%E7%B1%BB%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97">用分类进行计算</a></li>
<li><a href="#%E7%94%A8%E5%88%86%E7%B1%BB%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD">用分类提高性能</a></li>
<li><a href="#%E5%88%86%E7%B1%BB%E6%96%B9%E6%B3%95">分类方法</a></li>
<li><a href="#%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%8F%98%E9%87%8F">为建模创建虚拟变量</a></li>
</ul>
</li>
<li><a href="#groupby%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><code>GroupBy</code>高级应用</a>
<ul>
<li><a href="#%E5%88%86%E7%BB%84%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%A7%A3%E5%B0%81groupby">分组转换和“解封”<code>GroupBy</code></a></li>
<li><a href="#%E5%88%86%E7%BB%84%E7%9A%84%E6%97%B6%E9%97%B4%E9%87%8D%E9%87%87%E6%A0%B7">分组的时间重采样</a></li>
</ul>
</li>
<li><a href="#%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF">链式编程技术</a>
<ul>
<li><a href="#%E7%AE%A1%E9%81%93%E6%96%B9%E6%B3%95">管道方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#python%E5%BB%BA%E6%A8%A1%E5%BA%93"><code>Python</code>建模库</a>
<ul>
<li><a href="#pandas%E4%B8%8E%E6%A8%A1%E5%9E%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8E%A5%E5%8F%A3"><code>pandas</code>与模型代码的接口</a></li>
<li><a href="#scikit-learn%E4%BB%8B%E7%BB%8D"><code>scikit-learn</code>介绍</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B">数据分析案例</a>
<ul>
<li><a href="#%E6%9D%A5%E8%87%AAbitly%E7%9A%84usagov%E6%95%B0%E6%8D%AE">来自Bitly的USA.gov数据</a>
<ul>
<li><a href="#%E7%94%A8%E7%BA%AFpython%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%97%B6%E5%8C%BA%E8%BF%9B%E8%A1%8C%E8%AE%A1%E6%95%B0">用纯<code>Python</code>代码对时区进行计数</a></li>
<li><a href="#%E7%94%A8pandas%E5%AF%B9%E6%97%B6%E5%8C%BA%E8%BF%9B%E8%A1%8C%E8%AE%A1%E6%95%B0">用<code>pandas</code>对时区进行计数</a></li>
</ul>
</li>
<li><a href="#movielens-1m%E6%95%B0%E6%8D%AE%E9%9B%86"><code>MovieLens 1M</code>数据集</a>
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E8%AF%84%E5%88%86%E5%88%86%E6%AD%A7">计算评分分歧</a></li>
</ul>
</li>
<li><a href="#1880-2010%E5%B9%B4%E9%97%B4%E5%85%A8%E7%BE%8E%E5%A9%B4%E5%84%BF%E5%A7%93%E5%90%8D">1880-2010年间全美婴儿姓名</a>
<ul>
<li><a href="#%E5%88%86%E6%9E%90%E5%91%BD%E5%90%8D%E8%B6%8B%E5%8A%BF">分析命名趋势</a></li>
<li><a href="#%E8%AF%84%E4%BC%B0%E5%91%BD%E5%90%8D%E5%A4%9A%E6%A0%B7%E6%80%A7%E7%9A%84%E5%A2%9E%E9%95%BF">评估命名多样性的增长</a></li>
<li><a href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AF%8D%E7%9A%84%E5%8F%98%E9%9D%A9">“最后一个字母”的变革</a></li>
<li><a href="#%E5%8F%98%E6%88%90%E5%A5%B3%E5%AD%A9%E5%90%8D%E5%AD%97%E7%9A%84%E7%94%B7%E5%AD%A9%E5%90%8D%E5%AD%97%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%8F%8D%E7%9A%84%E6%83%85%E5%86%B5">变成女孩名字的男孩名字（以及相反的情况）</a></li>
</ul>
</li>
<li><a href="#usda%E9%A3%9F%E5%93%81%E6%95%B0%E6%8D%AE%E5%BA%93">USDA食品数据库</a></li>
<li><a href="#2012%E8%81%94%E9%82%A6%E9%80%89%E4%B8%BE%E5%A7%94%E5%91%98%E4%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93">2012联邦选举委员会数据库</a>
<ul>
<li><a href="#%E6%A0%B9%E6%8D%AE%E8%81%8C%E4%B8%9A%E5%92%8C%E9%9B%87%E4%B8%BB%E7%BB%9F%E8%AE%A1%E8%B5%9E%E5%8A%A9%E4%BF%A1%E6%81%AF">根据职业和雇主统计赞助信息</a></li>
<li><a href="#%E5%AF%B9%E5%87%BA%E8%B5%84%E9%A2%9D%E5%88%86%E7%BB%84">对出资额分组</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E5%B7%9E%E7%BB%9F%E8%AE%A1%E8%B5%9E%E5%8A%A9%E4%BF%A1%E6%81%AF">根据州统计赞助信息</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="利用python进行数据分析">利用<code>Python</code>进行数据分析</h1>
<h2 id="入门">入门</h2>
<h3 id="数据结构介绍">数据结构介绍</h3>
<h4 id="series"><code>Series</code></h4>
<p><code>Series</code>是一种类似于一维数组的对象，它由一组数据（各种<code>NumPy</code>数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的<code>Series</code>：</p>
<pre><code class="language-python">obj = pd.Series([4, 7, -5, 3])

obj
0    4
1    7
2   -5
3    3
dtype: int64
</code></pre>
<p><code>Series</code>的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过<code>Series</code> 的<code>values</code>和<code>index</code>属性获取其数组表示形式和索引对象：</p>
<pre><code class="language-python">obj.values
array([ 4,  7, -5,  3])
obj.index  # like range(4)
RangeIndex(start=0, stop=4, step=1)
</code></pre>
<p>通常，我们希望所创建的<code>Series</code>带有一个可以对各个数据点进行标记的索引：</p>
<pre><code class="language-python">obj2 = pd.Series([4, 7, -5, 3], index=['d', 'b', 'a', 'c'])
obj2
d    4
b    7
a   -5
c    3
dtype: int64
obj2.index
Index(['d', 'b', 'a', 'c'], dtype='object')
</code></pre>
<p>与普通<code>NumPy</code>数组相比，你可以通过索引的方式选取<code>Series</code>中的单个或一组值：</p>
<pre><code class="language-python">obj2['a']
-5
obj2['d'] = 6
obj2[['c', 'a', 'd']]
c    3
a   -5
d    6
dtype: int64
</code></pre>
<p><code>['c', 'a', 'd']</code>是索引列表，即使它包含的是字符串而不是整数。</p>
<p>使用<code>NumPy</code>函数或类似<code>NumPy</code>的运算（如根据布尔型数组进行过滤、标量乘法、应用数学函数等）都会保留索引值的链接：</p>
<pre><code class="language-python">obj2[obj2 &gt; 0]
d    6
b    7
c    3
dtype: int64
obj2 * 2
d    12
b    14
a   -10
c     6
dtype: int64
np.exp(obj2)
d     403.428793
b    1096.633158
a       0.006738
c      20.085537
dtype: float64
</code></pre>
<p>还可以将<code>Series</code>看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中：</p>
<pre><code class="language-python">'b' in obj2
True
'e' in obj2
False
</code></pre>
<p>如果数据被存放在一个<code>Python</code>字典中，也可以直接通过这个字典来创建<code>Series</code>：</p>
<pre><code class="language-python">sdata = {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000}
obj3 = pd.Series(sdata)
obj3
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
</code></pre>
<p>如果只传入一个字典，则结果<code>Series</code>中的索引就是原字典的键（有序排列）。你可以传入排好序的字典的键以改变顺序：</p>
<pre><code class="language-python">states = ['California', 'Ohio', 'Oregon', 'Texas']
obj4 = pd.Series(sdata, index=states)
obj4
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
</code></pre>
<p>在这个例子中，<code>sdata</code>中跟<code>states</code>索引相匹配的那3个值会被找出来并放到相应的位置上，但由于<code>&quot;California&quot;</code>所对应的<code>sdata</code>值找不到，所以其结果就为<code>NaN</code>（即“非数字”（<code>not a number</code>），在<code>pandas</code>中，它用于表示缺失或<code>NA</code>值）。因为<code>‘Utah’</code>不在<code>states</code>中，它被从结果中除去。</p>
<p>使用缺失（<code>missing</code>）或<code>NA</code>表示缺失数据。<code>pandas</code>的<code>isnull</code>和<code>notnull</code>函数可用于检测缺失数据：</p>
<pre><code class="language-python">pd.isnull(obj4)
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
pd.notnull(obj4)
California    False
Ohio           True
Oregon         True
Texas          True
dtype: bool
</code></pre>
<p><code>Series</code>也有类似的实例方法：</p>
<pre><code class="language-python">obj4.isnull()
California     True
Ohio          False
Oregon        False
Texas         False
dtype: bool
</code></pre>
<p>对于许多应用而言，<code>Series</code>最重要的一个功能是，它会根据运算的索引标签自动对齐数据：</p>
<pre><code class="language-python">obj3
Ohio      35000
Oregon    16000
Texas     71000
Utah       5000
dtype: int64
obj4
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
dtype: float64
obj3 + obj4
California         NaN
Ohio           70000.0
Oregon         32000.0
Texas         142000.0
Utah               NaN
dtype: float64
</code></pre>
<p><code>Series</code>对象本身及其索引都有一个<code>name</code>属性，该属性跟<code>pandas</code>其他的关键功能关系非常密切：</p>
<pre><code class="language-python">obj4.name = 'population'
obj4.index.name = 'state'
obj4
state
California        NaN
Ohio          35000.0
Oregon        16000.0
Texas         71000.0
Name: population, dtype: float64
</code></pre>
<p><code>Series</code>的索引可以通过赋值的方式就地修改：</p>
<pre><code class="language-python">obj
0    4
1    7
2   -5
3    3
dtype: int64
obj.index = ['Bob', 'Steve', 'Jeff', 'Ryan']
obj
Bob      4
Steve    7
Jeff    -5
Ryan     3
dtype: int64
</code></pre>
<h4 id="dataframe"><code>DataFrame</code></h4>
<p><code>DataFrame</code>是一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。<code>DataFrame</code>既有行索引也有列索引，它可以被看做由<code>Series</code>组成的字典（共用同一个索引）。<code>DataFrame</code>中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。<br>
建DataFrame的办法有很多，最常用的一种是直接传入一个由等长列表或NumPy数组组成的字典：</p>
<pre><code class="language-python">data = {'state': ['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada', 'Nevada'],
        'year': [2000, 2001, 2002, 2001, 2002, 2003],
        'pop': [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}
frame = pd.DataFrame(data)
</code></pre>
<p>结果<code>DataFrame</code>会自动加上索引（跟<code>Series</code>一样），且全部列会被有序排列：</p>
<pre><code class="language-python">frame
   pop   state  year
0  1.5    Ohio  2000
1  1.7    Ohio  2001
2  3.6    Ohio  2002
3  2.4  Nevada  2001
4  2.9  Nevada  2002
5  3.2  Nevada  2003
</code></pre>
<p>如果指定了列序列，则<code>DataFrame</code>的列就会按照指定顺序进行排列：</p>
<pre><code class="language-python">pd.DataFrame(data, columns=['year', 'state', 'pop'])
   year   state  pop
0  2000    Ohio  1.5
1  2001    Ohio  1.7
2  2002    Ohio  3.6
3  2001  Nevada  2.4
4  2002  Nevada  2.9
5  2003  Nevada  3.2
</code></pre>
<p>如果传入的列在数据中找不到，就会在结果中产生缺失值：</p>
<pre><code class="language-python">frame2 = pd.DataFrame(data, columns=['year', 'state', 'pop', 'debt'],
                     index=['one', 'two', 'three', 'four',
                     'five', 'six'])
frame2
       year   state  pop debt
one    2000    Ohio  1.5  NaN
two    2001    Ohio  1.7  NaN
three  2002    Ohio  3.6  NaN
four   2001  Nevada  2.4  NaN
five   2002  Nevada  2.9  NaN
six    2003  Nevada  3.2  NaN
frame2.columns
Index(['year', 'state', 'pop', 'debt'], dtype='object')
</code></pre>
<p>通过类似字典标记的方式或属性的方式，可以将<code>DataFrame</code>的列获取为一个<code>Series</code>：</p>
<pre><code class="language-python">frame2['state']
one        Ohio
two        Ohio
three      Ohio
four     Nevada
five     Nevada
six      Nevada
Name: state, dtype: object
frame2.year
one      2000
two      2001
three    2002
four     2001
five     2002
six      2003
Name: year, dtype: int64
</code></pre>
<p>注意，返回的<code>Series</code>拥有原<code>DataFrame</code>相同的索引，且其<code>name</code>属性也已经被相应地设置好了。</p>
<p>行也可以通过位置或名称的方式进行获取，比如用<code>loc</code>属性：</p>
<pre><code class="language-python">frame2.loc['three']
year     2002
state    Ohio
pop       3.6
debt      NaN
Name: three, dtype: object
</code></pre>
<p>列可以通过赋值的方式进行修改。例如，我们可以给那个空的<code>&quot;debt&quot;</code>列赋上一个标量值或一组值：</p>
<pre><code class="language-python">frame2['debt'] = 16.5
frame2
       year   state  pop  debt
one    2000    Ohio  1.5  16.5
two    2001    Ohio  1.7  16.5
three  2002    Ohio  3.6  16.5
four   2001  Nevada  2.4  16.5
five   2002  Nevada  2.9  16.5
six    2003  Nevada  3.2  16.5
frame2['debt'] = np.arange(6.)
frame2
       year   state  pop  debt
one    2000    Ohio  1.5   0.0
two    2001    Ohio  1.7   1.0
three  2002    Ohio  3.6   2.0
four   2001  Nevada  2.4   3.0
five   2002  Nevada  2.9   4.0
six    2003  Nevada  3.2   5.0
</code></pre>
<p>将列表或数组赋值给某个列时，其长度必须跟<code>DataFrame</code>的长度相匹配。如果赋值的是一个<code>Series</code>，就会精确匹配<code>DataFrame</code>的索引，所有的空位都将被填上缺失值：</p>
<pre><code class="language-python">val = pd.Series([-1.2, -1.5, -1.7], index=['two', 'four', 'five'])
frame2['debt'] = val
frame2
       year   state  pop  debt
one    2000    Ohio  1.5   NaN
two    2001    Ohio  1.7  -1.2
three  2002    Ohio  3.6   NaN
four   2001  Nevada  2.4  -1.5
five   2002  Nevada  2.9  -1.7
six    2003  Nevada  3.2   NaN
</code></pre>
<p>为不存在的列赋值会创建出一个新列。关键字<code>del</code>用于删除列。</p>
<p>作为<code>del</code>的例子，先添加一个新的布尔值的列，<code>state</code>是否为<code>'Ohio'</code>：</p>
<pre><code class="language-python">frame2['eastern'] = frame2.state == 'Ohio'
frame2
       year   state  pop  debt  eastern
one    2000    Ohio  1.5   NaN     True
two    2001    Ohio  1.7  -1.2     True
three  2002    Ohio  3.6   NaN     True
four   2001  Nevada  2.4  -1.5    False
five   2002  Nevada  2.9  -1.7    False
six    2003  Nevada  3.2   NaN    False
</code></pre>
<p>注意：不能用<code>frame2.eastern</code>创建新的列。</p>
<p><code>del</code>方法可以用来删除这列：</p>
<pre><code class="language-python">del frame2['eastern']
frame2.columns
Index(['year', 'state', 'pop', 'debt'], dtype='object')
</code></pre>
<p>注意：通过索引方式返回的列只是相应数据的视图而已，并不是副本。因此，对返回的<code>Series</code>所做的任何就地修改全都会反映到源<code>DataFrame</code>上。通过<code>Series</code>的<code>copy</code>方法即可指定复制列。</p>
<p>另一种常见的数据形式是嵌套字典：</p>
<pre><code class="language-python">pop = {'Nevada': {2001: 2.4, 2002: 2.9},'Ohio': {2000: 1.5, 2001: 1.7, 2002: 3.6}}
</code></pre>
<p>如果嵌套字典传给<code>DataFrame</code>，pandas就会被解释为：外层字典的键作为列，内层键则作为行索引：</p>
<pre><code class="language-python">frame3 = pd.DataFrame(pop)
frame3
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
2002     2.9   3.6
</code></pre>
<p>你也可以使用类似<code>NumPy</code>数组的方法，对<code>DataFrame</code>进行转置（交换行和列）：</p>
<pre><code class="language-python">frame3.T
        2000  2001  2002
Nevada   NaN   2.4   2.9
Ohio     1.5   1.7   3.6
</code></pre>
<p>内层字典的键会被合并、排序以形成最终的索引。如果明确指定了索引，则不会这样：</p>
<pre><code class="language-python">pd.DataFrame(pop, index=[2001, 2002, 2003])
      Nevada  Ohio
2001     2.4   1.7
2002     2.9   3.6
2003     NaN   NaN
</code></pre>
<p>由<code>Series</code>组成的字典差不多也是一样的用法：</p>
<pre><code class="language-python">pdata = {'Ohio': frame3['Ohio'][:-1],
         'Nevada': frame3['Nevada'][:2]}
pd.DataFrame(pdata)
      Nevada  Ohio
2000     NaN   1.5
2001     2.4   1.7
</code></pre>
<p>下表列出了<code>DataFrame</code>构造函数所能接受的各种数据。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407034118.png" alt="" loading="lazy"><br>
如果设置了<code>DataFrame</code>的<code>index</code>和<code>columns</code>的<code>name</code>属性，则这些信息也会被显示出来：</p>
<pre><code class="language-python">frame3.index.name = 'year'; frame3.columns.name = 'state'
frame3
state  Nevada  Ohio
year
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6
</code></pre>
<p>跟<code>Series</code>一样，<code>values</code>属性也会以二维<code>ndarray</code>的形式返回<code>DataFrame</code>中的数据：</p>
<pre><code class="language-python">frame3.values
array([[ nan,  1.5],
       [ 2.4,  1.7],
       [ 2.9,  3.6]])
</code></pre>
<p>如果<code>DataFrame</code>各列的数据类型不同，则值数组的<code>dtype</code>就会选用能兼容所有列的数据类型：</p>
<pre><code class="language-python">frame2.values
array([[2000, 'Ohio', 1.5, nan],
       [2001, 'Ohio', 1.7, -1.2],
       [2002, 'Ohio', 3.6, nan],
       [2001, 'Nevada', 2.4, -1.5],
       [2002, 'Nevada', 2.9, -1.7],
       [2003, 'Nevada', 3.2, nan]], dtype=object)
</code></pre>
<h4 id="索引对象">索引对象</h4>
<p><code>pandas</code>的索引对象负责管理轴标签和其他元数据（比如轴名称等）。构建<code>Series</code>或<code>DataFrame</code>时，所用到的任何数组或其他序列的标签都会被转换成一个<code>Index</code>：</p>
<pre><code class="language-python">obj = pd.Series(range(3), index=['a', 'b', 'c'])
index = obj.index
index
Index(['a', 'b', 'c'], dtype='object')
index[1:]
Index(['b', 'c'], dtype='object')
</code></pre>
<p><code>Index</code>对象是不可变的，因此用户不能对其进行修改：</p>
<pre><code class="language-python">index[1] = 'd'  # TypeError
</code></pre>
<p>不可变可以使<code>Index</code>对象在多个数据结构之间安全共享：</p>
<pre><code class="language-python">labels = pd.Index(np.arange(3))
labels
Int64Index([0, 1, 2], dtype='int64')
obj2 = pd.Series([1.5, -2.5, 0], index=labels)
obj2
0    1.5
1   -2.5
2    0.0
dtype: float64
obj2.index is labels
True
</code></pre>
<p>注意：虽然用户不需要经常使用<code>Index</code>的功能，但是因为一些操作会生成包含被索引化的数据，理解它们的工作原理是很重要的。</p>
<p>除了类似于数组，<code>Index</code>的功能也类似一个固定大小的集合：</p>
<pre><code class="language-python">frame3
state  Nevada  Ohio
year               
2000      NaN   1.5
2001      2.4   1.7
2002      2.9   3.6
frame3.columns
Index(['Nevada', 'Ohio'], dtype='object', name='state')
'Ohio' in frame3.columns
True
2003 in frame3.index
False
</code></pre>
<p>与<code>python</code>的集合不同，<code>pandas</code>的<code>Index</code>可以包含重复的标签：</p>
<pre><code class="language-python">dup_labels = pd.Index(['foo', 'foo', 'bar', 'bar'])
dup_labels
Index(['foo', 'foo', 'bar', 'bar'], dtype='object')
</code></pre>
<p>选择重复的标签，会显示所有的结果。<br>
每个索引都有一些方法和属性，它们可用于设置逻辑并回答有关该索引所包含的数据的常见问题。下表列出了这些函数。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407034949.png" alt="" loading="lazy"></p>
<h3 id="基本功能">基本功能</h3>
<h4 id="重新索引">重新索引</h4>
<p><code>pandas</code>对象的一个重要方法是<code>reindex</code>，其作用是创建一个新对象，它的数据符合新的索引。看下面的例子：</p>
<pre><code class="language-python">obj = pd.Series([4.5, 7.2, -5.3, 3.6], index=['d', 'b', 'a', 'c'])
obj
d    4.5
b    7.2
a   -5.3
c    3.6
dtype: float64
</code></pre>
<p>用该<code>Series</code>的<code>reindex</code>将会根据新索引进行重排。如果某个索引值当前不存在，就引入缺失值：</p>
<pre><code class="language-python">obj2 = obj.reindex(['a', 'b', 'c', 'd', 'e'])
obj2
a   -5.3
b    7.2
c    3.6
d    4.5
e    NaN
dtype: float64
</code></pre>
<p>对于时间序列这样的有序数据，重新索引时可能需要做一些插值处理。<code>method</code>选项即可达到此目的，例如，使用<code>ffill</code>可以实现前向值填充：</p>
<pre><code class="language-python">obj3 = pd.Series(['blue', 'purple', 'yellow'], index=[0, 2, 4])
obj3
0      blue
2    purple
4    yellow
dtype: object
obj3.reindex(range(6), method='ffill')
0      blue
1      blue
2    purple
3    purple
4    yellow
5    yellow
dtype: object
</code></pre>
<p>借助<code>DataFrame</code>，<code>reindex</code>可以修改（行）索引和列。只传递一个序列时，会重新索引结果的行：</p>
<pre><code class="language-python">frame = pd.DataFrame(np.arange(9).reshape((3, 3)),index=['a', 'c', 'd'],columns=['Ohio', 'Texas', 'California'])
frame
   Ohio  Texas  California
a     0      1           2
c     3      4           5
d     6      7           8
frame2 = frame.reindex(['a', 'b', 'c', 'd'])
frame2
   Ohio  Texas  California
a   0.0    1.0         2.0
b   NaN    NaN         NaN
c   3.0    4.0         5.0
d   6.0    7.0         8.0
</code></pre>
<p>列可以用<code>columns</code>关键字重新索引：</p>
<pre><code class="language-python">states = ['Texas', 'Utah', 'California']
frame.reindex(columns=states)
   Texas  Utah  California
a      1   NaN           2
c      4   NaN           5
d      7   NaN           8
</code></pre>
<p>下表列出了<code>reindex</code>函数的各参数及说明。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407035512.png" alt="" loading="lazy"></p>
<h4 id="丢弃指定轴上的项">丢弃指定轴上的项</h4>
<p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以<code>drop</code>方法返回的是一个在指定轴上删除了指定值的新对象：</p>
<pre><code class="language-python">obj = pd.Series(np.arange(5.), index=['a', 'b', 'c', 'd', 'e'])
obj
a    0.0
b    1.0
c    2.0
d    3.0
e    4.0
dtype: float64
new_obj = obj.drop('c')
new_obj
a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
obj.drop(['d', 'c'])
a    0.0
b    1.0
e    4.0
dtype: float64
</code></pre>
<p>对于<code>DataFrame</code>，可以删除任意轴上的索引值。为了演示，先新建一个<code>DataFrame</code>例子：</p>
<pre><code class="language-python">data = pd.DataFrame(np.arange(16).reshape((4, 4)),index=['Ohio', 'Colorado', 'Utah', 'New York'],columns=['one', 'two', 'three', 'four'])
data
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
</code></pre>
<p>用标签序列调用<code>drop</code>会从行标签（<code>axis 0</code>）删除值：</p>
<pre><code class="language-python">data.drop(['Colorado', 'Ohio'])
          one  two  three  four
Utah        8    9     10    11
New York   12   13     14    15
</code></pre>
<p>通过传递<code>axis=1</code>或<code>axis='columns'</code>可以删除列的值：</p>
<pre><code class="language-python">data.drop('two', axis=1)
          one  three  four
Ohio        0      2     3
Colorado    4      6     7
Utah        8     10    11
New York   12     14    15
data.drop(['two', 'four'], axis='columns')
          one  three
Ohio        0      2
Colorado    4      6
Utah        8     10
New York   12     14
</code></pre>
<p>许多函数，如<code>drop</code>，会修改<code>Series</code>或<code>DataFrame</code>的大小或形状，可以就地修改对象，不会返回新的对象：</p>
<pre><code class="language-python">obj.drop('c', inplace=True)
obj
a    0.0
b    1.0
d    3.0
e    4.0
dtype: float64
</code></pre>
<p>小心使用<code>inplace</code>，它会销毁所有被删除的数据。</p>
<h4 id="索引-选取和过滤">索引、选取和过滤</h4>
<p><code>Series</code>索引（<code>obj[...]</code>）的工作方式类似于<code>NumPy</code>数组的索引，只不过<code>Series</code>的索引值不只是整数。下面是几个例子：</p>
<pre><code class="language-python">obj = pd.Series(np.arange(4.), index=['a', 'b', 'c', 'd'])
obj
a    0.0
b    1.0
c    2.0
d    3.0
dtype: float64
obj['b']
1.0
obj[1]
1.0
obj[2:4]
c    2.0
d    3.0
dtype: float64
obj[['b', 'a', 'd']]
b    1.0
a    0.0
d    3.0
dtype: float64
obj[[1, 3]]
b    1.0
d    3.0
dtype: float64
obj[obj &lt; 2]
a    0.0
b    1.0
dtype: float64
</code></pre>
<p>利用标签的切片运算与普通的<code>Python</code>切片运算不同，其末端是包含的：</p>
<pre><code class="language-python">obj['b':'c']
b    1.0
c    2.0
dtype: float64
</code></pre>
<p>用切片可以对<code>Series</code>的相应部分进行设置：</p>
<pre><code class="language-python">obj['b':'c'] = 5
obj
a    0.0
b    5.0
c    5.0
d    3.0
dtype: float64
</code></pre>
<p>用一个值或序列对<code>DataFrame</code>进行索引其实就是获取一个或多个列：</p>
<pre><code class="language-python">data = pd.DataFrame(np.arange(16).reshape((4, 4)),index=['Ohio', 'Colorado', 'Utah', 'New York'],columns=['one', 'two', 'three', 'four'])
data
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
data['two']
Ohio         1
Colorado     5
Utah         9
New York    13
Name: two, dtype: int64
data[['three', 'one']]
          three  one
Ohio          2    0
Colorado      6    4
Utah         10    8
New York     14   12
</code></pre>
<p>这种索引方式有几个特殊的情况。首先通过切片或布尔型数组选取数据：</p>
<pre><code class="language-python">data[:2]
          one  two  three  four
Ohio        0    1      2     3
Colorado    4    5      6     7
data[data['three'] &gt; 5]
          one  two  three  four
Colorado    4    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
</code></pre>
<p>选取行的语法<code>data[:2]</code>十分方便。向<code>[ ]</code>传递单一的元素或列表，就可选择列。</p>
<p>另一种用法是通过布尔型<code>DataFrame</code>（比如下面这个由标量比较运算得出的）进行索引：</p>
<pre><code class="language-python">data &lt; 5

            one    two  three   four
Ohio       True   True   True   True
Colorado   True  False  False  False
Utah      False  False  False  False
New York  False  False  False  False
data[data &lt; 5] = 0
data
          one  two  three  four
Ohio        0    0      0     0
Colorado    0    5      6     7
Utah        8    9     10    11
New York   12   13     14    15
</code></pre>
<p>这使得<code>DataFrame</code>的语法与<code>NumPy</code>二维数组的语法很像。</p>
<h4 id="用loc和iloc进行选取">用<code>loc</code>和<code>iloc</code>进行选取</h4>
<p>对于<code>DataFrame</code>的行的标签索引，我引入了特殊的标签运算符<code>loc</code>和<code>iloc</code>。它们可以让你用类似<code>NumPy</code>的标记，使用轴标签（<code>loc</code>）或整数索引（<code>iloc</code>），从<code>DataFrame</code>选择行和列的子集。</p>
<p>作为一个初步示例，让我们通过标签选择一行和多列：</p>
<pre><code class="language-python">data.loc['Colorado', ['two', 'three']]
two      5
three    6
Name: Colorado, dtype: int64
</code></pre>
<p>然后用<code>iloc</code>和整数进行选取：</p>
<pre><code class="language-python">data.iloc[2, [3, 0, 1]]
four    11
one      8
two      9
Name: Utah, dtype: int64
data.iloc[2]
one       8
two       9
three    10
four     11
Name: Utah, dtype: int64
data.iloc[[1, 2], [3, 0, 1]]
          four  one  two
Colorado     7    0    5
Utah        11    8    9
</code></pre>
<p>这两个索引函数也适用于一个标签或多个标签的切片：</p>
<pre><code class="language-python">data.loc[:'Utah', 'two']
Ohio        0
Colorado    5
Utah        9
Name: two, dtype: int64
data.iloc[:, :3][data.three &gt; 5]
          one  two  three
Colorado    0    5      6
Utah        8    9     10
New York   12   13     14
</code></pre>
<p>所以，在<code>pandas</code>中，有多个方法可以选取和重新组合数据。对于<code>DataFrame</code>，下表进行了总结。后面会看到，还有更多的方法进行层级化索引。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407040459.png" alt="" loading="lazy"></p>
<h4 id="整数索引">整数索引</h4>
<p>处理整数索引的<code>pandas</code>对象常常难住新手，因为它与<code>Python</code>内置的列表和元组的索引语法不同。例如，你可能不认为下面的代码会出错：</p>
<pre><code class="language-python">ser = pd.Series(np.arange(3.))
ser
ser[-1]
</code></pre>
<p>这里，<code>pandas</code>可以勉强进行整数索引，但是会导致小<code>bug</code>。我们有包含0,1,2的索引，但是引入用户想要的东西（基于标签或位置的索引）很难：</p>
<pre><code class="language-python">In [144]: ser
0    0.0
1    1.0
2    2.0
dtype: float64
</code></pre>
<p>另外，对于非整数索引，不会产生歧义：</p>
<pre><code class="language-python">ser2 = pd.Series(np.arange(3.), index=['a', 'b', 'c'])
ser2[-1]
2.0
</code></pre>
<p>为了进行统一，如果轴索引含有整数，数据选取总会使用标签。为了更准确，请使用<code>loc</code>（标签）或<code>iloc</code>（整数）：</p>
<pre><code class="language-python">ser[:1]
0    0.0
dtype: float64
ser.loc[:1]
0    0.0
1    1.0
dtype: float64
ser.iloc[:1]
0    0.0
dtype: float64
</code></pre>
<h4 id="算术运算和数据对齐">算术运算和数据对齐</h4>
<p><code>pandas</code>最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p>
<pre><code class="language-python">s1 = pd.Series([7.3, -2.5, 3.4, 1.5], index=['a', 'c', 'd', 'e'])
s2 = pd.Series([-2.1, 3.6, -1.5, 4, 3.1],index=['a', 'c', 'e', 'f', 'g'])
s1
a    7.3
c   -2.5
d    3.4
e    1.5
dtype: float64
s2
a   -2.1
c    3.6
e   -1.5
f    4.0
g    3.1
dtype: float64
</code></pre>
<p>将它们相加就会产生：</p>
<pre><code class="language-python">s1 + s2
a    5.2
c    1.1
d    NaN
e    0.0
f    NaN
g    NaN
dtype: float64
</code></pre>
<p>自动的数据对齐操作在不重叠的索引处引入了<code>NA</code>值。缺失值会在算术运算过程中传播。</p>
<p>对于<code>DataFrame</code>，对齐操作会同时发生在行和列上：</p>
<pre><code class="language-python">df1 = pd.DataFrame(np.arange(9.).reshape((3, 3)), columns=list('bcd'),index=['Ohio', 'Texas', 'Colorado'])
df2 = pd.DataFrame(np.arange(12.).reshape((4, 3)), columns=list('bde'),index=['Utah', 'Ohio', 'Texas', 'Oregon'])
df1
            b    c    d
Ohio      0.0  1.0  2.0
Texas     3.0  4.0  5.0
Colorado  6.0  7.0  8.0
df2
          b     d     e
Utah    0.0   1.0   2.0
Ohio    3.0   4.0   5.0
Texas   6.0   7.0   8.0
Oregon  9.0  10.0  11.0
</code></pre>
<p>把它们相加后将会返回一个新的<code>DataFrame</code>，其索引和列为原来那两个<code>DataFrame</code>的并集：</p>
<pre><code class="language-python">df1 + df2
            b   c     d   e
Colorado  NaN NaN   NaN NaN
Ohio      3.0 NaN   6.0 NaN
Oregon    NaN NaN   NaN NaN
Texas     9.0 NaN  12.0 NaN
Utah      NaN NaN   NaN NaN
</code></pre>
<p>因为<code>'c'</code>和<code>'e'</code>列均不在两个<code>DataFrame</code>对象中，在结果中以缺省值呈现。行也是同样。</p>
<p>如果<code>DataFrame</code>对象相加，没有共用的列或行标签，结果都会是空：</p>
<pre><code class="language-python">df1 = pd.DataFrame({'A': [1, 2]})
df2 = pd.DataFrame({'B': [3, 4]})
df1
   A
0  1
1  2
df2
   B
0  3
1  4
df1 - df2
    A   B
0 NaN NaN
1 NaN NaN
</code></pre>
<h4 id="在算术方法中填充值">在算术方法中填充值</h4>
<p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p>
<pre><code class="language-python">df1 = pd.DataFrame(np.arange(12.).reshape((3, 4)),columns=list('abcd'))
df2 = pd.DataFrame(np.arange(20.).reshape((4, 5)),columns=list('abcde'))
df2.loc[1, 'b'] = np.nan
df1
     a    b     c     d
0  0.0  1.0   2.0   3.0
1  4.0  5.0   6.0   7.0
2  8.0  9.0  10.0  11.0
df2
      a     b     c     d     e
0   0.0   1.0   2.0   3.0   4.0
1   5.0   NaN   7.0   8.0   9.0
2  10.0  11.0  12.0  13.0  14.0
3  15.0  16.0  17.0  18.0  19.0
</code></pre>
<p>将它们相加时，没有重叠的位置就会产生<code>NA</code>值：</p>
<pre><code class="language-python">df1 + df2
      a     b     c     d   e
0   0.0   2.0   4.0   6.0 NaN
1   9.0   NaN  13.0  15.0 NaN
2  18.0  20.0  22.0  24.0 NaN
3   NaN   NaN   NaN   NaN NaN
</code></pre>
<p>使用<code>df1</code>的<code>add</code>方法，传入<code>df2</code>以及一个<code>fill_value</code>参数：</p>
<pre><code class="language-python">df1.add(df2, fill_value=0)
      a     b     c     d     e
0   0.0   2.0   4.0   6.0   4.0
1   9.0   5.0  13.0  15.0   9.0
2  18.0  20.0  22.0  24.0  14.0
3  15.0  16.0  17.0  18.0  19.0
</code></pre>
<p>下表列出了<code>Series</code>和<code>DataFrame</code>的算术方法。它们每个都有一个副本，以字母<code>r</code>开头，它会翻转参数。因此这两个语句是等价的：</p>
<pre><code class="language-python">1 / df1
          a         b         c         d
0       inf  1.000000  0.500000  0.333333
1  0.250000  0.200000  0.166667  0.142857
2  0.125000  0.111111  0.100000  0.090909
df1.rdiv(1)
          a         b         c         d
0       inf  1.000000  0.500000  0.333333
1  0.250000  0.200000  0.166667  0.142857
2  0.125000  0.111111  0.100000  0.090909
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407040459.png" alt="" loading="lazy"><br>
与此类似，在对<code>Series</code>或<code>DataFrame</code>重新索引时，也可以指定一个填充值：</p>
<pre><code class="language-python">df1.reindex(columns=df2.columns, fill_value=0)
     a    b     c     d  e
0  0.0  1.0   2.0   3.0  0
1  4.0  5.0   6.0   7.0  0
2  8.0  9.0  10.0  11.0  0
</code></pre>
<h4 id="dataframe和series之间的运算"><code>DataFrame</code>和<code>Series</code>之间的运算</h4>
<p>跟不同维度的<code>NumPy</code>数组一样，<code>DataFrame</code>和<code>Series</code>之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p>
<pre><code class="language-python">arr = np.arange(12.).reshape((3, 4))
arr
array([[  0.,   1.,   2.,   3.],
       [  4.,   5.,   6.,   7.],
       [  8.,   9.,  10.,  11.]])
arr[0]
array([ 0.,  1.,  2.,  3.])
arr - arr[0]
array([[ 0.,  0.,  0.,  0.],
       [ 4.,  4.,  4.,  4.],
       [ 8.,  8.,  8.,  8.]])
</code></pre>
<p>当我们从<code>arr</code>减去<code>arr[0]</code>，每一行都会执行这个操作。这就叫做广播（<code>broadcasting</code>）。<code>DataFrame</code>和<code>Series</code>之间的运算差不多也是如此：</p>
<pre><code class="language-python">frame = pd.DataFrame(np.arange(12.).reshape((4, 3)),columns=list('bde'),index=['Utah', 'Ohio', 'Texas', 'Oregon'])
series = frame.iloc[0]
frame
          b     d     e
Utah    0.0   1.0   2.0
Ohio    3.0   4.0   5.0
Texas   6.0   7.0   8.0
Oregon  9.0  10.0  11.0
series
b    0.0
d    1.0
e    2.0
Name: Utah, dtype: float64
</code></pre>
<p>默认情况下，<code>DataFrame</code>和<code>Series</code>之间的算术运算会将<code>Series</code>的索引匹配到<code>DataFrame</code>的列，然后沿着行一直向下广播：</p>
<pre><code class="language-python">frame - series
          b    d    e
Utah    0.0  0.0  0.0
Ohio    3.0  3.0  3.0
Texas   6.0  6.0  6.0
Oregon  9.0  9.0  9.0
</code></pre>
<p>如果某个索引值在<code>DataFrame</code>的列或<code>Series</code>的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p>
<pre><code class="language-python">series2 = pd.Series(range(3), index=['b', 'e', 'f'])
frame + series2
          b   d     e   f
Utah    0.0 NaN   3.0 NaN
Ohio    3.0 NaN   6.0 NaN
Texas   6.0 NaN   9.0 NaN
Oregon  9.0 NaN  12.0 NaN
</code></pre>
<p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p>
<pre><code class="language-python">series3 = frame['d']
frame
          b     d     e
Utah    0.0   1.0   2.0
Ohio    3.0   4.0   5.0
Texas   6.0   7.0   8.0
Oregon  9.0  10.0  11.0
series3
Utah       1.0
Ohio       4.0
Texas      7.0
Oregon    10.0
Name: d, dtype: float64
frame.sub(series3, axis='index')
          b    d    e
Utah   -1.0  0.0  1.0
Ohio   -1.0  0.0  1.0
Texas  -1.0  0.0  1.0
Oregon -1.0  0.0  1.0
</code></pre>
<p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配<code>DataFrame</code>的行索引（<code>axis='index'</code> or <code>axis=0</code>）并进行广播。</p>
<h4 id="函数应用和映射">函数应用和映射</h4>
<p><code>NumPy</code>的<code>ufuncs</code>（元素级数组方法）也可用于操作<code>pandas</code>对象：</p>
<pre><code class="language-pythoh">frame = pd.DataFrame(np.random.randn(4, 3), columns=list('bde'),index=['Utah', 'Ohio', 'Texas', 'Oregon'])
frame
               b         d         e
Utah   -0.204708  0.478943 -0.519439
Ohio   -0.555730  1.965781  1.393406
Texas   0.092908  0.281746  0.769023
Oregon  1.246435  1.007189 -1.296221
np.abs(frame)
               b         d         e
Utah    0.204708  0.478943  0.519439
Ohio    0.555730  1.965781  1.393406
Texas   0.092908  0.281746  0.769023
Oregon  1.246435  1.007189  1.296221
</code></pre>
<p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。<code>DataFrame</code>的<code>apply</code>方法即可实现此功能：</p>
<pre><code class="language-python">f = lambda x: x.max() - x.min()
frame.apply(f)
b    1.802165
d    1.684034
e    2.689627
dtype: float64
</code></pre>
<p>这里的函数<code>f</code>，计算了一个<code>Series</code>的最大值和最小值的差，在<code>frame</code>的每列都执行了一次。结果是一个<code>Series</code>，使用<code>frame</code>的列作为索引。</p>
<p>如果传递<code>axis='columns'</code>到<code>apply</code>，这个函数会在每行执行：</p>
<pre><code class="language-python">frame.apply(f, axis='columns')
Utah      0.998382
Ohio      2.521511
Texas     0.676115
Oregon    2.542656
dtype: float64
</code></pre>
<p>许多最为常见的数组统计功能都被实现成<code>DataFrame</code>的方法（如<code>sum</code>和<code>mean</code>），因此无需使用<code>apply</code>方法。</p>
<p>传递到<code>apply</code>的函数不是必须返回一个标量，还可以返回由多个值组成的<code>Series</code>：</p>
<pre><code class="language-python">def f(x):
    return pd.Series([x.min(), x.max()], index=['min', 'max'])
frame.apply(f)
            b         d         e
min -0.555730  0.281746 -1.296221
max  1.246435  1.965781  1.393406
</code></pre>
<p>元素级的<code>Python</code>函数也是可以用的。假如你想得到<code>frame</code>中各个浮点值的格式化字符串，使用<code>applymap</code>即可：</p>
<pre><code class="language-python">format = lambda x: '%.2f' % x
frame.applymap(format)
            b     d      e
Utah    -0.20  0.48  -0.52
Ohio    -0.56  1.97   1.39
Texas    0.09  0.28   0.77
Oregon   1.25  1.01  -1.30
</code></pre>
<p>之所以叫做<code>applymap</code>，是因为<code>Series</code>有一个用于应用元素级函数的<code>map</code>方法：</p>
<pre><code class="language-python">frame['e'].map(format)
Utah      -0.52
Ohio       1.39
Texas      0.77
Oregon    -1.30
Name: e, dtype: object
</code></pre>
<h4 id="排序和排名">排序和排名</h4>
<p>根据条件对数据集排序（<code>sorting</code>）也是一种重要的内置运算。要对行或列索引进行排序（按字典顺序），可使用<code>sort_index</code>方法，它将返回一个已排序的新对象：</p>
<pre><code class="language-python">obj = pd.Series(range(4), index=['d', 'a', 'b', 'c'])
obj.sort_index()
a    1
b    2
c    3
d    0
dtype: int64
</code></pre>
<p>对于<code>DataFrame</code>，则可以根据任意一个轴上的索引进行排序：</p>
<pre><code class="language-python">frame = pd.DataFrame(np.arange(8).reshape((2, 4)),index=['three', 'one'],columns=['d', 'a', 'b', 'c'])
frame.sort_index()
       d  a  b  c
one    4  5  6  7
three  0  1  2  3
frame.sort_index(axis=1)
       a  b  c  d
three  1  2  3  0
one    5  6  7  4
</code></pre>
<p>数据默认是按升序排序的，但也可以降序排序：</p>
<pre><code class="language-python">frame.sort_index(axis=1, ascending=False)
       d  c  b  a
three  0  3  2  1
one    4  7  6  5
</code></pre>
<p>若要按值对<code>Series</code>进行排序，可使用其<code>sort_values</code>方法：</p>
<pre><code class="language-python">obj = pd.Series([4, 7, -3, 2])
obj.sort_values()
2   -3
3    2
0    4
1    7
dtype: int64
</code></pre>
<p>在排序时，任何缺失值默认都会被放到<code>Series</code>的末尾：</p>
<pre><code class="language-python">obj = pd.Series([4, np.nan, 7, np.nan, -3, 2])
obj.sort_values()
4   -3.0
5    2.0
0    4.0
2    7.0
1    NaN
3    NaN
dtype: float64
</code></pre>
<p>当排序一个<code>DataFrame</code>时，你可能希望根据一个或多个列中的值进行排序。将一个或多个列的名字传递给<code>sort_values</code>的<code>by</code>选项即可达到该目的：</p>
<pre><code class="language-python">frame = pd.DataFrame({'b': [4, 7, -3, 2], 'a': [0, 1, 0, 1]})
frame
   a  b
0  0  4
1  1  7
2  0 -3
3  1  2
frame.sort_values(by='b')
   a  b
2  0 -3
3  1  2
0  0  4
1  1  7
</code></pre>
<p>要根据多个列进行排序，传入名称的列表即可：</p>
<pre><code class="language-python">frame.sort_values(by=['a', 'b'])
   a  b
2  0 -3
0  0  4
3  1  2
1  1  7
</code></pre>
<p>排名会从1开始一直到数组中有效数据的数量。接下来介绍<code>Series</code>和<code>DataFrame</code>的<code>rank</code>方法。默认情况下，<code>rank</code>是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<pre><code class="language-python">obj = pd.Series([7, -5, 7, 4, 2, 0, 4])
obj.rank()
0    6.5
1    1.0
2    6.5
3    4.5
4    3.0
5    2.0
6    4.5
dtype: float64
</code></pre>
<p>也可以根据值在原数据中出现的顺序给出排名：</p>
<pre><code class="language-python">obj.rank(method='first')
0    6.0
1    1.0
2    7.0
3    4.0
4    3.0
5    2.0
6    5.0
dtype: float64
</code></pre>
<p>这里，条目0和2没有使用平均排名6.5，它们被设成了6和7，因为数据中标签0位于标签2的前面。</p>
<p>你也可以按降序进行排名：</p>
<pre><code class="language-python">#Assign tie values the maximum rank in the group
obj.rank(ascending=False, method='max')
0    2.0
1    7.0
2    2.0
3    4.0
4    5.0
5    6.0
6    4.0
dtype: float64
</code></pre>
<p>下表列出了所有用于破坏平级关系的<code>method</code>选项。<code>DataFrame</code>可以在行或列上计算排名：</p>
<pre><code class="language-python">frame = pd.DataFrame({'b': [4.3, 7, -3, 2], 'a': [0, 1, 0, 1],'c': [-2, 5, 8, -2.5]})
frame
   a    b    c
0  0  4.3 -2.0
1  1  7.0  5.0
2  0 -3.0  8.0
3  1  2.0 -2.5
frame.rank(axis='columns')
     a    b    c
0  2.0  3.0  1.0
1  1.0  3.0  2.0
2  2.0  1.0  3.0
3  2.0  3.0  1.0
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407043605.png" alt="" loading="lazy"></figure>
<h4 id="带有重复标签的轴索引">带有重复标签的轴索引</h4>
<p>直到目前为止，我所介绍的所有范例都有着唯一的轴标签（索引值）。虽然许多<code>pandas</code>函数（如<code>reindex</code>）都要求标签唯一，但这并不是强制性的。我们来看看下面这个简单的带有重复索引值的<code>Series</code>：</p>
<pre><code class="language-python">obj = pd.Series(range(5), index=['a', 'a', 'b', 'b', 'c'])
obj
a    0
a    1
b    2
b    3
c    4
dtype: int64
</code></pre>
<p>索引的<code>is_unique</code>属性可以告诉你它的值是否是唯一的：</p>
<pre><code class="language-python">obj.index.is_unique
False
</code></pre>
<p>对于带有重复值的索引，数据选取的行为将会有些不同。如果某个索引对应多个值，则返回一个<code>Series</code>；而对应单个值的，则返回一个标量值：</p>
<pre><code class="language-python">obj['a']
a    0
a    1
dtype: int64
obj['c']
4
</code></pre>
<p>这样会使代码变复杂，因为索引的输出类型会根据标签是否有重复发生变化。</p>
<p>对<code>DataFrame</code>的行进行索引时也是如此：</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.randn(4, 3), index=['a', 'a', 'b', 'b'])
df
          0         1         2
a  0.274992  0.228913  1.352917
a  0.886429 -2.001637 -0.371843
b  1.669025 -0.438570 -0.539741
b  0.476985  3.248944 -1.021228
df.loc['b']
          0         1         2
b  1.669025 -0.438570 -0.539741
b  0.476985  3.248944 -1.021228
</code></pre>
<h3 id="汇总和计算描述统计">汇总和计算描述统计</h3>
<p><code>pandas</code>对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从<code>Series</code>中提取单个值（如<code>sum</code>或<code>mean</code>）或从<code>DataFrame</code>的行或列中提取一个<code>Series</code>。跟对应的<code>NumPy</code>数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的<code>DataFrame</code>：</p>
<pre><code class="language-python">df = pd.DataFrame([[1.4, np.nan], [7.1, -4.5],[np.nan, np.nan], [0.75, -1.3]],index=['a', 'b', 'c', 'd'],columns=['one', 'two'])
df
    one  two
a  1.40  NaN
b  7.10 -4.5
c   NaN  NaN
d  0.75 -1.3
</code></pre>
<p>调用<code>DataFrame</code>的<code>sum</code>方法将会返回一个含有列的和的<code>Series</code>：</p>
<pre><code class="language-python">df.sum()
one    9.25
two   -5.80
dtype: float64
</code></pre>
<p>传入<code>axis='columns'</code>或<code>axis=1</code>将会按行进行求和运算：</p>
<pre><code class="language-python">df.sum(axis=1)
a    1.40
b    2.60
c     NaN
d   -0.55
</code></pre>
<p><code>NA</code>值会自动被排除，除非整个切片（这里指的是行或列）都是<code>NA</code>。通过<code>skipna</code>选项可以禁用该功能：</p>
<pre><code class="language-python">df.mean(axis='columns', skipna=False)
a      NaN
b    1.300
c      NaN
d   -0.275
dtype: float64
</code></pre>
<p>下表列出了这些约简方法的常用选项。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407044135.png" alt="" loading="lazy"><br>
有些方法（如<code>idxmin</code>和<code>idxmax</code>）返回的是间接统计（比如达到最小值或最大值的索引）：</p>
<pre><code class="language-python">df.idxmax()
one    b
two    d
dtype: object
</code></pre>
<p>另一些方法则是累计型的：</p>
<pre><code class="language-python">df.cumsum()
    one  two
a  1.40  NaN
b  8.50 -4.5
c   NaN  NaN
d  9.25 -5.8
</code></pre>
<p>还有一种方法，它既不是约简型也不是累计型。<code>describe</code>就是一个例子，它用于一次性产生多个汇总统计：</p>
<pre><code class="language-python">df.describe()
            one       two
count  3.000000  2.000000
mean   3.083333 -2.900000
std    3.493685  2.262742
min    0.750000 -4.500000
25%    1.075000 -3.700000
50%    1.400000 -2.900000
75%    4.250000 -2.100000
max    7.100000 -1.300000
</code></pre>
<p>对于非数值型数据，<code>describe</code>会产生另外一种汇总统计：</p>
<pre><code class="language-python">obj = pd.Series(['a', 'a', 'b', 'c'] * 4)
obj.describe()
count     16
unique     3
top        a
freq       8
dtype: object
</code></pre>
<p>下表列出了所有与描述统计相关的方法。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407044400.png" alt="" loading="lazy"></p>
<h4 id="相关系数与协方差">相关系数与协方差</h4>
<p>有些汇总统计（如相关系数和协方差）是通过参数对计算出来的。我们来看几个<code>DataFrame</code>，它们的数据来自Yahoo!Finance的股票价格和成交量。<br>
我使用<code>pandas_datareader</code>模块下载了一些股票数据：</p>
<pre><code class="language-python">import pandas_datareader.data as web
all_data = {ticker: web.get_data_yahoo(ticker)
            for ticker in ['AAPL', 'IBM', 'MSFT', 'GOOG']}

price = pd.DataFrame({ticker: data['Adj Close']
                     for ticker, data in all_data.items()})
volume = pd.DataFrame({ticker: data['Volume']
                      for ticker, data in all_data.items()})
</code></pre>
<p>现在计算价格的百分数变化：</p>
<pre><code class="language-python">returns = price.pct_change()
returns.tail()
                AAPL      GOOG       IBM      MSFT
Date                                              
2016-10-17 -0.000680  0.001837  0.002072 -0.003483
2016-10-18 -0.000681  0.019616 -0.026168  0.007690
2016-10-19 -0.002979  0.007846  0.003583 -0.002255
2016-10-20 -0.000512 -0.005652  0.001719 -0.004867
2016-10-21 -0.003930  0.003011 -0.012474  0.042096
</code></pre>
<p><code>Series</code>的<code>corr</code>方法用于计算两个<code>Series</code>中重叠的、非<code>NA</code>的、按索引对齐的值的相关系数。与此类似，<code>cov</code>用于计算协方差：</p>
<pre><code class="language-python">returns['MSFT'].corr(returns['IBM'])
0.49976361144151144
returns['MSFT'].cov(returns['IBM'])
8.8706554797035462e-05
</code></pre>
<p>因为<code>MSTF</code>是一个合理的<code>Python</code>属性，我们还可以用更简洁的语法选择列：</p>
<pre><code class="language-python">returns.MSFT.corr(returns.IBM)
0.49976361144151144
</code></pre>
<p>另一方面，<code>DataFrame</code>的<code>corr</code>和<code>cov</code>方法将以<code>DataFrame</code>的形式分别返回完整的相关系数或协方差矩阵：</p>
<pre><code class="language-python">returns.corr()
          AAPL      GOOG       IBM      MSFT
AAPL  1.000000  0.407919  0.386817  0.389695
GOOG  0.407919  1.000000  0.405099  0.465919
IBM   0.386817  0.405099  1.000000  0.499764
MSFT  0.389695  0.465919  0.499764  1.000000
returns.cov()
          AAPL      GOOG       IBM      MSFT
AAPL  0.000277  0.000107  0.000078  0.000095
GOOG  0.000107  0.000251  0.000078  0.000108
IBM   0.000078  0.000078  0.000146  0.000089
MSFT  0.000095  0.000108  0.000089  0.000215
</code></pre>
<p>利用<code>DataFrame</code>的<code>corrwith</code>方法，你可以计算其列或行跟另一个<code>Series</code>或<code>DataFrame</code>之间的相关系数。传入一个<code>Series</code>将会返回一个相关系数值<code>Series</code>（针对各列进行计算）：</p>
<pre><code class="language-python">returns.corrwith(returns.IBM)
AAPL    0.386817
GOOG    0.405099
IBM     1.000000
MSFT    0.499764
dtype: float64
</code></pre>
<p>传入一个<code>DataFrame</code>则会计算按列名配对的相关系数。这里，我计算百分比变化与成交量的相关系数：</p>
<pre><code class="language-python">returns.corrwith(volume)
AAPL   -0.075565
GOOG   -0.007067
IBM    -0.204849
MSFT   -0.092950
dtype: float64
</code></pre>
<p>传入<code>axis='columns'</code>即可按行进行计算。无论如何，在计算相关系数之前，所有的数据项都会按标签对齐。</p>
<h4 id="唯一值-值计数以及成员资格">唯一值、值计数以及成员资格</h4>
<p>还有一类方法可以从一维<code>Series</code>的值中抽取信息。看下面的例子：</p>
<pre><code class="language-python">obj = pd.Series(['c', 'a', 'd', 'a', 'a', 'b', 'b', 'c', 'c'])
</code></pre>
<p>第一个函数是<code>unique</code>，它可以得到<code>Series</code>中的唯一值数组：</p>
<pre><code class="language-python">uniques = obj.unique()
uniques
array(['c', 'a', 'd', 'b'], dtype=object)
</code></pre>
<p>返回的唯一值是未排序的，如果需要的话，可以对结果再次进行排序（<code>uniques.sort()</code>）。相似的，<code>value_counts</code>用于计算一个<code>Series</code>中各值出现的频率：</p>
<pre><code class="language-python">obj.value_counts()
c    3
a    3
b    2
d    1
dtype: int64
</code></pre>
<p>为了便于查看，结果<code>Series</code>是按值频率降序排列的。<code>value_counts</code>还是一个顶级<code>pandas</code>方法，可用于任何数组或序列：</p>
<pre><code class="language-python">pd.value_counts(obj.values, sort=False)
a    3
b    2
c    3
d    1
dtype: int64
</code></pre>
<p><code>isin</code>用于判断矢量化集合的成员资格，可用于过滤<code>Series</code>中或<code>DataFrame</code>列中数据的子集：</p>
<pre><code class="language-python">obj
0    c
1    a
2    d
3    a
4    a
5    b
6    b
7    c
8    c
dtype: object
mask = obj.isin(['b', 'c'])
mask
0     True
1    False
2    False
3    False
4    False
5     True
6     True
7     True
8     True
dtype: bool
obj[mask]
0    c
5    b
6    b
7    c
8    c
dtype: object
</code></pre>
<p>与<code>isin</code>类似的是<code>Index.get_indexer</code>方法，它可以给你一个索引数组，从可能包含重复值的数组到另一个不同值的数组：</p>
<pre><code class="language-python">to_match = pd.Series(['c', 'a', 'b', 'b', 'c', 'a'])
unique_vals = pd.Series(['c', 'b', 'a'])
pd.Index(unique_vals).get_indexer(to_match)
array([0, 2, 1, 1, 0, 2])
</code></pre>
<p>下表给出了这几个方法的一些参考信息。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407045054.png" alt="" loading="lazy"><br>
有时，你可能希望得到<code>DataFrame</code>中多个相关列的一张柱状图。例如：</p>
<pre><code class="language-python">data = pd.DataFrame({'Qu1': [1, 3, 4, 3, 4],
                     'Qu2': [2, 3, 1, 2, 3],
                     'Qu3': [1, 5, 2, 4, 4]})
data
   Qu1  Qu2  Qu3
0    1    2    1
1    3    3    5
2    4    1    2
3    3    2    4
4    4    3    4
</code></pre>
<p>将<code>pandas.value_counts</code>传给该<code>DataFrame</code>的<code>apply</code>函数，就会出现：</p>
<pre><code class="language-python">result = data.apply(pd.value_counts).fillna(0)
result
   Qu1  Qu2  Qu3
1  1.0  1.0  1.0
2  0.0  2.0  1.0
3  2.0  2.0  0.0
4  2.0  0.0  2.0
5  0.0  0.0  1.0
</code></pre>
<p>这里，结果中的行标签是所有列的唯一值。后面的频率值是每个列中这些值的相应计数。</p>
<h2 id="数据加载-存储与文件格式">数据加载、存储与文件格式</h2>
<h3 id="读写文本格式的数据">读写文本格式的数据</h3>
<p><code>pandas</code>提供了一些用于将表格型数据读取为<code>DataFrame</code>对象的函数。下表对它们进行了总结，其中<code>read_csv</code>和<code>read_table</code>可能会是你今后用得最多的。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407045624.png" alt="" loading="lazy"><br>
我将大致介绍一下这些函数在将文本数据转换为<code>DataFrame</code>时所用到的一些技术。这些函数的选项可以划分为以下几个大类：</p>
<ul>
<li>索引：将一个或多个列当做返回的<code>DataFrame</code>处理，以及是否从文件、用户获取列名。</li>
<li>类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。</li>
<li>日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。</li>
<li>迭代：支持对大文件进行逐块迭代。</li>
<li>不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。<br>
因为工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是<code>read_csv</code>）的选项逐渐变得复杂起来。面对不同的参数，感到头痛很正常（<code>read_csv</code>有超过<code>50</code>个参数）。<code>pandas</code>文档有这些参数的例子，如果你感到阅读某个文件很难，可以通过相似的足够多的例子找到正确的参数。</li>
</ul>
<p>其中一些函数，比如<code>pandas.read_csv</code>，有类型推断功能，因为列数据的类型不属于数据类型。也就是说，你不需要指定列的类型到底是数值、整数、布尔值，还是字符串。其它的数据格式，如<code>HDF5</code>、<code>Feather</code>和<code>msgpack</code>，会在格式中存储数据类型。</p>
<p>日期和其他自定义类型的处理需要多花点工夫才行。首先我们来看一个以逗号分隔的（<code>CSV</code>）文本文件：</p>
<pre><code class="language-python">a,b,c,d,message
1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo
</code></pre>
<p>由于该文件以逗号分隔，所以我们可以使用<code>read_csv</code>将其读入一个<code>DataFrame</code>：</p>
<pre><code class="language-python">df = pd.read_csv('examples/ex1.csv')
df
   a   b   c   d message
0  1   2   3   4   hello
1  5   6   7   8   world
2  9  10  11  12     foo
</code></pre>
<p>我们还可以使用<code>read_table</code>，并指定分隔符：</p>
<pre><code class="language-python">pd.read_table('examples/ex1.csv', sep=',')
   a   b   c   d message
0  1   2   3   4   hello
1  5   6   7   8   world
2  9  10  11  12     foo
</code></pre>
<p>并不是所有文件都有标题行。看看下面这个文件：</p>
<pre><code class="language-python">1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo
</code></pre>
<p>读入该文件的办法有两个。你可以让<code>pandas</code>为其分配默认的列名，也可以自己定义列名：</p>
<pre><code class="language-python">pd.read_csv('examples/ex2.csv', header=None)
   0   1   2   3      4
0  1   2   3   4  hello
1  5   6   7   8  world
2  9  10  11  12    foo
pd.read_csv('examples/ex2.csv', names=['a', 'b', 'c', 'd', 'message'])
   a   b   c   d message
0  1   2   3   4   hello
1  5   6   7   8   world
2  9  10  11  12     foo
</code></pre>
<p>假设你希望将<code>message</code>列做成<code>DataFrame</code>的索引。你可以明确表示要将该列放到索引4的位置上，也可以通过<code>index_col</code>参数指定<code>&quot;message&quot;</code>：</p>
<pre><code class="language-python">names = ['a', 'b', 'c', 'd', 'message']
pd.read_csv('examples/ex2.csv', names=names, index_col='message')
         a   b   c   d
message               
hello    1   2   3   4
world    5   6   7   8
foo      9  10  11  12
</code></pre>
<p>如果希望将多个列做成一个层次化索引，只需传入由列编号或列名组成的列表即可：</p>
<pre><code class="language-python">key1,key2,value1,value2
one,a,1,2
one,b,3,4
one,c,5,6
one,d,7,8
two,a,9,10
two,b,11,12
two,c,13,14
two,d,15,16
parsed = pd.read_csv('examples/csv_mindex.csv',index_col=['key1', 'key2'])
parsed
           value1  value2
key1 key2                
one  a          1       2
     b          3       4
     c          5       6
     d          7       8
two  a          9      10
     b         11      12
     c         13      14
     d         15      16
</code></pre>
<p>有些情况下，有些表格可能不是用固定的分隔符去分隔字段的（比如空白符或其它模式）。看看下面这个文本文件：</p>
<pre><code class="language-python">list(open('examples/ex3.txt'))
['            A         B         C\n',
 'aaa -0.264438 -1.026059 -0.619500\n',
 'bbb  0.927272  0.302904 -0.032399\n',
 'ccc -0.264273 -0.386314 -0.217601\n',
 'ddd -0.871858 -0.348382  1.100491\n']
</code></pre>
<p>虽然可以手动对数据进行规整，这里的字段是被数量不同的空白字符间隔开的。这种情况下，你可以传递一个正则表达式作为<code>read_table</code>的分隔符。可以用正则表达式表达为<code>\s+</code>，于是有：</p>
<pre><code class="language-python">result = pd.read_table('examples/ex3.txt', sep='\s+')
result
            A         B         C
aaa -0.264438 -1.026059 -0.619500
bbb  0.927272  0.302904 -0.032399
ccc -0.264273 -0.386314 -0.217601
ddd -0.871858 -0.348382  1.100491
</code></pre>
<p>这里，由于列名比数据行的数量少，所以<code>read_table</code>推断第一列应该是<code>DataFrame</code>的索引。</p>
<p>这些解析器函数还有许多参数可以帮助你处理各种各样的异形文件格式。<br>
缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，<code>pandas</code>会用一组经常出现的标记值进行识别，比如<code>NA</code>及<code>NULL</code>：</p>
<pre><code class="language-python">something,a,b,c,d,message
one,1,2,3,4,NA
two,5,6,,8,world
three,9,10,11,12,foo
result = pd.read_csv('examples/ex5.csv')
result
  something  a   b     c   d message
0       one  1   2   3.0   4     NaN
1       two  5   6   NaN   8   world
2     three  9  10  11.0  12     foo
pd.isnull(result)
   something      a      b      c      d  message
0      False  False  False  False  False     True
1      False  False  False   True  False    False
2      False  False  False  False  False    False
</code></pre>
<p><code>na_values</code>可以用一个列表或集合的字符串表示缺失值：</p>
<pre><code class="language-python">result = pd.read_csv('examples/ex5.csv', na_values=['NULL'])
result
  something  a   b     c   d message
0       one  1   2   3.0   4     NaN
1       two  5   6   NaN   8   world
2     three  9  10  11.0  12     foo
</code></pre>
<p>字典的各列可以使用不同的<code>NA</code>标记值：</p>
<pre><code class="language-python">sentinels = {'message': ['foo', 'NA'], 'something': ['two']}
pd.read_csv('examples/ex5.csv', na_values=sentinels)
something  a   b     c   d message
0       one  1   2   3.0   4     NaN
1       NaN  5   6   NaN   8   world
2     three  9  10  11.0  12     NaN
</code></pre>
<p>下表列出了<code>pandas.read_csv</code>和<code>pandas.read_table</code>常用的选项。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407050809.png" alt="" loading="lazy"></p>
<h4 id="逐块读取文本文件">逐块读取文本文件</h4>
<p>在处理很大的文件时，或找出大文件中的参数集以便于后续处理时，你可能只想读取文件的一小部分或逐块对文件进行迭代。</p>
<p>在看大文件之前，我们先设置<code>pandas</code>显示地更紧些：</p>
<pre><code class="language-python">result = pd.read_csv('examples/ex6.csv')
result
           one       two     three      four key
0     0.467976 -0.038649 -0.295344 -1.824726   L
1    -0.358893  1.404453  0.704965 -0.200638   B
2    -0.501840  0.659254 -0.421691 -0.057688   G
3     0.204886  1.074134  1.388361 -0.982404   R
4     0.354628 -0.133116  0.283763 -0.837063   Q
...        ...       ...       ...       ...  ..
9995  2.311896 -0.417070 -1.409599 -0.515821   L
9996 -0.479893 -0.650419  0.745152 -0.646038   E
9997  0.523331  0.787112  0.486066  1.093156   K
9998 -0.362559  0.598894 -1.843201  0.887292   G
9999 -0.096376 -1.012999 -0.657431 -0.573315   0
[10000 rows x 5 columns]
</code></pre>
<p>如果只想读取几行（避免读取整个文件），通过<code>nrows</code>进行指定即可：</p>
<pre><code class="language-python">pd.read_csv('examples/ex6.csv', nrows=5)

        one       two     three      four key
0  0.467976 -0.038649 -0.295344 -1.824726   L
1 -0.358893  1.404453  0.704965 -0.200638   B
2 -0.501840  0.659254 -0.421691 -0.057688   G
3  0.204886  1.074134  1.388361 -0.982404   R
4  0.354628 -0.133116  0.283763 -0.837063   Q
</code></pre>
<p>要逐块读取文件，可以指定<code>chunksize</code>（行数）：</p>
<pre><code class="language-python">chunker = pd.read_csv('ch06/ex6.csv', chunksize=1000)
chunker
&lt;pandas.io.parsers.TextParser at 0x8398150&gt;
</code></pre>
<p><code>read_csv</code>所返回的这个<code>TextParser</code>对象使你可以根据<code>chunksize</code>对文件进行逐块迭代。比如说，我们可以迭代处理<code>ex6.csv</code>，将值计数聚合到<code>&quot;key&quot;</code>列中，如下所示：</p>
<pre><code class="language-python">chunker = pd.read_csv('examples/ex6.csv', chunksize=1000)

tot = pd.Series([])
for piece in chunker:
    tot = tot.add(piece['key'].value_counts(), fill_value=0)

tot = tot.sort_values(ascending=False)
</code></pre>
<p>然后有：</p>
<pre><code class="language-python">tot[:10]
E    368.0
X    364.0
L    346.0
O    343.0
Q    340.0
M    338.0
J    337.0
F    335.0
K    334.0
H    330.0
dtype: float64
</code></pre>
<p><code>TextParser</code>还有一个<code>get_chunk</code>方法，它使你可以读取任意大小的块。</p>
<h4 id="将数据写出到文本格式">将数据写出到文本格式</h4>
<p>数据也可以被输出为分隔符格式的文本。我们再来看看之前读过的一个<code>CSV</code>文件：</p>
<pre><code class="language-python">data = pd.read_csv('examples/ex5.csv')
data
  something  a   b     c   d message
0       one  1   2   3.0   4     NaN
1       two  5   6   NaN   8   world
2     three  9  10  11.0  12     foo
</code></pre>
<p>利用<code>DataFrame</code>的<code>to_csv</code>方法，我们可以将数据写到一个以逗号分隔的文件中：</p>
<pre><code class="language-python">data.to_csv('examples/out.csv')
,something,a,b,c,d,message
0,one,1,2,3.0,4,
1,two,5,6,,8,world
2,three,9,10,11.0,12,foo
</code></pre>
<p>当然，还可以使用其他分隔符（由于这里直接写出到<code>sys.stdout</code>，所以仅仅是打印出文本结果而已）：</p>
<pre><code class="language-python">import sys
data.to_csv(sys.stdout, sep='|')
|something|a|b|c|d|message
0|one|1|2|3.0|4|
1|two|5|6||8|world
2|three|9|10|11.0|12|foo
</code></pre>
<p>缺失值在输出结果中会被表示为空字符串。你可能希望将其表示为别的标记值：</p>
<pre><code class="language-python">data.to_csv(sys.stdout, na_rep='NULL')
,something,a,b,c,d,message
0,one,1,2,3.0,4,NULL
1,two,5,6,NULL,8,world
2,three,9,10,11.0,12,foo
</code></pre>
<p>如果没有设置其他选项，则会写出行和列的标签。当然，它们也都可以被禁用：</p>
<pre><code class="language-python">data.to_csv(sys.stdout, index=False, header=False)
one,1,2,3.0,4,
two,5,6,,8,world
three,9,10,11.0,12,foo
</code></pre>
<p>此外，你还可以只写出一部分的列，并以你指定的顺序排列：</p>
<pre><code class="language-python">data.to_csv(sys.stdout, index=False, columns=['a', 'b', 'c'])
a,b,c
1,2,3.0
5,6,
9,10,11.0
</code></pre>
<p><code>Series</code>也有一个<code>to_csv</code>方法：</p>
<pre><code class="language-python">dates = pd.date_range('1/1/2000', periods=7)
ts = pd.Series(np.arange(7), index=dates)
ts.to_csv('examples/tseries.csv')
2000-01-01,0
2000-01-02,1
2000-01-03,2
2000-01-04,3
2000-01-05,4
2000-01-06,5
2000-01-07,6
</code></pre>
<h4 id="处理分隔符格式">处理分隔符格式</h4>
<p>大部分存储在磁盘上的表格型数据都能用<code>pandas.read_table</code>进行加载。然而，有时还是需要做一些手工处理。由于接收到含有畸形行的文件而使<code>read_table</code>出毛病的情况并不少见。为了说明这些基本工具，看看下面这个简单的<code>CSV</code>文件：</p>
<pre><code class="language-python">&quot;a&quot;,&quot;b&quot;,&quot;c&quot;
&quot;1&quot;,&quot;2&quot;,&quot;3&quot;
&quot;1&quot;,&quot;2&quot;,&quot;3&quot;
</code></pre>
<p>对于任何单字符分隔符文件，可以直接使用<code>Python</code>内置的<code>csv</code>模块。将任意已打开的文件或文件型的对象传给<code>csv.reader</code>：</p>
<pre><code class="language-python">import csv
f = open('examples/ex7.csv')

reader = csv.reader(f)
</code></pre>
<p>对这个<code>reader</code>进行迭代将会为每行产生一个元组（并移除了所有的引号）：</p>
<pre><code class="language-python">for line in reader:
    print(line)
['a', 'b', 'c']
['1', '2', '3']
['1', '2', '3']
</code></pre>
<p>现在，为了使数据格式合乎要求，你需要对其做一些整理工作。我们一步一步来做。首先，读取文件到一个多行的列表中：</p>
<pre><code class="language-python">with open('examples/ex7.csv') as f:
    lines = list(csv.reader(f))
</code></pre>
<p>然后，我们将这些行分为标题行和数据行：</p>
<pre><code class="language-python">header, values = lines[0], lines[1:]
</code></pre>
<p>然后，我们可以用字典构造式和<code>zip(*values)</code>，后者将行转置为列，创建数据列的字典：</p>
<pre><code class="language-python">data_dict = {h: v for h, v in zip(header, zip(*values))}
data_dict
{'a': ('1', '1'), 'b': ('2', '2'), 'c': ('3', '3')}
</code></pre>
<p><code>CSV</code>文件的形式有很多。只需定义<code>csv.Dialect</code>的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p>
<pre><code class="language-python">class my_dialect(csv.Dialect):
    lineterminator = '\n'
    delimiter = ';'
    quotechar = '&quot;'
    quoting = csv.QUOTE_MINIMAL
reader = csv.reader(f, dialect=my_dialect)
</code></pre>
<p>各个<code>CSV</code>语支的参数也可以用关键字的形式提供给<code>csv.reader</code>，而无需定义子类：</p>
<pre><code class="language-python">reader = csv.reader(f, delimiter='|')
</code></pre>
<p>可用的选项（<code>csv.Dialect</code>的属性）及其功能如下表所示。<br>
笔记：对于那些使用复杂分隔符或多字符分隔符的文件，<code>csv</code>模块就无能为力了。这种情况下，你就只能使用字符串的<code>split</code>方法或正则表达式方法<code>re.split</code>进行行拆分和其他整理工作了。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407051656.png" alt="" loading="lazy"><br>
要手工输出分隔符文件，你可以使用<code>csv.writer</code>。它接受一个已打开且可写的文件对象以及跟<code>csv.reader</code>相同的那些语支和格式化选项：</p>
<pre><code class="language-python">with open('mydata.csv', 'w') as f:
    writer = csv.writer(f, dialect=my_dialect)
    writer.writerow(('one', 'two', 'three'))
    writer.writerow(('1', '2', '3'))
    writer.writerow(('4', '5', '6'))
    writer.writerow(('7', '8', '9'))
</code></pre>
<h4 id="json数据"><code>JSON</code>数据</h4>
<p><code>JSON</code>（JavaScript Object Notation的简称）已经成为通过<code>HTTP</code>请求在<code>Web</code>浏览器和其他应用程序之间发送数据的标准格式之一。它是一种比表格型文本格式（如<code>CSV</code>）灵活得多的数据格式。下面是一个例子：</p>
<pre><code class="language-js">obj = &quot;&quot;&quot;
{&quot;name&quot;: &quot;Wes&quot;,
 &quot;places_lived&quot;: [&quot;United States&quot;, &quot;Spain&quot;, &quot;Germany&quot;],
 &quot;pet&quot;: null,
 &quot;siblings&quot;: [{&quot;name&quot;: &quot;Scott&quot;, &quot;age&quot;: 30, &quot;pets&quot;: [&quot;Zeus&quot;, &quot;Zuko&quot;]},
              {&quot;name&quot;: &quot;Katie&quot;, &quot;age&quot;: 38,
               &quot;pets&quot;: [&quot;Sixes&quot;, &quot;Stache&quot;, &quot;Cisco&quot;]}]
}
&quot;&quot;&quot;
</code></pre>
<p>除其空值<code>null</code>和一些其他的细微差别（如列表末尾不允许存在多余的逗号）之外，<code>JSON</code>非常接近于有效的<code>Python</code>代码。基本类型有对象（字典）、数组（列表）、字符串、数值、布尔值以及<code>null</code>。对象中所有的键都必须是字符串。许多<code>Python</code>库都可以读写<code>JSON</code>数据。我将使用<code>json</code>，因为它是构建<code>于Python</code>标准库中的。通过<code>json.loads</code>即可将<code>JSON</code>字符串转换成<code>Python</code>形式：</p>
<pre><code class="language-python">import json
result = json.loads(obj)
result
{'name': 'Wes',
 'pet': None,
 'places_lived': ['United States', 'Spain', 'Germany'],
 'siblings': [{'age': 30, 'name': 'Scott', 'pets': ['Zeus', 'Zuko']},
  {'age': 38, 'name': 'Katie', 'pets': ['Sixes', 'Stache', 'Cisco']}]}
</code></pre>
<p><code>json.dumps</code>则将<code>Python</code>对象转换成<code>JSON</code>格式：</p>
<pre><code class="language-python">asjson = json.dumps(result)
</code></pre>
<p>如何将（一个或一组）<code>JSON</code>对象转换为<code>DataFrame</code>或其他便于分析的数据结构就由你决定了。最简单方便的方式是：向<code>DataFrame</code>构造器传入一个字典的列表（就是原先的<code>JSON</code>对象），并选取数据字段的子集：</p>
<pre><code class="language-python">siblings = pd.DataFrame(result['siblings'], columns=['name', 'age'])
siblings
    name  age
0  Scott   30
1  Katie   38
</code></pre>
<p><code>pandas.read_json</code>可以自动将特别格式的<code>JSON</code>数据集转换为<code>Series</code>或<code>DataFrame</code>。例如：</p>
<pre><code class="language-python">[{&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3},
 {&quot;a&quot;: 4, &quot;b&quot;: 5, &quot;c&quot;: 6},
 {&quot;a&quot;: 7, &quot;b&quot;: 8, &quot;c&quot;: 9}]
</code></pre>
<p><code>pandas.read_json</code>的默认选项假设<code>JSON</code>数组中的每个对象是表格中的一行：</p>
<pre><code class="language-python">data = pd.read_json('examples/example.json')
data
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</code></pre>
<p>如果你需要将数据从<code>pandas</code>输出到<code>JSON</code>，可以使用<code>to_json</code>方法：</p>
<pre><code class="language-python">print(data.to_json())
{&quot;a&quot;:{&quot;0&quot;:1,&quot;1&quot;:4,&quot;2&quot;:7},&quot;b&quot;:{&quot;0&quot;:2,&quot;1&quot;:5,&quot;2&quot;:8},&quot;c&quot;:{&quot;0&quot;:3,&quot;1&quot;:6,&quot;2&quot;:9}}
print(data.to_json(orient='records'))
[{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3},{&quot;a&quot;:4,&quot;b&quot;:5,&quot;c&quot;:6},{&quot;a&quot;:7,&quot;b&quot;:8,&quot;c&quot;:9}]
</code></pre>
<h3 id="二进制数据格式">二进制数据格式</h3>
<p>实现数据的高效二进制格式存储最简单的办法之一是使用<code>Python</code>内置的<code>pickle</code>序列化。<code>pandas</code>对象都有一个用于将数据以<code>pickle</code>格式保存到磁盘上的<code>to_pickle</code>方法：</p>
<pre><code class="language-python">frame = pd.read_csv('examples/ex1.csv')
frame
   a   b   c   d message
0  1   2   3   4   hello
1  5   6   7   8   world
2  9  10  11  12     foo
frame.to_pickle('examples/frame_pickle')
</code></pre>
<p>你可以通过<code>pickle</code>直接读取被<code>pickle</code>化的数据，或是使用更为方便的<code>pandas.read_pickle</code>：</p>
<pre><code class="language-python">pd.read_pickle('examples/frame_pickle')
   a   b   c   d message
0  1   2   3   4   hello
1  5   6   7   8   world
2  9  10  11  12     foo
</code></pre>
<p>注意：<code>pickle</code>仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的；今天<code>pickle</code>的对象可能无法被后续版本的库<code>unpickle</code>出来。虽然我尽力保证这种事情不会发生在<code>pandas</code>中，但是今后的某个时候说不定还是得“打破”该<code>pickle</code>格式。</p>
<p><code>pandas</code>内置支持两个二进制数据格式：<code>HDF5</code>和<code>MessagePack</code>。</p>
<h4 id="使用hdf5格式">使用<code>HDF5</code>格式</h4>
<p><code>HDF5</code>是一种存储大规模科学数组数据的非常好的文件格式。它可以被作为<code>C</code>标准库。<code>HDF5</code>中的<code>HDF</code>指的是层次型数据格式（hierarchical data format）。每个<code>HDF5</code>文件都含有一个文件系统式的节点结构，它使你能够存储多个数据集并支持元数据。与其他简单格式相比，<code>HDF5</code>支持多种压缩器的即时压缩，还能更高效地存储重复模式数据。对于那些非常大的无法直接放入内存的数据集，<code>HDF5</code>就是不错的选择，因为它可以高效地分块读写。</p>
<p>虽然可以用<code>PyTables</code>或<code>h5py</code>库直接访问<code>HDF5</code>文件，<code>pandas</code>提供了更为高级的接口，可以简化存储<code>Series</code>和<code>DataFrame</code>对象。<code>HDFStore</code>类可以像字典一样，处理低级的细节：</p>
<pre><code class="language-python">frame = pd.DataFrame({'a': np.random.randn(100)})

store = pd.HDFStore('mydata.h5')
store['obj1'] = frame
store['obj1_col'] = frame['a']
store
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: mydata.h5
/obj1                frame        (shape-&gt;[100,1])                               
        
/obj1_col            series       (shape-&gt;[100])                                 
        
/obj2                frame_table  (typ-&gt;appendable,nrows-&gt;100,ncols-&gt;1,indexers-&gt;
[index])
/obj3                frame_table  (typ-&gt;appendable,nrows-&gt;100,ncols-&gt;1,indexers-&gt;
[index])
</code></pre>
<p><code>HDF5</code>文件中的对象可以通过与字典一样的<code>API</code>进行获取：</p>
<pre><code class="language-python">store['obj1']
           a
0  -0.204708
1   0.478943
2  -0.519439
3  -0.555730
4   1.965781
..       ...
95  0.795253
96  0.118110
97 -0.748532
98  0.584970
99  0.152677
[100 rows x 1 columns]
</code></pre>
<p><code>HDFStore</code>支持两种存储模式，<code>'fixed'</code>和<code>'table'</code>。后者通常会更慢，但是支持使用特殊语法进行查询操作：</p>
<pre><code class="language-python">store.put('obj2', frame, format='table')

store.select('obj2', where=['index &gt;= 10 and index &lt;= 15'])

           a
10  1.007189
11 -1.296221
12  0.274992
13  0.228913
14  1.352917
15  0.886429

store.close()
</code></pre>
<p><code>put</code>是<code>store['obj2'] = frame</code>方法的显示版本，允许我们设置其它的选项，比如格式。</p>
<p><code>pandas.read_hdf</code>函数可以快捷使用这些工具：</p>
<pre><code class="language-python">frame.to_hdf('mydata.h5', 'obj3', format='table')
pd.read_hdf('mydata.h5', 'obj3', where=['index &lt; 5'])
          a
0 -0.204708
1  0.478943
2 -0.519439
3 -0.555730
4  1.965781
</code></pre>
<p>如果需要本地处理海量数据，我建议你好好研究一下<code>PyTables</code>和<code>h5py</code>，看看它们能满足你的哪些需求。。由于许多数据分析问题都是<code>IO</code>密集型（而不是<code>CPU</code>密集型），利用<code>HDF5</code>这样的工具能显著提升应用程序的效率。</p>
<p>注意：<code>HDF5</code>不是数据库。它最适合用作“一次写多次读”的数据集。虽然数据可以在任何时候被添加到文件中，但如果同时发生多个写操作，文件就可能会被破坏。</p>
<h2 id="数据清洗和准备">数据清洗和准备</h2>
<h3 id="处理缺失数据">处理缺失数据</h3>
<p>在许多数据分析工作中，缺失数据是经常发生的。<code>pandas</code>的目标之一就是尽量轻松地处理缺失数据。例如，<code>pandas</code>对象的所有描述性统计默认都不包括缺失数据。</p>
<p>缺失数据在<code>pandas</code>中呈现的方式有些不完美，但对于大多数用户可以保证功能正常。对于数值数据，<code>pandas</code>使用浮点值<code>NaN</code>（<code>Not a Number</code>）表示缺失数据。我们称其为哨兵值，可以方便的检测出来：</p>
<pre><code class="language-python">string_data = pd.Series(['aardvark', 'artichoke', np.nan, 'avocado'])
string_data
0     aardvark
1    artichoke
2          NaN
3      avocado
dtype: object
string_data.isnull()
0    False
1    False
2     True
3    False
dtype: bool
</code></pre>
<p>在<code>pandas</code>中，我们采用了<code>R</code>语言中的惯用法，即将缺失值表示为<code>NA</code>，它表示不可用<code>not available</code>。在统计应用中，<code>NA</code>数据可能是不存在的数据或者虽然存在，但是没有观察到（例如，数据采集中发生了问题）。当进行数据清洗以进行分析时，最好直接对缺失数据进行分析，以判断数据采集的问题或缺失数据可能导致的偏差。</p>
<p><code>Python</code>内置的<code>None</code>值在对象数组中也可以作为<code>NA</code>：</p>
<pre><code class="language-python">string_data[0] = None
string_data.isnull()
0     True
1    False
2     True
3    False
dtype: bool
</code></pre>
<p><code>pandas</code>项目中还在不断优化内部细节以更好处理缺失数据，像用户<code>API</code>功能，例如<code>pandas.isnull</code>，去除了许多恼人的细节。下表列出了一些关于缺失数据处理的函数。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407145654.png" alt="" loading="lazy"></p>
<h4 id="滤除缺失数据">滤除缺失数据</h4>
<p>过滤掉缺失数据的办法有很多种。你可以通过<code>pandas.isnull</code>或布尔索引的手工方法，但<code>dropna</code>可能会更实用一些。对于一个<code>Series</code>，<code>dropna</code>返回一个仅含非空数据和索引值的<code>Series</code>：</p>
<pre><code class="language-python">from numpy import nan as NA
data = pd.Series([1, NA, 3.5, NA, 7])
data.dropna()
0    1.0
2    3.5
4    7.0
dtype: float64
</code></pre>
<p>这等价于：</p>
<pre><code class="language-python">data[data.notnull()]
0    1.0
2    3.5
4    7.0
dtype: float64
</code></pre>
<p>而对于<code>DataFrame</code>对象，事情就有点复杂了。你可能希望丢弃全<code>NA</code>或含有<code>NA</code>的行或列。<code>dropna</code>默认丢弃任何含有缺失值的行：</p>
<pre><code class="language-python">data = pd.DataFrame([[1., 6.5, 3.], [1., NA, NA],[NA, NA, NA], [NA, 6.5, 3.]])
cleaned = data.dropna()
data
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
2  NaN  NaN  NaN
3  NaN  6.5  3.0
cleaned
     0    1    2
0  1.0  6.5  3.0
</code></pre>
<p>传入<code>how='all'</code>将只丢弃全为<code>NA</code>的那些行：</p>
<pre><code class="language-python">data.dropna(how='all')
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
3  NaN  6.5  3.0
</code></pre>
<p>用这种方式丢弃列，只需传入<code>axis=1</code>即可：</p>
<pre><code class="language-python">data[4] = NA
data 
     0    1    2   4
0  1.0  6.5  3.0 NaN
1  1.0  NaN  NaN NaN
2  NaN  NaN  NaN NaN
3  NaN  6.5  3.0 NaN
data.dropna(axis=1, how='all')
     0    1    2
0  1.0  6.5  3.0
1  1.0  NaN  NaN
2  NaN  NaN  NaN
3  NaN  6.5  3.0
</code></pre>
<p>另一个滤除<code>DataFrame</code>行的问题涉及时间序列数据。假设你只想留下一部分观测数据，可以用<code>thresh</code>参数实现此目的：</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.randn(7, 3))
df.iloc[:4, 1] = NA
df.iloc[:2, 2] = NA
df
          0         1         2
0 -0.204708       NaN       NaN
1 -0.555730       NaN       NaN
2  0.092908       NaN  0.769023
3  1.246435       NaN -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
df.dropna()
          0         1         2
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
df.dropna(thresh=2)
          0         1         2
2  0.092908       NaN  0.769023
3  1.246435       NaN -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
</code></pre>
<h4 id="填充缺失数据">填充缺失数据</h4>
<p>你可能不想滤除缺失数据（有可能会丢弃跟它有关的其他数据），而是希望通过其他方式填补那些“空洞”。对于大多数情况而言，<code>fillna</code>方法是最主要的函数。通过一个常数调用<code>fillna</code>就会将缺失值替换为那个常数值：</p>
<pre><code class="language-python">df.fillna(0)
          0         1         2
0 -0.204708  0.000000  0.000000
1 -0.555730  0.000000  0.000000
2  0.092908  0.000000  0.769023
3  1.246435  0.000000 -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
</code></pre>
<p>若是通过一个字典调用<code>fillna</code>，就可以实现对不同的列填充不同的值：</p>
<pre><code class="language-python">df.fillna({1: 0.5, 2: 0})
          0         1         2
0 -0.204708  0.500000  0.000000
1 -0.555730  0.500000  0.000000
2  0.092908  0.500000  0.769023
3  1.246435  0.500000 -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
</code></pre>
<p><code>fillna</code>默认会返回新对象，但也可以对现有对象进行就地修改：</p>
<pre><code class="language-python">_ = df.fillna(0, inplace=True)
df
          0         1         2
0 -0.204708  0.000000  0.000000
1 -0.555730  0.000000  0.000000
2  0.092908  0.000000  0.769023
3  1.246435  0.000000 -1.296221
4  0.274992  0.228913  1.352917
5  0.886429 -2.001637 -0.371843
6  1.669025 -0.438570 -0.539741
</code></pre>
<p>对<code>reindexing</code>有效的那些插值方法也可用于<code>fillna</code>：</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.randn(6, 3))
df.iloc[2:, 1] = NA
df.iloc[4:, 2] = NA
df 
          0         1         2
0  0.476985  3.248944 -1.021228
1 -0.577087  0.124121  0.302614
2  0.523772       NaN  1.343810
3 -0.713544       NaN -2.370232
4 -1.860761       NaN       NaN
5 -1.265934       NaN       NaN
df.fillna(method='ffill')
          0         1         2
0  0.476985  3.248944 -1.021228
1 -0.577087  0.124121  0.302614
2  0.523772  0.124121  1.343810
3 -0.713544  0.124121 -2.370232
4 -1.860761  0.124121 -2.370232
5 -1.265934  0.124121 -2.370232
df.fillna(method='ffill', limit=2)
          0         1         2
0  0.476985  3.248944 -1.021228
1 -0.577087  0.124121  0.302614
2  0.523772  0.124121  1.343810
3 -0.713544  0.124121 -2.370232
4 -1.860761       NaN -2.370232
5 -1.265934       NaN -2.370232
</code></pre>
<p>只要有些创新，你就可以利用<code>fillna</code>实现许多别的功能。比如说，你可以传入<code>Series</code>的平均值或中位数：</p>
<pre><code class="language-python">data = pd.Series([1., NA, 3.5, NA, 7])
data.fillna(data.mean())
0    1.000000
1    3.833333
2    3.500000
3    3.833333
4    7.000000
dtype: float64
</code></pre>
<p>下表列出了<code>fillna</code>的参考。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407151513.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407151527.png" alt="" loading="lazy"></p>
<h3 id="数据转换">数据转换</h3>
<h4 id="移除重复数据">移除重复数据</h4>
<p><code>DataFrame</code>中出现重复行有多种原因。下面就是一个例子：</p>
<pre><code class="language-python">data = pd.DataFrame({'k1': ['one', 'two'] * 3 + ['two'],'k2': [1, 1, 2, 3, 3, 4, 4]})
data
    k1  k2
0  one   1
1  two   1
2  one   2
3  two   3
4  one   3
5  two   4
6  two   4
</code></pre>
<p><code>DataFrame</code>的<code>duplicated</code>方法返回一个布尔型<code>Series</code>，表示各行是否是重复行（前面出现过的行）：</p>
<pre><code class="language-python">data.duplicated()
0    False
1    False
2    False
3    False
4    False
5    False
6     True
dtype: bool
</code></pre>
<p>还有一个与此相关的<code>drop_duplicates</code>方法，它会返回一个<code>DataFrame</code>，重复的数组会标为<code>False</code>：</p>
<pre><code class="language-python">data.drop_duplicates()
    k1  k2
0  one   1
1  two   1
2  one   2
3  two   3
4  one   3
5  two   4
</code></pre>
<p>这两个方法默认会判断全部列，你也可以指定部分列进行重复项判断。假设我们还有一列值，且只希望根据<code>k1</code>列过滤重复项：</p>
<pre><code class="language-python">data['v1'] = range(7)
data.drop_duplicates(['k1'])
    k1  k2  v1
0  one   1   0
1  two   1   1
</code></pre>
<p><code>duplicated</code>和<code>drop_duplicates</code>默认保留的是第一个出现的值组合。传入<code>keep='last'</code>则保留最后一个：</p>
<pre><code class="language-python">data.drop_duplicates(['k1', 'k2'], keep='last')
    k1  k2  v1
0  one   1   0
1  two   1   1
2  one   2   2
3  two   3   3
4  one   3   4
6  two   4   6
</code></pre>
<h4 id="利用函数或映射进行数据转换">利用函数或映射进行数据转换</h4>
<p>对于许多数据集，你可能希望根据数组、<code>Series</code>或<code>DataFrame</code>列中的值来实现转换工作。我们来看看下面这组有关肉类的数据：</p>
<pre><code class="language-python">data = pd.DataFrame({'food': ['bacon', 'pulled pork', 'bacon','Pastrami', 'corned beef', 'Bacon','pastrami', 'honey ham', 'nova lox'],'ounces': [4, 3, 12, 6, 7.5, 8, 3, 5, 6]})
data
          food  ounces
0        bacon     4.0
1  pulled pork     3.0
2        bacon    12.0
3     Pastrami     6.0
4  corned beef     7.5
5        Bacon     8.0
6     pastrami     3.0
7    honey ham     5.0
8     nova lox     6.0
</code></pre>
<p>假设你想要添加一列表示该肉类食物来源的动物类型。我们先编写一个不同肉类到动物的映射：</p>
<pre><code class="language-python">meat_to_animal = {
  'bacon': 'pig',
  'pulled pork': 'pig',
  'pastrami': 'cow',
  'corned beef': 'cow',
  'honey ham': 'pig',
  'nova lox': 'salmon'
}
</code></pre>
<p><code>Series</code>的<code>map</code>方法可以接受一个函数或含有映射关系的字典型对象，但是这里有一个小问题，即有些肉类的首字母大写了，而另一些则没有。因此，我们还需要使用<code>Series</code>的<code>str.lower</code>方法，将各个值转换为小写：</p>
<pre><code class="language-python">lowercased = data['food'].str.lower()
lowercased
0          bacon
1    pulled pork
2          bacon
3       pastrami
4    corned beef
5          bacon
6       pastrami
7      honey ham
8       nova lox
Name: food, dtype: object
data['animal'] = lowercased.map(meat_to_animal)
data
          food  ounces  animal
0        bacon     4.0     pig
1  pulled pork     3.0     pig
2        bacon    12.0     pig
3     Pastrami     6.0     cow
4  corned beef     7.5     cow
5        Bacon     8.0     pig
6     pastrami     3.0     cow
7    honey ham     5.0     pig
8     nova lox     6.0  salmon
</code></pre>
<p>我们也可以传入一个能够完成全部这些工作的函数：</p>
<pre><code class="language-python">data['food'].map(lambda x: meat_to_animal[x.lower()])
0       pig
1       pig
2       pig
3       cow
4       cow
5       pig
6       cow
7       pig
8    salmon
Name: food, dtype: object
</code></pre>
<p>使用<code>map</code>是一种实现元素级转换以及其他数据清理工作的便捷方式。</p>
<h4 id="替换值">替换值</h4>
<p>利用<code>fillna</code>方法填充缺失数据可以看做值替换的一种特殊情况。前面已经看到，<code>map</code>可用于修改对象的数据子集，而<code>replace</code>则提供了一种实现该功能的更简单、更灵活的方式。我们来看看下面这个<code>Series</code>：</p>
<pre><code class="language-python">data = pd.Series([1., -999., 2., -999., -1000., 3.])
data
0       1.0
1    -999.0
2       2.0
3    -999.0
4   -1000.0
5       3.0
</code></pre>
<p>-999这个值可能是一个表示缺失数据的标记值。要将其替换为<code>pandas</code>能够理解的<code>NA</code>值，我们可以利用<code>replace</code>来产生一个新的<code>Series</code>（除非传入<code>inplace=True</code>）：</p>
<pre><code class="language-python">data.replace(-999, np.nan)
0       1.0
1       NaN
2       2.0
3       NaN
4   -1000.0
5       3.0
dtype: float64
</code></pre>
<p>如果你希望一次性替换多个值，可以传入一个由待替换值组成的列表以及一个替换值：：</p>
<pre><code class="language-python">data.replace([-999, -1000], np.nan)
0    1.0
1    NaN
2    2.0
3    NaN
4    NaN
5    3.0
dtype: float64
</code></pre>
<p>要让每个值有不同的替换值，可以传递一个替换列表：</p>
<pre><code class="language-python">data.replace([-999, -1000], [np.nan, 0])
0    1.0
1    NaN
2    2.0
3    NaN
4    0.0
5    3.0
dtype: float64
</code></pre>
<p>传入的参数也可以是字典：</p>
<pre><code class="language-python">data.replace({-999: np.nan, -1000: 0})
0    1.0
1    NaN
2    2.0
3    NaN
4    0.0
5    3.0
dtype: float64
</code></pre>
<p>笔记：<code>data.replace</code>方法与<code>data.str.replace</code>不同，后者做的是字符串的元素级替换。我们会在后面学习<code>Series</code>的字符串方法。</p>
<h4 id="重命名轴索引">重命名轴索引</h4>
<p>跟<code>Series</code>中的值一样，轴标签也可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。轴还可以被就地修改，而无需新建一个数据结构。接下来看看下面这个简单的例子：</p>
<pre><code class="language-python">data = pd.DataFrame(np.arange(12).reshape((3, 4)),index=['Ohio', 'Colorado', 'New York'],columns=['one', 'two', 'three', 'four'])
</code></pre>
<p>跟<code>Series</code>一样，轴索引也有一个<code>map</code>方法：</p>
<pre><code class="language-python">transform = lambda x: x[:4].upper()
data.index.map(transform)
Index(['OHIO', 'COLO', 'NEW '], dtype='object')
</code></pre>
<p>你可以将其赋值给<code>index</code>，这样就可以对<code>DataFrame</code>进行就地修改：</p>
<pre><code class="language-python">data.index = data.index.map(transform)
data
one  two  three  four
OHIO    0    1      2     3
COLO    4    5      6     7
NEW     8    9     10    11
</code></pre>
<p>如果想要创建数据集的转换版（而不是修改原始数据），比较实用的方法是<code>rename</code>：</p>
<pre><code class="language-python">data.rename(index=str.title, columns=str.upper)
      ONE  TWO  THREE  FOUR
Ohio    0    1      2     3
Colo    4    5      6     7
New     8    9     10    11
</code></pre>
<p>特别说明一下，<code>rename</code>可以结合字典型对象实现对部分轴标签的更新：</p>
<pre><code class="language-python">data.rename(index={'OHIO': 'INDIANA'},columns={'three': 'peekaboo'})
one  two  peekaboo  four
INDIANA    0    1         2     3
COLO       4    5         6     7
NEW        8    9        10    11
</code></pre>
<p><code>rename</code>可以实现复制<code>DataFrame</code>并对其索引和列标签进行赋值。如果希望就地修改某个数据集，传入<code>inplace=True</code>即可：</p>
<pre><code class="language-python">data.rename(index={'OHIO': 'INDIANA'}, inplace=True)
data
         one  two  three  four
INDIANA    0    1      2     3
COLO       4    5      6     7
NEW        8    9     10    11
</code></pre>
<h4 id="离散化和面元划分">离散化和面元划分</h4>
<p>为了便于分析，连续数据常常被离散化或拆分为“面元”（<code>bin</code>）。假设有一组人员数据，而你希望将它们划分为不同的年龄组：</p>
<pre><code class="language-python">ages = [20, 22, 25, 27, 21, 23, 37, 31, 61, 45, 41, 32]
</code></pre>
<p>接下来将这些数据划分为“18到25”、“26到35”、“35到60”以及“60以上”几个面元。要实现该功能，你需要使用<code>pandas</code>的<code>cut</code>函数：</p>
<pre><code class="language-python">bins = [18, 25, 35, 60, 100]
cats = pd.cut(ages, bins)
cats
[(18, 25], (18, 25], (18, 25], (25, 35], (18, 25], ..., (25, 35], (60, 100], (35,60], (35, 60], (25, 35]]
Length: 12
Categories (4, interval[int64]): [(18, 25] &lt; (25, 35] &lt; (35, 60] &lt; (60, 100]]
</code></pre>
<p><code>pandas</code>返回的是一个特殊的<code>Categorical</code>对象。结果展示了<code>pandas.cut</code>划分的面元。你可以将其看做一组表示面元名称的字符串。它的底层含有一个表示不同分类名称的类型数组，以及一个<code>codes</code>属性中的年龄数据的标签：</p>
<pre><code class="language-python">cats.codes
array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)
cats.categories
IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]]closed='right',dtype='interval[int64]')
pd.value_counts(cats)
(18, 25]     5
(35, 60]     3
(25, 35]     3
(60, 100]    1
dtype: int64
</code></pre>
<p><code>pd.value_counts(cats)</code>是<code>pandas.cut</code>结果的面元计数。</p>
<p>跟“区间”的数学符号一样，圆括号表示开端，而方括号则表示闭端（包括）。哪边是闭端可以通过<code>right=False</code>进行修改：</p>
<pre><code class="language-python">pd.cut(ages, [18, 26, 36, 61, 100], right=False)
[[18, 26), [18, 26), [18, 26), [26, 36), [18, 26), ..., [26, 36), [61, 100), [36,
 61), [36, 61), [26, 36)]
Length: 12
Categories (4, interval[int64]): [[18, 26) &lt; [26, 36) &lt; [36, 61) &lt; [61, 100)]
</code></pre>
<p>你可 以通过传递一个列表或数组到<code>labels</code>，设置自己的面元名称：</p>
<pre><code class="language-python">group_names = ['Youth', 'YoungAdult', 'MiddleAged', 'Senior']
pd.cut(ages, bins, labels=group_names)
[Youth, Youth, Youth, YoungAdult, Youth, ..., YoungAdult, Senior, MiddleAged, Mid
dleAged, YoungAdult]
Length: 12
Categories (4, object): [Youth &lt; YoungAdult &lt; MiddleAged &lt; Senior]
</code></pre>
<p>如果向<code>cut</code>传入的是面元的数量而不是确切的面元边界，则它会根据数据的最小值和最大值计算等长面元。下面这个例子中，我们将一些均匀分布的数据分成四组：</p>
<pre><code class="language-python">data = np.random.rand(20)
pd.cut(data, 4, precision=2)
[(0.34, 0.55], (0.34, 0.55], (0.76, 0.97], (0.76, 0.97], (0.34, 0.55], ..., (0.34
, 0.55], (0.34, 0.55], (0.55, 0.76], (0.34, 0.55], (0.12, 0.34]]
Length: 20
Categories (4, interval[float64]): [(0.12, 0.34] &lt; (0.34, 0.55] &lt; (0.55, 0.76] &lt; 
(0.76, 0.97]]
</code></pre>
<p>选项<code>precision=2</code>，限定小数只有两位。</p>
<p><code>qcut</code>是一个非常类似于<code>cut</code>的函数，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，<code>cut</code>可能无法使各个面元中含有相同数量的数据点。而<code>qcut</code>由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<pre><code class="language-python">data = np.random.randn(1000)  # Normally distributed
cats = pd.qcut(data, 4)  # Cut into quartiles
cats
[(-0.0265, 0.62], (0.62, 3.928], (-0.68, -0.0265], (0.62, 3.928], (-0.0265, 0.62]
, ..., (-0.68, -0.0265], (-0.68, -0.0265], (-2.95, -0.68], (0.62, 3.928], (-0.68,
 -0.0265]]
Length: 1000
Categories (4, interval[float64]): [(-2.95, -0.68] &lt; (-0.68, -0.0265] &lt; (-0.0265,
 0.62] &lt;(0.62, 3.928]]
pd.value_counts(cats)
(0.62, 3.928]       250
(-0.0265, 0.62]     250
(-0.68, -0.0265]    250
(-2.95, -0.68]      250
dtype: int64
</code></pre>
<p>与<code>cut</code>类似，你也可以传递自定义的分位数（0到1之间的数值，包含端点）：</p>
<pre><code class="language-python">pd.qcut(data, [0, 0.1, 0.5, 0.9, 1.])
[(-0.0265, 1.286], (-0.0265, 1.286], (-1.187, -0.0265], (-0.0265, 1.286], (-0.026
5, 1.286], ..., (-1.187, -0.0265], (-1.187, -0.0265], (-2.95, -1.187], (-0.0265, 
1.286], (-1.187, -0.0265]]
Length: 1000
Categories (4, interval[float64]): [(-2.95, -1.187] &lt; (-1.187, -0.0265] &lt; (-0.026
5, 1.286] &lt;(1.286, 3.928]]
</code></pre>
<p>本章稍后在讲解聚合和分组运算时会再次用到<code>cut</code>和<code>qcut</code>，因为这两个离散化函数对分位和分组分析非常重要。</p>
<h4 id="检测和过滤异常值">检测和过滤异常值</h4>
<p>过滤或变换异常值（<code>outlier</code>）在很大程度上就是运用数组运算。来看一个含有正态分布数据的<code>DataFrame</code>：</p>
<pre><code class="language-python">data = pd.DataFrame(np.random.randn(1000, 4))
data.describe()
                 0            1            2            3
count  1000.000000  1000.000000  1000.000000  1000.000000
mean      0.049091     0.026112    -0.002544    -0.051827
std       0.996947     1.007458     0.995232     0.998311
min      -3.645860    -3.184377    -3.745356    -3.428254
25%      -0.599807    -0.612162    -0.687373    -0.747478
50%       0.047101    -0.013609    -0.022158    -0.088274
75%       0.756646     0.695298     0.699046     0.623331
max       2.653656     3.525865     2.735527     3.366626
</code></pre>
<p>假设你想要找出某列中绝对值大小超过3的值：</p>
<pre><code class="language-python">col = data[2]
col[np.abs(col) &gt; 3]
41    -3.399312
136   -3.745356
Name: 2, dtype: float64
</code></pre>
<p>要选出全部含有“超过3或－3的值”的行，你可以在布尔型<code>DataFrame</code>中使用<code>any</code>方法：</p>
<pre><code class="language-python">data[(np.abs(data) &gt; 3).any(1)]
            0         1         2         3
41   0.457246 -0.025907 -3.399312 -0.974657
60   1.951312  3.260383  0.963301  1.201206
136  0.508391 -0.196713 -3.745356 -1.520113
235 -0.242459 -3.056990  1.918403 -0.578828
258  0.682841  0.326045  0.425384 -3.428254
322  1.179227 -3.184377  1.369891 -1.074833
544 -3.548824  1.553205 -2.186301  1.277104
635 -0.578093  0.193299  1.397822  3.366626
782 -0.207434  3.525865  0.283070  0.544635
803 -3.645860  0.255475 -0.549574 -1.907459
</code></pre>
<p>根据这些条件，就可以对值进行设置。下面的代码可以将值限制在区间－3到3以内：</p>
<pre><code class="language-python">data[np.abs(data) &gt; 3] = np.sign(data) * 3
data.describe()
                 0            1            2            3
count  1000.000000  1000.000000  1000.000000  1000.000000
mean      0.050286     0.025567    -0.001399    -0.051765
std       0.992920     1.004214     0.991414     0.995761
min      -3.000000    -3.000000    -3.000000    -3.000000
25%      -0.599807    -0.612162    -0.687373    -0.747478
50%       0.047101    -0.013609    -0.022158    -0.088274
75%       0.756646     0.695298     0.699046     0.623331
max       2.653656     3.000000     2.735527     3.000000
</code></pre>
<p>根据数据的值是正还是负，<code>np.sign(data)</code>可以生成1和-1：</p>
<pre><code class="language-python">np.sign(data).head()
     0    1    2    3
0 -1.0  1.0 -1.0  1.0
1  1.0 -1.0  1.0 -1.0
2  1.0  1.0  1.0 -1.0
3 -1.0 -1.0  1.0 -1.0
4 -1.0  1.0 -1.0 -1.0
</code></pre>
<h4 id="排列和随机采样">排列和随机采样</h4>
<p>利用<code>numpy.random.permutation</code>函数可以轻松实现对<code>Series</code>或<code>DataFrame</code>的列的排列工作（<code>permuting</code>，随机重排序）。通过需要排列的轴的长度调用<code>permutation</code>，可产生一个表示新顺序的整数数组：</p>
<pre><code class="language-python">df = pd.DataFrame(np.arange(5 * 4).reshape((5, 4)))
sampler = np.random.permutation(5)
sampler
array([3, 1, 4, 2, 0])
</code></pre>
<p>然后就可以在基于<code>iloc</code>的索引操作或<code>take</code>函数中使用该数组了：</p>
<pre><code class="language-python">df
    0   1   2   3
0   0   1   2   3
1   4   5   6   7
2   8   9  10  11
3  12  13  14  15
4  16  17  18  19
df.take(sampler)
    0   1   2   3
3  12  13  14  15
1   4   5   6   7
4  16  17  18  19
2   8   9  10  11
0   0   1   2   3
</code></pre>
<p>如果不想用替换的方式选取随机子集，可以在<code>Series</code>和<code>DataFrame</code>上使用<code>sample</code>方法：</p>
<pre><code class="language-python">df.sample(n=3)
    0   1   2   3
3  12  13  14  15
4  16  17  18  19
2   8   9  10  11
</code></pre>
<p>要通过替换的方式产生样本（允许重复选择），可以传递<code>replace=True</code>到<code>sample</code>：</p>
<pre><code class="language-python">choices = pd.Series([5, 7, -1, 6, 4])
draws = choices.sample(n=10, replace=True)
draws
4    4
1    7
4    4
2   -1
0    5
3    6
1    7
4    4
0    5
4    4
dtype: int64
</code></pre>
<h4 id="计算指标哑变量">计算指标/哑变量</h4>
<p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（<code>categorical variable</code>）转换为“哑变量”或“指标矩阵”。</p>
<p>如果<code>DataFrame</code>的某一列中含有<code>k</code>个不同的值，则可以派生出一个<code>k</code>列矩阵或<code>DataFrame</code>（其值全为1和0）。<code>pandas</code>有一个<code>get_dummies</code>函数可以实现该功能（其实自己动手做一个也不难）。使用之前的一个<code>DataFrame</code>例子：</p>
<pre><code class="language-python">df = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'b'],'data1': range(6)})
pd.get_dummies(df['key'])
   a  b  c
0  0  1  0
1  0  1  0
2  1  0  0
3  0  0  1
4  1  0  0
5  0  1  0
</code></pre>
<p>有时候，你可能想给指标<code>DataFrame</code>的列加上一个前缀，以便能够跟其他数据进行合并。<code>get_dummies</code>的<code>prefix</code>参数可以实现该功能：</p>
<pre><code class="language-python">dummies = pd.get_dummies(df['key'], prefix='key')
df_with_dummy = df[['data1']].join(dummies)
df_with_dummy
   data1  key_a  key_b  key_c
0      0      0      1      0
1      1      0      1      0
2      2      1      0      0
3      3      0      0      1
4      4      1      0      0
5      5      0      1      0
</code></pre>
<p>如果<code>DataFrame</code>中的某行同属于多个分类，则事情就会有点复杂。看一下MovieLens 1M数据集，14章会更深入地研究它：</p>
<pre><code class="language-python">mnames = ['movie_id', 'title', 'genres']
movies = pd.read_table('datasets/movielens/movies.dat', sep='::',header=None, names=mnames)
movies[:10]
   movie_id                               title                        genres
0         1                    Toy Story (1995)   Animation|Children's|Comedy
1         2                      Jumanji (1995)  Adventure|Children's|Fantasy
2         3             Grumpier Old Men (1995)                Comedy|Romance
3         4            Waiting to Exhale (1995)                  Comedy|Drama
4         5  Father of the Bride Part II (1995)                        Comedy
5         6                         Heat (1995)         Action|Crime|Thriller
6         7                      Sabrina (1995)                Comedy|Romance
7         8                 Tom and Huck (1995)          Adventure|Children's
8         9                 Sudden Death (1995)                        Action
9        10                    GoldenEye (1995)     Action|Adventure|Thriller
</code></pre>
<p>要为每个<code>genre</code>添加指标变量就需要做一些数据规整操作。首先，我们从数据集中抽取出不同的<code>genre</code>值：</p>
<pre><code class="language-python">all_genres = []
for x in movies.genres:
    all_genres.extend(x.split('|'))
genres = pd.unique(all_genres)
genres
array(['Animation', &quot;Children's&quot;, 'Comedy', 'Adventure', 'Fantasy',
       'Romance', 'Drama', 'Action', 'Crime', 'Thriller','Horror',
       'Sci-Fi', 'Documentary', 'War', 'Musical', 'Mystery', 'Film-Noir',
       'Western'], dtype=object)
</code></pre>
<p>构建指标<code>DataFrame</code>的方法之一是从一个全零<code>DataFrame</code>开始：</p>
<pre><code class="language-python">zero_matrix = np.zeros((len(movies), len(genres)))
dummies = pd.DataFrame(zero_matrix, columns=genres)
</code></pre>
<p>现在，迭代每一部电影，并将<code>dummies</code>各行的条目设为1。要这么做，我们使用<code>dummies.columns</code>来计算每个类型的列索引：</p>
<pre><code class="language-python">gen = movies.genres[0]
gen.split('|')
['Animation', &quot;Children's&quot;, 'Comedy']
dummies.columns.get_indexer(gen.split('|'))
array([0, 1, 2])
</code></pre>
<p>然后，根据索引，使用<code>.iloc</code>设定值：</p>
<pre><code class="language-python">for i, gen in enumerate(movies.genres):
    indices = dummies.columns.get_indexer(gen.split('|'))
    dummies.iloc[i, indices] = 1
</code></pre>
<p>然后，和以前一样，再将其与movies合并起来：</p>
<pre><code class="language-python">movies_windic = movies.join(dummies.add_prefix('Genre_'))
movies_windic.iloc[0]
movie_id                                       1
title                           Toy Story (1995)
genres               Animation|Children's|Comedy
Genre_Animation                                1
Genre_Children's                               1
Genre_Comedy                                   1
Genre_Adventure                                0
Genre_Fantasy                                  0
Genre_Romance                                  0
Genre_Drama                                    0
                                ...             
Genre_Crime                                    0
Genre_Thriller                                 0
Genre_Horror                                   0
Genre_Sci-Fi                                   0
Genre_Documentary                              0
Genre_War                                      0
Genre_Musical                                  0
Genre_Mystery                                  0
Genre_Film-Noir                                0
Genre_Western                                  0
Name: 0, Length: 21, dtype: object
</code></pre>
<p>笔记：对于很大的数据，用这种方式构建多成员指标变量就会变得非常慢。最好使用更低级的函数，将其写入<code>NumPy</code>数组，然后结果包装在<code>DataFrame</code>中。</p>
<p>一个对统计应用有用的秘诀是：结合<code>get_dummies</code>和诸如<code>cut</code>之类的离散化函数：</p>
<pre><code class="language-python">np.random.seed(12345)
values = np.random.rand(10)
values
array([ 0.9296,  0.3164,  0.1839,  0.2046,  0.5677,  0.5955,  0.9645,
        0.6532,  0.7489,  0.6536])
bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
pd.get_dummies(pd.cut(values, bins))
   (0.0, 0.2]  (0.2, 0.4]  (0.4, 0.6]  (0.6, 0.8]  (0.8, 1.0]
0           0           0           0           0           1
1           0           1           0           0           0
2           1           0           0           0           0
3           0           1           0           0           0
4           0           0           1           0           0
5           0           0           1           0           0
6           0           0           0           0           1
7           0           0           0           1           0
8           0           0           0           1           0
9           0           0           0           1           0
</code></pre>
<p>我们用<code>numpy.random.seed</code>，使这个例子具有确定性。本书后面会介绍<code>pandas.get_dummies</code>。</p>
<h3 id="字符串操作">字符串操作</h3>
<p><code>Python</code>能够成为流行的数据处理语言，部分原因是其简单易用的字符串和文本处理功能。大部分文本运算都直接做成了字符串对象的内置方法。对于更为复杂的模式匹配和文本操作，则可能需要用到正则表达式。<code>pandas</code>对此进行了加强，它使你能够对整组数据应用字符串表达式和正则表达式，而且能处理烦人的缺失数据。</p>
<h4 id="字符串对象方法">字符串对象方法</h4>
<p>对于许多字符串处理和脚本应用，内置的字符串方法已经能够满足要求了。例如，以逗号分隔的字符串可以用<code>split</code>拆分成数段：</p>
<pre><code class="language-python">val = 'a,b,  guido'
val.split(',')
['a', 'b', '  guido']
</code></pre>
<p><code>split</code>常常与<code>strip</code>一起使用，以去除空白符（包括换行符）：</p>
<pre><code class="language-python">pieces = [x.strip() for x in val.split(',')]
pieces
['a', 'b', 'guido']
</code></pre>
<p>利用加法，可以将这些子字符串以双冒号分隔符的形式连接起来：</p>
<pre><code class="language-python">first, second, third = pieces
first + '::' + second + '::' + third
'a::b::guido'
</code></pre>
<p>但这种方式并不是很实用。一种更快更符合<code>Python</code>风格的方式是，向字符串<code>&quot;::&quot;</code>的<code>join</code>方法传入一个列表或元组：</p>
<pre><code class="language-python">'::'.join(pieces)
'a::b::guido'
</code></pre>
<p>其它方法关注的是子串定位。检测子串的最佳方式是利用<code>Python</code>的<code>in</code>关键字，还可以使用<code>index</code>和<code>find</code>：</p>
<pre><code class="language-python">'guido' in val
True
val.index(',')
1
val.find(':')
-1
</code></pre>
<p>注意<code>find</code>和<code>index</code>的区别：如果找不到字符串，<code>index</code>将会引发一个异常（而不是返回<code>－1</code>）：</p>
<pre><code class="language-python">val.index(':')
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-144-280f8b2856ce&gt; in &lt;module&gt;()
----&gt; 1 val.index(':')
ValueError: substring not found
</code></pre>
<p>与此相关，<code>count</code>可以返回指定子串的出现次数：</p>
<pre><code class="language-python">val.count(',')
2
</code></pre>
<p><code>replace</code>用于将指定模式替换为另一个模式。通过传入空字符串，它也常常用于删除模式：</p>
<pre><code class="language-python">val.replace(',', '::')
'a::b::  guido'
val.replace(',', '')
'ab  guido'
</code></pre>
<p>下表列出了<code>Python</code>内置的字符串方法。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407190549.png" alt="" loading="lazy"><br>
这些运算大部分都能使用正则表达式实现（马上就会看到）。<br>
<code>casefold</code> 将字符转换为小写，并将任何特定区域的变量字符组合转换成一个通用的可比较形式。</p>
<h4 id="正则表达式">正则表达式</h4>
<p>正则表达式提供了一种灵活的在文本中搜索或匹配（通常比前者复杂）字符串模式的方式。正则表达式，常称作<code>regex</code>，是根据正则表达式语言编写的字符串。<code>Python</code>内置的<code>re</code>模块负责对字符串应用正则表达式。我将通过一些例子说明其使用方法。</p>
<p><code>re</code>模块的函数可以分为三个大类：模式匹配、替换以及拆分。当然，它们之间是相辅相成的。一个<code>regex</code>描述了需要在文本中定位的一个模式，它可以用于许多目的。我们先来看一个简单的例子：假设我想要拆分一个字符串，分隔符为数量不定的一组空白符（制表符、空格、换行符等）。描述一个或多个空白符的<code>regex</code>是<code>\s+</code>：</p>
<pre><code class="language-python">import re
text = &quot;foo    bar\t baz  \tqux&quot;
re.split('\s+', text)
['foo', 'bar', 'baz', 'qux']
</code></pre>
<p>调用<code>re.split('\s+',text)</code>时，正则表达式会先被编译，然后再在<code>text</code>上调用其<code>split</code>方法。你可以用<code>re.compile</code>自己编译<code>regex</code>以得到一个可重用的<code>regex</code>对象：</p>
<pre><code class="language-python">regex = re.compile('\s+')
regex.split(text)
['foo', 'bar', 'baz', 'qux']
</code></pre>
<p>如果只希望得到匹配<code>regex</code>的所有模式，则可以使用<code>findall</code>方法：</p>
<pre><code class="language-python">regex.findall(text)
['    ', '\t ', '  \t']
</code></pre>
<p>笔记：如果想避免正则表达式中不需要的转义（<code>\</code>），则可以使用原始字符串字面量如r<code>'C:\x'</code>（也可以编写其等价式<code>'C:\x'</code>）。</p>
<p>如果打算对许多字符串应用同一条正则表达式，强烈建议通过<code>re.compile</code>创建<code>regex</code>对象。这样将可以节省大量的<code>CPU</code>时间。</p>
<p><code>match</code>和<code>search</code>跟<code>findall</code>功能类似。<code>findall</code>返回的是字符串中所有的匹配项，而<code>search</code>则只返回第一个匹配项。<code>match</code>更加严格，它只匹配字符串的首部。来看一个小例子，假设我们有一段文本以及一条能够识别大部分电子邮件地址的正则表达式：</p>
<pre><code class="language-python">text = &quot;&quot;&quot;Dave dave@google.com
Steve steve@gmail.com
Rob rob@gmail.com
Ryan ryan@yahoo.com
&quot;&quot;&quot;
pattern = r'[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}'
#re.IGNORECASE makes the regex case-insensitive
regex = re.compile(pattern, flags=re.IGNORECASE)
</code></pre>
<p>对<code>text</code>使用<code>findall</code>将得到一组电子邮件地址：</p>
<pre><code class="language-python">regex.findall(text)
['dave@google.com',
 'steve@gmail.com',
 'rob@gmail.com',
 'ryan@yahoo.com']
</code></pre>
<p><code>search</code>返回的是文本中第一个电子邮件地址（以特殊的匹配项对象形式返回）。对于上面那个<code>regex</code>，匹配项对象只能告诉我们模式在原字符串中的起始和结束位置：</p>
<pre><code class="language-python">m = regex.search(text)
m
&lt;_sre.SRE_Match object; span=(5, 20), match='dave@google.com'&gt;
text[m.start():m.end()]
'dave@google.com'
</code></pre>
<p><code>regex.match</code>则将返回<code>None</code>，因为它只匹配出现在字符串开头的模式：</p>
<pre><code class="language-python">print(regex.match(text))
None
</code></pre>
<p>相关的，<code>sub</code>方法可以将匹配到的模式替换为指定字符串，并返回所得到的新字符串：</p>
<pre><code class="language-python">print(regex.sub('REDACTED', text))
Dave REDACTED
Steve REDACTED
Rob REDACTED
Ryan REDACTED
</code></pre>
<p>假设你不仅想要找出电子邮件地址，还想将各个地址分成3个部分：用户名、域名以及域后缀。要实现此功能，只需将待分段的模式的各部分用圆括号包起来即可：</p>
<pre><code class="language-python">pattern = r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]{2,4})'
regex = re.compile(pattern, flags=re.IGNORECASE)
</code></pre>
<p>由这种修改过的正则表达式所产生的匹配项对象，可以通过其<code>groups</code>方法返回一个由模式各段组成的元组：</p>
<pre><code class="language-python">m = regex.match('wesm@bright.net')
m.groups()
('wesm', 'bright', 'net')
</code></pre>
<p>对于带有分组功能的模式，<code>findall</code>会返回一个元组列表：</p>
<pre><code class="language-python">regex.findall(text)
[('dave', 'google', 'com'),
 ('steve', 'gmail', 'com'),
 ('rob', 'gmail', 'com'),
 ('ryan', 'yahoo', 'com')]
</code></pre>
<p><code>sub</code>还能通过诸如<code>\1</code>、<code>\2</code>之类的特殊符号访问各匹配项中的分组。符号<code>\1</code>对应第一个匹配的组，<code>\2</code>对应第二个匹配的组，以此类推：</p>
<pre><code class="language-python">print(regex.sub(r'Username: \1, Domain: \2, Suffix: \3', text))
Dave Username: dave, Domain: google, Suffix: com
Steve Username: steve, Domain: gmail, Suffix: com
Rob Username: rob, Domain: gmail, Suffix: com
Ryan Username: ryan, Domain: yahoo, Suffix: com
</code></pre>
<p><code>Python</code>中还有许多的正则表达式，但大部分都超出了本书的范围。下表是一个简要概括。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407191324.png" alt="" loading="lazy"><br>
<code>pandas</code>的矢量化字符串函数<br>
清理待分析的散乱数据时，常常需要做一些字符串规整化工作。更为复杂的情况是，含有字符串的列有时还含有缺失数据：</p>
<pre><code class="language-python">data = {'Dave': 'dave@google.com', 'Steve': 'steve@gmail.com','Rob': 'rob@gmail.com', 'Wes': np.nan}
data = pd.Series(data)
data
Dave     dave@google.com
Rob        rob@gmail.com
Steve    steve@gmail.com
Wes                  NaN
dtype: object
data.isnull()
Dave     False
Rob      False
Steve    False
Wes       True
dtype: bool
</code></pre>
<p>通过<code>data.map</code>，所有字符串和正则表达式方法都能被应用于（传入<code>lambda</code>表达式或其他函数）各个值，但是如果存在<code>NA</code>（<code>null</code>）就会报错。为了解决这个问题，<code>Series</code>有一些能够跳过<code>NA</code>值的面向数组方法，进行字符串操作。通过<code>Series</code>的<code>str</code>属性即可访问这些方法。例如，我们可以通过<code>str.contains</code>检查各个电子邮件地址是否含有&quot;gmail&quot;：</p>
<pre><code class="language-python">data.str.contains('gmail')
Dave     False
Rob       True
Steve     True
Wes        NaN
dtype: object
</code></pre>
<p>也可以使用正则表达式，还可以加上任意<code>re</code>选项（如IGNORECASE）：</p>
<pre><code class="language-python">pattern
'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]{2,4})'
data.str.findall(pattern, flags=re.IGNORECASE)
Dave     [(dave, google, com)]
Rob        [(rob, gmail, com)]
Steve    [(steve, gmail, com)]
Wes                        NaN
dtype: object
</code></pre>
<p>有两个办法可以实现矢量化的元素获取操作：要么使用<code>str.get</code>，要么在<code>str</code>属性上使用索引：</p>
<pre><code class="language-python">matches = data.str.match(pattern, flags=re.IGNORECASE)
matches
Dave     True
Rob      True
Steve    True
Wes       NaN
dtype: object
</code></pre>
<p>要访问嵌入列表中的元素，我们可以传递索引到这两个函数中：</p>
<pre><code class="language-python">matches.str.get(1)
Dave    NaN
Rob     NaN
Steve   NaN
Wes     NaN
dtype: float64
matches.str[0]
Dave    NaN
Rob     NaN
Steve   NaN
Wes     NaN
dtype: float64
</code></pre>
<p>你可以利用这种方法对字符串进行截取：</p>
<pre><code class="language-python">data.str[:5]
Dave     dave@
Rob      rob@g
Steve    steve
Wes        NaN
dtype: object
</code></pre>
<p>下表介绍了更多的<code>pandas</code>字符串方法。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407192315.png" alt="" loading="lazy"></p>
<h2 id="数据规整聚合-合并和重塑">数据规整：聚合、合并和重塑</h2>
<h3 id="层次化索引">层次化索引</h3>
<p>层次化索引（hierarchical indexing）是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。抽象点说，它使你能以低维度形式处理高维度数据。我们先来看一个简单的例子：创建一个<code>Series</code>，并用一个由列表或数组组成的列表作为索引：</p>
<pre><code class="language-python">data = pd.Series(np.random.randn(9),index=[['a', 'a', 'a', 'b', 'b', 'c', 'c', 'd', 'd'],[1, 2, 3, 1, 3, 1, 2, 2, 3]])
data
a  1   -0.204708
   2    0.478943
   3   -0.519439
b  1   -0.555730
   3    1.965781
c  1    1.393406
   2    0.092908
d  2    0.281746
   3    0.769023
dtype: float64
</code></pre>
<p>看到的结果是经过美化的带有<code>MultiIndex</code>索引的<code>Series</code>的格式。索引之间的“间隔”表示“直接使用上面的标签”：</p>
<pre><code class="language-python">data.index
MultiIndex(levels=[['a', 'b', 'c', 'd'], [1, 2, 3]],labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1, 1, 2]])
</code></pre>
<p>对于一个层次化索引的对象，可以使用所谓的部分索引，使用它选取数据子集的操作更简单：</p>
<pre><code class="language-python">data['b']
1   -0.555730
3    1.965781
dtype: float64
data['b':'c']
b  1   -0.555730
   3    1.965781
c  1    1.393406
   2    0.092908
dtype: float64
data.loc[['b', 'd']]
b  1   -0.555730
   3    1.965781
d  2    0.281746
   3    0.769023
dtype: float64
</code></pre>
<p>有时甚至还可以在“内层”中进行选取：</p>
<pre><code class="language-python">data.loc[:, 2]
a    0.478943
c    0.092908
d    0.281746
dtype: float64
</code></pre>
<p>层次化索引在数据重塑和基于分组的操作（如透视表生成）中扮演着重要的角色。例如，可以通过<code>unstack</code>方法将这段数据重新安排到一个<code>DataFrame</code>中：</p>
<pre><code class="language-python">data.unstack()
          1         2         3
a -0.204708  0.478943 -0.519439
b -0.555730       NaN  1.965781
c  1.393406  0.092908       NaN
d       NaN  0.281746  0.769023
</code></pre>
<p><code>unstack</code>的逆运算是<code>stack</code>：</p>
<pre><code class="language-python">data.unstack().stack()
a  1   -0.204708
   2    0.478943
   3   -0.519439
b  1   -0.555730
   3    1.965781
c  1    1.393406
   2    0.092908
d  2    0.281746
   3    0.769023
dtype: float64
</code></pre>
<p>对于一个<code>DataFrame</code>，每条轴都可以有分层索引：</p>
<pre><code class="language-python">frame = pd.DataFrame(np.arange(12).reshape((4, 3)),index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],columns=[['Ohio', 'Ohio', 'Colorado'],
['Green', 'Red', 'Green']])
frame
     Ohio     Colorado
    Green Red    Green
a 1     0   1        2
  2     3   4        5
b 1     6   7        8
  2     9  10       11
</code></pre>
<p>各层都可以有名字（可以是字符串，也可以是别的<code>Python</code>对象）。如果指定了名称，它们就会显示在控制台输出中：</p>
<pre><code class="language-python">frame.index.names = ['key1', 'key2']
frame.columns.names = ['state', 'color']
frame
state      Ohio     Colorado
color     Green Red    Green
key1 key2                   
a    1        0   1        2
     2        3   4        5
b    1        6   7        8
     2        9  10       11
</code></pre>
<p>注意：小心区分索引名<code>state</code>、<code>color</code>与行标签。</p>
<p>有了部分列索引，因此可以轻松选取列分组：</p>
<pre><code class="language-python">frame['Ohio']
color      Green  Red
key1 key2            
a    1         0    1
     2         3    4
b    1         6    7
     2         9   10
</code></pre>
<p>可以单独创建<code>MultiIndex</code>然后复用。上面那个<code>DataFrame</code>中的（带有分级名称）列可以这样创建：</p>
<pre><code class="language-python">MultiIndex.from_arrays([['Ohio', 'Ohio', 'Colorado'], ['Green', 'Red', 'Green']],
                       names=['state', 'color'])
</code></pre>
<h3 id="重排与分级排序">重排与分级排序</h3>
<p>有时，你需要重新调整某条轴上各级别的顺序，或根据指定级别上的值对数据进行排序。<code>swaplevel</code>接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）：</p>
<pre><code class="language-python">frame.swaplevel('key1', 'key2') 
state      Ohio     Colorado
color     Green Red    Green
key2 key1                   
1    a        0   1        2
2    a        3   4        5
1    b        6   7        8
2    b        9  10       11
</code></pre>
<p>而<code>sort_index</code>则根据单个级别中的值对数据进行排序。交换级别时，常常也会用到<code>sort_index</code>，这样最终结果就是按照指定顺序进行字母排序了：</p>
<pre><code class="language-python">frame.sort_index(level=1)
state      Ohio     Colorado
color     Green Red    Green
key1 key2                   
a    1        0   1        2
b    1        6   7        8
a    2        3   4        5
b    2        9  10       11
frame.swaplevel(0, 1).sort_index(level=0)
state      Ohio     Colorado
color     Green Red    Green
key2 key1                   
1    a        0   1        2
     b        6   7        8
2    a        3   4        5
     b        9  10       11
</code></pre>
<h3 id="根据级别汇总统计">根据级别汇总统计</h3>
<p>许多对<code>DataFrame</code>和<code>Series</code>的描述和汇总统计都有一个<code>level</code>选项，它用于指定在某条轴上求和的级别。再以上面那个<code>DataFrame</code>为例，我们可以根据行或列上的级别来进行求和：</p>
<pre><code class="language-python">frame.sum(level='key2')
state  Ohio     Colorado
color Green Red    Green
key2                    
1         6   8       10
2        12  14       16
frame.sum(level='color', axis=1)
color      Green  Red
key1 key2            
a    1         2    1
     2         8    4
b    1        14    7
     2        20   10
</code></pre>
<p>这其实是利用了<code>pandas</code>的<code>groupby</code>功能。</p>
<h3 id="使用dataframe的列进行索引">使用<code>DataFrame</code>的列进行索引</h3>
<p>人们经常想要将<code>DataFrame</code>的一个或多个列当做行索引来用，或者可能希望将行索引变成<code>DataFrame</code>的列。以下面这个<code>DataFrame</code>为例：</p>
<pre><code class="language-python">frame = pd.DataFrame({'a': range(7), 'b': range(7, 0, -1),'c': ['one', 'one', 'one', 'two', 'two','two', 'two'],'d': [0, 1, 2, 0, 1, 2, 3]})
frame
   a  b    c  d
0  0  7  one  0
1  1  6  one  1
2  2  5  one  2
3  3  4  two  0
4  4  3  two  1
5  5  2  two  2
6  6  1  two  3
</code></pre>
<p><code>DataFrame</code>的<code>set_index</code>函数会将其一个或多个列转换为行索引，并创建一个新的<code>DataFrame</code>：</p>
<pre><code class="language-python">frame2 = frame.set_index(['c', 'd'])
frame2
       a  b
c   d      
one 0  0  7
    1  1  6
    2  2  5
two 0  3  4
    1  4  3
    2  5  2
    3  6  1
</code></pre>
<p>默认情况下，那些列会从<code>DataFrame</code>中移除，但也可以将其保留下来：</p>
<pre><code class="language-python">frame.set_index(['c', 'd'], drop=False)
       a  b    c  d
c   d              
one 0  0  7  one  0
    1  1  6  one  1
    2  2  5  one  2
two 0  3  4  two  0
    1  4  3  two  1
    2  5  2  two  2
    3  6  1  two  3
</code></pre>
<p><code>reset_index</code>的功能跟<code>set_index</code>刚好相反，层次化索引的级别会被转移到列里面：</p>
<pre><code class="language-python">frame2.reset_index()
    c  d  a  b
0  one  0  0  7
1  one  1  1  6
2  one  2  2  5
3  two  0  3  4
4  two  1  4  3
5  two  2  5  2
6  two  3  6  1
</code></pre>
<h3 id="合并数据集">合并数据集</h3>
<p><code>pandas</code>对象中的数据可以通过一些方式进行合并：</p>
<p><code>pandas.merge</code>可根据一个或多个键将不同<code>DataFrame</code>中的行连接起来。<code>SQL</code>或其他关系型数据库的用户对此应该会比较熟悉，因为它实现的就是数据库的<code>join</code>操作。<br>
<code>pandas.concat</code>可以沿着一条轴将多个对象堆叠到一起。<br>
实例方法<code>combine_first</code>可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</p>
<h4 id="数据库风格的dataframe合并">数据库风格的<code>DataFrame</code>合并</h4>
<p>数据集的合并（<code>merge</code>）或连接（<code>join</code>）运算是通过一个或多个键将行连接起来的。这些运算是关系型数据库（基于<code>SQL</code>）的核心。<code>pandas</code>的<code>merge</code>函数是对数据应用这些算法的主要切入点。</p>
<p>以一个简单的例子开始：</p>
<pre><code class="language-python">df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],'data1': range(7)})
df2 = pd.DataFrame({'key': ['a', 'b', 'd'],'data2': range(3)})
df1
   data1 key
0      0   b
1      1   b
2      2   a
3      3   c
4      4   a
5      5   a
6      6   b
df2
   data2 key
0      0   a
1      1   b
2      2   d
</code></pre>
<p>这是一种多对一的合并。<code>df1</code>中的数据有多个被标记为<code>a</code>和<code>b</code>的行，而<code>df2</code>中<code>key</code>列的每个值则仅对应一行。对这些对象调用<code>merge</code>即可得到：</p>
<pre><code class="language-python">pd.merge(df1, df2)
   data1 key  data2
0      0   b      1
1      1   b      1
2      6   b      1
3      2   a      0
4      4   a      0
5      5   a      0
</code></pre>
<p>注意，我并没有指明要用哪个列进行连接。如果没有指定，<code>merge</code>就会将重叠列的列名当做键。不过，最好明确指定一下：</p>
<pre><code class="language-python">pd.merge(df1, df2, on='key')
   data1 key  data2
0      0   b      1
1      1   b      1
2      6   b      1
3      2   a      0
4      4   a      0
5      5   a      0
</code></pre>
<p>如果两个对象的列名不同，也可以分别进行指定：</p>
<pre><code class="language-python">df3 = pd.DataFrame({'lkey': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],'data1': range(7)})
df4 = pd.DataFrame({'rkey': ['a', 'b', 'd'],'data2': range(3)})
pd.merge(df3, df4, left_on='lkey', right_on='rkey')
   data1 lkey  data2 rkey
0      0    b      1    b
1      1    b      1    b
2      6    b      1    b
3      2    a      0    a
4      4    a      0    a
5      5    a      0    a
</code></pre>
<p>可能你已经注意到了，结果里面c和d以及与之相关的数据消失了。默认情况下，<code>merge</code>做的是“内连接”；结果中的键是交集。其他方式还有<code>&quot;left&quot;</code>、<code>&quot;right&quot;</code>以及<code>&quot;outer&quot;</code>。外连接求取的是键的并集，组合了左连接和右连接的效果：</p>
<pre><code class="language-python">pd.merge(df1, df2, how='outer')
   data1 key  data2
0    0.0   b    1.0
1    1.0   b    1.0
2    6.0   b    1.0
3    2.0   a    0.0
4    4.0   a    0.0
5    5.0   a    0.0
6    3.0   c    NaN
7    NaN   d    2.0
</code></pre>
<p>下表对这些选项进行了总结。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408000000.png" alt="" loading="lazy"><br>
多对多的合并有些不直观。看下面的例子：</p>
<pre><code class="language-python">df1 = pd.DataFrame({'key': ['b', 'b', 'a', 'c', 'a', 'b'],'data1': range(6)})
df2 = pd.DataFrame({'key': ['a', 'b', 'a', 'b', 'd'],'data2': range(5)})
df1
   data1 key
0      0   b
1      1   b
2      2   a
3      3   c
4      4   a
5      5   b
df2
   data2 key
0      0   a
1      1   b
2      2   a
3      3   b
4      4   d
pd.merge(df1, df2, on='key', how='left')
    data1 key  data2
0       0   b    1.0
1       0   b    3.0
2       1   b    1.0
3       1   b    3.0
4       2   a    0.0
5       2   a    2.0
6       3   c    NaN
7       4   a    0.0
8       4   a    2.0
9       5   b    1.0
10      5   b    3.0
</code></pre>
<p>多对多连接产生的是行的笛卡尔积。由于左边的<code>DataFrame</code>有3个&quot;b&quot;行，右边的有2个，所以最终结果中就有6个&quot;b&quot;行。连接方式只影响出现在结果中的不同的键的值：</p>
<pre><code class="language-python">pd.merge(df1, df2, how='inner')
   data1 key  data2
0      0   b      1
1      0   b      3
2      1   b      1
3      1   b      3
4      5   b      1
5      5   b      3
6      2   a      0
7      2   a      2
8      4   a      0
9      4   a      2
</code></pre>
<p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p>
<pre><code class="language-python">left = pd.DataFrame({'key1': ['foo', 'foo', 'bar'],'key2': ['one', 'two', 'one'],'lval': [1, 2, 3]})
right = pd.DataFrame({'key1': ['foo', 'foo', 'bar', 'bar'],'key2': ['one', 'one', 'one', 'two'],'rval': [4, 5, 6, 7]})
pd.merge(left, right, on=['key1', 'key2'], how='outer')
  key1 key2  lval  rval
0  foo  one   1.0   4.0
1  foo  one   1.0   5.0
2  foo  two   2.0   NaN
3  bar  one   3.0   6.0
4  bar  two   NaN   7.0
</code></pre>
<p>结果中会出现哪些键组合取决于所选的合并方式，你可以这样来理解：多个键形成一系列元组，并将其当做单个连接键（当然，实际上并不是这么回事）。</p>
<p>注意：在进行列－列连接时，<code>DataFrame</code>对象中的索引会被丢弃。</p>
<p>对于合并运算需要考虑的最后一个问题是对重复列名的处理。虽然你可以手工处理列名重叠的问题（查看前面介绍的重命名轴标签），但<code>merge</code>有一个更实用的<code>suffixes</code>选项，用于指定附加到左右两个<code>DataFrame</code>对象的重叠列名上的字符串：</p>
<pre><code class="language-python">pd.merge(left, right, on='key1')
  key1 key2_x  lval key2_y  rval
0  foo    one     1    one     4
1  foo    one     1    one     5
2  foo    two     2    one     4
3  foo    two     2    one     5
4  bar    one     3    one     6
5  bar    one     3    two     7
pd.merge(left, right, on='key1', suffixes=('_left', '_right'))
  key1 key2_left  lval key2_right  rval
0  foo       one     1        one     4
1  foo       one     1        one     5
2  foo       two     2        one     4
3  foo       two     2        one     5
4  bar       one     3        one     6
5  bar       one     3        two     7
</code></pre>
<p>merge的参数请参见下表。使用<code>DataFrame</code>的行索引合并是下一节的主题。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408005252.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408005321.png" alt="" loading="lazy"></p>
<h4 id="索引上的合并">索引上的合并</h4>
<p>有时候，<code>DataFrame</code>中的连接键位于其索引中。在这种情况下，你可以传入<code>left_index=True</code>或<code>right_index=True</code>（或两个都传）以说明索引应该被用作连接键：</p>
<pre><code class="language-python">left1 = pd.DataFrame({'key': ['a', 'b', 'a', 'a', 'b', 'c'],'value': range(6)})
right1 = pd.DataFrame({'group_val': [3.5, 7]}, index=['a', 'b'])
left1
  key  value
0   a      0
1   b      1
2   a      2
3   a      3
4   b      4
5   c      5
right1
   group_val
a        3.5
b        7.0
pd.merge(left1, right1, left_on='key', right_index=True)
  key  value  group_val
0   a      0        3.5
2   a      2        3.5
3   a      3        3.5
1   b      1        7.0
4   b      4        7.0
</code></pre>
<p>由于默认的<code>merge</code>方法是求取连接键的交集，因此你可以通过外连接的方式得到它们的并集：</p>
<pre><code class="language-python">pd.merge(left1, right1, left_on='key', right_index=True, how='outer')
  key  value  group_val
0   a      0        3.5
2   a      2        3.5
3   a      3        3.5
1   b      1        7.0
4   b      4        7.0
5   c      5        NaN
</code></pre>
<p>对于层次化索引的数据，事情就有点复杂了，因为索引的合并默认是多键合并：</p>
<pre><code class="language-python">lefth = pd.DataFrame({'key1': ['Ohio', 'Ohio', 'Ohio','Nevada', 'Nevada'],'key2': [2000, 2001, 2002, 2001, 2002],'data': np.arange(5.)})
righth = pd.DataFrame(np.arange(12).reshape((6, 2)),index=[['Nevada', 'Nevada', 'Ohio', 'Ohio','Ohio', 'Ohio'],[2001, 2000, 2000, 2000, 2001, 2002]],columns=['event1', 'event2'])
lefth
   data    key1  key2
0   0.0    Ohio  2000
1   1.0    Ohio  2001
2   2.0    Ohio  2002
3   3.0  Nevada  2001
4   4.0  Nevada  2002
righth
             event1  event2
Nevada 2001       0       1
       2000       2       3
Ohio   2000       4       5
       2000       6       7
       2001       8       9
       2002      10      11
</code></pre>
<p>这种情况下，你必须以列表的形式指明用作合并键的多个列（注意用<code>how='outer'</code>对重复索引值的处理）：</p>
<pre><code class="language-python">pd.merge(lefth, righth, left_on=['key1', 'key2'], right_index=True)
   data    key1  key2  event1  event2
0   0.0    Ohio  2000       4       5
0   0.0    Ohio  2000       6       7
1   1.0    Ohio  2001       8       9
2   2.0    Ohio  2002      10      11
3   3.0  Nevada  2001       0       1
pd.merge(lefth, righth, left_on=['key1', 'key2'],right_index=True, how='outer')
   data    key1  key2  event1  event2
0   0.0    Ohio  2000     4.0     5.0
0   0.0    Ohio  2000     6.0     7.0
1   1.0    Ohio  2001     8.0     9.0
2   2.0    Ohio  2002    10.0    11.0
3   3.0  Nevada  2001     0.0     1.0
4   4.0  Nevada  2002     NaN     NaN
4   NaN  Nevada  2000     2.0     3.0
</code></pre>
<p>同时使用合并双方的索引也没问题：</p>
<pre><code class="language-python">left2 = pd.DataFrame([[1., 2.], [3., 4.], [5., 6.]],index=['a', 'c', 'e'],columns=['Ohio', 'Nevada'])
right2 = pd.DataFrame([[7., 8.], [9., 10.], [11., 12.], [13, 14]],index=['b', 'c', 'd', 'e'],columns=['Missouri', 'Alabama'])
left2
   Ohio  Nevada
a   1.0     2.0
c   3.0     4.0
e   5.0     6.0
right2
   Missouri  Alabama
b       7.0      8.0
c       9.0     10.0
d      11.0     12.0
e      13.0     14.0
pd.merge(left2, right2, how='outer', left_index=True, right_index=True)
   Ohio  Nevada  Missouri  Alabama
a   1.0     2.0       NaN      NaN
b   NaN     NaN       7.0      8.0
c   3.0     4.0       9.0     10.0
d   NaN     NaN      11.0     12.0
e   5.0     6.0      13.0     14.0
</code></pre>
<p><code>DataFrame</code>还有一个便捷的<code>join</code>实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的<code>DataFrame</code>对象，但要求没有重叠的列。在上面那个例子中，我们可以编写：</p>
<pre><code class="language-python">left2.join(right2, how='outer')
   Ohio  Nevada  Missouri  Alabama
a   1.0     2.0       NaN      NaN
b   NaN     NaN       7.0      8.0
c   3.0     4.0       9.0     10.0
d   NaN     NaN      11.0     12.0
e   5.0     6.0      13.0     14.0
</code></pre>
<p>因为一些历史版本的遗留原因，<code>DataFrame</code>的<code>join</code>方法默认使用的是左连接，保留左边表的行索引。它还支持在调用的<code>DataFrame</code>的列上，连接传递的<code>DataFrame</code>索引：</p>
<pre><code class="language-python">left1.join(right1, on='key')
  key  value  group_val
0   a      0        3.5
1   b      1        7.0
2   a      2        3.5
3   a      3        3.5
4   b      4        7.0
5   c      5        NaN
</code></pre>
<p>最后，对于简单的索引合并，你还可以向<code>join</code>传入一组<code>DataFrame</code>，下一节会介绍更为通用的<code>concat</code>函数，也能实现此功能：</p>
<pre><code class="language-python">another = pd.DataFrame([[7., 8.], [9., 10.], [11., 12.], [16., 17.]],index=['a', 'c', 'e', 'f'],columns=['New York','Oregon'])
another
   New York  Oregon
a       7.0     8.0
c       9.0    10.0
e      11.0    12.0
f      16.0    17.0
left2.join([right2, another])
   Ohio  Nevada  Missouri  Alabama  New York  Oregon
a   1.0     2.0       NaN      NaN       7.0     8.0
c   3.0     4.0       9.0     10.0       9.0    10.0
e   5.0     6.0      13.0     14.0      11.0    12.0
left2.join([right2, another], how='outer')
   Ohio  Nevada  Missouri  Alabama  New York  Oregon
a   1.0     2.0       NaN      NaN       7.0     8.0
b   NaN     NaN       7.0      8.0       NaN     NaN
c   3.0     4.0       9.0     10.0       9.0    10.0
d   NaN     NaN      11.0     12.0       NaN     NaN
e   5.0     6.0      13.0     14.0      11.0    12.0
f   NaN     NaN       NaN      NaN      16.0    17.0
</code></pre>
<h4 id="轴向连接">轴向连接</h4>
<p>另一种数据合并运算也被称作连接（<code>concatenation</code>）、绑定（<code>binding</code>）或堆叠（<code>stacking</code>）。<code>NumPy</code>的<code>concatenation</code>函数可以用<code>NumPy</code>数组来做：</p>
<pre><code class="language-python">arr = np.arange(12).reshape((3, 4))
arr
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
np.concatenate([arr, arr], axis=1)
array([[ 0,  1,  2,  3,  0,  1,  2,  3],
       [ 4,  5,  6,  7,  4,  5,  6,  7],
       [ 8,  9, 10, 11,  8,  9, 10, 11]])
</code></pre>
<p>对于<code>pandas</code>对象（如<code>Series</code>和<code>DataFrame</code>），带有标签的轴使你能够进一步推广数组的连接运算。具体点说，你还需要考虑以下这些东西：</p>
<ul>
<li>如果对象在其它轴上的索引不同，我们应该合并这些轴的不同元素还是只使用交集？</li>
<li>连接的数据集是否需要在结果对象中可识别？</li>
<li>连接轴中保存的数据是否需要保留？许多情况下，<code>DataFrame</code>默认的整数标签最好在连接时删掉。<br>
<code>pandas</code>的<code>concat</code>函数提供了一种能够解决这些问题的可靠方式。我将给出一些例子来讲解其使用方式。假设有三个没有重叠索引的<code>Series</code>：</li>
</ul>
<pre><code class="language-python">s1 = pd.Series([0, 1], index=['a', 'b'])
s2 = pd.Series([2, 3, 4], index=['c', 'd', 'e'])
s3 = pd.Series([5, 6], index=['f', 'g'])
</code></pre>
<p>对这些对象调用<code>concat</code>可以将值和索引粘合在一起：</p>
<pre><code class="language-python">pd.concat([s1, s2, s3])
a    0
b    1
c    2
d    3
e    4
f    5
g    6
dtype: int64
</code></pre>
<p>默认情况下，<code>concat</code>是在<code>axis=0</code>上工作的，最终产生一个新的<code>Series</code>。如果传入<code>axis=1</code>，则结果就会变成一个<code>DataFrame</code>（<code>axis=1</code>是列）：</p>
<pre><code class="language-python">pd.concat([s1, s2, s3], axis=1)
     0    1    2
a  0.0  NaN  NaN
b  1.0  NaN  NaN
c  NaN  2.0  NaN
d  NaN  3.0  NaN
e  NaN  4.0  NaN
f  NaN  NaN  5.0
g  NaN  NaN  6.0
</code></pre>
<p>这种情况下，另外的轴上没有重叠，从索引的有序并集（外连接）上就可以看出来。传入<code>join='inner'</code>即可得到它们的交集：</p>
<pre><code class="language-python">s4 = pd.concat([s1, s3])
s4
a    0
b    1
f    5
g    6
dtype: int64
pd.concat([s1, s4], axis=1)
     0  1
a  0.0  0
b  1.0  1
f  NaN  5
g  NaN  6
pd.concat([s1, s4], axis=1, join='inner')
   0  1
a  0  0
b  1  1
</code></pre>
<p>在这个例子中，f和g标签消失了，是因为使用的是<code>join='inner'</code>选项。</p>
<p>你可以通过<code>join_axes</code>指定要在其它轴上使用的索引：</p>
<pre><code class="language-python">pd.concat([s1, s4], axis=1, join_axes=[['a', 'c', 'b', 'e']])
     0    1
a  0.0  0.0
c  NaN  NaN
b  1.0  1.0
e  NaN  NaN
</code></pre>
<p>不过有个问题，参与连接的片段在结果中区分不开。假设你想要在连接轴上创建一个层次化索引。使用<code>keys</code>参数即可达到这个目的：</p>
<pre><code class="language-python">result = pd.concat([s1, s1, s3], keys=['one','two', 'three'])
result
one    a    0
       b    1
two    a    0
       b    1
three  f    5
       g    6
dtype: int64
result.unstack()
         a    b    f    g
one    0.0  1.0  NaN  NaN
two    0.0  1.0  NaN  NaN
three  NaN  NaN  5.0  6.0
</code></pre>
<p>如果沿着<code>axis=1</code>对<code>Series</code>进行合并，则<code>keys</code>就会成为<code>DataFrame</code>的列头：</p>
<pre><code class="language-python">pd.concat([s1, s2, s3], axis=1, keys=['one','two', 'three'])
   one  two  three
a  0.0  NaN    NaN
b  1.0  NaN    NaN
c  NaN  2.0    NaN
d  NaN  3.0    NaN
e  NaN  4.0    NaN
f  NaN  NaN    5.0
g  NaN  NaN    6.0
</code></pre>
<p>同样的逻辑也适用于<code>DataFrame</code>对象：</p>
<pre><code class="language-python">df1 = pd.DataFrame(np.arange(6).reshape(3, 2), index=['a', 'b', 'c'],columns=['one', 'two'])
df2 = pd.DataFrame(5 + np.arange(4).reshape(2, 2), index=['a', 'c'],columns=['three', 'four'])
df1
   one  two
a    0    1
b    2    3
c    4    5
df2
   three  four
a      5     6
c      7     8
pd.concat([df1, df2], axis=1, keys=['level1', 'level2'])
  level1     level2     
     one two  three four
a      0   1    5.0  6.0
b      2   3    NaN  NaN
c      4   5    7.0  8.0
</code></pre>
<p>如果传入的不是列表而是一个字典，则字典的键就会被当做<code>keys</code>选项的值：</p>
<pre><code class="language-python">pd.concat({'level1': df1, 'level2': df2}, axis=1)

  level1     level2     
     one two  three four
a      0   1    5.0  6.0
b      2   3    NaN  NaN
c      4   5    7.0  8.0
</code></pre>
<p>此外还有两个用于管理层次化索引创建方式的参数（参见下表）。举个例子，我们可以用<code>names</code>参数命名创建的轴级别：</p>
<pre><code class="language-python">pd.concat([df1, df2], axis=1, keys=['level1', 'level2'],names=['upper', 'lower'])
upper level1     level2     
lower    one two  three four
a          0   1    5.0  6.0
b          2   3    NaN  NaN
c          4   5    7.0  8.0
</code></pre>
<p>最后一个关于<code>DataFrame</code>的问题是，<code>DataFrame</code>的行索引不包含任何相关数据：</p>
<pre><code class="language-python">df1 = pd.DataFrame(np.random.randn(3, 4), columns=['a', 'b', 'c', 'd'])
df2 = pd.DataFrame(np.random.randn(2, 3), columns=['b', 'd', 'a'])
df1
          a         b         c         d
0  1.246435  1.007189 -1.296221  0.274992
1  0.228913  1.352917  0.886429 -2.001637
2 -0.371843  1.669025 -0.438570 -0.539741
df2
          b         d         a
0  0.476985  3.248944 -1.021228
1 -0.577087  0.124121  0.302614
</code></pre>
<p>在这种情况下，传入<code>ignore_index=True</code>即可：</p>
<pre><code class="language-python">pd.concat([df1, df2], ignore_index=True)
          a         b         c         d
0  1.246435  1.007189 -1.296221  0.274992
1  0.228913  1.352917  0.886429 -2.001637
2 -0.371843  1.669025 -0.438570 -0.539741
3 -1.021228  0.476985       NaN  3.248944
4  0.302614 -0.577087       NaN  0.124121
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408005321.png" alt="" loading="lazy"></figure>
<h4 id="合并重叠数据">合并重叠数据</h4>
<p>还有一种数据组合问题不能用简单的合并（<code>merge</code>）或连接（<code>concatenation</code>）运算来处理。比如说，你可能有索引全部或部分重叠的两个数据集。举个有启发性的例子，我们使用<code>NumPy</code>的<code>where</code>函数，它表示一种等价于面向数组的<code>if-else</code>：</p>
<pre><code class="language-python">a = pd.Series([np.nan, 2.5, np.nan, 3.5, 4.5, np.nan],index=['f', 'e', 'd', 'c', 'b', 'a'])
b = pd.Series(np.arange(len(a), dtype=np.float64),index=['f', 'e', 'd', 'c', 'b', 'a'])
b[-1] = np.nan
a
f    NaN
e    2.5
d    NaN
c    3.5
b    4.5
a    NaN
dtype: float64
b
f    0.0
e    1.0
d    2.0
c    3.0
b    4.0
a    NaN
dtype: float64
np.where(pd.isnull(a), b, a)
array([ 0. ,  2.5,  2. ,  3.5,  4.5,  nan])
</code></pre>
<p><code>Series</code>有一个<code>combine_first</code>方法，实现的也是一样的功能，还带有<code>pandas</code>的数据对齐：</p>
<pre><code class="language-python">b[:-2].combine_first(a[2:])
a    NaN
b    4.5
c    3.0
d    2.0
e    1.0
f    0.0
dtype: float64
</code></pre>
<p>对于<code>DataFrame</code>，<code>combine_first</code>自然也会在列上做同样的事情，因此你可以将其看做：用传递对象中的数据为调用对象的缺失数据“打补丁”：</p>
<pre><code class="language-python">df1 = pd.DataFrame({'a': [1., np.nan, 5., np.nan],'b': [np.nan, 2., np.nan, 6.],'c': range(2, 18, 4)})
df2 = pd.DataFrame({'a': [5., 4., np.nan, 3., 7.],'b': [np.nan, 3., 4., 6., 8.]})
df1
     a    b   c
0  1.0  NaN   2
1  NaN  2.0   6
2  5.0  NaN  10
3  NaN  6.0  14
df2
     a    b
0  5.0  NaN
1  4.0  3.0
2  NaN  4.0
3  3.0  6.0
4  7.0  8.0
df1.combine_first(df2)
     a    b     c
0  1.0  NaN   2.0
1  4.0  2.0   6.0
2  5.0  4.0  10.0
3  3.0  6.0  14.0
4  7.0  8.0   NaN
</code></pre>
<h3 id="重塑和轴向旋转">重塑和轴向旋转</h3>
<p>有许多用于重新排列表格型数据的基础运算。这些函数也称作重塑（<code>reshape</code>）或轴向旋转（<code>pivot</code>）运算。</p>
<h4 id="重塑层次化索引">重塑层次化索引</h4>
<p>层次化索引为<code>DataFrame</code>数据的重排任务提供了一种具有良好一致性的方式。主要功能有二：</p>
<ul>
<li><code>stack</code>：将数据的列“旋转”为行。</li>
<li><code>unstack</code>：将数据的行“旋转”为列。<br>
我将通过一系列的范例来讲解这些操作。接下来看一个简单的<code>DataFrame</code>，其中的行列索引均为字符串数组：</li>
</ul>
<pre><code class="language-python">data = pd.DataFrame(np.arange(6).reshape((2, 3)),index=pd.Index(['Ohio','Colorado'], name='state'),columns=pd.Index(['one', 'two', 'three'],name='number'))
data
number    one  two  three
state                    
Ohio        0    1      2
Colorado    3    4      5
</code></pre>
<p>对该数据使用<code>stack</code>方法即可将列转换为行，得到一个<code>Series</code>：</p>
<pre><code class="language-python">result = data.stack()
result
state     number
Ohio      one       0
          two       1
          three     2
Colorado  one       3
          two       4
          three     5
dtype: int64
</code></pre>
<p>对于一个层次化索引的<code>Series</code>，你可以用<code>unstack</code>将其重排为一个<code>DataFrame</code>：</p>
<pre><code class="language-python">result.unstack()
number    one  two  three
state                    
Ohio        0    1      2
Colorado    3    4      5
</code></pre>
<p>默认情况下，<code>unstack</code>操作的是最内层（<code>stack</code>也是如此）。传入分层级别的编号或名称即可对其它级别进行<code>unstack</code>操作：</p>
<pre><code class="language-python">result.unstack(0)
state   Ohio  Colorado
number                
one        0         3
two        1         4
three      2         5
result.unstack('state')
state   Ohio  Colorado
number                
one        0         3
two        1         4
three      2         5
</code></pre>
<p>如果不是所有的级别值都能在各分组中找到的话，则<code>unstack</code>操作可能会引入缺失数据：</p>
<pre><code class="language-python">s1 = pd.Series([0, 1, 2, 3], index=['a', 'b', 'c', 'd'])
s2 = pd.Series([4, 5, 6], index=['c', 'd', 'e'])
data2 = pd.concat([s1, s2], keys=['one', 'two'])
data2
one  a    0
     b    1
     c    2
     d    3
two  c    4
     d    5
     e    6
dtype: int64
data2.unstack()
       a    b    c    d    e
one  0.0  1.0  2.0  3.0  NaN
two  NaN  NaN  4.0  5.0  6.0
</code></pre>
<p><code>stack</code>默认会滤除缺失数据，因此该运算是可逆的：</p>
<pre><code class="language-python">data2.unstack()
       a    b    c    d    e
one  0.0  1.0  2.0  3.0  NaN
two  NaN  NaN  4.0  5.0  6.0
data2.unstack().stack()
one  a    0.0
     b    1.0
     c    2.0
     d    3.0
two  c    4.0
     d    5.0
     e    6.0
dtype: float64
data2.unstack().stack(dropna=False)
one  a    0.0
     b    1.0
     c    2.0
     d    3.0
     e    NaN
two  a    NaN
     b    NaN
     c    4.0
     d    5.0
     e    6.0
dtype: float64
</code></pre>
<p>在对<code>DataFrame</code>进行<code>unstack</code>操作时，作为旋转轴的级别将会成为结果中的最低级别：</p>
<pre><code class="language-python">df = pd.DataFrame({'left': result, 'right': result + 5},columns=pd.Index(['left', 'right'], name='side'))
df
side             left  right
state    number             
Ohio     one        0      5
         two        1      6
         three      2      7
Colorado one        3      8
         two        4      9
         three      5     10
df.unstack('state')
side   left          right
state  Ohio Colorado  Ohio Colorado
number                             
one       0        3     5        8
two       1        4     6        9
three     2        5     7       10
</code></pre>
<p>当调用<code>stack</code>，我们可以指明轴的名字：</p>
<pre><code class="language-python">df.unstack('state').stack('side')
state         Colorado  Ohio
number side                 
one    left          3     0
       right         8     5
two    left          4     1
       right         9     6
three  left          5     2
       right        10     7
</code></pre>
<h4 id="将长格式旋转为宽格式">将“长格式”旋转为“宽格式”</h4>
<p>多个时间序列数据通常是以所谓的“长格式”（<code>long</code>）或“堆叠格式”（<code>stacked</code>）存储在数据库和<code>CSV</code>中的。我们先加载一些示例数据，做一些时间序列规整和数据清洗：</p>
<pre><code class="language-python">data = pd.read_csv('examples/macrodata.csv')
data.head()
     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \
0  1959.0      1.0  2710.349    1707.4  286.898   470.045   1886.9  28.98   
1  1959.0      2.0  2778.801    1733.7  310.859   481.301   1919.7  29.15   
2  1959.0      3.0  2775.488    1751.8  289.226   491.260   1916.4  29.35   
3  1959.0      4.0  2785.204    1753.7  299.356   484.052   1931.3  29.37   
4  1960.0      1.0  2847.699    1770.5  331.722   462.199   1955.5  29.54   
      m1  tbilrate  unemp      pop  infl  realint  
0  139.7      2.82    5.8  177.146  0.00     0.00
1  141.7      3.08    5.1  177.830  2.34     0.74  
2  140.5      3.82    5.3  178.657  2.74     1.09  
3  140.0      4.33    5.6  179.386  0.27     4.06  
4  139.6      3.50    5.2  180.007  2.31     1.19  
periods = pd.PeriodIndex(year=data.year, quarter=data.quarter,name='date')
columns = pd.Index(['realgdp', 'infl', 'unemp'], name='item')
data = data.reindex(columns=columns)
data.index = periods.to_timestamp('D', 'end')
ldata = data.stack().reset_index().rename(columns={0: 'value'})
</code></pre>
<p>这就是多个时间序列（或者其它带有两个或多个键的可观察数据，这里，我们的键是<code>date</code>和<code>item</code>）的长格式。表中的每行代表一次观察。</p>
<p>关系型数据库（如<code>MySQL</code>）中的数据经常都是这样存储的，因为固定架构（即列名和数据类型）有一个好处：随着表中数据的添加，<code>item</code>列中的值的种类能够增加。在前面的例子中，<code>date</code>和<code>item</code>通常就是主键（用关系型数据库的说法），不仅提供了关系完整性，而且提供了更为简单的查询支持。有的情况下，使用这样的数据会很麻烦，你可能会更喜欢<code>DataFrame</code>，不同的<code>item</code>值分别形成一列，<code>date</code>列中的时间戳则用作索引。<code>DataFrame</code>的<code>pivot</code>方法完全可以实现这个转换：</p>
<pre><code class="language-python">pivoted = ldata.pivot('date', 'item', 'value')
pivoted
item        infl    realgdp  unemp
date                              
1959-03-31  0.00   2710.349    5.8
1959-06-30  2.34   2778.801    5.1
1959-09-30  2.74   2775.488    5.3
1959-12-31  0.27   2785.204    5.6
1960-03-31  2.31   2847.699    5.2
1960-06-30  0.14   2834.390    5.2
1960-09-30  2.70   2839.022    5.6
1960-12-31  1.21   2802.616    6.3
1961-03-31 -0.40   2819.264    6.8
1961-06-30  1.47   2872.005    7.0
...          ...        ...    ...
2007-06-30  2.75  13203.977    4.5
2007-09-30  3.45  13321.109    4.7
2007-12-31  6.38  13391.249    4.8
2008-03-31  2.82  13366.865    4.9
2008-06-30  8.53  13415.266    5.4
2008-09-30 -3.16  13324.600    6.0
2008-12-31 -8.79  13141.920    6.9
2009-03-31  0.94  12925.410    8.1
2009-06-30  3.37  12901.504    9.2
2009-09-30  3.56  12990.341    9.6
[203 rows x 3 columns]
</code></pre>
<p>前两个传递的值分别用作行和列索引，最后一个可选值则是用于填充<code>DataFrame</code>的数据列。假设有两个需要同时重塑的数据列：</p>
<pre><code class="language-python">ldata['value2'] = np.random.randn(len(ldata))
ldata[:10]
        date     item     value    value2
0 1959-03-31  realgdp  2710.349  0.523772
1 1959-03-31     infl     0.000  0.000940
2 1959-03-31    unemp     5.800  1.343810
3 1959-06-30  realgdp  2778.801 -0.713544
4 1959-06-30     infl     2.340 -0.831154
5 1959-06-30    unemp     5.100 -2.370232
6 1959-09-30  realgdp  2775.488 -1.860761
7 1959-09-30     infl     2.740 -0.860757
8 1959-09-30    unemp     5.300  0.560145
9 1959-12-31  realgdp  2785.204 -1.265934
</code></pre>
<p>如果忽略最后一个参数，得到的<code>DataFrame</code>就会带有层次化的列：</p>
<pre><code class="language-python">pivoted = ldata.pivot('date', 'item')
pivoted[:5]
           value                    value2                    
item        infl   realgdp unemp      infl   realgdp     unemp
date                                                          
1959-03-31  0.00  2710.349   5.8  0.000940  0.523772  1.343810
1959-06-30  2.34  2778.801   5.1 -0.831154 -0.713544 -2.370232
1959-09-30  2.74  2775.488   5.3 -0.860757 -1.860761  0.560145
1959-12-31  0.27  2785.204   5.6  0.119827 -1.265934 -1.063512
1960-03-31  2.31  2847.699   5.2 -2.359419  0.332883 -0.199543
pivoted['value'][:5]
item        infl   realgdp  unemp
date                             
1959-03-31  0.00  2710.349    5.8
1959-06-30  2.34  2778.801    5.1
1959-09-30  2.74  2775.488    5.3
1959-12-31  0.27  2785.204    5.6
1960-03-31  2.31  2847.699    5.2
</code></pre>
<p>注意，<code>pivot</code>其实就是用<code>set_index</code>创建层次化索引，再用<code>unstack</code>重塑：</p>
<pre><code class="language-python">unstacked = ldata.set_index(['date', 'item']).unstack('item')
unstacked[:7]
           value                    value2                    
item        infl   realgdp unemp      infl   realgdp     unemp
date                                                          
1959-03-31  0.00  2710.349   5.8  0.000940  0.523772  1.343810
1959-06-30  2.34  2778.801   5.1 -0.831154 -0.713544 -2.370232
1959-09-30  2.74  2775.488   5.3 -0.860757 -1.860761  0.560145
1959-12-31  0.27  2785.204   5.6  0.119827 -1.265934 -1.063512
1960-03-31  2.31  2847.699   5.2 -2.359419  0.332883 -0.199543
1960-06-30  0.14  2834.390   5.2 -0.970736 -1.541996 -1.307030
1960-09-30  2.70  2839.022   5.6  0.377984  0.286350 -0.753887
</code></pre>
<h4 id="将宽格式旋转为长格式">将“宽格式”旋转为“长格式”</h4>
<p>旋转<code>DataFrame</code>的逆运算是<code>pandas.melt</code>。它不是将一列转换到多个新的<code>DataFrame</code>，而是合并多个列成为一个，产生一个比输入长的<code>DataFrame</code>。看一个例子：</p>
<pre><code class="language-python">df = pd.DataFrame({'key': ['foo', 'bar', 'baz'],'A': [1, 2, 3],'B': [4, 5, 6],'C': [7, 8, 9]})
df
   A  B  C  key
0  1  4  7  foo
1  2  5  8  bar
2  3  6  9  baz
</code></pre>
<p><code>key</code>列可能是分组指标，其它的列是数据值。当使用<code>pandas.melt</code>，我们必须指明哪些列是分组指标。下面使用<code>key</code>作为唯一的分组指标：</p>
<pre><code class="language-python">melted = pd.melt(df, ['key'])
melted 
   key variable  value
0  foo        A      1
1  bar        A      2
2  baz        A      3
3  foo        B      4
4  bar        B      5
5  baz        B      6
6  foo        C      7
7  bar        C      8
8  baz        C      9
</code></pre>
<p>使用<code>pivot</code>，可以重塑回原来的样子：</p>
<pre><code class="language-python">reshaped = melted.pivot('key', 'variable', 'value')
reshaped
variable  A  B  C
key              
bar       2  5  8
baz       3  6  9
foo       1  4  7
</code></pre>
<p>因为<code>pivot</code>的结果从列创建了一个索引，用作行标签，我们可以使用<code>reset_index</code>将数据移回列：</p>
<pre><code class="language-python">reshaped.reset_index()
variable  key  A  B  C
0         bar  2  5  8
1         baz  3  6  9
2         foo  1  4  7
</code></pre>
<p>你还可以指定列的子集，作为值的列：</p>
<pre><code class="language-python">pd.melt(df, id_vars=['key'], value_vars=['A', 'B'])
   key variable  value
0  foo        A      1
1  bar        A      2
2  baz        A      3
3  foo        B      4
4  bar        B      5
5  baz        B      6
</code></pre>
<p><code>pandas.melt</code>也可以不用分组指标：</p>
<pre><code class="language-python">pd.melt(df, value_vars=['A', 'B', 'C'])
  variable  value
0        A      1
1        A      2
2        A      3
3        B      4
4        B      5
5        B      6
6        C      7
7        C      8
8        C      9
pd.melt(df, value_vars=['key', 'A', 'B'])
  variable value
0      key   foo
1      key   bar
2      key   baz
3        A     1
4        A     2
5        A     3
6        B     4
7        B     5
8        B     6
</code></pre>
<h2 id="数据聚合与分组运算">数据聚合与分组运算</h2>
<p>在本章中，你将会学到：</p>
<ul>
<li>使用一个或多个键（形式可以是函数、数组或<code>DataFrame</code>列名）分割<code>pandas</code>对象。</li>
<li>计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。</li>
<li>应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。</li>
<li>计算透视表或交叉表。</li>
<li>执行分位数分析以及其它统计分组分析。</li>
</ul>
<blockquote>
<p>笔记：对时间序列数据的聚合（<code>groupby</code>的特殊用法之一）也称作重采样（<code>resampling</code>）</p>
</blockquote>
<h3 id="groupby机制"><code>GroupBy</code>机制</h3>
<p>Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语&quot;split-apply-combine&quot;（拆分－应用－合并）。第一个阶段，<code>pandas</code>对象（无论是<code>Series</code>、<code>DataFrame</code>还是其他的）中的数据会根据你所提供的一个或多个键被拆分（<code>split</code>）为多组。拆分操作是在对象的特定轴上执行的。例如，<code>DataFrame</code>可以在其行（<code>axis=0</code>）或列（<code>axis=1</code>）上进行分组。然后，将一个函数应用（<code>apply</code>）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（<code>combine</code>）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。下图大致说明了一个简单的分组聚合过程。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408204156.png" alt="" loading="lazy"><br>
分组键可以有多种形式，且类型不必相同：</p>
<ul>
<li>列表或数组，其长度与待分组的轴一样。</li>
<li>表示<code>DataFrame</code>某个列名的值。</li>
<li>字典或<code>Series</code>，给出待分组轴上的值与分组名之间的对应关系。</li>
<li>函数，用于处理轴索引或索引中的各个标签。<br>
后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。首先来看看下面这个非常简单的表格型数据集（以<code>DataFrame</code>的形式）：</li>
</ul>
<pre><code class="language-python">df = pd.DataFrame({'key1' : ['a', 'a', 'b', 'b', 'a'],'key2' : ['one', 'two', 'one', 'two', 'one'],'data1' : np.random.randn(5),'data2' : np.random.randn(5)})
df
      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
4  1.965781  1.246435    a  one
</code></pre>
<p>假设你想要按<code>key1</code>进行分组，并计算<code>data1</code>列的平均值。实现该功能的方式有很多，而我们这里要用的是：访问<code>data1</code>，并根据<code>key1</code>调用<code>groupby</code>：</p>
<pre><code class="language-python">grouped = df['data1'].groupby(df['key1'])
grouped
&lt;pandas.core.groupby.SeriesGroupBy object at 0x7faa31537390&gt;
</code></pre>
<p>变量<code>grouped</code>是一个<code>GroupBy</code>对象。它实际上还没有进行任何计算，只是含有一些有关分组键<code>df['key1']</code>的中间数据而已。换句话说，该对象已经有了接下来对各分组执行运算所需的一切信息。例如，我们可以调用<code>GroupBy</code>的<code>mean</code>方法来计算分组平均值：</p>
<pre><code class="language-python">grouped.mean()
key1
a    0.746672
b   -0.537585
Name: data1, dtype: float64
</code></pre>
<p>稍后我将详细讲解<code>.mean()</code>的调用过程。这里最重要的是，数据（<code>Series</code>）根据分组键进行了聚合，产生了一个新的<code>Series</code>，其索引为<code>key1</code>列中的唯一值。之所以结果中索引的名称为<code>key1</code>，是因为原始<code>DataFrame</code>的列<code>df['key1']</code>就叫这个名字。</p>
<p>如果我们一次传入多个数组的列表，就会得到不同的结果：</p>
<pre><code class="language-python">means = df['data1'].groupby([df['key1'], df['key2']]).mean()
means
key1  key2
a     one     0.880536
      two     0.478943
b     one    -0.519439
      two    -0.555730
Name: data1, dtype: float64
</code></pre>
<p>这里，我通过两个键对数据进行了分组，得到的<code>Series</code>具有一个层次化索引（由唯一的键对组成）：</p>
<pre><code class="language-python">means.unstack()
key2       one       two
key1                    
a     0.880536  0.478943
b    -0.519439 -0.555730
</code></pre>
<p>在这个例子中，分组键均为<code>Series</code>。实际上，分组键可以是任何长度适当的数组：</p>
<pre><code class="language-python">states = np.array(['Ohio', 'California', 'California', 'Ohio', 'Ohio'])
years = np.array([2005, 2005, 2006, 2005, 2006])
df['data1'].groupby([states, years]).mean()
California  2005    0.478943
            2006   -0.519439
Ohio        2005   -0.380219
            2006    1.965781
Name: data1, dtype: float64
</code></pre>
<p>通常，分组信息就位于相同的要处理<code>DataFrame</code>中。这里，你还可以将列名（可以是字符串、数字或其他<code>Python</code>对象）用作分组键：</p>
<pre><code class="language-python">df.groupby('key1').mean()
         data1     data2
key1
a     0.746672  0.910916
b    -0.537585  0.525384
df.groupby(['key1', 'key2']).mean()
              data1     data2
key1 key2                    
a    one   0.880536  1.319920
     two   0.478943  0.092908
b    one  -0.519439  0.281746
     two  -0.555730  0.769023
</code></pre>
<p>你可能已经注意到了，第一个例子在执行<code>df.groupby('key1').mean()</code>时，结果中没有<code>key2</code>列。这是因为<code>df['key2']</code>不是数值数据（俗称“麻烦列”），所以被从结果中排除了。默认情况下，所有数值列都会被聚合，虽然有时可能会被过滤为一个子集，稍后就会碰到。</p>
<p>无论你准备拿<code>groupby</code>做什么，都有可能会用到<code>GroupBy</code>的<code>size</code>方法，它可以返回一个含有分组大小的<code>Series</code>：</p>
<pre><code class="language-python">df.groupby(['key1', 'key2']).size()
key1  key2
a     one     2
      two     1
b     one     1
      two     1
dtype: int64
</code></pre>
<p>注意，任何分组关键词中的缺失值，都会被从结果中除去。</p>
<h4 id="对分组进行迭代">对分组进行迭代</h4>
<p><code>GroupBy</code>对象支持迭代，可以产生一组二元元组（由分组名和数据块组成）。</p>
<pre><code class="language-python">for name, group in df.groupby('key1'):
    print(name)
    print(group)
a
      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
4  1.965781  1.246435    a  one
b
      data1     data2 key1 key2
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
</code></pre>
<p>对于多重键的情况，元组的第一个元素将会是由键值组成的元组：</p>
<pre><code class="language-python">for (k1, k2), group in df.groupby(['key1', 'key2']):
    print((k1, k2))
    print(group)
('a', 'one')
      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
4  1.965781  1.246435    a  one
('a', 'two')
      data1     data2 key1 key2
1  0.478943  0.092908    a  two
('b', 'one')
      data1     data2 key1 key2
2 -0.519439  0.281746    b  one
('b', 'two')
     data1     data2 key1 key2
3 -0.55573  0.769023    b  two
</code></pre>
<p>当然，你可以对这些数据片段做任何操作。有一个你可能会觉得有用的运算：将这些数据片段做成一个字典：</p>
<pre><code class="language-python">pieces = dict(list(df.groupby('key1')))
pieces['b']
      data1     data2 key1 key2
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
</code></pre>
<p><code>groupby</code>默认是在<code>axis=0</code>上进行分组的，通过设置也可以在其他任何轴上进行分组。拿上面例子中的<code>df</code>来说，我们可以根据<code>dtype</code>对列进行分组：</p>
<pre><code class="language-python">df.dtypes
data1    float64
data2    float64
key1      object
key2      object
dtype: object
grouped = df.groupby(df.dtypes, axis=1)
</code></pre>
<p>可以如下打印分组：</p>
<pre><code class="language-python">for dtype, group in grouped:
    print(dtype)    
    print(group)
float64
      data1     data2
0 -0.204708  1.393406
1  0.478943  0.092908
2 -0.519439  0.281746
3 -0.555730  0.769023
4  1.965781  1.246435
object
  key1 key2
0    a  one
1    a  two
2    b  one
3    b  two
4    a  one
</code></pre>
<h4 id="选取一列或列的子集">选取一列或列的子集</h4>
<p>对于由<code>DataFrame</code>产生的<code>GroupBy</code>对象，如果用一个（单个字符串）或一组（字符串数组）列名对其进行索引，就能实现选取部分列进行聚合的目的。也就是说：</p>
<pre><code class="language-python">df.groupby('key1')['data1']
df.groupby('key1')[['data2']]
</code></pre>
<p>是以下代码的语法糖：</p>
<pre><code class="language-python">df['data1'].groupby(df['key1'])
df[['data2']].groupby(df['key1'])
</code></pre>
<p>尤其对于大数据集，很可能只需要对部分列进行聚合。例如，在前面那个数据集中，如果只需计算<code>data2</code>列的平均值并以<code>DataFrame</code>形式得到结果，可以这样写：</p>
<pre><code class="language-python">df.groupby(['key1', 'key2'])[['data2']].mean()
              data2
key1 key2          
a    one   1.319920
     two   0.092908
b    one   0.281746
     two   0.769023
</code></pre>
<p>这种索引操作所返回的对象是一个已分组的<code>DataFrame</code>（如果传入的是列表或数组）或已分组的<code>Series</code>（如果传入的是标量形式的单个列名）：</p>
<pre><code class="language-python">s_grouped = df.groupby(['key1', 'key2'])['data2']
s_grouped
&lt;pandas.core.groupby.SeriesGroupBy object at 0x7faa30c78da0&gt;
s_grouped.mean()
key1  key2
a     one     1.319920
      two     0.092908
b     one     0.281746
      two     0.769023
Name: data2, dtype: float64
</code></pre>
<p>通过字典或<code>Series</code>进行分组 除数组以外，分组信息还可以其他形式存在。来看另一个示例<code>DataFrame</code>：</p>
<pre><code class="language-python">people = pd.DataFrame(np.random.randn(5, 5),columns=['a', 'b', 'c', 'd', 'e'],index=['Joe', 'Steve', 'Wes', 'Jim', 'Travis'])
people.iloc[2:3, [1, 2]] = np.nan # Add a few NA values
people
               a         b         c         d         e
Joe     1.007189 -1.296221  0.274992  0.228913  1.352917
Steve   0.886429 -2.001637 -0.371843  1.669025 -0.438570
Wes    -0.539741       NaN       NaN -1.021228 -0.577087
Jim     0.124121  0.302614  0.523772  0.000940  1.343810
Travis -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre>
<p>现在，假设已知列的分组关系，并希望根据分组计算列的和：</p>
<pre><code class="language-python">mapping = {'a': 'red', 'b': 'red', 'c': 'blue','d': 'blue', 'e': 'red', 'f' : 'orange'}
</code></pre>
<p>现在，你可以将这个字典传给<code>groupby</code>，来构造数组，但我们可以直接传递字典（我包含了键“f”来强调，存在未使用的分组键是可以的）：</p>
<pre><code class="language-python">by_column = people.groupby(mapping, axis=1)
by_column.sum()
            blue       red
Joe     0.503905  1.063885
Steve   1.297183 -1.553778
Wes    -1.021228 -1.116829
Jim     0.524712  1.770545
Travis -4.230992 -2.405455
</code></pre>
<p><code>Series</code>也有同样的功能，它可以被看做一个固定大小的映射：</p>
<pre><code class="language-python">map_series = pd.Series(mapping)
map_series
a       red
b       red
c      blue
d      blue
e       red
f    orange
dtype: object
people.groupby(map_series, axis=1).count()
        blue  red
Joe        2    3
Steve      2    3
Wes        1    2
Jim        2    3
Travis     2    3
</code></pre>
<p>通过函数进行分组 比起使用字典或<code>Series</code>，使用<code>Python</code>函数是一种更原生的方法定义分组映射。任何被当做分组键的函数都会在各个索引值上被调用一次，其返回值就会被用作分组名称。具体点说，以上一小节的示例<code>DataFrame</code>为例，其索引值为人的名字。你可以计算一个字符串长度的数组，更简单的方法是传入<code>len</code>函数：</p>
<pre><code class="language-python">people.groupby(len).sum()
          a         b         c         d         e
3  0.591569 -0.993608  0.798764 -0.791374  2.119639
5  0.886429 -2.001637 -0.371843  1.669025 -0.438570
6 -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre>
<p>将函数跟数组、列表、字典、<code>Series</code>混合使用也不是问题，因为任何东西在内部都会被转换为数组：</p>
<pre><code class="language-python">key_list = ['one', 'one', 'one', 'two', 'two']
people.groupby([len, key_list]).min()
              a         b         c         d         e
3 one -0.539741 -1.296221  0.274992 -1.021228 -0.577087
  two  0.124121  0.302614  0.523772  0.000940  1.343810
5 one  0.886429 -2.001637 -0.371843  1.669025 -0.438570
6 two -0.713544 -0.831154 -2.370232 -1.860761 -0.860757
</code></pre>
<h4 id="根据索引级别分组">根据索引级别分组</h4>
<p>层次化索引数据集最方便的地方就在于它能够根据轴索引的一个级别进行聚合：</p>
<pre><code class="language-python">columns = pd.MultiIndex.from_arrays([['US', 'US', 'US', 'JP', 'JP'],[1, 3, 5, 1, 3]],names=['cty', 'tenor'])
hier_df = pd.DataFrame(np.random.randn(4, 5), columns=columns)
hier_df
cty          US                            JP          
tenor         1         3         5         1         3
0      0.560145 -1.265934  0.119827 -1.063512  0.332883
1     -2.359419 -0.199543 -1.541996 -0.970736 -1.307030
2      0.286350  0.377984 -0.753887  0.331286  1.349742
3      0.069877  0.246674 -0.011862  1.004812  1.327195
</code></pre>
<p>要根据级别分组，使用<code>level</code>关键字传递级别序号或名字：</p>
<pre><code class="language-python">hier_df.groupby(level='cty', axis=1).count()
cty  JP  US
0     2   3
1     2   3
2     2   3
3     2   3
</code></pre>
<h4 id="数据聚合">数据聚合</h4>
<p>聚合指的是任何能够从数组产生标量值的数据转换过程。之前的例子已经用过一些，比如<code>mean</code>、<code>count</code>、<code>min</code>以及<code>sum</code>等。你可能想知道在<code>GroupBy</code>对象上调用<code>mean()</code>时究竟发生了什么。许多常见的聚合运算（如下表所示）都有进行优化。然而，除了这些方法，你还可以使用其它的。<br>
经过优化的<code>groupby</code>方法:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408211211.png" alt="" loading="lazy"></p>
<p>你可以使用自己发明的聚合运算，还可以调用分组对象上已经定义好的任何方法。例如，<code>quantile</code>可以计算<code>Series</code>或<code>DataFrame</code>列的样本分位数。</p>
<p>虽然<code>quantile</code>并没有明确地实现于<code>GroupBy</code>，但它是一个<code>Series</code>方法，所以这里是能用的。实际上，<code>GroupBy</code>会高效地对<code>Series</code>进行切片，然后对各片调用<code>piece.quantile(0.9)</code>，最后将这些结果组装成最终结果：</p>
<pre><code class="language-python">df
      data1     data2 key1 key2
0 -0.204708  1.393406    a  one
1  0.478943  0.092908    a  two
2 -0.519439  0.281746    b  one
3 -0.555730  0.769023    b  two
4  1.965781  1.246435    a  one
grouped = df.groupby('key1')
grouped['data1'].quantile(0.9)
key1
a    1.668413
b   -0.523068
Name: data1, dtype: float64
</code></pre>
<p>如果要使用你自己的聚合函数，只需将其传入<code>aggregate</code>或<code>agg</code>方法即可：</p>
<pre><code class="language-python">def peak_to_peak(arr):
    return arr.max() - arr.min()
grouped.agg(peak_to_peak)
         data1     data2
key1                    
a     2.170488  1.300498
b     0.036292  0.487276
</code></pre>
<p>你可能注意到注意，有些方法（如<code>describe</code>）也是可以用在这里的，即使严格来讲，它们并非聚合运算：</p>
<pre><code class="language-python">grouped.describe()
     data1                                                              \
     count      mean       std       min       25%       50%       75%   
key1                                                                     
a      3.0  0.746672  1.109736 -0.204708  0.137118  0.478943  1.222362   
b      2.0 -0.537585  0.025662 -0.555730 -0.546657 -0.537585 -0.528512   
               data2                                                    \
max count      mean       std       min       25%       50%   
key1                                                                     
a     1.965781   3.0  0.910916  0.712217  0.092908  0.669671  1.246435   
b    -0.519439   2.0  0.525384  0.344556  0.281746  0.403565  0.525384   
                          
           75%       max  
key1                      
a     1.319920  1.393406  
b     0.647203  0.769023
</code></pre>
<blockquote>
<p>笔记：自定义聚合函数要比上表中那些经过优化的函数慢得多。这是因为在构造中间分组数据块时存在非常大的开销（函数调用、数据重排等）。</p>
</blockquote>
<h4 id="面向列的多函数应用">面向列的多函数应用</h4>
<p>回到前面小费的例子。使用<code>read_csv</code>导入数据之后，我们添加了一个小费百分比的列<code>tip_pct</code>：</p>
<pre><code class="language-python">tips = pd.read_csv('examples/tips.csv')
#Add tip percentage of total bill
tips['tip_pct'] = tips['tip'] / tips['total_bill']
tips[:6]
   total_bill   tip smoker  day    time  size   tip_pct
0       16.99  1.01     No  Sun  Dinner     2  0.059447
1       10.34  1.66     No  Sun  Dinner     3  0.160542
2       21.01  3.50     No  Sun  Dinner     3  0.166587
3       23.68  3.31     No  Sun  Dinner     2  0.139780
4       24.59  3.61     No  Sun  Dinner     4  0.146808
5       25.29  4.71     No  Sun  Dinner     4  0.186240
</code></pre>
<p>你已经看到，对<code>Series</code>或<code>DataFrame</code>列的聚合运算其实就是使用<code>aggregate</code>（使用自定义函数）或调用诸如<code>mean</code>、<code>std</code>之类的方法。然而，你可能希望对不同的列使用不同的聚合函数，或一次应用多个函数。其实这也好办，我将通过一些示例来进行讲解。首先，我根据天和<code>smoker</code>对<code>tips</code>进行分组：</p>
<pre><code class="language-python">grouped = tips.groupby(['day', 'smoker'])
</code></pre>
<p>注意，对于上表中的那些描述统计，可以将函数名以字符串的形式传入：</p>
<pre><code class="language-python">grouped_pct = grouped['tip_pct']
grouped_pct.agg('mean')
day   smoker
Fri   No        0.151650
      Yes       0.174783
Sat   No        0.158048
      Yes       0.147906
Sun   No        0.160113
      Yes       0.187250
Thur  No        0.160298
      Yes       0.163863
Name: tip_pct, dtype: float64
</code></pre>
<p>如果传入一组函数或函数名，得到的<code>DataFrame</code>的列就会以相应的函数命名：</p>
<pre><code class="language-python">grouped_pct.agg(['mean', 'std', peak_to_peak])
                 mean       std  peak_to_peak
day  smoker                                  
Fri  No      0.151650  0.028123      0.067349
     Yes     0.174783  0.051293      0.159925
Sat  No      0.158048  0.039767      0.235193
     Yes     0.147906  0.061375      0.290095
Sun  No      0.160113  0.042347      0.193226
     Yes     0.187250  0.154134      0.644685
Thur No      0.160298  0.038774      0.193350
     Yes     0.163863  0.039389      0.151240
</code></pre>
<p>这里，我们传递了一组聚合函数进行聚合，独立对数据分组进行评估。</p>
<p>你并非一定要接受<code>GroupBy</code>自动给出的那些列名，特别是<code>lambda</code>函数，它们的名称是<code>''</code>，这样的辨识度就很低了（通过函数的<code>__name__</code>属性看看就知道了）。因此，如果传入的是一个由<code>(name,function)</code>元组组成的列表，则各元组的第一个元素就会被用作<code>DataFrame</code>的列名（可以将这种二元元组列表看做一个有序映射）：</p>
<pre><code class="language-python">grouped_pct.agg([('foo', 'mean'), ('bar', np.std)])
                  foo       bar
day  smoker                    
Fri  No      0.151650  0.028123
     Yes     0.174783  0.051293
Sat  No      0.158048  0.039767
     Yes     0.147906  0.061375
Sun  No      0.160113  0.042347
     Yes     0.187250  0.154134
Thur No      0.160298  0.038774
     Yes     0.163863  0.039389
</code></pre>
<p>对于<code>DataFrame</code>，你还有更多选择，你可以定义一组应用于全部列的一组函数，或不同的列应用不同的函数。假设我们想要对<code>tip_pct</code>和<code>total_bill</code>列计算三个统计信息：</p>
<pre><code class="language-python">functions = ['count', 'mean', 'max']
result = grouped['tip_pct', 'total_bill'].agg(functions)
result
            tip_pct                     total_bill                  
              count      mean       max      count       mean    max
day  smoker                                                         
Fri  No           4  0.151650  0.187735          4  18.420000  22.75
     Yes         15  0.174783  0.263480         15  16.813333  40.17
Sat  No          45  0.158048  0.291990         45  19.661778  48.33
     Yes         42  0.147906  0.325733         42  21.276667  50.81
Sun  No          57  0.160113  0.252672         57  20.506667  48.17
     Yes         19  0.187250  0.710345         19  24.120000  45.35
Thur No          45  0.160298  0.266312         45  17.113111  41.19
     Yes         17  0.163863  0.241255         17  19.190588  43.11
</code></pre>
<p>如你所见，结果<code>DataFrame</code>拥有层次化的列，这相当于分别对各列进行聚合，然后用<code>concat</code>将结果组装到一起，使用列名用作<code>keys</code>参数：</p>
<pre><code class="language-python">result['tip_pct']
             count      mean       max
day  smoker                           
Fri  No          4  0.151650  0.187735
     Yes        15  0.174783  0.263480
Sat  No         45  0.158048  0.291990
     Yes        42  0.147906  0.325733
Sun  No         57  0.160113  0.252672
     Yes        19  0.187250  0.710345
Thur No         45  0.160298  0.266312
     Yes        17  0.163863  0.241255
</code></pre>
<p>跟前面一样，这里也可以传入带有自定义名称的一组元组：</p>
<pre><code class="language-python">ftuples = [('Durchschnitt', 'mean'),('Abweichung', np.var)]
grouped['tip_pct', 'total_bill'].agg(ftuples)
                 tip_pct              total_bill            
            Durchschnitt Abweichung Durchschnitt  Abweichung
day  smoker                                                 
Fri  No         0.151650   0.000791    18.420000   25.596333
     Yes        0.174783   0.002631    16.813333   82.562438
Sat  No         0.158048   0.001581    19.661778   79.908965
     Yes        0.147906   0.003767    21.276667  101.387535
Sun  No         0.160113   0.001793    20.506667   66.099980
     Yes        0.187250   0.023757    24.120000  109.046044
Thur No         0.160298   0.001503    17.113111   59.625081
     Yes        0.163863   0.001551    19.190588   69.808518
</code></pre>
<p>现在，假设你想要对一个列或不同的列应用不同的函数。具体的办法是向<code>agg</code>传入一个从列名映射到函数的字典：</p>
<pre><code class="language-python">grouped.agg({'tip' : np.max, 'size' : 'sum'})
               tip  size
day  smoker             
Fri  No       3.50     9
     Yes      4.73    31
Sat  No       9.00   115
     Yes     10.00   104
Sun  No       6.00   167
     Yes      6.50    49
Thur No       6.70   112
     Yes      5.00    40
grouped.agg({'tip_pct' : ['min', 'max', 'mean', 'std'],'size' : 'sum'})
              tip_pct                               size
                  min       max      mean       std  sum
day  smoker                                             
Fri  No      0.120385  0.187735  0.151650  0.028123    9
     Yes     0.103555  0.263480  0.174783  0.051293   31
Sat  No      0.056797  0.291990  0.158048  0.039767  115
     Yes     0.035638  0.325733  0.147906  0.061375  104
Sun  No      0.059447  0.252672  0.160113  0.042347  167
     Yes     0.065660  0.710345  0.187250  0.154134   49
Thur No      0.072961  0.266312  0.160298  0.038774  112
     Yes     0.090014  0.241255  0.163863  0.039389   40
</code></pre>
<p>只有将多个函数应用到至少一列时，<code>DataFrame</code>才会拥有层次化的列。</p>
<h4 id="以没有行索引的形式返回聚合数据">以“没有行索引”的形式返回聚合数据</h4>
<p>到目前为止，所有示例中的聚合数据都有由唯一的分组键组成的索引（可能还是层次化的）。由于并不总是需要如此，所以你可以向<code>groupby</code>传入<code>as_index=False</code>以禁用该功能：</p>
<pre><code class="language-python">tips.groupby(['day', 'smoker'], as_index=False).mean()
    day smoker  total_bill       tip      size   tip_pct
0   Fri     No   18.420000  2.812500  2.250000  0.151650
1   Fri    Yes   16.813333  2.714000  2.066667  0.174783
2   Sat     No   19.661778  3.102889  2.555556  0.158048
3   Sat    Yes   21.276667  2.875476  2.476190  0.147906
4   Sun     No   20.506667  3.167895  2.929825  0.160113
5   Sun    Yes   24.120000  3.516842  2.578947  0.187250
6  Thur     No   17.113111  2.673778  2.488889  0.160298
7  Thur    Yes   19.190588  3.030000  2.352941  0.163863
</code></pre>
<p>当然，对结果调用<code>reset_index</code>也能得到这种形式的结果。使用<code>as_index=False</code>方法可以避免一些不必要的计算。</p>
<h3 id="apply一般性的拆分-应用-合并"><code>apply</code>：一般性的“拆分－应用－合并”</h3>
<p>最通用的<code>GroupBy</code>方法是<code>apply</code>，本节剩余部分将重点讲解它。如下图所示，<code>apply</code>会将待处理的对象拆分成多个片段，然后对各片段调用传入的函数，最后尝试将各片段组合到一起。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408212405.png" alt="" loading="lazy"><br>
回到之前那个小费数据集，假设你想要根据分组选出最高的5个<code>tip_pct</code>值。首先，编写一个选取指定列具有最大值的行的函数：</p>
<pre><code class="language-python">def top(df, n=5, column='tip_pct'):
    return df.sort_values(by=column)[-n:]
top(tips, n=6)
     total_bill   tip smoker  day    time  size   tip_pct
109       14.31  4.00    Yes  Sat  Dinner     2  0.279525
183       23.17  6.50    Yes  Sun  Dinner     4  0.280535
232       11.61  3.39     No  Sat  Dinner     2  0.291990
67         3.07  1.00    Yes  Sat  Dinner     1  0.325733
178        9.60  4.00    Yes  Sun  Dinner     2  0.416667
172        7.25  5.15    Yes  Sun  Dinner     2  0.710345
</code></pre>
<p>现在，如果对<code>smoker</code>分组并用该函数调用<code>apply</code>，就会得到：</p>
<pre><code class="language-python">tips.groupby('smoker').apply(top)
            total_bill   tip smoker   day    time  size   tip_pct
smoker                                                           
No     88        24.71  5.85     No  Thur   Lunch     2  0.236746
       185       20.69  5.00     No   Sun  Dinner     5  0.241663
       51        10.29  2.60     No   Sun  Dinner     2  0.252672
       149        7.51  2.00     No  Thur   Lunch     2  0.266312
       232       11.61  3.39     No   Sat  Dinner     2  0.291990
Yes    109       14.31  4.00    Yes   Sat  Dinner     2  0.279525
       183       23.17  6.50    Yes   Sun  Dinner     4  0.280535
       67         3.07  1.00    Yes   Sat  Dinner     1  0.325733
       178        9.60  4.00    Yes   Sun  Dinner     2  0.416667
       172        7.25  5.15    Yes   Sun  Dinner     2  0.710345
</code></pre>
<p>这里发生了什么？<code>top</code>函数在<code>DataFrame</code>的各个片段上调用，然后结果由<code>pandas.concat</code>组装到一起，并以分组名称进行了标记。于是，最终结果就有了一个层次化索引，其内层索引值来自原<code>DataFrame</code>。</p>
<p>如果传给<code>apply</code>的函数能够接受其他参数或关键字，则可以将这些内容放在函数名后面一并传入：</p>
<pre><code class="language-python">tips.groupby(['smoker', 'day']).apply(top, n=1, column='total_bill')
                 total_bill    tip smoker   day    time  size   tip_pct
smoker day                                                             
No     Fri  94        22.75   3.25     No   Fri  Dinner     2  0.142857
       Sat  212       48.33   9.00     No   Sat  Dinner     4  0.186220
       Sun  156       48.17   5.00     No   Sun  Dinner     6  0.103799
       Thur 142       41.19   5.00     No  Thur   Lunch     5  0.121389
Yes    Fri  95        40.17   4.73    Yes   Fri  Dinner     4  0.117750
       Sat  170       50.81  10.00    Yes   Sat  Dinner     3  0.196812
       Sun  182       45.35   3.50    Yes   Sun  Dinner     3  0.077178
       Thur 197       43.11   5.00    Yes  Thur   Lunch     4  0.115982
</code></pre>
<blockquote>
<p>笔记：除这些基本用法之外，能否充分发挥<code>apply</code>的威力很大程度上取决于你的创造力。传入的那个函数能做什么全由你说了算，它只需返回一个<code>pandas</code>对象或标量值即可。本章后续部分的示例主要用于讲解如何利用<code>groupby</code>解决各种各样的问题。</p>
</blockquote>
<p>可能你已经想起来了，之前我在<code>GroupBy</code>对象上调用过<code>describe</code>：</p>
<pre><code class="language-python">result = tips.groupby('smoker')['tip_pct'].describe()
result
        count      mean       std       min       25%       50%       75%  \
smoker                                                                      
No      151.0  0.159328  0.039910  0.056797  0.136906  0.155625  0.185014   
Yes      93.0  0.163196  0.085119  0.035638  0.106771  0.153846  0.195059   
             max  
smoker

No      0.291990  
Yes     0.710345  
result.unstack('smoker')
       smoker
count  No        151.000000
       Yes        93.000000
mean   No          0.159328
       Yes         0.163196
std    No          0.039910
       Yes         0.085119
min    No          0.056797
       Yes         0.035638
25%    No          0.136906
       Yes         0.106771
50%    No          0.155625
       Yes         0.153846
75%    No          0.185014
       Yes         0.195059
max    No          0.291990
       Yes         0.710345
dtype: float64
</code></pre>
<p>在<code>GroupBy</code>中，当你调用诸如<code>describe</code>之类的方法时，实际上只是应用了下面两条代码的快捷方式而已：</p>
<pre><code class="language-python">f = lambda x: x.describe()
grouped.apply(f)
</code></pre>
<h4 id="禁止分组键">禁止分组键</h4>
<p>从上面的例子中可以看出，分组键会跟原始对象的索引共同构成结果对象中的层次化索引。将<code>group_keys=False</code>传入<code>groupby</code>即可禁止该效果：</p>
<pre><code class="language-python">tips.groupby('smoker', group_keys=False).apply(top)
     total_bill   tip smoker   day    time  size   tip_pct
88        24.71  5.85     No  Thur   Lunch     2  0.236746
185       20.69  5.00     No   Sun  Dinner     5  0.241663
51        10.29  2.60     No   Sun  Dinner     2  0.252672
149        7.51  2.00     No  Thur   Lunch     2  0.266312
232       11.61  3.39     No   Sat  Dinner     2  0.291990
109       14.31  4.00    Yes   Sat  Dinner     2  0.279525
183       23.17  6.50    Yes   Sun  Dinner     4  0.280535
67         3.07  1.00    Yes   Sat  Dinner     1  0.325733
178        9.60  4.00    Yes   Sun  Dinner     2  0.416667
172        7.25  5.15    Yes   Sun  Dinner     2  0.710345
</code></pre>
<h4 id="分位数和桶分析">分位数和桶分析</h4>
<p><code>pandas</code>有一些能根据指定面元或样本分位数将数据拆分成多块的工具（比如<code>cut</code>和<code>qcut</code>）。将这些函数跟<code>groupby</code>结合起来，就能非常轻松地实现对数据集的桶（<code>bucket</code>）或分位数（<code>quantile</code>）分析了。以下面这个简单的随机数据集为例，我们利用<code>cut</code>将其装入长度相等的桶中：</p>
<pre><code class="language-python">frame = pd.DataFrame({'data1': np.random.randn(1000),'data2': np.random.randn(1000)})
quartiles = pd.cut(frame.data1, 4)
quartiles[:10]
0     (-1.23, 0.489]
1    (-2.956, -1.23]
2     (-1.23, 0.489]
3     (0.489, 2.208]
4     (-1.23, 0.489]
5     (0.489, 2.208]
6     (-1.23, 0.489]
7     (-1.23, 0.489]
8     (0.489, 2.208]
9     (0.489, 2.208]
Name: data1, dtype: category
Categories (4, interval[float64]): [(-2.956, -1.23] &lt; (-1.23, 0.489] &lt; (0.489, 2.
208] &lt; (2.208, 3.928]]
</code></pre>
<p>由<code>cut</code>返回的<code>Categorical</code>对象可直接传递到<code>groupby</code>。因此，我们可以像下面这样对<code>data2</code>列做一些统计计算：</p>
<pre><code class="language-python">def get_stats(group):
    return {'min': group.min(), 'max': group.max(),'count': group.count(), 'mean': group.mean()}
grouped = frame.data2.groupby(quartiles)
grouped.apply(get_stats).unstack()
                 count       max      mean       min
data1                                               
(-2.956, -1.23]   95.0  1.670835 -0.039521 -3.399312
(-1.23, 0.489]   598.0  3.260383 -0.002051 -2.989741
(0.489, 2.208]   297.0  2.954439  0.081822 -3.745356
(2.208, 3.928]    10.0  1.765640  0.024750 -1.929776
</code></pre>
<p>这些都是长度相等的桶。要根据样本分位数得到大小相等的桶，使用<code>qcut</code>即可。传入<code>labels=False</code>即可只获取分位数的编号：</p>
<pre><code class="language-python">#Return quantile numbers
grouping = pd.qcut(frame.data1, 10, labels=False)
grouped = frame.data2.groupby(grouping)
grouped.apply(get_stats).unstack()
       count       max      mean       min
data1                                     
0      100.0  1.670835 -0.049902 -3.399312
1      100.0  2.628441  0.030989 -1.950098
2      100.0  2.527939 -0.067179 -2.925113
3      100.0  3.260383  0.065713 -2.315555
4      100.0  2.074345 -0.111653 -2.047939
5      100.0  2.184810  0.052130 -2.989741
6      100.0  2.458842 -0.021489 -2.223506
7      100.0  2.954439 -0.026459 -3.056990
8      100.0  2.735527  0.103406 -3.745356
9      100.0  2.377020  0.220122 -2.064111
</code></pre>
<h4 id="示例用特定于分组的值填充缺失值">示例：用特定于分组的值填充缺失值</h4>
<p>对于缺失数据的清理工作，有时你会用<code>dropna</code>将其替换掉，而有时则可能会希望用一个固定值或由数据集本身所衍生出来的值去填充<code>NA</code>值。这时就得使用<code>fillna</code>这个工具了。在下面这个例子中，我用平均值去填充<code>NA</code>值：</p>
<pre><code class="language-python">s = pd.Series(np.random.randn(6))
s[::2] = np.nan
s
0         NaN
1   -0.125921
2         NaN
3   -0.884475
4         NaN
5    0.227290
dtype: float64
s.fillna(s.mean())
0   -0.261035
1   -0.125921
2   -0.261035
3   -0.884475
4   -0.261035
5    0.227290
dtype: float64
</code></pre>
<p>假设你需要对不同的分组填充不同的值。一种方法是将数据分组，并使用<code>apply</code>和一个能够对各数据块调用<code>fillna</code>的函数即可。下面是一些有关美国几个州的示例数据，这些州又被分为东部和西部：</p>
<pre><code class="language-python">states = ['Ohio', 'New York', 'Vermont', 'Florida','Oregon', 'Nevada', 'California', 'Idaho']
group_key = ['East'] * 4 + ['West'] * 4
data = pd.Series(np.random.randn(8), index=states)
data
Ohio          0.922264
New York     -2.153545
Vermont      -0.365757
Florida      -0.375842
Oregon        0.329939
Nevada        0.981994
California    1.105913
Idaho        -1.613716
dtype: float64
</code></pre>
<p><code>['East'] * 4</code>产生了一个列表，包括了<code>['East']</code>中元素的四个拷贝。将这些列表串联起来。<br>
将一些值设为缺失：</p>
<pre><code class="language-python">data[['Vermont', 'Nevada', 'Idaho']] = np.nan
data
Ohio          0.922264
New York     -2.153545
Vermont            NaN
Florida      -0.375842
Oregon        0.329939
Nevada             NaN
California    1.105913
Idaho              NaN
dtype: float64
data.groupby(group_key).mean()
East   -0.535707
West    0.717926
dtype: float64
</code></pre>
<p>我们可以用分组平均值去填充<code>NA</code>值:</p>
<pre><code class="language-python">fill_mean = lambda g: g.fillna(g.mean())
data.groupby(group_key).apply(fill_mean)
Ohio          0.922264
New York     -2.153545
Vermont      -0.535707
Florida      -0.375842
Oregon        0.329939
Nevada        0.717926
California    1.105913
Idaho         0.717926
dtype: float64
</code></pre>
<p>另外，也可以在代码中预定义各组的填充值。由于分组具有一个<code>name</code>属性，所以我们可以拿来用一下：</p>
<pre><code class="language-python">fill_values = {'East': 0.5, 'West': -1}
fill_func = lambda g: g.fillna(fill_values[g.name])
data.groupby(group_key).apply(fill_func)
Ohio          0.922264
New York     -2.153545
Vermont       0.500000
Florida      -0.375842
Oregon        0.329939
Nevada       -1.000000
California    1.105913
Idaho        -1.000000
dtype: float64
</code></pre>
<h4 id="示例随机采样和排列">示例：随机采样和排列</h4>
<p>假设你想要从一个大数据集中随机抽取（进行替换或不替换）样本以进行蒙特卡罗模拟（<code>Monte Carlo simulation</code>）或其他分析工作。“抽取”的方式有很多，这里使用的方法是对<code>Series</code>使用<code>sample</code>方法：</p>
<pre><code class="language-python">#Hearts, Spades, Clubs, Diamonds
suits = ['H', 'S', 'C', 'D']
card_val = (list(range(1, 11)) + [10] * 3) * 4
base_names = ['A'] + list(range(2, 11)) + ['J', 'K', 'Q']
cards = []
for suit in ['H', 'S', 'C', 'D']:
    cards.extend(str(num) + suit for num in base_names)

deck = pd.Series(card_val, index=cards)
</code></pre>
<p>现在我有了一个长度为52的<code>Series</code>，其索引包括牌名，值则是21点或其他游戏中用于计分的点数（为了简单起见，我当A的点数为1）：</p>
<pre><code class="language-python">deck[:13]
AH      1
2H      2
3H      3
4H      4
5H      5
6H      6
7H      7
8H      8
9H      9
10H    10
JH     10
KH     10
QH     10
dtype: int64
</code></pre>
<p>现在，根据我上面所讲的，从整副牌中抽出5张，代码如下：</p>
<pre><code class="language-python">def draw(deck, n=5):
    return deck.sample(n)
draw(deck)
AD     1
8C     8
5H     5
KC    10
2C     2
dtype: int64
</code></pre>
<p>假设你想要从每种花色中随机抽取两张牌。由于花色是牌名的最后一个字符，所以我们可以据此进行分组，并使用<code>apply</code>：</p>
<pre><code class="language-python">get_suit = lambda card: card[-1] # last letter is suit
deck.groupby(get_suit).apply(draw, n=2)
C  2C     2
   3C     3
D  KD    10
   8D     8
H  KH    10
   3H     3
S  2S     2
   4S     4
dtype: int64
</code></pre>
<p>或者，也可以这样写：</p>
<pre><code class="language-python">deck.groupby(get_suit, group_keys=False).apply(draw, n=2)
KC    10
JC    10
AD     1
5D     5
5H     5
6H     6
7S     7
KS    10
dtype: int64
</code></pre>
<h4 id="示例分组加权平均数和相关系数">示例：分组加权平均数和相关系数</h4>
<p>根据<code>groupby</code>的“拆分－应用－合并”范式，可以进行<code>DataFrame</code>的列与列之间或两个<code>Series</code>之间的运算（比如分组加权平均）。以下面这个数据集为例，它含有分组键、值以及一些权重值：</p>
<pre><code class="language-python">df = pd.DataFrame({'category': ['a', 'a', 'a', 'a','b', 'b', 'b', 'b'],'data': np.random.randn(8),'weights': np.random.rand(8)})
df
  category      data   weights
0        a  1.561587  0.957515
1        a  1.219984  0.347267
2        a -0.482239  0.581362
3        a  0.315667  0.217091
4        b -0.047852  0.894406
5        b -0.454145  0.918564
6        b -0.556774  0.277825
7        b  0.253321  0.955905
</code></pre>
<p>然后可以利用<code>category</code>计算分组加权平均数：</p>
<pre><code class="language-python">grouped = df.groupby('category')
get_wavg = lambda g: np.average(g['data'], weights=g['weights'])
grouped.apply(get_wavg)
category
a    0.811643
b   -0.122262
dtype: float64
</code></pre>
<p>另一个例子，考虑一个来自Yahoo!Finance的数据集，其中含有几只股票和标准普尔500指数（符号SPX）的收盘价：</p>
<pre><code class="language-python">close_px = pd.read_csv('examples/stock_px_2.csv', parse_dates=True,index_col=0)
close_px.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
DatetimeIndex: 2214 entries, 2003-01-02 to 2011-10-14
Data columns (total 4 columns):
AAPL    2214 non-null float64
MSFT    2214 non-null float64
XOM     2214 non-null float64
SPX     2214 non-null float64
dtypes: float64(4)
memory usage: 86.5 KB
close_px[-4:]
              AAPL   MSFT    XOM      SPX
2011-10-11  400.29  27.00  76.27  1195.54
2011-10-12  402.19  26.96  77.16  1207.25
2011-10-13  408.43  27.18  76.37  1203.66
2011-10-14  422.00  27.27  78.11  1224.58
</code></pre>
<p>来做一个比较有趣的任务：计算一个由日收益率（通过百分数变化计算）与SPX之间的年度相关系数组成的<code>DataFrame</code>。下面是一个实现办法，我们先创建一个函数，用它计算每列和SPX列的成对相关系数：</p>
<pre><code class="language-python">spx_corr = lambda x: x.corrwith(x['SPX'])
</code></pre>
<p>接下来，我们使用<code>pct_change</code>计算<code>close_px</code>的百分比变化：</p>
<pre><code class="language-python">rets = close_px.pct_change().dropna()
</code></pre>
<p>最后，我们用年对百分比变化进行分组，可以用一个一行的函数，从每行的标签返回每个<code>datetime</code>标签的<code>year</code>属性：</p>
<pre><code class="language-python">get_year = lambda x: x.year
by_year = rets.groupby(get_year)
by_year.apply(spx_corr)
          AAPL      MSFT       XOM  SPX
2003  0.541124  0.745174  0.661265  1.0
2004  0.374283  0.588531  0.557742  1.0
2005  0.467540  0.562374  0.631010  1.0
2006  0.428267  0.406126  0.518514  1.0
2007  0.508118  0.658770  0.786264  1.0
2008  0.681434  0.804626  0.828303  1.0
2009  0.707103  0.654902  0.797921  1.0
2010  0.710105  0.730118  0.839057  1.0
2011  0.691931  0.800996  0.859975  1.0
</code></pre>
<p>当然，你还可以计算列与列之间的相关系数。这里，我们计算<code>Apple</code>和<code>Microsoft</code>的年相关系数：</p>
<pre><code class="language-python">by_year.apply(lambda g: g['AAPL'].corr(g['MSFT']))
2003    0.480868
2004    0.259024
2005    0.300093
2006    0.161735
2007    0.417738
2008    0.611901
2009    0.432738
2010    0.571946
2011    0.581987
dtype: float64
</code></pre>
<h4 id="示例组级别的线性回归">示例：组级别的线性回归</h4>
<p>顺着上一个例子继续，你可以用<code>groupby</code>执行更为复杂的分组统计分析，只要函数返回的是<code>pandas</code>对象或标量值即可。例如，我可以定义下面这个<code>regress</code>函数（利用statsmodels计量经济学库）对各数据块执行普通最小二乘法（Ordinary Least Squares，OLS）回归：</p>
<pre><code class="language-python">import statsmodels.api as sm
def regress(data, yvar, xvars):
    Y = data[yvar]
    X = data[xvars]
    X['intercept'] = 1.
    result = sm.OLS(Y, X).fit()
    return result.params
</code></pre>
<p>现在，为了按年计算AAPL对SPX收益率的线性回归，执行：</p>
<pre><code class="language-python">by_year.apply(regress, 'AAPL', ['SPX'])
           SPX  intercept
2003  1.195406   0.000710
2004  1.363463   0.004201
2005  1.766415   0.003246
2006  1.645496   0.000080
2007  1.198761   0.003438
2008  0.968016  -0.001110
2009  0.879103   0.002954
2010  1.052608   0.001261
2011  0.806605   0.001514
</code></pre>
<h3 id="透视表和交叉表">透视表和交叉表</h3>
<p>透视表（<code>pivot table</code>）是各种电子表格程序和其他数据分析软件中一种常见的数据汇总工具。它根据一个或多个键对数据进行聚合，并根据行和列上的分组键将数据分配到各个矩形区域中。在<code>Python</code>和<code>pandas</code>中，可以通过本章所介绍的<code>groupby</code>功能以及（能够利用层次化索引的）重塑运算制作透视表。<code>DataFrame</code>有一个<code>pivot_table</code>方法，此外还有一个顶级的<code>pandas.pivot_table</code>函数。除能为<code>groupby</code>提供便利之外，<code>pivot_table</code>还可以添加分项小计，也叫做<code>margins</code>。</p>
<p>回到小费数据集，假设我想要根据<code>day</code>和<code>smoker</code>计算分组平均数（<code>pivot_table</code>的默认聚合类型），并将<code>day</code>和<code>smoker</code>放到行上：</p>
<pre><code class="language-python">tips.pivot_table(index=['day', 'smoker'])
                 size       tip   tip_pct  total_bill
day  smoker                                          
Fri  No      2.250000  2.812500  0.151650   18.420000
     Yes     2.066667  2.714000  0.174783   16.813333
Sat  No      2.555556  3.102889  0.158048   19.661778
     Yes     2.476190  2.875476  0.147906   21.276667
Sun  No      2.929825  3.167895  0.160113   20.506667
     Yes     2.578947  3.516842  0.187250   24.120000
Thur No      2.488889  2.673778  0.160298   17.113111
     Yes     2.352941  3.030000  0.163863   19.190588
</code></pre>
<p>可以用<code>groupby</code>直接来做。现在，假设我们只想聚合<code>tip_pct</code>和<code>size</code>，而且想根据<code>time</code>进行分组。我将<code>smoker</code>放到列上，把<code>day</code>放到行上：</p>
<pre><code class="language-python">tips.pivot_table(['tip_pct', 'size'], index=['time', 'day'],columns='smoker')
                 size             tip_pct          
smoker             No       Yes        No       Yes
time   day                                         
Dinner Fri   2.000000  2.222222  0.139622  0.165347
       Sat   2.555556  2.476190  0.158048  0.147906
       Sun   2.929825  2.578947  0.160113  0.187250
       Thur  2.000000       NaN  0.159744       NaN
Lunch  Fri   3.000000  1.833333  0.187735  0.188937
       Thur  2.500000  2.352941  0.160311  0.163863
</code></pre>
<p>还可以对这个表作进一步的处理，传入<code>margins=True</code>添加分项小计。这将会添加标签为All的行和列，其值对应于单个等级中所有数据的分组统计：</p>
<pre><code class="language-python">tips.pivot_table(['tip_pct', 'size'], index=['time', 'day'],columns='smoker', margins=True)
                 size                       tip_pct                    
smoker             No       Yes       All        No       Yes       All
time   day                                                             
Dinner Fri   2.000000  2.222222  2.166667  0.139622  0.165347  0.158916
       Sat   2.555556  2.476190  2.517241  0.158048  0.147906  0.153152
       Sun   2.929825  2.578947  2.842105  0.160113  0.187250  0.166897
       Thur  2.000000       NaN  2.000000  0.159744       NaN  0.159744
Lunch  Fri   3.000000  1.833333  2.000000  0.187735  0.188937  0.188765
       Thur  2.500000  2.352941  2.459016  0.160311  0.163863  0.161301
All          2.668874  2.408602  2.569672  0.159328  0.163196  0.160803
</code></pre>
<p>这里，All值为平均数：不单独考虑烟民与非烟民（All列），不单独考虑行分组两个级别中的任何单项（All行）。</p>
<p>要使用其他的聚合函数，将其传给<code>aggfunc</code>即可。例如，使用<code>count</code>或<code>len</code>可以得到有关分组大小的交叉表（计数或频率）：</p>
<pre><code class="language-python">tips.pivot_table('tip_pct', index=['time', 'smoker'], columns='day',aggfunc=len, margins=True)
day             Fri   Sat   Sun  Thur    All
time   smoker                               
Dinner No       3.0  45.0  57.0   1.0  106.0
       Yes      9.0  42.0  19.0   NaN   70.0
Lunch  No       1.0   NaN   NaN  44.0   45.0
       Yes      6.0   NaN   NaN  17.0   23.0
All            19.0  87.0  76.0  62.0  244.0
</code></pre>
<p>如果存在空的组合（也就是<code>NA</code>），你可能会希望设置一个<code>fill_value</code>：</p>
<pre><code class="language-python">tips.pivot_table('tip_pct', index=['time', 'size', 'smoker'],columns='day', aggfunc='mean', fill_value=0)
day                      Fri       Sat       Sun      Thur
time   size smoker                                        
Dinner 1    No      0.000000  0.137931  0.000000  0.000000
            Yes     0.000000  0.325733  0.000000  0.000000
       2    No      0.139622  0.162705  0.168859  0.159744
            Yes     0.171297  0.148668  0.207893  0.000000
       3    No      0.000000  0.154661  0.152663  0.000000
            Yes     0.000000  0.144995  0.152660  0.000000
       4    No      0.000000  0.150096  0.148143  0.000000
            Yes     0.117750  0.124515  0.193370  0.000000
       5    No      0.000000  0.000000  0.206928  0.000000
Yes     0.000000  0.106572  0.065660  0.000000
...                      ...       ...       ...       ...
Lunch  1    No      0.000000  0.000000  0.000000  0.181728
            Yes     0.223776  0.000000  0.000000  0.000000
       2    No      0.000000  0.000000  0.000000  0.166005
            Yes     0.181969  0.000000  0.000000  0.158843
       3    No      0.187735  0.000000  0.000000  0.084246
            Yes     0.000000  0.000000  0.000000  0.204952
       4    No      0.000000  0.000000  0.000000  0.138919
            Yes     0.000000  0.000000  0.000000  0.155410
       5    No      0.000000  0.000000  0.000000  0.121389
       6    No      0.000000  0.000000  0.000000  0.173706
[21 rows x 4 columns]
</code></pre>
<p><code>pivot_table</code>的参数说明请参见下表。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408212522.png" alt="" loading="lazy"></p>
<p>交叉表（<code>cross-tabulation</code>，简称<code>crosstab</code>）是一种用于计算分组频率的特殊透视表。看下面的例子：</p>
<pre><code class="language-python">data
   Sample Nationality    Handedness
0       1         USA  Right-handed
1       2       Japan   Left-handed
2       3         USA  Right-handed
3       4       Japan  Right-handed
4       5       Japan   Left-handed
5       6       Japan  Right-handed
6       7         USA  Right-handed
7       8         USA   Left-handed
8       9       Japan  Right-handed
9      10         USA  Right-handed
</code></pre>
<p>作为调查分析的一部分，我们可能想要根据国籍和用手习惯对这段数据进行统计汇总。虽然可以用<code>pivot_table</code>实现该功能，但是<code>pandas.crosstab</code>函数会更方便：</p>
<pre><code class="language-python">pd.crosstab(data.Nationality, data.Handedness, margins=True)
Handedness   Left-handed  Right-handed  All
Nationality
Japan                  2             3    5
USA                    1             4    5
All                    3             7   10
</code></pre>
<p><code>crosstab</code>的前两个参数可以是数组或<code>Series</code>，或是数组列表。就像小费数据：</p>
<pre><code class="language-python">pd.crosstab([tips.time, tips.day], tips.smoker, margins=True)
smoker        No  Yes  All
time   day                
Dinner Fri     3    9   12
       Sat    45   42   87
       Sun    57   19   76
       Thur    1    0    1
Lunch  Fri     1    6    7
       Thur   44   17   61
All          151   93  244
</code></pre>
<h2 id="时间序列">时间序列</h2>
<p>时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p>
<ul>
<li>时间戳（<code>timestamp</code>），特定的时刻。</li>
<li>固定时期（<code>period</code>），如2007年1月或2010年全年。</li>
<li>时间间隔（<code>interval</code>），由起始和结束时间戳表示。时期（<code>period</code>）可以被看做间隔（<code>interval</code>）的特例。<br>
许多技术都可用于处理实验型时间序列，其索引可能是一个整数或浮点数（表示从实验开始算起已经过去的时间）。最简单也最常见的时间序列都是用时间戳进行索引的。<code>pandas</code>也支持基于<code>timedeltas</code>的指数，它可以有效代表实验或经过的时间。</li>
</ul>
<h3 id="日期和时间数据类型及工具">日期和时间数据类型及工具</h3>
<p><code>Python</code>标准库包含用于日期（<code>date</code>）和时间（<code>time</code>）数据的数据类型，而且还有日历方面的功能。我们主要会用到<code>datetime</code>、<code>time</code>以及<code>calendar</code>模块。<code>datetime.datetime</code>（也可以简写为<code>datetime</code>）是用得最多的数据类型：</p>
<pre><code class="language-python">from datetime import datetime

now = datetime.now()

now
datetime.datetime(2017, 9, 25, 14, 5, 52, 72973)
now.year, now.month, now.day
(2017, 9, 25)
</code></pre>
<p><code>datetime</code>以毫秒形式存储日期和时间。<code>timedelta</code>表示两个<code>datetime</code>对象之间的时间差：</p>
<pre><code class="language-python">delta = datetime(2011, 1, 7) - datetime(2008, 6, 24, 8, 15)
delta
datetime.timedelta(926, 56700)

delta.days
926
delta.seconds
56700
</code></pre>
<p>可以给<code>datetime</code>对象加上（或减去）一个或多个<code>timedelta</code>，这样会产生一个新对象：</p>
<pre><code class="language-python">from datetime import timedelta
start = datetime(2011, 1, 7)
start + timedelta(12)
datetime.datetime(2011, 1, 19, 0, 0)
start - 2 * timedelta(12)
datetime.datetime(2010, 12, 14, 0, 0)
</code></pre>
<p><code>datetime</code>模块中的数据类型参见下表。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408224708.png" alt="" loading="lazy"></p>
<h4 id="字符串和datetime的相互转换">字符串和<code>datetime</code>的相互转换</h4>
<p>利用<code>str</code>或<code>strftime</code>方法（传入一个格式化字符串），<code>datetime</code>对象和<code>pandas</code>的<code>Timestamp</code>对象可以被格式化为字符串：</p>
<pre><code class="language-python">stamp = datetime(2011, 1, 3)
str(stamp)
'2011-01-03 00:00:00'
stamp.strftime('%Y-%m-%d')
'2011-01-03'
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408225010.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408225041.png" alt="" loading="lazy"><br>
<code>datetime.strptime</code>可以用这些格式化编码将字符串转换为日期：</p>
<pre><code class="language-python">value = '2011-01-03'
datetime.strptime(value, '%Y-%m-%d')
datetime.datetime(2011, 1, 3, 0, 0)
datestrs = ['7/6/2011', '8/6/2011']
[datetime.strptime(x, '%m/%d/%Y') for x in datestrs]
[datetime.datetime(2011, 7, 6, 0, 0),
 datetime.datetime(2011, 8, 6, 0, 0)]
</code></pre>
<p><code>datetime.strptime</code>是通过已知格式进行日期解析的最佳方式。但是每次都要编写格式定义是很麻烦的事情，尤其是对于一些常见的日期格式。这种情况下，你可以用<code>dateutil</code>这个第三方包中的<code>parser.parse</code>方法（<code>pandas</code>中已经自动安装好了）：</p>
<pre><code class="language-python">from dateutil.parser import parse
parse('2011-01-03')
datetime.datetime(2011, 1, 3, 0, 0)
</code></pre>
<p><code>dateutil</code>可以解析几乎所有人类能够理解的日期表示形式：</p>
<pre><code class="language-python">parse('Jan 31, 1997 10:45 PM')
datetime.datetime(1997, 1, 31, 22, 45)
</code></pre>
<p>在国际通用的格式中，日出现在月的前面很普遍，传入<code>dayfirst=True</code>即可解决这个问题：</p>
<pre><code class="language-python">parse('6/12/2011', dayfirst=True)
datetime.datetime(2011, 12, 6, 0, 0)
</code></pre>
<p><code>pandas</code>通常是用于处理成组日期的，不管这些日期是<code>DataFrame</code>的轴索引还是列。<code>to_datetime</code>方法可以解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快：</p>
<pre><code class="language-python">datestrs = ['2011-07-06 12:00:00', '2011-08-06 00:00:00']
pd.to_datetime(datestrs)
DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)
</code></pre>
<p>它还可以处理缺失值（<code>None</code>、空字符串等）：</p>
<pre><code class="language-python">idx = pd.to_datetime(datestrs + [None])
idx
DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00', 'NaT'], dtype='datetime64[ns]', freq=None)
idx[2]
NaT
pd.isnull(idx)
array([False, False,  True], dtype=bool)
</code></pre>
<p><code>NaT</code>（Not a Time）是<code>pandas</code>中时间戳数据的<code>null</code>值。</p>
<blockquote>
<p>注意：<code>dateutil.parser</code>是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如&quot;42&quot;会被解析为2042年的今天）。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408233344.png" alt="" loading="lazy"></p>
</blockquote>
<h3 id="时间序列基础">时间序列基础</h3>
<p><code>pandas</code>最基本的时间序列类型就是以时间戳（通常以<code>Python</code>字符串或<code>datatime</code>对象表示）为索引的<code>Series</code>：</p>
<pre><code class="language-python">from datetime import datetime
dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),datetime(2011, 1, 7), datetime(2011, 1, 8),datetime(2011, 1, 10), datetime(2011, 1, 12)]
ts = pd.Series(np.random.randn(6), index=dates)
ts
2011-01-02   -0.204708
2011-01-05    0.478943
2011-01-07   -0.519439
2011-01-08   -0.555730
2011-01-10    1.965781
2011-01-12    1.393406
dtype: float64
</code></pre>
<p>这些<code>datetime</code>对象实际上是被放在一个<code>DatetimeIndex</code>中的：</p>
<pre><code class="language-python">ts.index
DatetimeIndex(['2011-01-02', '2011-01-05', '2011-01-07', '2011-01-08',
               '2011-01-10', '2011-01-12'],
              dtype='datetime64[ns]', freq=None)
</code></pre>
<p>跟其他<code>Series</code>一样，不同索引的时间序列之间的算术运算会自动按日期对齐：</p>
<pre><code class="language-python">ts + ts[::2]
2011-01-02   -0.409415
2011-01-05         NaN
2011-01-07   -1.038877
2011-01-08         NaN
2011-01-10    3.931561
2011-01-12         NaN
dtype: float64
</code></pre>
<p><code>ts[::2]</code> 是每隔两个取一个。</p>
<p><code>pandas</code>用<code>NumPy</code>的<code>datetime64</code>数据类型以纳秒形式存储时间戳：</p>
<pre><code class="language-python">ts.index.dtype
dtype('&lt;M8[ns]')
</code></pre>
<p><code>DatetimeIndex</code>中的各个标量值是<code>pandas</code>的<code>Timestamp</code>对象：</p>
<pre><code class="language-python">stamp = ts.index[0]
stamp
Timestamp('2011-01-02 00:00:00')
</code></pre>
<p>只要有需要，<code>TimeStamp</code>可以随时自动转换为<code>datetime</code>对象。此外，它还可以存储频率信息（如果有的话）。</p>
<h4 id="索引-选取-子集构造">索引、选取、子集构造</h4>
<p>当你根据标签索引选取数据时，时间序列和其它的<code>pandas.Series</code>很像：</p>
<pre><code class="language-python">stamp = ts.index[2]
ts[stamp]
-0.51943871505673811
</code></pre>
<p>还有一种更为方便的用法：传入一个可以被解释为日期的字符串：</p>
<pre><code class="language-python">ts['1/10/2011']
1.9657805725027142
ts['20110110']
1.9657805725027142
</code></pre>
<p>对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片：</p>
<pre><code class="language-python">longer_ts = pd.Series(np.random.randn(1000),index=pd.date_range('1/1/2000', periods=1000))
longer_ts
2000-01-01    0.092908
2000-01-02    0.281746
2000-01-03    0.769023
2000-01-04    1.246435
2000-01-05    1.007189
2000-01-06   -1.296221
2000-01-07    0.274992
2000-01-08    0.228913
2000-01-09    1.352917
2000-01-10    0.886429
                ...   
2002-09-17   -0.139298
2002-09-18   -1.159926
2002-09-19    0.618965
2002-09-20    1.373890
2002-09-21   -0.983505
2002-09-22    0.930944
2002-09-23   -0.811676
2002-09-24   -1.830156
2002-09-25   -0.138730
2002-09-26    0.334088
Freq: D, Length: 1000, dtype: float64
longer_ts['2001']
2001-01-01    1.599534
2001-01-02    0.474071
2001-01-03    0.151326
2001-01-04   -0.542173
2001-01-05   -0.475496
2001-01-06    0.106403
2001-01-07   -1.308228
2001-01-08    2.173185
2001-01-09    0.564561
2001-01-10   -0.190481
                ...   
2001-12-22    0.000369
2001-12-23    0.900885
2001-12-24   -0.454869
2001-12-25   -0.864547
2001-12-26    1.129120
2001-12-27    0.057874
2001-12-28   -0.433739
2001-12-29    0.092698
2001-12-30   -1.397820
2001-12-31    1.457823
Freq: D, Length: 365, dtype: float64
</code></pre>
<p>这里，字符串“2001”被解释成年，并根据它选取时间区间。指定月也同样奏效：</p>
<pre><code class="language-python">longer_ts['2001-05']
2001-05-01   -0.622547
2001-05-02    0.936289
2001-05-03    0.750018
2001-05-04   -0.056715
2001-05-05    2.300675
2001-05-06    0.569497
2001-05-07    1.489410
2001-05-08    1.264250
2001-05-09   -0.761837
2001-05-10   -0.331617
                ...   
2001-05-22    0.503699
2001-05-23   -1.387874
2001-05-24    0.204851
2001-05-25    0.603705
2001-05-26    0.545680
2001-05-27    0.235477
2001-05-28    0.111835
2001-05-29   -1.251504
2001-05-30   -2.949343
2001-05-31    0.634634
Freq: D, Length: 31, dtype: float64
</code></pre>
<p><code>datetime</code>对象也可以进行切片：</p>
<pre><code class="language-python">ts[datetime(2011, 1, 7):]
2011-01-07   -0.519439
2011-01-08   -0.555730
2011-01-10    1.965781
2011-01-12    1.393406
dtype: float64
</code></pre>
<p>由于大部分时间序列数据都是按照时间先后排序的，因此你也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）：</p>
<pre><code class="language-python">ts
2011-01-02   -0.204708
2011-01-05    0.478943
2011-01-07   -0.519439
2011-01-08   -0.555730
2011-01-10    1.965781
2011-01-12    1.393406
dtype: float64
ts['1/6/2011':'1/11/2011']
2011-01-07   -0.519439
2011-01-08   -0.555730
2011-01-10    1.965781
dtype: float64
</code></pre>
<p>跟之前一样，你可以传入字符串日期、<code>datetime</code>或<code>Timestamp</code>。注意，这样切片所产生的是原时间序列的视图，跟<code>NumPy</code>数组的切片运算是一样的。</p>
<p>这意味着，没有数据被复制，对切片进行修改会反映到原始数据上。</p>
<p>此外，还有一个等价的实例方法也可以截取两个日期之间<code>TimeSeries</code>：</p>
<pre><code class="language-python">ts.truncate(after='1/9/2011')
2011-01-02   -0.204708
2011-01-05    0.478943
2011-01-07   -0.519439
2011-01-08   -0.555730
dtype: float64
</code></pre>
<p>面这些操作对<code>DataFrame</code>也有效。例如，对<code>DataFrame</code>的行进行索引：</p>
<pre><code class="language-python">dates = pd.date_range('1/1/2000', periods=100, freq='W-WED')
long_df = pd.DataFrame(np.random.randn(100, 4),index=dates,columns=['Colorado', 'Texas','New York', 'Ohio'])
long_df.loc['5-2001']
            Colorado     Texas  New York      Ohio
2001-05-02 -0.006045  0.490094 -0.277186 -0.707213
2001-05-09 -0.560107  2.735527  0.927335  1.513906
2001-05-16  0.538600  1.273768  0.667876 -0.969206
2001-05-23  1.676091 -0.817649  0.050188  1.951312
2001-05-30  3.260383  0.963301  1.201206 -1.852001
</code></pre>
<h4 id="带有重复索引的时间序列">带有重复索引的时间序列</h4>
<p>在某些应用场景中，可能会存在多个观测数据落在同一个时间点上的情况。下面就是一个例子：</p>
<pre><code class="language-python">dates = pd.DatetimeIndex(['1/1/2000', '1/2/2000', '1/2/2000','1/2/2000', '1/3/2000'])
dup_ts = pd.Series(np.arange(5), index=dates)
dup_ts
2000-01-01    0
2000-01-02    1
2000-01-02    2
2000-01-02    3
2000-01-03    4
dtype: int64
</code></pre>
<p>通过检查索引的<code>is_unique</code>属性，我们就可以知道它是不是唯一的：</p>
<pre><code class="language-python">dup_ts.index.is_unique
False
</code></pre>
<p>对这个时间序列进行索引，要么产生标量值，要么产生切片，具体要看所选的时间点是否重复：</p>
<pre><code class="language-python">dup_ts['1/3/2000']  # not duplicated
4
dup_ts['1/2/2000']  # duplicated
2000-01-02    1
2000-01-02    2
2000-01-02    3
dtype: int64
</code></pre>
<p>假设你想要对具有非唯一时间戳的数据进行聚合。一个办法是使用<code>groupby</code>，并传入<code>level=0</code>：</p>
<pre><code class="language-python">grouped = dup_ts.groupby(level=0)
grouped.mean()
2000-01-01    0
2000-01-02    2
2000-01-03    4
dtype: int64
grouped.count()
2000-01-01    1
2000-01-02    3
2000-01-03    1
dtype: int64
</code></pre>
<h3 id="日期的范围-频率以及移动">日期的范围、频率以及移动</h3>
<p><code>pandas</code>中的原生时间序列一般被认为是不规则的，也就是说，它们没有固定的频率。对于大部分应用程序而言，这是无所谓的。但是，它常常需要以某种相对固定的频率进行分析，比如每日、每月、每15分钟等（这样自然会在时间序列中引入缺失值）。幸运的是，<code>pandas</code>有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。例如，我们可以将之前那个时间序列转换为一个具有固定频率（每日）的时间序列，只需调用<code>resample</code>即可：</p>
<pre><code class="language-python">ts
2011-01-02   -0.204708
2011-01-05    0.478943
2011-01-07   -0.519439
2011-01-08   -0.555730
2011-01-10    1.965781
2011-01-12    1.393406
dtype: float64
resampler = ts.resample('D')
</code></pre>
<p>字符串“D”是每天的意思。</p>
<p>这里，我将告诉你如何使用基本的频率和它的倍数。</p>
<h4 id="生成日期范围">生成日期范围</h4>
<p>虽然我之前用的时候没有明说，但你可能已经猜到<code>pandas.date_range</code>可用于根据指定的频率生成指定长度的<code>DatetimeIndex</code>：</p>
<pre><code class="language-python">index = pd.date_range('2012-04-01', '2012-06-01')
index
DatetimeIndex(['2012-04-01', '2012-04-02', '2012-04-03', '2012-04-04',
               '2012-04-05', '2012-04-06', '2012-04-07', '2012-04-08',
               '2012-04-09', '2012-04-10', '2012-04-11', '2012-04-12',
               '2012-04-13', '2012-04-14', '2012-04-15', '2012-04-16',
               '2012-04-17', '2012-04-18', '2012-04-19', '2012-04-20',
               '2012-04-21', '2012-04-22', '2012-04-23', '2012-04-24',
               '2012-04-25', '2012-04-26', '2012-04-27', '2012-04-28',
               '2012-04-29', '2012-04-30', '2012-05-01', '2012-05-02',
               '2012-05-03', '2012-05-04', '2012-05-05', '2012-05-06',
               '2012-05-07', '2012-05-08', '2012-05-09', '2012-05-10',
               '2012-05-11', '2012-05-12', '2012-05-13', '2012-05-14',
               '2012-05-15', '2012-05-16', '2012-05-17', '2012-05-18',
               '2012-05-19', '2012-05-20', '2012-05-21', '2012-05-22',
               '2012-05-23', '2012-05-24', '2012-05-25', '2012-05-26',
               '2012-05-27', '2012-05-28', '2012-05-29', '2012-05-30',
               '2012-05-31', '2012-06-01'],
              dtype='datetime64[ns]', freq='D')
</code></pre>
<p>默认情况下，<code>date_range</code>会产生按天计算的时间点。如果只传入起始或结束日期，那就还得传入一个表示一段时间的数字：</p>
<pre><code class="language-python">pd.date_range(start='2012-04-01', periods=20)
DatetimeIndex(['2012-04-01', '2012-04-02', '2012-04-03', '2012-04-04',
               '2012-04-05', '2012-04-06', '2012-04-07', '2012-04-08',
               '2012-04-09', '2012-04-10', '2012-04-11', '2012-04-12',
               '2012-04-13', '2012-04-14', '2012-04-15', '2012-04-16',
               '2012-04-17', '2012-04-18', '2012-04-19', '2012-04-20'],
              dtype='datetime64[ns]', freq='D')
pd.date_range(end='2012-06-01', periods=20)
DatetimeIndex(['2012-05-13', '2012-05-14', '2012-05-15', '2012-05-16',
               '2012-05-17', '2012-05-18', '2012-05-19', '2012-05-20',
               '2012-05-21', '2012-05-22', '2012-05-23', '2012-05-24',
               '2012-05-25', '2012-05-26', '2012-05-27','2012-05-28',
               '2012-05-29', '2012-05-30', '2012-05-31', '2012-06-01'],
              dtype='datetime64[ns]', freq='D')
</code></pre>
<p>起始和结束日期定义了日期索引的严格边界。例如，如果你想要生成一个由每月最后一个工作日组成的日期索引，可以传入<code>&quot;BM&quot;</code>频率（表示business end of month，下表是频率列表），这样就只会包含时间间隔内（或刚好在边界上的）符合频率要求的日期：</p>
<pre><code class="language-python">pd.date_range('2000-01-01', '2000-12-01', freq='BM')
DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-28',
               '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',
               '2000-09-29', '2000-10-31', '2000-11-30'],
              dtype='datetime64[ns]', freq='BM')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408235607.png" alt="" loading="lazy"><br>
<code>date_range</code>默认会保留起始和结束时间戳的时间信息（如果有的话）：</p>
<pre><code class="language-python">pd.date_range('2012-05-02 12:56:31', periods=5)
DatetimeIndex(['2012-05-02 12:56:31', '2012-05-03 12:56:31',
               '2012-05-04 12:56:31', '2012-05-05 12:56:31',
               '2012-05-06 12:56:31'],
              dtype='datetime64[ns]', freq='D')
</code></pre>
<p>有时，虽然起始和结束日期带有时间信息，但你希望产生一组被规范化（<code>normalize</code>）到午夜的时间戳。<code>normalize</code>选项即可实现该功能：</p>
<pre><code class="language-python">pd.date_range('2012-05-02 12:56:31', periods=5, normalize=True)
DatetimeIndex(['2012-05-02', '2012-05-03', '2012-05-04', '2012-05-05',
               '2012-05-06'],
              dtype='datetime64[ns]', freq='D')
</code></pre>
<h4 id="频率和日期偏移量">频率和日期偏移量</h4>
<p><code>pandas</code>中的频率是由一个基础频率（<code>base frequency</code>）和一个乘数组成的。基础频率通常以一个字符串别名表示，比如<code>&quot;M&quot;</code>表示每月，<code>&quot;H&quot;</code>表示每小时。对于每个基础频率，都有一个被称为日期偏移量（<code>date offset</code>）的对象与之对应。例如，按小时计算的频率可以用<code>Hour</code>类表示：</p>
<pre><code class="language-python">rom pandas.tseries.offsets import Hour, Minute
hour = Hour()
hour
&lt;Hour&gt;
</code></pre>
<p>传入一个整数即可定义偏移量的倍数：</p>
<pre><code class="language-python">four_hours = Hour(4)
four_hours
&lt;4 * Hours&gt;
</code></pre>
<p>一般来说，无需明确创建这样的对象，只需使用诸如<code>&quot;H&quot;</code>或<code>&quot;4H&quot;</code>这样的字符串别名即可。在基础频率前面放上一个整数即可创建倍数：</p>
<pre><code class="language-python">pd.date_range('2000-01-01', '2000-01-03 23:59', freq='4h')
DatetimeIndex(['2000-01-01 00:00:00', '2000-01-01 04:00:00',
               '2000-01-01 08:00:00', '2000-01-01 12:00:00',
               '2000-01-01 16:00:00', '2000-01-01 20:00:00',
               '2000-01-02 00:00:00', '2000-01-02 04:00:00',
               '2000-01-02 08:00:00', '2000-01-02 12:00:00',
               '2000-01-02 16:00:00', '2000-01-02 20:00:00',
               '2000-01-03 00:00:00', '2000-01-03 04:00:00',
               '2000-01-03 08:00:00', '2000-01-03 12:00:00',
               '2000-01-03 16:00:00', '2000-01-03 20:00:00'],
              dtype='datetime64[ns]', freq='4H')
</code></pre>
<p>大部分偏移量对象都可通过加法进行连接：</p>
<pre><code class="language-python">Hour(2) + Minute(30)
&lt;150 * Minutes&gt;
</code></pre>
<p>同理，你也可以传入频率字符串（如<code>&quot;2h30min&quot;</code>），这种字符串可以被高效地解析为等效的表达式：</p>
<pre><code class="language-python">pd.date_range('2000-01-01', periods=10, freq='1h30min')
DatetimeIndex(['2000-01-01 00:00:00', '2000-01-01 01:30:00',
               '2000-01-01 03:00:00', '2000-01-01 04:30:00',
               '2000-01-01 06:00:00', '2000-01-01 07:30:00',
               '2000-01-01 09:00:00', '2000-01-01 10:30:00',
               '2000-01-01 12:00:00', '2000-01-01 13:30:00'],
              dtype='datetime64[ns]', freq='90T')
</code></pre>
<p>有些频率所描述的时间点并不是均匀分隔的。例如，<code>&quot;M&quot;</code>（日历月末）和<code>&quot;BM&quot;</code>（每月最后一个工作日）就取决于每月的天数，对于后者，还要考虑月末是不是周末。由于没有更好的术语，我将这些称为锚点偏移量（<code>anchored offset</code>）。</p>
<p>下表列出了<code>pandas</code>中的频率代码和日期偏移量类。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200408235607.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409015131.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409015146.png" alt="" loading="lazy"></p>
<p>笔记：用户可以根据实际需求自定义一些频率类以便提供<code>pandas</code>所没有的日期逻辑，但具体的细节超出了本书的范围。</p>
<h4 id="wom日期"><code>WOM</code>日期</h4>
<p><code>WOM</code>（Week Of Month）是一种非常实用的频率类，它以<code>WOM</code>开头。它使你能获得诸如“每月第3个星期五”之类的日期</p>
<pre><code class="language-python">rng = pd.date_range('2012-01-01', '2012-09-01', freq='WOM-3FRI')
list(rng)
[Timestamp('2012-01-20 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-02-17 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-03-16 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-04-20 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-05-18 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-06-15 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-07-20 00:00:00', freq='WOM-3FRI'),
 Timestamp('2012-08-17 00:00:00', freq='WOM-3FRI')]
</code></pre>
<h4 id="移动超前和滞后数据">移动（超前和滞后）数据</h4>
<p>移动（<code>shifting</code>）指的是沿着时间轴将数据前移或后移。<code>Series</code>和<code>DataFrame</code>都有一个<code>shift</code>方法用于执行单纯的前移或后移操作，保持索引不变：</p>
<pre><code class="language-python">ts = pd.Series(np.random.randn(4),index=pd.date_range('1/1/2000', periods=4, freq='M'))
ts
2000-01-31   -0.066748
2000-02-29    0.838639
2000-03-31   -0.117388
2000-04-30   -0.517795
Freq: M, dtype: float64
ts.shift(2)
2000-01-31         NaN
2000-02-29         NaN
2000-03-31   -0.066748
2000-04-30    0.838639
Freq: M, dtype: float64
ts.shift(-2)
2000-01-31   -0.117388
2000-02-29   -0.517795
2000-03-31         NaN
2000-04-30         NaN
Freq: M, dtype: float64
</code></pre>
<p>当我们这样进行移动时，就会在时间序列的前面或后面产生缺失数据。</p>
<p><code>shift</code>通常用于计算一个时间序列或多个时间序列（如<code>DataFrame</code>的列）中的百分比变化。可以这样表达：</p>
<pre><code class="language-python">ts / ts.shift(1) - 1
</code></pre>
<p>由于单纯的移位操作不会修改索引，所以部分数据会被丢弃。因此，如果频率已知，则可以将其传给<code>shift</code>以便实现对时间戳进行位移而不是对数据进行简单位移：</p>
<pre><code class="language-python">ts.shift(2, freq='M')
2000-03-31   -0.066748
2000-04-30    0.838639
2000-05-31   -0.117388
2000-06-30   -0.517795
Freq: M, dtype: float64
</code></pre>
<p>这里还可以使用其他频率，于是你就能非常灵活地对数据进行超前和滞后处理了：</p>
<pre><code class="language-python">ts.shift(3, freq='D')
2000-02-03   -0.066748
2000-03-03    0.838639
2000-04-03   -0.117388
2000-05-03   -0.517795
dtype: float64
ts.shift(1, freq='90T')
2000-01-31 01:30:00   -0.066748
2000-02-29 01:30:00    0.838639
2000-03-31 01:30:00   -0.117388
2000-04-30 01:30:00   -0.517795
Freq: M, dtype: float64
</code></pre>
<h4 id="通过偏移量对日期进行位移">通过偏移量对日期进行位移</h4>
<p><code>pandas</code>的日期偏移量还可以用在<code>datetime</code>或<code>Timestamp</code>对象上：</p>
<pre><code class="language-python">from pandas.tseries.offsets import Day, MonthEnd
now = datetime(2011, 11, 17)
now + 3 * Day()
Timestamp('2011-11-20 00:00:00')
</code></pre>
<p>如果加的是锚点偏移量（比如<code>MonthEnd</code>），第一次增量会将原日期向前滚动到符合频率规则的下一个日期：</p>
<pre><code class="language-python">now + MonthEnd()
Timestamp('2011-11-30 00:00:00')
now + MonthEnd(2)
Timestamp('2011-12-31 00:00:00')
</code></pre>
<p>通过锚点偏移量的<code>rollforward</code>和<code>rollback</code>方法，可明确地将日期向前或向后“滚动”：</p>
<pre><code class="language-python">offset = MonthEnd()
offset.rollforward(now)
Timestamp('2011-11-30 00:00:00')
offset.rollback(now)
Timestamp('2011-10-31 00:00:00')
</code></pre>
<p>日期偏移量还有一个巧妙的用法，即结合<code>groupby</code>使用这两个“滚动”方法：</p>
<pre><code class="language-python">ts = pd.Series(np.random.randn(20),index=pd.date_range('1/15/2000', periods=20, freq='4d'))
ts
2000-01-15   -0.116696
2000-01-19    2.389645
2000-01-23   -0.932454
2000-01-27   -0.229331
2000-01-31   -1.140330
2000-02-04    0.439920
2000-02-08   -0.823758
2000-02-12   -0.520930
2000-02-16    0.350282
2000-02-20    0.204395
2000-02-24    0.133445
2000-02-28    0.327905
2000-03-03    0.072153
2000-03-07    0.131678
2000-03-11   -1.297459
2000-03-15    0.997747
2000-03-19    0.870955
2000-03-23   -0.991253
2000-03-27    0.151699
2000-03-31    1.266151
Freq: 4D, dtype: float64
ts.groupby(offset.rollforward).mean()
2000-01-31   -0.005833
2000-02-29    0.015894
2000-03-31    0.150209
dtype: float64
</code></pre>
<p>当然，更简单、更快速地实现该功能的办法是使用<code>resample</code>：</p>
<pre><code class="language-python">ts.resample('M').mean()
2000-01-31   -0.005833
2000-02-29    0.015894
2000-03-31    0.150209
Freq: M, dtype: float64
</code></pre>
<h3 id="时期及其算术运算">时期及其算术运算</h3>
<p>时期（<code>period</code>）表示的是时间区间，比如数日、数月、数季、数年等。<code>Period</code>类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及频率：</p>
<pre><code class="language-python">p = pd.Period(2007, freq='A-DEC')
p
Period('2007', 'A-DEC')
</code></pre>
<p>这里，这个<code>Period</code>对象表示的是从2007年1月1日到2007年12月31日之间的整段时间。只需对<code>Period</code>对象加上或减去一个整数即可达到根据其频率进行位移的效果：</p>
<pre><code class="language-python">p + 5
Period('2012', 'A-DEC')
p - 2
Period('2005', 'A-DEC')
</code></pre>
<p>如果两个<code>Period</code>对象拥有相同的频率，则它们的差就是它们之间的单位数量：</p>
<pre><code class="language-python">pd.Period('2014', freq='A-DEC') - p
7
</code></pre>
<p><code>period_range</code>函数可用于创建规则的时期范围：</p>
<pre><code class="language-python">rng = pd.period_range('2000-01-01', '2000-06-30', freq='M')
rng
PeriodIndex(['2000-01', '2000-02', '2000-03', '2000-04', '2000-05', '20
00-06'], dtype='period[M]', freq='M')
</code></pre>
<p><code>PeriodIndex</code>类保存了一组<code>Period</code>，它可以在任何<code>pandas</code>数据结构中被用作轴索引：</p>
<pre><code class="language-python">pd.Series(np.random.randn(6), index=rng)
2000-01   -0.514551
2000-02   -0.559782
2000-03   -0.783408
2000-04   -1.797685
2000-05   -0.172670
2000-06    0.680215
Freq: M, dtype: float64
</code></pre>
<p>如果你有一个字符串数组，你也可以使用<code>PeriodIndex</code>类：</p>
<pre><code class="language-python">values = ['2001Q3', '2002Q2', '2003Q1']
index = pd.PeriodIndex(values, freq='Q-DEC')
index
PeriodIndex(['2001Q3', '2002Q2', '2003Q1'], dtype='period[Q-DEC]', freq
='Q-DEC')
</code></pre>
<h4 id="时期的频率转换">时期的频率转换</h4>
<p><code>Period</code>和<code>PeriodIndex</code>对象都可以通过其<code>asfreq</code>方法被转换成别的频率。假设我们有一个年度时期，希望将其转换为当年年初或年末的一个月度时期。该任务非常简单：</p>
<pre><code class="language-python">p = pd.Period('2007', freq='A-DEC')
p
Period('2007', 'A-DEC')
p.asfreq('M', how='start')
Period('2007-01', 'M')
p.asfreq('M', how='end')
Period('2007-12', 'M')
</code></pre>
<p>你可以将<code>Period('2007','A-DEC')</code>看做一个被划分为多个月度时期的时间段中的游标。对于一个不以12月结束的财政年度，月度子时期的归属情况就不一样了：</p>
<pre><code class="language-python">p = pd.Period('2007', freq='A-JUN')
p
Period('2007', 'A-JUN')
p.asfreq('M', 'start')
Period('2006-07', 'M')
p.asfreq('M', 'end')
Period('2007-06', 'M')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409021309.png" alt="" loading="lazy"><br>
在将高频率转换为低频率时，超时期（<code>superperiod</code>）是由子时期（<code>subperiod</code>）所属的位置决定的。例如，在<code>A-JUN</code>频率中，月份“2007年8月”实际上是属于周期“2008年”的：</p>
<pre><code class="language-python">p = pd.Period('Aug-2007', 'M')
p.asfreq('A-JUN')
Period('2008', 'A-JUN')
</code></pre>
<p>完整的<code>PeriodIndex</code>或<code>TimeSeries</code>的频率转换方式也是如此：</p>
<pre><code class="language-python">rng = pd.period_range('2006', '2009', freq='A-DEC')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
ts
2006    1.607578
2007    0.200381
2008   -0.834068
2009   -0.302988
Freq: A-DEC, dtype: float64
ts.asfreq('M', how='start')
2006-01    1.607578
2007-01    0.200381
2008-01   -0.834068
2009-01   -0.302988
Freq: M, dtype: float64
</code></pre>
<p>这里，根据年度时期的第一个月，每年的时期被取代为每月的时期。如果我们想要每年的最后一个工作日，我们可以使用“B”频率，并指明想要该时期的末尾：</p>
<pre><code class="language-python">ts.asfreq('B', how='end')

2006-12-29    1.607578
2007-12-31    0.200381
2008-12-31   -0.834068
2009-12-31   -0.302988
Freq: B, dtype: float64
</code></pre>
<h4 id="按季度计算的时期频率">按季度计算的时期频率</h4>
<p>季度型数据在会计、金融等领域中很常见。许多季度型数据都会涉及“财年末”的概念，通常是一年12个月中某月的最后一个日历日或工作日。就这一点来说，时期&quot;2012Q4&quot;根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC：</p>
<pre><code class="language-python">p = pd.Period('2012Q4', freq='Q-JAN')
p
Period('2012Q4', 'Q-JAN')
</code></pre>
<p>在以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）。</p>
<pre><code class="language-python">p.asfreq('D', 'start')
Period('2011-11-01', 'D')
p.asfreq('D', 'end')
Period('2012-01-31', 'D')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409021535.png" alt="" loading="lazy"><br>
因此，<code>Period</code>之间的算术运算会非常简单。例如，要获取该季度倒数第二个工作日下午4点的时间戳，你可以这样：</p>
<pre><code class="language-python">p4pm = (p.asfreq('B', 'e') - 1).asfreq('T', 's') + 16 * 60
p4pm
Period('2012-01-30 16:00', 'T')
p4pm.to_timestamp()
Timestamp('2012-01-30 16:00:00')
</code></pre>
<p><code>period_range</code>可用于生成季度型范围。季度型范围的算术运算也跟上面是一样的：</p>
<pre><code class="language-python">rng = pd.period_range('2011Q3', '2012Q4', freq='Q-JAN')
ts = pd.Series(np.arange(len(rng)), index=rng)
ts
2011Q3    0
2011Q4    1
2012Q1    2
2012Q2    3
2012Q3    4
2012Q4    5
Freq: Q-JAN, dtype: int64
new_rng = (rng.asfreq('B', 'e') - 1).asfreq('T', 's') + 16 * 60
ts.index = new_rng.to_timestamp()
ts
2010-10-28 16:00:00    0
2011-01-28 16:00:00    1
2011-04-28 16:00:00    2
2011-07-28 16:00:00    3
2011-10-28 16:00:00    4
2012-01-30 16:00:00    5
dtype: int64
</code></pre>
<h4 id="将timestamp转换为period及其反向过程">将<code>Timestamp</code>转换为<code>Period</code>（及其反向过程）</h4>
<p>通过使用<code>to_period</code>方法，可以将由时间戳索引的<code>Series</code>和<code>DataFrame</code>对象转换为以时期索引：</p>
<pre><code class="language-python">rng = pd.date_range('2000-01-01', periods=3, freq='M')
ts = pd.Series(np.random.randn(3), index=rng)
ts
2000-01-31    1.663261
2000-02-29   -0.996206
2000-03-31    1.521760
Freq: M, dtype: float64
pts = ts.to_period()
pts
2000-01    1.663261
2000-02   -0.996206
2000-03    1.521760
Freq: M, dtype: float64
</code></pre>
<p>由于时期指的是非重叠时间区间，因此对于给定的频率，一个时间戳只能属于一个时期。新<code>PeriodIndex</code>的频率默认是从时间戳推断而来的，你也可以指定任何别的频率。结果中允许存在重复时期：</p>
<pre><code class="language-python">rng = pd.date_range('1/29/2000', periods=6, freq='D')
ts2 = pd.Series(np.random.randn(6), index=rng)
ts2
2000-01-29    0.244175
2000-01-30    0.423331
2000-01-31   -0.654040
2000-02-01    2.089154
2000-02-02   -0.060220
2000-02-03   -0.167933
Freq: D, dtype: float64
ts2.to_period('M')
2000-01    0.244175
2000-01    0.423331
2000-01   -0.654040
2000-02    2.089154
2000-02   -0.060220
2000-02   -0.167933
Freq: M, dtype: float64
</code></pre>
<p>要转换回时间戳，使用<code>to_timestamp</code>即可：</p>
<pre><code class="language-python">pts = ts2.to_period()
pts
2000-01-29    0.244175
2000-01-30    0.423331
2000-01-31   -0.654040
2000-02-01    2.089154
2000-02-02   -0.060220
2000-02-03   -0.167933
Freq: D, dtype: float64
pts.to_timestamp(how='end')
2000-01-29    0.244175
2000-01-30    0.423331
2000-01-31   -0.654040
2000-02-01    2.089154
2000-02-02   -0.060220
2000-02-03   -0.167933
Freq: D, dtype: float64
</code></pre>
<h4 id="通过数组创建periodindex">通过数组创建<code>PeriodIndex</code></h4>
<p>固定频率的数据集通常会将时间信息分开存放在多个列中。例如，在下面这个宏观经济数据集中，年度和季度就分别存放在不同的列中：</p>
<pre><code class="language-python">data = pd.read_csv('examples/macrodata.csv')
data.head(5)
     year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \
0  1959.0      1.0  2710.349    1707.4  286.898   470.045   1886.9  28.98   
1  1959.0      2.0  2778.801    1733.7  310.859   481.301   1919.7  29.15   
2  1959.0      3.0  2775.488    1751.8  289.226   491.260   1916.4  29.35   
3  1959.0      4.0  2785.204    1753.7  299.356   484.052   1931.3  29.37   
4  1960.0      1.0  2847.699    1770.5  331.722   462.199   1955.5  29.54   
      m1  tbilrate  unemp      pop  infl  realint  
0  139.7      2.82    5.8  177.146  0.00     0.00  
1  141.7      3.08    5.1  177.830  2.34     0.74  
2  140.5      3.82    5.3  178.657  2.74     1.09  
3  140.0      4.33    5.6  179.386  0.27     4.06  
4  139.6      3.50    5.2  180.007  2.31     1.19  
data.year
0      1959.0
1      1959.0
2      1959.0
3      1959.0
4      1960.0
5      1960.0
6      1960.0
7      1960.0
8      1961.0
9      1961.0
        ...  
193    2007.0
194    2007.0
195    2007.0
196    2008.0
197    2008.0
198    2008.0
199    2008.0
200    2009.0
201    2009.0
202    2009.0
Name: year, Length: 203, dtype: float64
data.quarter
0      1.0
1      2.0
2      3.0
3      4.0
4      1.0
5      2.0
6      3.0
7      4.0
8      1.0
9      2.0
      ... 
193    2.0
194    3.0
195    4.0
196    1.0
197    2.0
198    3.0
199    4.0
200    1.0
201    2.0
202    3.0
Name: quarter, Length: 203, dtype: float64
</code></pre>
<p>通过将这些数组以及一个频率传入<code>PeriodIndex</code>，就可以将它们合并成<code>DataFrame</code>的一个索引：</p>
<pre><code class="language-python">index = pd.PeriodIndex(year=data.year, quarter=data.quarter,freq='Q-DEC')
index
PeriodIndex(['1959Q1', '1959Q2', '1959Q3', '1959Q4', '1960Q1', '1960Q2',
             '1960Q3', '1960Q4', '1961Q1', '1961Q2',
             ...
             '2007Q2', '2007Q3', '2007Q4', '2008Q1', '2008Q2', '2008Q3',
             '2008Q4', '2009Q1', '2009Q2', '2009Q3'],
            dtype='period[Q-DEC]', length=203, freq='Q-DEC')
data.index = index
data.infl
1959Q1    0.00
1959Q2    2.34
1959Q3    2.74
1959Q4    0.27
1960Q1    2.31
1960Q2    0.14
1960Q3    2.70
1960Q4    1.21
1961Q1   -0.40
1961Q2    1.47
          ... 
2007Q2    2.75
2007Q3    3.45
2007Q4    6.38
2008Q1    2.82
2008Q2    8.53
2008Q3   -3.16
2008Q4   -8.79
2009Q1    0.94
2009Q2    3.37
2009Q3    3.56
Freq: Q-DEC, Name: infl, Length: 203, dtype: float64
</code></pre>
<h3 id="重采样及频率转换">重采样及频率转换</h3>
<p>重采样（<code>resampling</code>）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（<code>downsampling</code>），而将低频率数据转换到高频率则称为升采样（<code>upsampling</code>）。并不是所有的重采样都能被划分到这两个大类中。例如，将<code>W-WED</code>（每周三）转换为<code>W-FRI</code>既不是降采样也不是升采样。</p>
<p><code>pandas</code>对象都带有一个<code>resample</code>方法，它是各种频率转换工作的主力函数。<code>resample</code>有一个类似于<code>groupby</code>的<code>API</code>，调用<code>resample</code>可以分组数据，然后会调用一个聚合函数：</p>
<pre><code class="language-python">rng = pd.date_range('2000-01-01', periods=100, freq='D')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
ts
2000-01-01    0.631634
2000-01-02   -1.594313
2000-01-03   -1.519937
2000-01-04    1.108752
2000-01-05    1.255853
2000-01-06   -0.024330
2000-01-07   -2.047939
2000-01-08   -0.272657
2000-01-09   -1.692615
2000-01-10    1.423830
                ...   
2000-03-31   -0.007852
2000-04-01   -1.638806
2000-04-02    1.401227
2000-04-03    1.758539
2000-04-04    0.628932
2000-04-05   -0.423776
2000-04-06    0.789740
2000-04-07    0.937568
2000-04-08   -2.253294
2000-04-09   -1.772919
Freq: D, Length: 100, dtype: float64
ts.resample('M').mean()
2000-01-31   -0.165893
2000-02-29    0.078606
2000-03-31    0.223811
2000-04-30   -0.063643
Freq: M, dtype: float64
ts.resample('M', kind='period').mean()
2000-01   -0.165893
2000-02    0.078606
2000-03    0.223811
2000-04   -0.063643
Freq: M, dtype: float64
</code></pre>
<p><code>resample</code>是一个灵活高效的方法，可用于处理非常大的时间序列。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409153339.png" alt="" loading="lazy"></p>
<h3 id="降采样">降采样</h3>
<p>将数据聚合到规律的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（<code>'M'</code>或<code>'BM'</code>），数据需要被划分到多个单月时间段中。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用<code>resample</code>对数据进行降采样时，需要考虑两样东西：</p>
<ul>
<li>各区间哪边是闭合的。</li>
<li>如何标记各个聚合面元，用区间的开头还是末尾。<br>
为了说明，我们来看一些“1分钟”数据：</li>
</ul>
<pre><code class="language-python">rng = pd.date_range('2000-01-01', periods=12, freq='T')
ts = pd.Series(np.arange(12), index=rng)
ts
2000-01-01 00:00:00     0
2000-01-01 00:01:00     1
2000-01-01 00:02:00     2
2000-01-01 00:03:00     3
2000-01-01 00:04:00     4
2000-01-01 00:05:00     5
2000-01-01 00:06:00     6
2000-01-01 00:07:00     7
2000-01-01 00:08:00     8
2000-01-01 00:09:00     9
2000-01-01 00:10:00    10
2000-01-01 00:11:00    11
Freq: T, dtype: int64
</code></pre>
<p>假设你想要通过求和的方式将这些数据聚合到“5分钟”块中：</p>
<pre><code class="language-python">ts.resample('5min', closed='right').sum()
1999-12-31 23:55:00     0
2000-01-01 00:00:00    15
2000-01-01 00:05:00    40
2000-01-01 00:10:00    11
Freq: 5T, dtype: int64
</code></pre>
<p>传入的频率将会以“5分钟”的增量定义面元边界。默认情况下，面元的右边界是包含的，因此<code>00:00</code>到<code>00:05</code>的区间中是包含<code>00:05</code>的。传入<code>closed='left'</code>会让区间以左边界闭合：</p>
<pre><code class="language-python">ts.resample('5min', closed='right').sum()
1999-12-31 23:55:00     0
2000-01-01 00:00:00    15
2000-01-01 00:05:00    40
2000-01-01 00:10:00    11
Freq: 5T, dtype: int64
</code></pre>
<p>如你所见，最终的时间序列是以各面元右边界的时间戳进行标记的。传入<code>label='right'</code>即可用面元的邮编界对其进行标记：</p>
<pre><code class="language-python">ts.resample('5min', closed='right', label='right').sum()
2000-01-01 00:00:00     0
2000-01-01 00:05:00    15
2000-01-01 00:10:00    40
2000-01-01 00:15:00    11
Freq: 5T, dtype: int64
</code></pre>
<p>下图说明了“1分钟”数据被转换为“5分钟”数据的处理过程。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409154029.png" alt="" loading="lazy"><br>
最后，你可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过<code>loffset</code>设置一个字符串或日期偏移量即可实现这个目的：</p>
<pre><code class="language-python">ts.resample('5min', closed='right',label='right', loffset='-1s').sum()
1999-12-31 23:59:59     0
2000-01-01 00:04:59    15
ts.resample('5min', closed='right',label='right', loffset='-1s').sum()
1999-12-31 23:59:59     0
2000-01-01 00:04:59    15
</code></pre>
<p>此外，也可以通过调用结果对象的<code>shift</code>方法来实现该目的，这样就不需要设置<code>loffset</code>了。</p>
<h3 id="ohlc重采样">OHLC重采样</h3>
<p>金融领域中有一种无所不在的时间序列聚合方式，即计算各面元的四个值：第一个值（<code>open</code>，开盘）、最后一个值（<code>close</code>，收盘）、最大值（<code>high</code>，最高）以及最小值（<code>low</code>，最低）。传入<code>how='ohlc'</code>即可得到一个含有这四种聚合值的<code>DataFrame</code>。整个过程很高效，只需一次扫描即可计算出结果：</p>
<pre><code class="language-python">ts.resample('5min').ohlc()
                     open  high  low  close
2000-01-01 00:00:00     0     4    0      4
2000-01-01 00:05:00     5     9    5      9
2000-01-01 00:10:00    10    11   10     11
</code></pre>
<h3 id="升采样和插值">升采样和插值</h3>
<p>在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的<code>DataFrame</code>：</p>
<pre><code class="language-python">frame = pd.DataFrame(np.random.randn(2, 4),index=pd.date_range('1/1/2000', periods=2,freq='W-WED'),columns=['Colorado', 'Texas', 'New York', 'Ohio'])
frame
            Colorado     Texas  New York      Ohio
2000-01-05 -0.896431  0.677263  0.036503  0.087102
2000-01-12 -0.046662  0.927238  0.482284 -0.867130
</code></pre>
<p>当你对这个数据进行聚合，每组只有一个值，这样就会引入缺失值。我们使用<code>asfreq</code>方法转换成高频，不经过聚合：</p>
<pre><code class="language-python">df_daily = frame.resample('D').asfreq()
df_daily
            Colorado     Texas  New York      Ohio
2000-01-05 -0.896431  0.677263  0.036503  0.087102
2000-01-06       NaN       NaN       NaN       NaN
2000-01-07       NaN       NaN       NaN       NaN
2000-01-08       NaN       NaN       NaN       NaN
2000-01-09       NaN       NaN       NaN       NaN
2000-01-10       NaN       NaN       NaN       NaN
2000-01-11       NaN       NaN       NaN       NaN
2000-01-12 -0.046662  0.927238  0.482284 -0.867130
</code></pre>
<p>假设你想要用前面的周型值填充“非星期三”。<code>resampling</code>的填充和插值方式跟<code>fillna</code>和<code>reindex</code>的一样：</p>
<pre><code class="language-python">frame.resample('D').ffill()
            Colorado     Texas  New York      Ohio
2000-01-05 -0.896431  0.677263  0.036503  0.087102
2000-01-06 -0.896431  0.677263  0.036503  0.087102
2000-01-07 -0.896431  0.677263  0.036503  0.087102
2000-01-08 -0.896431  0.677263  0.036503  0.087102
2000-01-09 -0.896431  0.677263  0.036503  0.087102
2000-01-10 -0.896431  0.677263  0.036503  0.087102
2000-01-11 -0.896431  0.677263  0.036503  0.087102
2000-01-12 -0.046662  0.927238  0.482284 -0.867130
</code></pre>
<p>同样，这里也可以只填充指定的时期数（目的是限制前面的观测值的持续使用距离）：</p>
<pre><code class="language-python">frame.resample('D').ffill(limit=2)
            Colorado     Texas  New York      Ohio
2000-01-05 -0.896431  0.677263  0.036503  0.087102
2000-01-06 -0.896431  0.677263  0.036503  0.087102
2000-01-07 -0.896431  0.677263  0.036503  0.087102
2000-01-08       NaN       NaN       NaN       NaN
2000-01-09       NaN       NaN       NaN       NaN
2000-01-10       NaN       NaN       NaN       NaN
2000-01-11       NaN       NaN       NaN       NaN
2000-01-12 -0.046662  0.927238  0.482284 -0.867130
</code></pre>
<p>注意，新的日期索引完全没必要跟旧的重叠：</p>
<pre><code class="language-python">frame.resample('W-THU').ffill()
            Colorado     Texas  New York      Ohio
2000-01-06 -0.896431  0.677263  0.036503  0.087102
2000-01-13 -0.046662  0.927238  0.482284 -0.867130
</code></pre>
<h3 id="通过时期进行重采样">通过时期进行重采样</h3>
<p>对那些使用时期索引的数据进行重采样与时间戳很像：</p>
<pre><code class="language-python">frame = pd.DataFrame(np.random.randn(24, 4),index=pd.period_range('1-2000', '12-2001',freq='M'),columns=['Colorado', 'Texas', 'New York', 'Ohio'])
frame[:5]
         Colorado     Texas  New York      Ohio
2000-01  0.493841 -0.155434  1.397286  1.507055
2000-02 -1.179442  0.443171  1.395676 -0.529658
2000-03  0.787358  0.248845  0.743239  1.267746
2000-04  1.302395 -0.272154 -0.051532 -0.467740
2000-05 -1.040816  0.426419  0.312945 -1.115689
annual_frame = frame.resample('A-DEC').mean()
annual_frame
      Colorado     Texas  New York      Ohio
2000  0.556703  0.016631  0.111873 -0.027445
2001  0.046303  0.163344  0.251503 -0.157276
</code></pre>
<p>升采样要稍微麻烦一些，因为你必须决定在新频率中各区间的哪端用于放置原来的值，就像<code>asfreq</code>方法那样。<code>convention</code>参数默认为<code>'start'</code>，也可设置为<code>'end'</code>：</p>
<pre><code class="language-python">#Q-DEC: Quarterly, year ending in December
annual_frame.resample('Q-DEC').ffill()
        Colorado     Texas  New York      Ohio
2000Q1  0.556703  0.016631  0.111873 -0.027445
2000Q2  0.556703  0.016631  0.111873 -0.027445
2000Q3  0.556703  0.016631  0.111873 -0.027445
2000Q4  0.556703  0.016631  0.111873 -0.027445
2001Q1  0.046303  0.163344  0.251503 -0.157276
2001Q2  0.046303  0.163344  0.251503 -0.157276
2001Q3  0.046303  0.163344  0.251503 -0.157276
2001Q4  0.046303  0.163344  0.251503 -0.157276
annual_frame.resample('Q-DEC', convention='end').ffill()
        Colorado     Texas  New York      Ohio
2000Q4  0.556703  0.016631  0.111873 -0.027445
2001Q1  0.556703  0.016631  0.111873 -0.027445
2001Q2  0.556703  0.016631  0.111873 -0.027445
2001Q3  0.556703  0.016631  0.111873 -0.027445
2001Q4  0.046303  0.163344  0.251503 -0.157276
</code></pre>
<p>由于时期指的是时间区间，所以升采样和降采样的规则就比较严格：</p>
<ul>
<li>在降采样中，目标频率必须是源频率的子时期（<code>subperiod</code>）。</li>
<li>在升采样中，目标频率必须是源频率的超时期（<code>superperiod</code>）。<br>
如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由<code>Q-MAR</code>定义的时间区间只能升采样为<code>A-MAR</code>、<code>A-JUN</code>、<code>A-SEP</code>、<code>A-DEC</code>等：</li>
</ul>
<pre><code class="language-python">annual_frame.resample('Q-MAR').ffill()
        Colorado     Texas  New York      Ohio
2000Q4  0.556703  0.016631  0.111873 -0.027445
2001Q1  0.556703  0.016631  0.111873 -0.027445
2001Q2  0.556703  0.016631  0.111873 -0.027445
2001Q3  0.556703  0.016631  0.111873 -0.027445
2001Q4  0.046303  0.163344  0.251503 -0.157276
2002Q1  0.046303  0.163344  0.251503 -0.157276
2002Q2  0.046303  0.163344  0.251503 -0.157276
2002Q3  0.046303  0.163344  0.251503 -0.157276
</code></pre>
<h3 id="移动窗口函数">移动窗口函数</h3>
<p>在移动窗口（可以带有指数衰减权数）上计算的各种统计函数也是一类常见于时间序列的数组变换。这样可以圆滑噪音数据或断裂数据。我将它们称为移动窗口函数（<code>moving window function</code>），其中还包括那些窗口不定长的函数（如指数加权移动平均）。跟其他统计函数一样，移动窗口函数也会自动排除缺失值。</p>
<p>开始之前，我们加载一些时间序列数据，将其重采样为工作日频率：</p>
<pre><code class="language-python">close_px_all = pd.read_csv('examples/stock_px_2.csv',parse_dates=True, index_col=0)
close_px = close_px_all[['AAPL', 'MSFT', 'XOM']]
close_px = close_px.resample('B').ffill()
</code></pre>
<p>现在引入<code>rolling</code>运算符，它与<code>resample</code>和<code>groupby</code>很像。可以在<code>TimeSeries</code>或<code>DataFrame</code>以及一个<code>window</code>（表示期数，见下图）上调用它：</p>
<pre><code class="language-python">close_px.AAPL.plot()
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f2f2570cf98&gt;
close_px.AAPL.rolling(250).mean().plot()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409160131.png" alt="" loading="lazy"><br>
表达式<code>rolling(250)</code>与<code>groupby</code>很像，但不是对其进行分组，而是创建一个按照250天分组的滑动窗口对象。然后，我们就得到了苹果公司股价的250天的移动窗口。</p>
<p>默认情况下，<code>rolling</code>函数需要窗口中所有的值为非<code>NA</code>值。可以修改该行为以解决缺失数据的问题。其实，在时间序列开始处尚不足窗口期的那些数据就是个特例（见下图）：</p>
<pre><code class="language-python">appl_std250 = close_px.AAPL.rolling(250, min_periods=10).std()
appl_std250[5:12]
2003-01-09         NaN
2003-01-10         NaN
2003-01-13         NaN
2003-01-14         NaN
2003-01-15    0.077496
2003-01-16    0.074760
2003-01-17    0.112368
Freq: B, Name: AAPL, dtype: float64
appl_std250.plot()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409160625.png" alt="" loading="lazy"><br>
要计算扩展窗口平均（<code>expanding window mean</code>），可以使用<code>expanding</code>而不是<code>rolling</code>。“扩展”意味着，从时间序列的起始处开始窗口，增加窗口直到它超过所有的序列。<code>apple_std250</code>时间序列的扩展窗口平均如下所示：</p>
<pre><code class="language-python">expanding_mean = appl_std250.expanding().mean()
</code></pre>
<p>对<code>DataFrame</code>调用<code>rolling_mean</code>（以及与之类似的函数）会将转换应用到所有的列上（见下图）：</p>
<pre><code class="language-python">close_px.rolling(60).mean().plot(logy=True)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409160801.png" alt="" loading="lazy"><br>
<code>rolling</code>函数也可以接受一个指定固定大小时间补偿字符串，而不是一组时期。这样可以方便处理不规律的时间序列。这些字符串也可以传递给<code>resample</code>。例如，我们可以计算20天的滚动均值，如下所示：</p>
<pre><code class="language-python">close_px.rolling('20D').mean()
                  AAPL       MSFT        XOM
2003-01-02    7.400000  21.110000  29.220000
2003-01-03    7.425000  21.125000  29.230000
2003-01-06    7.433333  21.256667  29.473333
2003-01-07    7.432500  21.425000  29.342500
2003-01-08    7.402000  21.402000  29.240000
2003-01-09    7.391667  21.490000  29.273333
2003-01-10    7.387143  21.558571  29.238571
2003-01-13    7.378750  21.633750  29.197500
2003-01-14    7.370000  21.717778  29.194444
2003-01-15    7.355000  21.757000  29.152000
...                ...        ...        ...
2011-10-03  398.002143  25.890714  72.413571
2011-10-04  396.802143  25.807857  72.427143
2011-10-05  395.751429  25.729286  72.422857
2011-10-06  394.099286  25.673571  72.375714
2011-10-07  392.479333  25.712000  72.454667
2011-10-10  389.351429  25.602143  72.527857
2011-10-11  388.505000  25.674286  72.835000
2011-10-12  388.531429  25.810000  73.400714
2011-10-13  388.826429  25.961429  73.905000
2011-10-14  391.038000  26.048667  74.185333
[2292 rows x 3 columns]
</code></pre>
<h4 id="指数加权函数">指数加权函数</h4>
<p>另一种使用固定大小窗口及相等权数观测值的办法是，定义一个衰减因子（<code>decay factor</code>）常量，以便使近期的观测值拥有更大的权数。衰减因子的定义方式有很多，比较流行的是使用时间间隔（<code>span</code>），它可以使结果兼容于窗口大小等于时间间隔的简单移动窗口（<code>simple moving window</code>）函数。</p>
<p>由于指数加权统计会赋予近期的观测值更大的权数，因此相对于等权统计，它能“适应”更快的变化。</p>
<p>除了<code>rolling</code>和<code>expanding</code>，<code>pandas</code>还有<code>ewm</code>运算符。下面这个例子对比了苹果公司股价的30日移动平均和span=30的指数加权移动平均（如下图所示）：</p>
<pre><code class="language-python">aapl_px = close_px.AAPL['2006':'2007']
ma60 = aapl_px.rolling(30, min_periods=20).mean()
ewma60 = aapl_px.ewm(span=30).mean()
ma60.plot(style='k--', label='Simple MA')
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f2f252161d0&gt;
ewma60.plot(style='k-', label='EW MA')
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f2f252161d0&gt;
plt.legend()
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409161314.png" alt="" loading="lazy"></figure>
<h4 id="二元移动窗口函数">二元移动窗口函数</h4>
<p>有些统计运算（如相关系数和协方差）需要在两个时间序列上执行。例如，金融分析师常常对某只股票对某个参考指数（如标准普尔500指数）的相关系数感兴趣。要进行说明，我们先计算我们感兴趣的时间序列的百分数变化：</p>
<pre><code class="language-python">spx_px = close_px_all['SPX']
spx_rets = spx_px.pct_change()

returns = close_px.pct_change()
</code></pre>
<p>调用<code>rolling</code>之后，<code>corr</code>聚合函数开始计算与<code>spx_rets</code>滚动相关系数（结果见下图）：</p>
<pre><code class="language-python">corr = returns.AAPL.rolling(125, min_periods=100).corr(spx_rets)
corr.plot() 
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409161446.png" alt="" loading="lazy"><br>
假设你想要一次性计算多只股票与标准普尔500指数的相关系数。虽然编写一个循环并新建一个<code>DataFrame</code>不是什么难事，但比较啰嗦。其实，只需传入一个<code>TimeSeries</code>和一个<code>DataFrame</code>，<code>rolling_corr</code>就会自动计算<code>TimeSeries</code>（本例中就是<code>spx_rets</code>）与<code>DataFrame</code>各列的相关系数。结果如图11-9所示：</p>
<pre><code class="language-python">corr = returns.rolling(125, min_periods=100).corr(spx_rets)
corr.plot()
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409161600.png" alt="" loading="lazy"></figure>
<h4 id="用户定义的移动窗口函数">用户定义的移动窗口函数</h4>
<p><code>rolling_apply</code>函数使你能够在移动窗口上应用自己设计的数组函数。唯一要求的就是：该函数要能从数组的各个片段中产生单个值（即约简）。比如说，当我们用<code>rolling(...).quantile(q)</code>计算样本分位数时，可能对样本中特定值的百分等级感兴趣。<code>scipy.stats.percentileofscore</code>函数就能达到这个目的（结果见下图）：</p>
<pre><code class="language-python">from scipy.stats import percentileofscore
score_at_2percent = lambda x: percentileofscore(x, 0.02)
result = returns.AAPL.rolling(250).apply(score_at_2percent)
result.plot()
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409161913.png" alt="" loading="lazy"></figure>
<h2 id="pandas高级应用"><code>pandas</code>高级应用</h2>
<h3 id="分类数据">分类数据</h3>
<p>表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了<code>unique</code>和<code>value_counts</code>，它们可以从数组提取出不同的值，并分别计算频率：</p>
<pre><code class="language-python">import numpy as np; import pandas as pd
values = pd.Series(['apple', 'orange', 'apple','apple'] * 2)
values
0     apple
1    orange
2     apple
3     apple
4     apple
5    orange
6     apple
7     apple
dtype: object
pd.unique(values)
array(['apple', 'orange'], dtype=object)
pd.value_counts(values)
apple     6
orange    2
dtype: int64
</code></pre>
<p>许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值的维表(<code>Dimension Table</code>)，将主要的参数存储为引用维表整数键：</p>
<pre><code class="language-python">values = pd.Series([0, 1, 0, 0] * 2)
dim = pd.Series(['apple', 'orange'])
values
0    0
1    1
2    0
3    0
4    0
5    1
6    0
7    0
dtype: int64
dim
0     apple
1    orange
dtype: object
</code></pre>
<p>可以使用<code>take</code>方法存储原始的字符串<code>Series</code>：</p>
<pre><code class="language-python">dim.take(values)
0     apple
1    orange
0     apple
0     apple
0     apple
1    orange
0     apple
0     apple
dtype: object
</code></pre>
<p>这种用整数表示的方法称为分类或字典编码表示法。不同值得数组称为分类、字典或数据级。本书中，我们使用分类的说法。表示分类的整数值称为分类编码或简单地称为编码。</p>
<p>分类表示可以在进行分析时大大的提高性能。你也可以在保持编码不变的情况下，对分类进行转换。一些相对简单的转变例子包括：</p>
<ul>
<li>重命名分类。</li>
<li>加入一个新的分类，不改变已经存在的分类的顺序或位置。</li>
</ul>
<h4 id="pandas的分类类型"><code>pandas</code>的分类类型</h4>
<p><code>pandas</code>有一个特殊的分类类型，用于保存使用整数分类表示法的数据。看一个之前的<code>Series</code>例子：</p>
<pre><code class="language-python">fruits = ['apple', 'orange', 'apple', 'apple'] * 2
N = len(fruits)
df = pd.DataFrame({'fruit': fruits,'basket_id': np.arange(N),'count': np.random.randint(3, 15, size=N),'weight': np.random.uniform(0, 4, size=N)},columns=['basket_id', 'fruit', 'count', 'weight'])
df
   basket_id   fruit  count    weight
0          0   apple      5  3.858058
1          1  orange      8  2.612708
2          2   apple      4  2.995627
3          3   apple      7  2.614279
4          4   apple     12  2.990859
5          5  orange      8  3.845227
6          6   apple      5  0.033553
7          7   apple      4  0.425778
</code></pre>
<p>这里，<code>df['fruit']</code>是一个Python字符串对象的数组。我们可以通过调用它，将它转变为分类：</p>
<pre><code class="language-python">fruit_cat = df['fruit'].astype('category')
fruit_cat
0     apple
1    orange
2     apple
3     apple
4     apple
5    orange
6     apple
7     apple
Name: fruit, dtype: category
Categories (2, object): [apple, orange]
</code></pre>
<p><code>fruit_cat</code>的值不是<code>NumPy</code>数组，而是一个<code>pandas.Categorical</code>实例：</p>
<pre><code class="language-python">c = fruit_cat.values
type(c)
pandas.core.categorical.Categorical
</code></pre>
<p>分类对象有<code>categories</code>和<code>codes</code>属性：</p>
<pre><code class="language-python">c.categories
Index(['apple', 'orange'], dtype='object')
c.codes
array([0, 1, 0, 0, 0, 1, 0, 0], dtype=int8)
</code></pre>
<p>你可将<code>DataFrame</code>的列通过分配转换结果，转换为分类：</p>
<pre><code class="language-python">df['fruit'] = df['fruit'].astype('category')
df.fruit
0     apple
1    orange
2     apple
3     apple
4     apple
5    orange
6     apple
7     apple
Name: fruit, dtype: category
Categories (2, object): [apple, orange]
</code></pre>
<p>你还可以从其它<code>Python</code>序列直接创建<code>pandas.Categorical</code>：</p>
<pre><code class="language-python">my_categories = pd.Categorical(['foo', 'bar', 'baz', 'foo', 'bar'])
my_categories
[foo, bar, baz, foo, bar]
Categories (3, object): [bar, baz, foo]
</code></pre>
<p>如果你已经从其它源获得了分类编码，你还可以使用<code>from_codes</code>构造器：</p>
<pre><code class="language-python">categories = ['foo', 'bar', 'baz']
codes = [0, 1, 2, 0, 0, 1]
my_cats_2 = pd.Categorical.from_codes(codes, categories)
my_cats_2
[foo, bar, baz, foo, foo, bar]
Categories (3, object): [foo, bar, baz]
</code></pre>
<p>与显示指定不同，分类变换不认定指定的分类顺序。因此取决于输入数据的顺序，<code>categories</code>数组的顺序会不同。当使用<code>from_codes</code>或其它的构造器时，你可以指定分类一个有意义的顺序：</p>
<pre><code class="language-python">ordered_cat = pd.Categorical.from_codes(codes, categories,ordered=True)
ordered_cat
[foo, bar, baz, foo, foo, bar]
Categories (3, object): [foo &lt; bar &lt; baz]
</code></pre>
<p>输出<code>[foo &lt; bar &lt; baz]</code>指明<code>‘foo’</code>位于<code>‘bar’</code>的前面，以此类推。无序的分类实例可以通过<code>as_ordered</code>排序：</p>
<pre><code class="language-python">my_cats_2.as_ordered()
[foo, bar, baz, foo, foo, bar]
Categories (3, object): [foo &lt; bar &lt; baz]
</code></pre>
<p>最后要注意，分类数据不需要字符串，尽管我仅仅展示了字符串的例子。分类数组可以包括任意不可变类型。</p>
<h4 id="用分类进行计算">用分类进行计算</h4>
<p>与非编码版本（比如字符串数组）相比，使用<code>pandas</code>的<code>Categorical</code>有些类似。某些<code>pandas</code>组件，比如<code>groupby</code>函数，更适合进行分类。还有一些函数可以使用有序标志位。</p>
<p>来看一些随机的数值数据，使用<code>pandas.qcut</code>面元函数。它会返回<code>pandas.Categorical</code>，我们之前使用过<code>pandas.cut</code>，但没解释分类是如何工作的：</p>
<pre><code class="language-python">np.random.seed(12345)
draws = np.random.randn(1000)
draws[:5]
array([-0.2047,  0.4789, -0.5194, -0.5557,  1.9658])
</code></pre>
<p>计算这个数据的分位面元，提取一些统计信息：</p>
<pre><code class="language-python">bins = pd.qcut(draws, 4)
bins
[(-0.684, -0.0101], (-0.0101, 0.63], (-0.684, -0.0101], (-0.684, -0.0101], (0.63,
 3.928], ..., (-0.0101, 0.63], (-0.684, -0.0101], (-2.95, -0.684], (-0.0101, 0.63
], (0.63, 3.928]]
Length: 1000
Categories (4, interval[float64]): [(-2.95, -0.684] &lt; (-0.684, -0.0101] &lt; (-0.010
1, 0.63] &lt;(0.63, 3.928]]
</code></pre>
<p>虽然有用，确切的样本分位数与分位的名称相比，不利于生成汇总。我们可以使用<code>labels</code>参数<code>qcut</code>，实现目的：</p>
<pre><code class="language-python">bins = pd.qcut(draws, 4, labels=['Q1', 'Q2', 'Q3', 'Q4'])
bins
[Q2, Q3, Q2, Q2, Q4, ..., Q3, Q2, Q1, Q3, Q4]
Length: 1000
Categories (4, object): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]
bins.codes[:10]
array([1, 2, 1, 1, 3, 3, 2, 2, 3, 3], dtype=int8)
</code></pre>
<p>加上标签的面元分类不包含数据面元边界的信息，因此可以使用<code>groupby</code>提取一些汇总信息：</p>
<pre><code class="language-python">bins = pd.Series(bins, name='quartile')
results = (pd.Series(draws).groupby(bins).agg(['count', 'min', 'max']).reset_index())
results
  quartile  count       min       max
0       Q1    250 -2.949343 -0.685484
1       Q2    250 -0.683066 -0.010115
2       Q3    250 -0.010032  0.628894
3       Q4    250  0.634238  3.927528
</code></pre>
<p>分位数列保存了原始的面元分类信息，包括排序：</p>
<pre><code class="language-python">results['quartile']
0    Q1
1    Q2
2    Q3
3    Q4
Name: quartile, dtype: category
Categories (4, object): [Q1 &lt; Q2 &lt; Q3 &lt; Q4]
</code></pre>
<h4 id="用分类提高性能">用分类提高性能</h4>
<p>如果你是在一个特定数据集上做大量分析，将其转换为分类可以极大地提高效率。<code>DataFrame</code>列的分类使用的内存通常少的多。来看一些包含一千万元素的<code>Series</code>，和一些不同的分类：</p>
<pre><code class="language-python">N = 10000000
draws = pd.Series(np.random.randn(N))
labels = pd.Series(['foo', 'bar', 'baz', 'qux'] * (N // 4))
</code></pre>
<p>现在，将标签转换为分类：</p>
<pre><code class="language-python">categories = labels.astype('category')
</code></pre>
<p>这时，可以看到标签使用的内存远比分类多：</p>
<pre><code class="language-python">labels.memory_usage()
80000080
categories.memory_usage()
10000272
</code></pre>
<p>转换为分类不是没有代价的，但这是一次性的代价：</p>
<pre><code class="language-python">%time _ = labels.astype('category')
CPU times: user 490 ms, sys: 240 ms, total: 730 ms
Wall time: 726 ms
</code></pre>
<p><code>GroupBy</code>使用分类操作明显更快，是因为底层的算法使用整数编码数组，而不是字符串数组。</p>
<h4 id="分类方法">分类方法</h4>
<p>包含分类数据的<code>Series</code>有一些特殊的方法，类似于<code>Series.str</code>字符串方法。它还提供了方便的分类和编码的使用方法。看下面的<code>Series</code>：</p>
<pre><code class="language-python">s = pd.Series(['a', 'b', 'c', 'd'] * 2)
cat_s = s.astype('category')
cat_s
0    a
1    b
2    c
3    d
4    a
5    b
6    c
7    d
dtype: category
Categories (4, object): [a, b, c, d]
</code></pre>
<p>特别的<code>cat</code>属性提供了分类方法的入口：</p>
<pre><code class="language-python">cat_s.cat.codes
0    0
1    1
2    2
3    3
4    0
5    1
6    2
7    3
dtype: int8
cat_s.cat.categories
Index(['a', 'b', 'c', 'd'], dtype='object')
</code></pre>
<p>假设我们知道这个数据的实际分类集，超出了数据中的四个值。我们可以使用<code>set_categories</code>方法改变它们：</p>
<pre><code class="language-python">actual_categories = ['a', 'b', 'c', 'd', 'e']
cat_s2 = cat_s.cat.set_categories(actual_categories)
cat_s2
0    a
1    b
2    c
3    d
4    a
5    b
6    c
7    d
dtype: category
Categories (5, object): [a, b, c, d, e]
</code></pre>
<p>虽然数据看起来没变，新的分类将反映在它们的操作中。例如，如果有的话，<code>value_counts</code>表示分类：</p>
<pre><code class="language-python">cat_s.value_counts()
d    2
c    2
b    2
a    2
dtype: int64
cat_s2.value_counts()
d    2
c    2
b    2
a    2
e    0
dtype: int64
</code></pre>
<p>在大数据集中，分类经常作为节省内存和高性能的便捷工具。过滤完大<code>DataFrame</code>或<code>Series</code>之后，许多分类可能不会出现在数据中。我们可以使用<code>remove_unused_categories</code>方法删除没看到的分类：</p>
<pre><code class="language-python">cat_s3 = cat_s[cat_s.isin(['a', 'b'])]
cat_s3
0    a
1    b
4    a
5    b
dtype: category
Categories (4, object): [a, b, c, d]
cat_s3.cat.remove_unused_categories()
0    a
1    b
4    a
5    b
dtype: category
Categories (2, object): [a, b]
</code></pre>
<p>下表列出了可用的分类方法。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200409172600.png" alt="" loading="lazy"></p>
<h4 id="为建模创建虚拟变量">为建模创建虚拟变量</h4>
<p>当你使用统计或机器学习工具时，通常会将分类数据转换为虚拟变量，也称为<code>one-hot</code>编码。这包括创建一个不同类别的列的<code>DataFrame</code>；这些列包含给定分类的1s，其它为0。</p>
<p>看前面的例子：</p>
<pre><code class="language-python">cat_s = pd.Series(['a', 'b', 'c', 'd'] * 2, dtype='category')
</code></pre>
<p><code>pandas.get_dummies</code>函数可以转换这个分类数据为包含虚拟变量的<code>DataFrame</code>：</p>
<pre><code class="language-python">pd.get_dummies(cat_s)
   a  b  c  d
0  1  0  0  0
1  0  1  0  0
2  0  0  1  0
3  0  0  0  1
4  1  0  0  0
5  0  1  0  0
6  0  0  1  0
7  0  0  0  1
</code></pre>
<h3 id="groupby高级应用"><code>GroupBy</code>高级应用</h3>
<h4 id="分组转换和解封groupby">分组转换和“解封”<code>GroupBy</code></h4>
<p>我们在分组操作中学习了<code>apply</code>方法，进行转换。还有另一个<code>transform</code>方法，它与<code>apply</code>很像，但是对使用的函数有一定限制：</p>
<ul>
<li>它可以产生向分组形状广播标量值</li>
<li>它可以产生一个和输入组形状相同的对象</li>
<li>它不能修改输入<br>
来看一个简单的例子：</li>
</ul>
<pre><code class="language-python">df = pd.DataFrame({'key': ['a', 'b', 'c'] * 4,'value': np.arange(12.)})
df
   key  value
0    a    0.0
1    b    1.0
2    c    2.0
3    a    3.0
4    b    4.0
5    c    5.0
6    a    6.0
7    b    7.0
8    c    8.0
9    a    9.0
10   b   10.0
11   c   11.0
</code></pre>
<p>按键进行分组：</p>
<pre><code class="language-python">g = df.groupby('key').value
g.mean()
key
a    4.5
b    5.5
c    6.5
Name: value, dtype: float64
</code></pre>
<p>假设我们想产生一个和<code>df['value']</code>形状相同的<code>Series</code>，但值替换为按键分组的平均值。我们可以传递函数<code>lambda x: x.mean()</code>进行转换：</p>
<pre><code class="language-python">g.transform(lambda x: x.mean())
0     4.5
1     5.5
2     6.5
3     4.5
4     5.5
5     6.5
6     4.5
7     5.5
8     6.5
9     4.5
10    5.5
11    6.5
Name: value, dtype: float64
</code></pre>
<p>对于内置的聚合函数，我们可以传递一个字符串假名作为<code>GroupBy</code>的<code>agg</code>方法：</p>
<pre><code class="language-python">g.transform('mean')
0     4.5
1     5.5
2     6.5
3     4.5
4     5.5
5     6.5
6     4.5
7     5.5
8     6.5
9     4.5
10    5.5
11    6.5
Name: value, dtype: float64
</code></pre>
<p>与<code>apply</code>类似，<code>transform</code>的函数会返回<code>Series</code>，但是结果必须与输入大小相同。举个例子，我们可以用<code>lambda</code>函数将每个分组乘以2：</p>
<pre><code class="language-python">g.transform(lambda x: x * 2)
0      0.0
1      2.0
2      4.0
3      6.0
4      8.0
5     10.0
6     12.0
7     14.0
8     16.0
9     18.0
10    20.0
11    22.0
Name: value, dtype: float64
</code></pre>
<p>再举一个复杂的例子，我们可以计算每个分组的降序排名：</p>
<pre><code class="language-python">g.transform(lambda x: x.rank(ascending=False))
0     4.0
1     4.0
2     4.0
3     3.0
4     3.0
5     3.0
6     2.0
7     2.0
8     2.0
9     1.0
10    1.0
11    1.0
Name: value, dtype: float64
</code></pre>
<p>看一个由简单聚合构造的的分组转换函数：</p>
<pre><code class="language-python">def normalize(x):
    return (x - x.mean()) / x.std()
</code></pre>
<p>我们用<code>transform</code>或<code>apply</code>可以获得等价的结果：</p>
<pre><code class="language-python">g.transform(normalize)
0    -1.161895
1    -1.161895
2    -1.161895
3    -0.387298
4    -0.387298
5    -0.387298
6     0.387298
7     0.387298
8     0.387298
9     1.161895
10    1.161895
11    1.161895
Name: value, dtype: float64
g.apply(normalize)
0    -1.161895
1    -1.161895
2    -1.161895
3    -0.387298
4    -0.387298
5    -0.387298
6     0.387298
7     0.387298
8     0.387298
9     1.161895
10    1.161895
11    1.161895
Name: value, dtype: float64
</code></pre>
<p>内置的聚合函数，比如<code>mean</code>或<code>sum</code>，通常比<code>apply</code>函数快，也比<code>transform</code>快。这允许我们进行一个所谓的解封（<code>unwrapped</code>）分组操作：</p>
<pre><code class="language-python">g.transform('mean')
0     4.5
1     5.5
2     6.5
3     4.5
4     5.5
5     6.5
6     4.5
7     5.5
8     6.5
9     4.5
10    5.5
11    6.5
Name: value, dtype: float64
normalized = (df['value'] - g.transform('mean')) / g.transform('std')
normalized
0    -1.161895
1    -1.161895
2    -1.161895
3    -0.387298
4    -0.387298
5    -0.387298
6     0.387298
7     0.387298
8     0.387298
9     1.161895
10    1.161895
11    1.161895
Name: value, dtype: float64
</code></pre>
<p>解封分组操作可能包括多个分组聚合，但是矢量化操作还是会带来收益。</p>
<h4 id="分组的时间重采样">分组的时间重采样</h4>
<p>对于时间序列数据，<code>resample</code>方法从语义上是一个基于内在时间的分组操作。下面是一个示例表：</p>
<pre><code class="language-python">N = 15
times = pd.date_range('2017-05-20 00:00', freq='1min', periods=N)
df = pd.DataFrame({'time': times,'value': np.arange(N)})
df
                  time  value
0  2017-05-20 00:00:00      0
1  2017-05-20 00:01:00      1
2  2017-05-20 00:02:00      2
3  2017-05-20 00:03:00      3
4  2017-05-20 00:04:00      4
5  2017-05-20 00:05:00      5
6  2017-05-20 00:06:00      6
7  2017-05-20 00:07:00      7
8  2017-05-20 00:08:00      8
9  2017-05-20 00:09:00      9
10 2017-05-20 00:10:00     10
11 2017-05-20 00:11:00     11
12 2017-05-20 00:12:00     12
13 2017-05-20 00:13:00     13
14 2017-05-20 00:14:00     14
</code></pre>
<p>这里，我们可以用<code>time</code>作为索引，然后重采样：</p>
<pre><code class="language-python">df.set_index('time').resample('5min').count()
                     value
time                      
2017-05-20 00:00:00      5
2017-05-20 00:05:00      5
2017-05-20 00:10:00      5
</code></pre>
<p>假设<code>DataFrame</code>包含多个时间序列，用一个额外的分组键的列进行标记：</p>
<pre><code class="language-python">df2 = pd.DataFrame({'time': times.repeat(3),'key': np.tile(['a', 'b', 'c'], N),'value': np.arange(N * 3.)})
df2[:7]
  key                time  value
0   a 2017-05-20 00:00:00    0.0
1   b 2017-05-20 00:00:00    1.0
2   c 2017-05-20 00:00:00    2.0
3   a 2017-05-20 00:01:00    3.0
4   b 2017-05-20 00:01:00    4.0
5   c 2017-05-20 00:01:00    5.0
6   a 2017-05-20 00:02:00    6.0
</code></pre>
<p>要对每个<code>key</code>值进行相同的重采样，我们引入<code>pandas.TimeGrouper</code>对象：</p>
<pre><code class="language-python">time_key = pd.TimeGrouper('5min')
</code></pre>
<p>我们然后设定时间索引，用<code>key</code>和<code>time_key</code>分组，然后聚合：</p>
<pre><code class="language-python">resampled = (df2.set_index('time').groupby(['key', time_key]).sum())
resampled
                         value
key time                      
a   2017-05-20 00:00:00   30.0
    2017-05-20 00:05:00  105.0
    2017-05-20 00:10:00  180.0
b   2017-05-20 00:00:00   35.0
    2017-05-20 00:05:00  110.0
    2017-05-20 00:10:00  185.0
c   2017-05-20 00:00:00   40.0
    2017-05-20 00:05:00  115.0
    2017-05-20 00:10:00  190.0
resampled.reset_index()
key                time  value
0   a 2017-05-20 00:00:00   30.0
1   a 2017-05-20 00:05:00  105.0
2   a 2017-05-20 00:10:00  180.0
3   b 2017-05-20 00:00:00   35.0
4   b 2017-05-20 00:05:00  110.0
5   b 2017-05-20 00:10:00  185.0
6   c 2017-05-20 00:00:00   40.0
7   c 2017-05-20 00:05:00  115.0
8   c 2017-05-20 00:10:00  190.0
</code></pre>
<p>使用<code>TimeGrouper</code>的限制是时间必须是<code>Series</code>或<code>DataFrame</code>的索引。</p>
<h3 id="链式编程技术">链式编程技术</h3>
<p>当对数据集进行一系列变换时，你可能发现创建的多个临时变量其实并没有在分析中用到。看下面的例子：</p>
<pre><code class="language-python">df = load_data()
df2 = df[df['col2'] &lt; 0]
df2['col1_demeaned'] = df2['col1'] - df2['col1'].mean()
result = df2.groupby('key').col1_demeaned.std()
</code></pre>
<p>虽然这里没有使用真实的数据，这个例子却指出了一些新方法。首先，<code>DataFrame.assign</code>方法是一个<code>df[k] = v</code>形式的函数式的列分配方法。它不是就地修改对象，而是返回新的修改过的<code>DataFrame</code>。因此，下面的语句是等价的：</p>
<pre><code class="language-python">#Usual non-functional way
df2 = df.copy()
df2['k'] = v
#Functional assign way
df2 = df.assign(k=v)
</code></pre>
<p>就地分配可能会比<code>assign</code>快，但是<code>assign</code>可以方便地进行链式编程：</p>
<pre><code class="language-python">result = (df2.assign(col1_demeaned=df2.col1 - df2.col2.mean()).groupby('key').col1_demeaned.std())
</code></pre>
<p>我使用外括号，这样便于添加换行符。</p>
<p>使用链式编程时要注意，你可能会需要涉及临时对象。在前面的例子中，我们不能使用<code>load_data</code>的结果，直到它被赋值给临时变量<code>df</code>。为了这么做，<code>assign</code>和许多其它<code>pandas</code>函数可以接收类似函数的参数，即可调用对象（<code>callable</code>）。为了展示可调用对象，看一个前面例子的片段：</p>
<pre><code class="language-python">df = load_data()
df2 = df[df['col2'] &lt; 0]
</code></pre>
<p>它可以重写为：</p>
<pre><code class="language-python">df = (load_data()
[lambda x: x['col2'] &lt; 0])
</code></pre>
<p>这里，<code>load_data</code>的结果没有赋值给某个变量，因此传递到<code>[ ]</code>的函数在这一步被绑定到了对象。</p>
<p>我们可以把整个过程写为一个单链表达式：</p>
<pre><code class="language-python">result = (load_data()
          [lambda x: x.col2 &lt; 0]
          .assign(col1_demeaned=lambda x: x.col1 - x.col1.mean())
          .groupby('key')
          .col1_demeaned.std())
</code></pre>
<p>是否将代码写成这种形式只是习惯而已，将它分开成若干步可以提高可读性。</p>
<h4 id="管道方法">管道方法</h4>
<p>你可以用<code>Python</code>内置的<code>pandas</code>函数和方法，用带有可调用对象的链式编程做许多工作。但是，有时你需要使用自己的函数，或是第三方库的函数。这时就要用到管道方法。</p>
<p>看下面的函数调用：</p>
<pre><code class="language-python">a = f(df, arg1=v1)
b = g(a, v2, arg3=v3)
c = h(b, arg4=v4)
</code></pre>
<p>当使用接收、返回<code>Series</code>或<code>DataFrame</code>对象的函数式，你可以调用<code>pipe</code>将其重写：</p>
<pre><code class="language-python">result = (df.pipe(f, arg1=v1)
          .pipe(g, v2, arg3=v3)
          .pipe(h, arg4=v4))
</code></pre>
<p><code>f(df)</code>和<code>df.pipe(f)</code>是等价的，但是<code>pipe</code>使得链式声明更容易。</p>
<p><code>pipe</code>的另一个有用的地方是提炼操作为可复用的函数。看一个从列减去分组方法的例子：</p>
<pre><code class="language-python">g = df.groupby(['key1', 'key2'])
df['col1'] = df['col1'] - g.transform('mean')
</code></pre>
<p>假设你想转换多列，并修改分组的键。另外，你想用链式编程做这个转换。下面就是一个方法：</p>
<pre><code class="language-python">def group_demean(df, by, cols):
    result = df.copy()
    g = df.groupby(by)
    for c in cols:
        result[c] = df[c] - g[c].transform('mean')
    return result
</code></pre>
<p>然后可以写为：</p>
<pre><code class="language-python">result = (df[df.col1 &lt; 0]
          .pipe(group_demean, ['key1', 'key2'], ['col1']))
</code></pre>
<h2 id="python建模库"><code>Python</code>建模库</h2>
<h3 id="pandas与模型代码的接口"><code>pandas</code>与模型代码的接口</h3>
<p>模型开发的通常工作流是使用<code>pandas</code>进行数据加载和清洗，然后切换到建模库进行建模。开发模型的重要一环是机器学习中的“特征工程”。它可以描述从原始数据集中提取信息的任何数据转换或分析，这些数据集可能在建模中有用。本书中学习的数据聚合和<code>GroupBy</code>工具常用于特征工程中。</p>
<p>优秀的特征工程超出了本书的范围，我会尽量直白地介绍一些用于数据操作和建模切换的方法。</p>
<p><code>pandas</code>与其它分析库通常是靠<code>NumPy</code>的数组联系起来的。将<code>DataFrame</code>转换为<code>NumPy</code>数组，可以使用<code>.values</code>属性：</p>
<pre><code class="language-python">import pandas as pd
import numpy as np
data = pd.DataFrame({'x0': [1, 2, 3, 4, 5],'x1': [0.01, -0.01, 0.25, -4.1, 0.],'y': [-1.5, 0., 3.6, 1.3, -2.]})
data
   x0    x1    y
0   1  0.01 -1.5
1   2 -0.01  0.0
2   3  0.25  3.6
3   4 -4.10  1.3
4   5  0.00 -2.0
data.columns
Index(['x0', 'x1', 'y'], dtype='object')
data.values
array([[ 1.  ,  0.01, -1.5 ],
       [ 2.  , -0.01,  0.  ],
       [ 3.  ,  0.25,  3.6 ],
       [ 4.  , -4.1 ,  1.3 ],
       [ 5.  ,  0.  , -2.  ]])
</code></pre>
<p>要转换回<code>DataFrame</code>，可以传递一个二维<code>ndarray</code>，可带有列名：</p>
<pre><code class="language-python">df2 = pd.DataFrame(data.values, columns=['one', 'two', 'three'])
df2
   one   two  three
0  1.0  0.01   -1.5
1  2.0 -0.01    0.0
2  3.0  0.25    3.6
3  4.0 -4.10    1.3
4  5.0  0.00   -2.0
</code></pre>
<blockquote>
<p>笔记：最好当数据是均匀的时候使用<code>.values</code>属性。例如，全是数值类型。如果数据是不均匀的，结果会是<code>Python</code>对象的<code>ndarray</code>：</p>
</blockquote>
<pre><code class="language-python">df3 = data.copy()

df3['strings'] = ['a', 'b', 'c', 'd', 'e']

df3

  x0    x1    y strings
0   1  0.01 -1.5       a
1   2 -0.01  0.0       b
2   3  0.25  3.6       c
3   4 -4.10  1.3       d
4   5  0.00 -2.0       e
df3.values
array([[1, 0.01, -1.5, 'a'],
      [2, -0.01, 0.0, 'b'],
      [3, 0.25, 3.6, 'c'],
      [4, -4.1, 1.3, 'd'],
      [5, 0.0, -2.0, 'e']], dtype=object)
</code></pre>
<p>对于一些模型，你可能只想使用列的子集。我建议你使用<code>loc</code>，用<code>values</code>作索引：</p>
<pre><code class="language-python">model_cols = ['x0', 'x1']
data.loc[:, model_cols].values
array([[ 1.  ,  0.01],
       [ 2.  , -0.01],
       [ 3.  ,  0.25],
       [ 4.  , -4.1 ],
       [ 5.  ,  0.  ]])
</code></pre>
<p>一些库原生支持<code>pandas</code>，会自动完成工作：从<code>DataFrame</code>转换到<code>NumPy</code>，将模型的参数名添加到输出表的列或<code>Series</code>。其它情况，你可以手工进行“元数据管理”。</p>
<pre><code class="language-python">data['category'] = pd.Categorical(['a', 'b', 'a', 'a', 'b'],categories=['a', 'b'])
data
   x0    x1    y category
0   1  0.01 -1.5        a
1   2 -0.01  0.0        b
2   3  0.25  3.6        a
3   4 -4.10  1.3        a
4   5  0.00 -2.0        b
</code></pre>
<p>如果我们想替换<code>category</code>列为虚变量，我们可以创建虚变量，删除<code>category</code>列，然后添加到结果：</p>
<pre><code class="language-python">dummies = pd.get_dummies(data.category, prefix='category')
data_with_dummies = data.drop('category', axis=1).join(dummies)
data_with_dummies
   x0    x1    y  category_a  category_b
0   1  0.01 -1.5           1           0
1   2 -0.01  0.0           0           1
2   3  0.25  3.6           1           0
3   4 -4.10  1.3           1           0
4   5  0.00 -2.0           0           1
</code></pre>
<p>用虚变量拟合某些统计模型会有一些细微差别。</p>
<h3 id="scikit-learn介绍"><code>scikit-learn</code>介绍</h3>
<p><code>scikit-learn</code>是一个广泛使用、用途多样的<code>Python</code>机器学习库。它包含多种标准监督和非监督机器学习方法和模型选择和评估、数据转换、数据加载和模型持久化工具。这些模型可以用于分类、聚合、预测和其它任务。</p>
<p>机器学习方面的学习和应用<code>scikit-learn</code>和<code>TensorFlow</code>解决实际问题的线上和纸质资料很多。本节中，我会简要介绍<code>scikit-learn</code> <code>API</code>的风格。</p>
<p>写作此书的时候，<code>scikit-learn</code>并没有和<code>pandas</code>深度结合，但是有些第三方包在开发中。尽管如此，<code>pandas</code>非常适合在模型拟合前处理数据集。</p>
<p>举个例子，我用一个Kaggle竞赛的经典数据集，关于泰坦尼克号乘客的生还率。我们用<code>pandas</code>加载测试和训练数据集：</p>
<pre><code class="language-python">train = pd.read_csv('datasets/titanic/train.csv')
test = pd.read_csv('datasets/titanic/test.csv')
train[:4]
   PassengerId  Survived  Pclass  \
0            1         0       3   
1            2         1       1   
2            3         1       3   
3            4         1       1   
                                                Name     Sex   Age  SibSp  \
0                            Braund, Mr. Owen Harris    male  22.0      1   
1  Cumings, Mrs. John Bradley (Florence Briggs Th...  female  38.0      1   
2                             Heikkinen, Miss. Laina  female  26.0      0   
3       Futrelle, Mrs. Jacques Heath (Lily May Peel)  female  35.0      1   
   Parch            Ticket     Fare Cabin Embarked  
0      0         A/5 21171   7.2500   NaN        S  
1      0          PC 17599  71.2833   C85        C  
2      0  STON/O2. 3101282   7.9250   NaN        S  
3      0            113803  53.1000  C123        S
</code></pre>
<p><code>statsmodels</code>和<code>scikit-learn</code>通常不能接收缺失数据，因此我们要查看列是否包含缺失值：</p>
<pre><code class="language-python">train.isnull().sum()
PassengerId      0
Survived         0
Pclass           0
Name             0
Sex              0
Age            177
SibSp            0
Parch            0
Ticket           0
Fare             0
Cabin          687
Embarked         2
dtype: int64
test.isnull().sum()
PassengerId      0
Pclass           0
Name             0
Sex              0
Age             86
SibSp            0
Parch            0
Ticket           0
Fare             1
Cabin          327
Embarked         0
dtype: int64
</code></pre>
<p>在统计和机器学习的例子中，根据数据中的特征，一个典型的任务是预测乘客能否生还。模型现在训练数据集中拟合，然后用样本外测试数据集评估。</p>
<p>我想用年龄作为预测值，但是它包含缺失值。缺失数据补全的方法有多种，我用的是一种简单方法，用训练数据集的中位数补全两个表的空值：</p>
<pre><code class="language-python">impute_value = train['Age'].median()
train['Age'] = train['Age'].fillna(impute_value)
test['Age'] = test['Age'].fillna(impute_value)
</code></pre>
<p>现在我们需要指定模型。我增加了一个列<code>IsFemale</code>，作为<code>“Sex”</code>列的编码：</p>
<pre><code class="language-python">train['IsFemale'] = (train['Sex'] == 'female').astype(int)
test['IsFemale'] = (test['Sex'] == 'female').astype(int)
</code></pre>
<p>然后，我们确定一些模型变量，并创建<code>NumPy</code>数组：</p>
<pre><code class="language-python">predictors = ['Pclass', 'IsFemale', 'Age']
X_train = train[predictors].values
X_test = test[predictors].values
y_train = train['Survived'].values
X_train[:5]
array([[  3.,   0.,  22.],
       [  1.,   1.,  38.],
       [  3.,   1.,  26.],
       [  1.,   1.,  35.],
       [  3.,   0.,  35.]])
y_train[:5]
array([0, 1, 1, 1, 0])
</code></pre>
<p>我不能保证这是一个好模型，但它的特征都符合。我们用<code>scikit-learn</code>的<code>LogisticRegression</code>模型，创建一个模型实例：</p>
<pre><code class="language-python">from sklearn.linear_model import LogisticRegression
model = LogisticRegression()
</code></pre>
<p>与<code>statsmodels</code>类似，我们可以用模型的<code>fit</code>方法，将它拟合到训练数据：</p>
<pre><code class="language-python">model.fit(X_train, y_train)
LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
          intercept_scaling=1, max_iter=100, multi_class='ovr', n_jobs=1,
          penalty='l2', random_state=None, solver='liblinear', tol=0.0001,
          verbose=0, warm_start=False)
</code></pre>
<p>现在，我们可以用<code>model.predict</code>，对测试数据进行预测：</p>
<pre><code class="language-python">y_predict = model.predict(X_test)
y_predict[:10]
array([0, 0, 0, 0, 1, 0, 1, 0, 1, 0])
</code></pre>
<p>如果你有测试数据集的真实值，你可以计算准确率或其它错误度量值：</p>
<pre><code class="language-python">(y_true == y_predict).mean()
</code></pre>
<p>在实际中，模型训练经常有许多额外的复杂因素。许多模型有可以调节的参数，有些方法（比如交叉验证）可以用来进行参数调节，避免对训练数据过拟合。这通常可以提高预测性或对新数据的健壮性。</p>
<p>交叉验证通过分割训练数据来模拟样本外预测。基于模型的精度得分（比如均方差），可以对模型参数进行网格搜索。有些模型，如<code>logistic</code>回归，有内置的交叉验证的估计类。例如，<code>logisticregressioncv</code>类可以用一个参数指定网格搜索对模型的正则化参数C的粒度：</p>
<pre><code class="language-python">from sklearn.linear_model import LogisticRegressionCV
model_cv = LogisticRegressionCV(10)
model_cv.fit(X_train, y_train)
LogisticRegressionCV(Cs=10, class_weight=None, cv=None, dual=False,
           fit_intercept=True, intercept_scaling=1.0, max_iter=100,
           multi_class='ovr', n_jobs=1, penalty='l2', random_state=None,
           refit=True, scoring=None, solver='lbfgs', tol=0.0001, verbose=0)
</code></pre>
<p>要手动进行交叉验证，你可以使用<code>cross_val_score</code>帮助函数，它可以处理数据分割。例如，要交叉验证我们的带有四个不重叠训练数据的模型，可以这样做：</p>
<pre><code class="language-python">from sklearn.model_selection import cross_val_score
model = LogisticRegression(C=10)
scores = cross_val_score(model, X_train, y_train, cv=4)
scores
array([ 0.7723,  0.8027,  0.7703,  0.7883])
</code></pre>
<p>默认的评分指标取决于模型本身，但是可以明确指定一个评分。交叉验证过的模型需要更长时间来训练，但会有更高的模型性能。</p>
<h2 id="数据分析案例">数据分析案例</h2>
<h3 id="来自bitly的usagov数据">来自Bitly的USA.gov数据</h3>
<p>2011年，URL缩短服务Bitly跟美国政府网站USA.gov合作，提供了一份从生成.gov或.mil短链接的用户那里收集来的匿名数据。在2011年，除实时数据之外，还可以下载文本文件形式的每小时快照。</p>
<p>以每小时快照为例，文件中各行的格式为<code>JSON</code>（即JavaScript Object Notation，这是一种常用的Web数据格式）。例如，如果我们只读取某个文件中的第一行，那么所看到的结果应该是下面这样：</p>
<pre><code class="language-python">path = 'datasets/bitly_usagov/example.txt'
open(path).readline()
'{ &quot;a&quot;: &quot;Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11
(KHTML, like Gecko) Chrome\\/17.0.963.78 Safari\\/535.11&quot;, &quot;c&quot;: &quot;US&quot;, &quot;nk&quot;: 1,
&quot;tz&quot;: &quot;America\\/New_York&quot;, &quot;gr&quot;: &quot;MA&quot;, &quot;g&quot;: &quot;A6qOVH&quot;, &quot;h&quot;: &quot;wfLQtf&quot;, &quot;l&quot;:
&quot;orofrog&quot;, &quot;al&quot;: &quot;en-US,en;q=0.8&quot;, &quot;hh&quot;: &quot;1.usa.gov&quot;, &quot;r&quot;:
&quot;http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf&quot;, &quot;u&quot;:
&quot;http:\\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991&quot;, &quot;t&quot;: 1331923247, &quot;hc&quot;:
1331822918, &quot;cy&quot;: &quot;Danvers&quot;, &quot;ll&quot;: [ 42.576698, -70.954903 ] }\n'
</code></pre>
<p><code>Python</code>有内置或第三方模块可以将<code>JSON</code>字符串转换成<code>Python</code>字典对象。这里，我将使用<code>json</code>模块及其<code>loads</code>函数逐行加载已经下载好的数据文件：</p>
<pre><code class="language-python">import json
path = 'datasets/bitly_usagov/example.txt'
records = [json.loads(line) for line in open(path)]
</code></pre>
<p>现在，<code>records</code>对象就成为一组<code>Python</code>字典了：</p>
<pre><code class="language-python">records[0]
{'a': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko)
Chrome/17.0.963.78 Safari/535.11',
 'al': 'en-US,en;q=0.8',
 'c': 'US',
 'cy': 'Danvers',
 'g': 'A6qOVH',
 'gr': 'MA',
 'h': 'wfLQtf',
 'hc': 1331822918,
 'hh': '1.usa.gov',
 'l': 'orofrog',
 'll': [42.576698, -70.954903],
 'nk': 1,
 'r': 'http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf',
 't': 1331923247,
 'tz': 'America/New_York',
 'u': 'http://www.ncbi.nlm.nih.gov/pubmed/22415991'}
</code></pre>
<h4 id="用纯python代码对时区进行计数">用纯<code>Python</code>代码对时区进行计数</h4>
<p>假设我们想要知道该数据集中最常出现的是哪个时区（即tz字段），得到答案的办法有很多。首先，我们用列表推导式取出一组时区：</p>
<pre><code class="language-python">time_zones = [rec['tz'] for rec in records]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
&lt;ipython-input-12-db4fbd348da9&gt; in &lt;module&gt;()
----&gt; 1 time_zones = [rec['tz'] for rec in records]
&lt;ipython-input-12-db4fbd348da9&gt; in &lt;listcomp&gt;(.0)
----&gt; 1 time_zones = [rec['tz'] for rec in records]
KeyError: 'tz'
</code></pre>
<p>晕！原来并不是所有记录都有时区字段。这个好办，只需在列表推导式末尾加上一个<code>if 'tz'in rec</code>判断即可：</p>
<pre><code class="language-python">time_zones = [rec['tz'] for rec in records if 'tz' in rec]
time_zones[:10]
['America/New_York',
 'America/Denver',
 'America/New_York',
 'America/Sao_Paulo',
 'America/New_York',
 'America/New_York',
 'Europe/Warsaw',
 '',
 '',
 '']
</code></pre>
<p>只看前10个时区，我们发现有些是未知的（即空的）。虽然可以将它们过滤掉，但现在暂时先留着。接下来，为了对时区进行计数，这里介绍两个办法：一个较难（只使用标准<code>Python</code>库），另一个较简单（使用<code>pandas</code>）。计数的办法之一是在遍历时区的过程中将计数值保存在字典中：</p>
<pre><code class="language-python">def get_counts(sequence):
    counts = {}
    for x in sequence:
        if x in counts:
            counts[x] += 1
        else:
            counts[x] = 1
    return counts
</code></pre>
<p>如果使用<code>Python</code>标准库的更高级工具，那么你可能会将代码写得更简洁一些：</p>
<pre><code class="language-python">from collections import defaultdict

def get_counts2(sequence):
    counts = defaultdict(int) # values will initialize to 0
    for x in sequence:
        counts[x] += 1
    return counts
</code></pre>
<p>我将逻辑写到函数中是为了获得更高的复用性。要用它对时区进行处理，只需将<code>time_zones</code>传入即可：</p>
<pre><code class="language-python">counts = get_counts(time_zones)
counts['America/New_York']
1251
len(time_zones)
3440
</code></pre>
<p>如果想要得到前10位的时区及其计数值，我们需要用到一些有关字典的处理技巧：</p>
<pre><code class="language-python">def top_counts(count_dict, n=10):
    value_key_pairs = [(count, tz) for tz, count in count_dict.items()]
    value_key_pairs.sort()
    return value_key_pairs[-n:]
</code></pre>
<p>然后有：</p>
<pre><code class="language-python">top_counts(counts)
[(33, 'America/Sao_Paulo'),
 (35, 'Europe/Madrid'),
(36, 'Pacific/Honolulu'),
 (37, 'Asia/Tokyo'),
 (74, 'Europe/London'),
 (191, 'America/Denver'),
 (382, 'America/Los_Angeles'),
 (400, 'America/Chicago'),
 (521, ''),
 (1251, 'America/New_York')]
</code></pre>
<p>如果你搜索<code>Python</code>的标准库，你能找到<code>collections.Counter</code>类，它可以使这项工作更简单：</p>
<pre><code class="language-python">from collections import Counter
counts = Counter(time_zones)
counts.most_common(10)
[('America/New_York', 1251),
 ('', 521),
 ('America/Chicago', 400),
 ('America/Los_Angeles', 382),
 ('America/Denver', 191),
 ('Europe/London', 74),
 ('Asia/Tokyo', 37),
 ('Pacific/Honolulu', 36),
 ('Europe/Madrid', 35),
 ('America/Sao_Paulo', 33)]
</code></pre>
<h4 id="用pandas对时区进行计数">用<code>pandas</code>对时区进行计数</h4>
<p>从原始记录的集合创建<code>DateFrame</code>，与将记录列表传递到<code>pandas.DataFrame</code>一样简单：</p>
<pre><code class="language-python">import pandas as pd
frame = pd.DataFrame(records)
frame.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 3560 entries, 0 to 3559
Data columns (total 18 columns):
_heartbeat_    120 non-null float64
a              3440 non-null object
al             3094 non-null object
c              2919 non-null object
cy             2919 non-null object
g              3440 non-null object
gr             2919 non-null object
h              3440 non-null object
hc             3440 non-null float64
hh             3440 non-null object
kw             93 non-null object
l              3440 non-null object
ll             2919 non-null object
nk             3440 non-null float64
r              3440 non-null object
t              3440 non-null float64
tz             3440 non-null object
u              3440 non-null object
dtypes: float64(4), object(14)
memory usage: 500.7+ KB
frame['tz'][:10]
0     America/New_York
1       America/Denver
2     America/New_York
3    America/Sao_Paulo
4     America/New_York
5     America/New_York
6        Europe/Warsaw
7                     
8                     
9                     
Name: tz, dtype: object
</code></pre>
<p>这里frame的输出形式是摘要视图（<code>summary view</code>），主要用于较大的<code>DataFrame</code>对象。我们然后可以对<code>Series</code>使用<code>value_counts</code>方法：</p>
<pre><code class="language-python">tz_counts = frame['tz'].value_counts()
tz_counts[:10]
America/New_York       1251
                        521
America/Chicago         400
America/Los_Angeles     382
America/Denver          191
Europe/London            74
Asia/Tokyo               37
Pacific/Honolulu         36
Europe/Madrid            35
America/Sao_Paulo        33
Name: tz, dtype: int64
</code></pre>
<p>我们可以用<code>matplotlib</code>可视化这个数据。为此，我们先给记录中未知或缺失的时区填上一个替代值。<code>fillna</code>函数可以替换缺失值（<code>NA</code>），而未知值（空字符串）则可以通过布尔型数组索引加以替换：</p>
<pre><code class="language-python">clean_tz = frame['tz'].fillna('Missing')
clean_tz[clean_tz == ''] = 'Unknown'
tz_counts = clean_tz.value_counts()
tz_counts[:10]
America/New_York       1251
Unknown                 521
America/Chicago         400
America/Los_Angeles     382
America/Denver          191
Missing                 120
Europe/London            74
Asia/Tokyo               37
Pacific/Honolulu         36
Europe/Madrid            35
Name: tz, dtype: int64
</code></pre>
<p>此时，我们可以用<code>seaborn</code>包创建水平柱状图（结果见下图）：</p>
<pre><code class="language-python">import seaborn as sns
subset = tz_counts[:10]
sns.barplot(y=subset.index, x=subset.values)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410010252.png" alt="" loading="lazy"><br>
a字段含有执行URL短缩操作的浏览器、设备、应用程序的相关信息：</p>
<pre><code class="language-python">frame['a'][1]
'GoogleMaps/RochesterNY'
frame['a'][50]
'Mozilla/5.0 (Windows NT 5.1; rv:10.0.2)
Gecko/20100101 Firefox/10.0.2'
frame['a'][51][:50]  # long line
'Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P9'
</code></pre>
<p>将这些&quot;agent&quot;字符串中的所有信息都解析出来是一件挺郁闷的工作。一种策略是将这种字符串的第一节（与浏览器大致对应）分离出来并得到另外一份用户行为摘要：</p>
<pre><code class="language-python">results = pd.Series([x.split()[0] for x in frame.a.dropna()])
results[:5]
0               Mozilla/5.0
1    GoogleMaps/RochesterNY
2               Mozilla/4.0
3               Mozilla/5.0
4               Mozilla/5.0
dtype: object
results.value_counts()[:8]
Mozilla/5.0                 2594
Mozilla/4.0                  601
GoogleMaps/RochesterNY       121
Opera/9.80                    34
TEST_INTERNET_AGENT           24
GoogleProducer                21
Mozilla/6.0                    5
BlackBerry8520/5.0.0.681       4
dtype: int64
</code></pre>
<p>现在，假设你想按Windows和非Windows用户对时区统计信息进行分解。为了简单起见，我们假定只要agent字符串中含有&quot;Windows&quot;就认为该用户为Windows用户。由于有的agent缺失，所以首先将它们从数据中移除：</p>
<pre><code class="language-python">cframe = frame[frame.a.notnull()]
</code></pre>
<p>然后计算出各行是否含有Windows的值：</p>
<pre><code class="language-python">cframe['os'] = np.where(cframe['a'].str.contains('Windows'),'Windows', 'Not Windows')
cframe['os'][:5]
0        Windows
1    Not Windows
2        Windows
3    Not Windows
4        Windows
Name: os, dtype: object
</code></pre>
<p>接下来就可以根据时区和新得到的操作系统列表对数据进行分组了：</p>
<pre><code class="language-python">by_tz_os = cframe.groupby(['tz', 'os'])
</code></pre>
<p>分组计数，类似于<code>value_counts</code>函数，可以用<code>size</code>来计算。并利用<code>unstack</code>对计数结果进行重塑：</p>
<pre><code class="language-python">agg_counts = by_tz_os.size().unstack().fillna(0)
agg_counts[:10]
os                              Not Windows  Windows
tz                                                  
                                      245.0    276.0
Africa/Cairo                            0.0      3.0
Africa/Casablanca                       0.0      1.0
Africa/Ceuta                            0.0      2.0
Africa/Johannesburg                     0.0      1.0
Africa/Lusaka                           0.0      1.0
America/Anchorage                       4.0      1.0
America/Argentina/Buenos_Aires          1.0      0.0
America/Argentina/Cordoba               0.0      1.0
America/Argentina/Mendoza               0.0      1.0
</code></pre>
<p>最后，我们来选取最常出现的时区。为了达到这个目的，我根据<code>agg_counts</code>中的行数构造了一个间接索引数组：</p>
<pre><code class="language-python">#Use to sort in ascending order
indexer = agg_counts.sum(1).argsort()
indexer[:10]
tz
                                  24
Africa/Cairo                      20
Africa/Casablanca                 21
Africa/Ceuta                      92
Africa/Johannesburg               87
Africa/Lusaka                     53
America/Anchorage                 54
America/Argentina/Buenos_Aires    57
America/Argentina/Cordoba         26
America/Argentina/Mendoza         55
dtype: int64
</code></pre>
<p>然后我通过<code>take</code>按照这个顺序截取了最后10行最大值：</p>
<pre><code class="language-python">count_subset = agg_counts.take(indexer[-10:])
count_subset
os                   Not Windows  Windows
tz                                       
America/Sao_Paulo           13.0     20.0
Europe/Madrid               16.0     19.0
Pacific/Honolulu             0.0     36.0
Asia/Tokyo                   2.0     35.0
Europe/London               43.0     31.0
America/Denver             132.0     59.0
America/Los_Angeles        130.0    252.0
America/Chicago            115.0    285.0
                           245.0    276.0
America/New_York           339.0    912.0
</code></pre>
<p><code>pandas</code>有一个简便方法<code>nlargest</code>，可以做同样的工作：</p>
<pre><code class="language-python">agg_counts.sum(1).nlargest(10)
tz
America/New_York       1251.0
                        521.0
America/Chicago         400.0
America/Los_Angeles     382.0
America/Denver          191.0
Europe/London            74.0
Asia/Tokyo               37.0
Pacific/Honolulu         36.0
Europe/Madrid            35.0
America/Sao_Paulo        33.0
dtype: float64
</code></pre>
<p>然后，如这段代码所示，可以用柱状图表示。我传递一个额外参数到<code>seaborn</code>的<code>barpolt</code>函数，来画一个堆积条形图（见下图）：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410011408.png" alt="" loading="lazy"></p>
<pre><code class="language-python">#Rearrange the data for plotting
count_subset = count_subset.stack()
count_subset.name = 'total'
count_subset = count_subset.reset_index()
count_subset[:10]
                  tz           os  total
0  America/Sao_Paulo  Not Windows   13.0
1  America/Sao_Paulo      Windows   20.0
2      Europe/Madrid  Not Windows   16.0
3      Europe/Madrid      Windows   19.0
4   Pacific/Honolulu  Not Windows    0.0
5   Pacific/Honolulu      Windows   36.0
6         Asia/Tokyo  Not Windows    2.0
7         Asia/Tokyo      Windows   35.0
8      Europe/London  Not Windows   43.0
9      Europe/London      Windows   31.0
sns.barplot(x='total', y='tz', hue='os',  data=count_subset)
</code></pre>
<p>这张图不容易看出Windows用户在小分组中的相对比例，因此标准化分组百分比之和为1：</p>
<pre><code class="language-python">def norm_total(group):
    group['normed_total'] = group.total / group.total.sum()
    return group

results = count_subset.groupby('tz').apply(norm_total)
</code></pre>
<p>再次画图，见下图：</p>
<pre><code class="language-python">sns.barplot(x='normed_total', y='tz', hue='os',  data=results)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410012736.png" alt="" loading="lazy"><br>
我们还可以用<code>groupby</code>的<code>transform</code>方法，更高效的计算标准化的和：</p>
<pre><code class="language-python">g = count_subset.groupby('tz')
results2 = count_subset.total / g.total.transform('sum')
</code></pre>
<h3 id="movielens-1m数据集"><code>MovieLens 1M</code>数据集</h3>
<p>GroupLens Research采集了一组从20世纪90年末到21世纪初由MovieLens用户提供的电影评分数据。这些数据中包括电影评分、电影元数据（风格类型和年代）以及关于用户的人口统计学数据（年龄、邮编、性别和职业等）。基于机器学习算法的推荐系统一般都会对此类数据感兴趣。虽然我不会在本书中详细介绍机器学习技术，但我会告诉你如何对这种数据进行切片切块以满足实际需求。</p>
<p>MovieLens 1M数据集含有来自6000名用户对4000部电影的100万条评分数据。它分为三个表：评分、用户信息和电影信息。将该数据从zip文件中解压出来之后，可以通过<code>pandas.read_table</code>将各个表分别读到一个<code>pandas DataFrame</code>对象中：</p>
<pre><code class="language-python">import pandas as pd
#Make display smaller
pd.options.display.max_rows = 10
unames = ['user_id', 'gender', 'age', 'occupation', 'zip']
users = pd.read_table('datasets/movielens/users.dat', sep='::',header=None, names=unames)
rnames = ['user_id', 'movie_id', 'rating', 'timestamp']
ratings = pd.read_table('datasets/movielens/ratings.dat', sep='::',header=None, names=rnames)
mnames = ['movie_id', 'title', 'genres']
movies = pd.read_table('datasets/movielens/movies.dat', sep='::',header=None, names=mnames)
</code></pre>
<p>利用<code>Python</code>的切片语法，通过查看每个<code>DataFrame</code>的前几行即可验证数据加载工作是否一切顺利：</p>
<pre><code class="language-python">users[:5]
   user_id gender  age  occupation    zip
0        1      F    1          10  48067
1        2      M   56          16  70072
2        3      M   25          15  55117
3        4      M   45           7  02460
4        5      M   25          20  55455
ratings[:5]
   user_id  movie_id  rating  timestamp
0        1      1193       5  978300760
1        1       661       3  978302109
2        1       914       3  978301968
3        1      3408       4  978300275
4        1      2355       5  978824291
movies[:5]
   movie_id                               title                        genres
0         1                    Toy Story (1995)   Animation|Children's|Comedy
1         2                      Jumanji (1995)  Adventure|Children's|Fantasy
2         3             Grumpier Old Men (1995)                Comedy|Romance
3         4            Waiting to Exhale (1995)                  Comedy|Drama
4         5  Father of the Bride Part II (1995)                        Comedy
ratings
         user_id  movie_id  rating  timestamp
0              1      1193       5  978300760
1              1       661       3  978302109
2              1       914       3  978301968
3              1      3408       4  978300275
4              1      2355       5  978824291
...          ...       ...     ...        ...
1000204     6040      1091       1  956716541
1000205     6040      1094       5  956704887
1000206     6040       562       5  956704746
1000207     6040      1096       4  956715648
1000208     6040      1097       4  956715569
[1000209 rows x 4 columns]
</code></pre>
<p>注意，其中的年龄和职业是以编码形式给出的，它们的具体含义请参考该数据集的<code>README</code>文件。分析散布在三个表中的数据可不是一件轻松的事情。假设我们想要根据性别和年龄计算某部电影的平均得分，如果将所有数据都合并到一个表中的话问题就简单多了。我们先用<code>pandas</code>的<code>merge</code>函数将<code>ratings</code>跟<code>users</code>合并到一起，然后再将<code>movies</code>也合并进去。<code>pandas</code>会根据列名的重叠情况推断出哪些列是合并（或连接）键：</p>
<pre><code class="language-python">data = pd.merge(pd.merge(ratings, users), movies)
data
         user_id  movie_id  rating  timestamp gender  age  occupation    zip  \
0              1      1193       5  978300760      F    1          10  48067   
1              2      1193       5  978298413      M   56          16  70072   
2             12      1193       4  978220179      M   25          12  32793   
3             15      1193       4  978199279      M   25           7  22903   
4             17      1193       5  978158471      M   50           1  95350   
...          ...       ...     ...        ...    ...  ...         ...    ...   
1000204     5949      2198       5  958846401      M   18          17  47901
1000205     5675      2703       3  976029116      M   35          14  30030   
1000206     5780      2845       1  958153068      M   18          17  92886   
1000207     5851      3607       5  957756608      F   18          20  55410   
1000208     5938      2909       4  957273353      M   25           1  35401   
                                               title                genres  
0             One Flew Over the Cuckoo's Nest (1975)                 Drama  
1             One Flew Over the Cuckoo's Nest (1975)                 Drama  
2             One Flew Over the Cuckoo's Nest (1975)                 Drama  
3             One Flew Over the Cuckoo's Nest (1975)                 Drama  
4             One Flew Over the Cuckoo's Nest (1975)                 Drama  
...                                              ...                   ...  
1000204                           Modulations (1998)           Documentary  
1000205                        Broken Vessels (1998)                 Drama  
1000206                            White Boys (1999)                 Drama  
1000207                     One Little Indian (1973)  Comedy|Drama|Western  
1000208  Five Wives, Three Secretaries and Me (1998)           Documentary  
[1000209 rows x 10 columns]
data.iloc[0]
user_id                                            1
movie_id                                        1193
rating                                             5
timestamp                                  978300760
gender                                             F
age                                                1
occupation                                        10
zip                                            48067
title         One Flew Over the Cuckoo's Nest (1975)
genres                                         Drama
Name: 0, dtype: object
</code></pre>
<p>为了按性别计算每部电影的平均得分，我们可以使用<code>pivot_table</code>方法：</p>
<pre><code class="language-python">mean_ratings = data.pivot_table('rating', index='title',columns='gender', aggfunc='mean')
mean_ratings[:5]
gender                                F         M
title                                            
$1,000,000 Duck (1971)         3.375000  2.761905
'Night Mother (1986)           3.388889  3.352941
'Til There Was You (1997)      2.675676  2.733333
'burbs, The (1989)             2.793478  2.962085
...And Justice for All (1979)  3.828571  3.689024
</code></pre>
<p>该操作产生了另一个<code>DataFrame</code>，其内容为电影平均得分，行标为电影名称（索引），列标为性别。现在，我打算过滤掉评分数据不够250条的电影（随便选的一个数字）。为了达到这个目的，我先对<code>title</code>进行分组，然后利用<code>size()</code>得到一个含有各电影分组大小的<code>Series</code>对象：</p>
<pre><code class="language-python">ratings_by_title = data.groupby('title').size()
ratings_by_title[:10]
title
$1,000,000 Duck (1971)                37
'Night Mother (1986)                  70
'Til There Was You (1997)             52
'burbs, The (1989)                   303
...And Justice for All (1979)        199
1-900 (1994)                           2
10 Things I Hate About You (1999)    700
101 Dalmatians (1961)                565
101 Dalmatians (1996)                364
12 Angry Men (1957)                  616
dtype: int64
active_titles = ratings_by_title.index[ratings_by_title &gt;= 250]
active_titles
Index([''burbs, The (1989)', '10 Things I Hate About You (1999)',
       '101 Dalmatians (1961)', '101 Dalmatians (1996)', '12 Angry Men (1957)',
       '13th Warrior, The (1999)', '2 Days in the Valley (1996)',
       '20,000 Leagues Under the Sea (1954)', '2001: A Space Odyssey (1968)',
       '2010 (1984)',
       ...
'X-Men (2000)', 'Year of Living Dangerously (1982)',
       'Yellow Submarine (1968)', 'You've Got Mail (1998)',
       'Young Frankenstein (1974)', 'Young Guns (1988)',
       'Young Guns II (1990)', 'Young Sherlock Holmes (1985)',
       'Zero Effect (1998)', 'eXistenZ (1999)'],
      dtype='object', name='title', length=1216)
</code></pre>
<p>标题索引中含有评分数据大于250条的电影名称，然后我们就可以据此从前面的<code>mean_ratings</code>中选取所需的行了：</p>
<pre><code class="language-python">#Select rows on the index
mean_ratings = mean_ratings.loc[active_titles]
mean_ratings
gender                                    F         M
title                                                
'burbs, The (1989)                 2.793478  2.962085
10 Things I Hate About You (1999)  3.646552  3.311966
101 Dalmatians (1961)              3.791444  3.500000
101 Dalmatians (1996)              3.240000  2.911215
12 Angry Men (1957)                4.184397  4.328421
...                                     ...       ...
Young Guns (1988)                  3.371795  3.425620
Young Guns II (1990)               2.934783  2.904025
Young Sherlock Holmes (1985)       3.514706  3.363344
Zero Effect (1998)                 3.864407  3.723140
eXistenZ (1999)                    3.098592  3.289086
[1216 rows x 2 columns]
</code></pre>
<p>为了了解女性观众最喜欢的电影，我们可以对F列降序排列：</p>
<pre><code class="language-python">top_female_ratings = mean_ratings.sort_values(by='F', ascending=False)
top_female_ratings[:10]
gender                                                     F         M
title                                                                 
Close Shave, A (1995)                               4.644444  4.473795
Wrong Trousers, The (1993)                          4.588235  4.478261
Sunset Blvd. (a.k.a. Sunset Boulevard) (1950)       4.572650  4.464589
Wallace &amp; Gromit: The Best of Aardman Animation...  4.563107  4.385075
Schindler's List (1993)                             4.562602  4.491415
Shawshank Redemption, The (1994)                    4.539075  4.560625
Grand Day Out, A (1992)                             4.537879  4.293255
To Kill a Mockingbird (1962)                        4.536667  4.372611
Creature Comforts (1990)                            4.513889  4.272277
Usual Suspects, The (1995)                          4.513317  4.518248
</code></pre>
<h4 id="计算评分分歧">计算评分分歧</h4>
<p>假设我们想要找出男性和女性观众分歧最大的电影。一个办法是给<code>mean_ratings</code>加上一个用于存放平均得分之差的列，并对其进行排序：</p>
<pre><code class="language-python">mean_ratings['diff'] = mean_ratings['M'] - mean_ratings['F']
</code></pre>
<p>按<code>&quot;diff&quot;</code>排序即可得到分歧最大且女性观众更喜欢的电影：</p>
<pre><code class="language-python">sorted_by_diff = mean_ratings.sort_values(by='diff')
sorted_by_diff[:10]
gender                                        F         M      diff
title                                                              
Dirty Dancing (1987)                   3.790378  2.959596 -0.830782
Jumpin' Jack Flash (1986)              3.254717  2.578358 -0.676359
Grease (1978)                          3.975265  3.367041 -0.608224
Little Women (1994)                    3.870588  3.321739 -0.548849
Steel Magnolias (1989)                 3.901734  3.365957 -0.535777
Anastasia (1997)                       3.800000  3.281609 -0.518391
Rocky Horror Picture Show, The (1975)  3.673016  3.160131 -0.512885
Color Purple, The (1985)               4.158192  3.659341 -0.498851
Age of Innocence, The (1993)           3.827068  3.339506 -0.487561
Free Willy (1993)                      2.921348  2.438776 -0.482573
</code></pre>
<p>对排序结果反序并取出前10行，得到的则是男性观众更喜欢的电影：</p>
<pre><code class="language-python">#Reverse order of rows, take first 10 rows
sorted_by_diff[::-1][:10]
gender                                         F         M      diff
title                                                               
Good, The Bad and The Ugly, The (1966)  3.494949  4.221300  0.726351
Kentucky Fried Movie, The (1977)        2.878788  3.555147  0.676359
Dumb &amp; Dumber (1994)                    2.697987  3.336595  0.638608
Longest Day, The (1962)                 3.411765  4.031447  0.619682
Cable Guy, The (1996)                   2.250000  2.863787  0.613787
Evil Dead II (Dead By Dawn) (1987)      3.297297  3.909283  0.611985
Hidden, The (1987)                      3.137931  3.745098  0.607167
Rocky III (1982)                        2.361702  2.943503  0.581801
Caddyshack (1980)                       3.396135  3.969737  0.573602
For a Few Dollars More (1965)           3.409091  3.953795  0.544704
</code></pre>
<p>如果只是想要找出分歧最大的电影（不考虑性别因素），则可以计算得分数据的方差或标准差：</p>
<pre><code class="language-python">#Standard deviation of rating grouped by title
rating_std_by_title = data.groupby('title')['rating'].std()

#Filter down to active_titles
rating_std_by_title = rating_std_by_title.loc[active_titles]

#Order Series by value in descending order
rating_std_by_title.sort_values(ascending=False)[:10]
title
Dumb &amp; Dumber (1994)                     1.321333
Blair Witch Project, The (1999)          1.316368
Natural Born Killers (1994)              1.307198
Tank Girl (1995)                         1.277695
Rocky Horror Picture Show, The (1975)    1.260177
Eyes Wide Shut (1999)                    1.259624
Evita (1996)                             1.253631
Billy Madison (1995)                     1.249970
Fear and Loathing in Las Vegas (1998)    1.246408
Bicentennial Man (1999)                  1.245533
Name: rating, dtype: float64
</code></pre>
<p>可能你已经注意到了，电影分类是以竖线（<code>|</code>）分隔的字符串形式给出的。如果想对电影分类进行分析的话，就需要先将其转换成更有用的形式才行。</p>
<h3 id="1880-2010年间全美婴儿姓名">1880-2010年间全美婴儿姓名</h3>
<p>美国社会保障总署（SSA）提供了一份从1880年到现在的婴儿名字频率数据。</p>
<p>我们要做一些数据规整才能加载这个数据集，这么做就会产生一个如下的<code>DataFrame</code>：</p>
<pre><code class="language-python">names.head(10)
        name sex  births  year
0       Mary   F    7065  1880
1       Anna   F    2604  1880
2       Emma   F    2003  1880
3  Elizabeth   F    1939  1880
4     Minnie   F    1746  1880
5   Margaret   F    1578  1880
6        Ida   F    1472  1880
7      Alice   F    1414  1880
8     Bertha   F    1320  1880
9      Sarah   F    1288  1880
</code></pre>
<p>你可以用这个数据集做很多事，例如：</p>
<ul>
<li>计算指定名字（可以是你自己的，也可以是别人的）的年度比例。</li>
<li>计算某个名字的相对排名。</li>
<li>计算各年度最流行的名字，以及增长或减少最快的名字。</li>
<li>分析名字趋势：元音、辅音、长度、总体多样性、拼写变化、首尾字母等。</li>
<li>分析外源性趋势：圣经中的名字、名人、人口结构变化等。<br>
利用前面介绍过的那些工具，这些分析工作都能很轻松地完成，我会讲解其中的一些。</li>
</ul>
<p>到编写本书时为止，美国社会保障总署将该数据库按年度制成了多个数据文件，其中给出了每个性别/名字组合的出生总数。</p>
<p>下载&quot;National data&quot;文件names.zip，解压后的目录中含有一组文件（如yob1880.txt）。我用UNIX的head命令查看了其中一个文件的前10行（在Windows上，你可以用more命令，或直接在文本编辑器中打开）：</p>
<pre><code class="language-python">!head -n 10 datasets/babynames/yob1880.txt
Mary,F,7065
Anna,F,2604
Emma,F,2003
Elizabeth,F,1939
Minnie,F,1746
Margaret,F,1578
Ida,F,1472
Alice,F,1414
Bertha,F,1320
Sarah,F,1288
</code></pre>
<p>由于这是一个非常标准的以逗号隔开的格式，所以可以用<code>pandas.read_csv</code>将其加载到<code>DataFrame</code>中：</p>
<pre><code class="language-python">import pandas as pd
names1880 =pd.read_csv('datasets/babynames/yob1880.txt',names=['name', 'sex', 'births'])
names1880
           name sex  births
0          Mary   F    7065
1          Anna   F    2604
2          Emma   F    2003
3     Elizabeth   F    1939
4        Minnie   F    1746
...         ...  ..     ...
1995     Woodie   M       5
1996     Worthy   M       5
1997     Wright   M       5
1998       York   M       5
1999  Zachariah   M       5
[2000 rows x 3 columns]
</code></pre>
<p>这些文件中仅含有当年出现超过5次的名字。为了简单起见，我们可以用<code>births</code>列的<code>sex</code>分组小计表示该年度的<code>births</code>总计：</p>
<pre><code class="language-python">names1880.groupby('sex').births.sum()
sex
F     90993
M    110493
Name: births, dtype: int64
</code></pre>
<p>由于该数据集按年度被分隔成了多个文件，所以第一件事情就是要将所有数据都组装到一个<code>DataFrame</code>里面，并加上一个<code>year</code>字段。使用<code>pandas.concat</code>即可达到这个目的：</p>
<pre><code class="language-python">years = range(1880, 2011)

pieces = []
columns = ['name', 'sex', 'births']

for year in years:
    path = 'datasets/babynames/yob%d.txt' % year
    frame = pd.read_csv(path, names=columns)

    frame['year'] = year
    pieces.append(frame)
#Concatenate everything into a single DataFrame
names = pd.concat(pieces, ignore_index=True)
</code></pre>
<p>这里需要注意几件事情。第一，<code>concat</code>默认是按行将多个<code>DataFrame</code>组合到一起的；第二，必须指定<code>ignore_index=True</code>，因为我们不希望保留<code>read_csv</code>所返回的原始行号。现在我们得到了一个非常大的<code>DataFrame</code>，它含有全部的名字数据：</p>
<pre><code class="language-python">names
              name sex  births  year
0             Mary   F    7065  1880
1             Anna   F    2604  1880
2             Emma   F    2003  1880
3        Elizabeth   F    1939  1880
4           Minnie   F    1746  1880
...            ...  ..     ...   ...
1690779    Zymaire   M       5  2010
1690780     Zyonne   M       5  2010
1690781  Zyquarius   M       5  2010
1690782      Zyran   M       5  2010
1690783      Zzyzx   M       5  2010
[1690784 rows x 4 columns]
</code></pre>
<p>有了这些数据之后，我们就可以利用<code>groupby</code>或<code>pivot_table</code>在<code>year</code>和<code>sex</code>级别上对其进行聚合了，如下图所示：</p>
<pre><code class="language-python">total_births = names.pivot_table('births', index='year',columns='sex', aggfunc=sum)
total_births.tail()
sex         F        M
year                  
2006  1896468  2050234
2007  1916888  2069242
2008  1883645  2032310
2009  1827643  1973359
2010  1759010  1898382
total_births.plot(title='Total births by sex and year')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410022325.png" alt="" loading="lazy"><br>
下面我们来插入一个<code>prop</code>列，用于存放指定名字的婴儿数相对于总出生数的比例。<code>prop</code>值为0.02表示每100名婴儿中有2名取了当前这个名字。因此，我们先按<code>year</code>和<code>sex</code>分组，然后再将新列加到各个分组上：</p>
<pre><code class="language-python">def add_prop(group):
    group['prop'] = group.births / group.births.sum()
    return group
names = names.groupby(['year', 'sex']).apply(add_prop)
</code></pre>
<p>现在，完整的数据集就有了下面这些列：</p>
<pre><code class="language-python">names
              name sex  births  year      prop
0             Mary   F    7065  1880  0.077643
1             Anna   F    2604  1880  0.028618
2             Emma   F    2003  1880  0.022013
3        Elizabeth   F    1939  1880  0.021309
4           Minnie   F    1746  1880  0.019188
...            ...  ..     ...   ...       ...
1690779    Zymaire   M       5  2010  0.000003
1690780     Zyonne   M       5  2010  0.000003
1690781  Zyquarius   M       5  2010  0.000003
1690782      Zyran   M       5  2010  0.000003
1690783      Zzyzx   M       5  2010  0.000003
[1690784 rows x 5 columns]
</code></pre>
<p>在执行这样的分组处理时，一般都应该做一些有效性检查，比如验证所有分组的<code>prop</code>的总和是否为1：</p>
<pre><code class="language-python">names.groupby(['year', 'sex']).prop.sum()
year  sex
1880  F      1.0
      M      1.0
1881  F      1.0
      M      1.0
1882  F      1.0
            ... 
2008  M      1.0
2009  F      1.0
      M      1.0
2010  F      1.0
      M      1.0
Name: prop, Length: 262, dtype: float64
</code></pre>
<p>工作完成。为了便于实现更进一步的分析，我需要取出该数据的一个子集：每对<code>sex</code>/<code>year</code>组合的前1000个名字。这又是一个分组操作：</p>
<pre><code class="language-python">def get_top1000(group):
    return group.sort_values(by='births', ascending=False)[:1000]
grouped = names.groupby(['year', 'sex'])
top1000 = grouped.apply(get_top1000)
#Drop the group index, not needed
top1000.reset_index(inplace=True, drop=True)
</code></pre>
<p>如果你喜欢DIY的话，也可以这样：</p>
<pre><code class="language-python">pieces = []
for year, group in names.groupby(['year', 'sex']):
    pieces.append(group.sort_values(by='births', ascending=False)[:1000])
top1000 = pd.concat(pieces, ignore_index=True)
</code></pre>
<p>现在的结果数据集就小多了：</p>
<pre><code class="language-python">top1000
             name sex  births  year      prop
0            Mary   F    7065  1880  0.077643
1            Anna   F    2604  1880  0.028618
2            Emma   F    2003  1880  0.022013
3       Elizabeth   F    1939  1880  0.021309
4          Minnie   F    1746  1880  0.019188
...           ...  ..     ...   ...       ...
261872     Camilo   M     194  2010  0.000102
261873     Destin   M     194  2010  0.000102
261874     Jaquan   M     194  2010  0.000102
261875     Jaydan   M     194  2010  0.000102
261876     Maxton   M     193  2010  0.000102
[261877 rows x 5 columns]
</code></pre>
<p>接下来的数据分析工作就针对这个top1000数据集了。</p>
<h4 id="分析命名趋势">分析命名趋势</h4>
<p>有了完整的数据集和刚才生成的top1000数据集，我们就可以开始分析各种命名趋势了。首先将前1000个名字分为男女两个部分：</p>
<pre><code class="language-python">boys = top1000[top1000.sex == 'M']

girls = top1000[top1000.sex == 'F']
</code></pre>
<p>这是两个简单的时间序列，只需稍作整理即可绘制出相应的图表（比如每年叫做John和Mary的婴儿数）。我们先生成一张按<code>year</code>和<code>name</code>统计的总出生数透视表：</p>
<pre><code class="language-python">total_births = top1000.pivot_table('births', index='year',columns='name',aggfunc=sum)
</code></pre>
<p>现在，我们用<code>DataFrame</code>的<code>plot</code>方法绘制几个名字的曲线图（见下图）：</p>
<pre><code class="language-python">total_births.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 131 entries, 1880 to 2010
Columns: 6868 entries, Aaden to Zuri
dtypes: float64(6868)
memory usage: 6.9 MB
subset = total_births[['John', 'Harry', 'Mary', 'Marilyn']]
subset.plot(subplots=True, figsize=(12, 10), grid=False,title=&quot;Number of births per year&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410023626.png" alt="" loading="lazy"><br>
从图中可以看出，这几个名字在美国人民的心目中已经风光不再了。但事实并非如此简单，我们在下一节中就能知道是怎么一回事了。</p>
<h4 id="评估命名多样性的增长">评估命名多样性的增长</h4>
<p>一种解释是父母愿意给小孩起常见的名字越来越少。这个假设可以从数据中得到验证。一个办法是计算最流行的1000个名字所占的比例，我按<code>year</code>和<code>sex</code>进行聚合并绘图（见下图）：</p>
<pre><code class="language-python">table = top1000.pivot_table('prop', index='year',columns='sex', aggfunc=sum)
table.plot(title='Sum of table1000.prop by year and sex',yticks=np.linspace(0, 1.2, 13), xticks=range(1880, 2020, 10))
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410023852.png" alt="" loading="lazy"><br>
从图中可以看出，名字的多样性确实出现了增长（前1000项的比例降低）。另一个办法是计算占总出生人数前50%的不同名字的数量，这个数字不太好计算。我们只考虑2010年男孩的名字：</p>
<pre><code class="language-python">df = boys[boys.year == 2010]
df
           name sex  births  year      prop
260877    Jacob   M   21875  2010  0.011523
260878    Ethan   M   17866  2010  0.009411
260879  Michael   M   17133  2010  0.009025
260880   Jayden   M   17030  2010  0.008971
260881  William   M   16870  2010  0.008887
...         ...  ..     ...   ...       ...
261872   Camilo   M     194  2010  0.000102
261873   Destin   M     194  2010  0.000102
261874   Jaquan   M     194  2010  0.000102
261875   Jaydan   M     194  2010  0.000102
261876   Maxton   M     193  2010  0.000102
[1000 rows x 5 columns]
</code></pre>
<p>在对<code>prop</code>降序排列之后，我们想知道前面多少个名字的人数加起来才够50%。虽然编写一个<code>for</code>循环确实也能达到目的，但<code>NumPy</code>有一种更聪明的矢量方式。先计算<code>prop</code>的累计和<code>cumsum</code>，然后再通过<code>searchsorted</code>方法找出0.5应该被插入在哪个位置才能保证不破坏顺序：</p>
<pre><code class="language-python">prop_cumsum = df.sort_values(by='prop', ascending=False).prop.cumsum()
prop_cumsum[:10]
260877    0.011523
260878    0.020934
260879    0.029959
260880    0.038930
260881    0.047817
260882    0.056579
260883    0.065155
260884    0.073414
260885    0.081528
260886    0.089621
Name: prop, dtype: float64
prop_cumsum.values.searchsorted(0.5)
116
</code></pre>
<p>由于数组索引是从0开始的，因此我们要给这个结果加1，即最终结果为117。拿1900年的数据来做个比较，这个数字要小得多：</p>
<pre><code class="language-python">df = boys[boys.year == 1900]
in1900 = df.sort_values(by='prop', ascending=False).prop.cumsum()
in1900.values.searchsorted(0.5) + 1
25
</code></pre>
<p>现在就可以对所有<code>year</code>/<code>sex</code>组合执行这个计算了。按这两个字段进行<code>groupby</code>处理，然后用一个函数计算各分组的这个值：</p>
<pre><code class="language-python">def get_quantile_count(group, q=0.5):
    group = group.sort_values(by='prop', ascending=False)
    return group.prop.cumsum().values.searchsorted(q) + 1

diversity = top1000.groupby(['year', 'sex']).apply(get_quantile_count)
diversity = diversity.unstack('sex')
</code></pre>
<p>现在，<code>diversity</code>这个<code>DataFrame</code>拥有两个时间序列（每个性别各一个，按年度索引）。如下图所示：</p>
<pre><code class="language-python">diversity.head()
sex    F   M
year        
1880  38  14
1881  38  14
1882  38  15
1883  39  15
1884  39  16
diversity.plot(title=&quot;Number of popular names in top 50%&quot;)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410024319.png" alt="" loading="lazy"><br>
从图中可以看出，女孩名字的多样性总是比男孩的高，而且还在变得越来越高。读者们可以自己分析一下具体是什么在驱动这个多样性（比如拼写形式的变化）。</p>
<h4 id="最后一个字母的变革">“最后一个字母”的变革</h4>
<p>2007年，一名婴儿姓名研究人员Laura Wattenberg在她自己的网站上指出：近百年来，男孩名字在最后一个字母上的分布发生了显著的变化。为了了解具体的情况，我首先将全部出生数据在年度、性别以及末字母上进行了聚合：</p>
<pre><code class="language-python">#extract last letter from name column
get_last_letter = lambda x: x[-1]
last_letters = names.name.map(get_last_letter)
last_letters.name = 'last_letter'
table = names.pivot_table('births', index=last_letters,
                          columns=['sex', 'year'], aggfunc=sum)
</code></pre>
<p>然后，我选出具有一定代表性的三年，并输出前面几行：</p>
<pre><code class="language-python">subtable = table.reindex(columns=[1910, 1960, 2010], level='year')
subtable.head()
sex                 F                            M                    
year             1910      1960      2010     1910      1960      2010
last_letter                                                           
a            108376.0  691247.0  670605.0    977.0    5204.0   28438.0
b                 NaN     694.0     450.0    411.0    3912.0   38859.0
c                 5.0      49.0     946.0    482.0   15476.0   23125.0
d              6750.0    3729.0    2607.0  22111.0  262112.0   44398.0
e            133569.0  435013.0  313833.0  28655.0  178823.0  129012.0
</code></pre>
<p>接下来我们需要按总出生数对该表进行规范化处理，以便计算出各性别各末字母占总出生人数的比例：</p>
<pre><code class="language-python">subtable.sum()
sex  year
F    1910     396416.0
     1960    2022062.0
     2010    1759010.0
M    1910     194198.0
     1960    2132588.0
2010    1898382.0
dtype: float64
letter_prop = subtable / subtable.sum()
letter_prop
sex                 F                             M                    
year             1910      1960      2010      1910      1960      2010
last_letter                                                            
a            0.273390  0.341853  0.381240  0.005031  0.002440  0.014980
b                 NaN  0.000343  0.000256  0.002116  0.001834  0.020470
c            0.000013  0.000024  0.000538  0.002482  0.007257  0.012181
d            0.017028  0.001844  0.001482  0.113858  0.122908  0.023387
e            0.336941  0.215133  0.178415  0.147556  0.083853  0.067959
...               ...       ...       ...       ...       ...       ...
v                 NaN  0.000060  0.000117  0.000113
0.000037  0.001434
w            0.000020  0.000031  0.001182  0.006329  0.007711  0.016148
x            0.000015  0.000037  0.000727  0.003965  0.001851  0.008614
y            0.110972  0.152569  0.116828  0.077349  0.160987  0.058168
z            0.002439  0.000659  0.000704  0.000170  0.000184  0.001831
[26 rows x 6 columns]
</code></pre>
<p>有了这个字母比例数据之后，就可以生成一张各年度各性别的条形图了，如下图所示：</p>
<pre><code class="language-python">import matplotlib.pyplot as plt

fig, axes = plt.subplots(2, 1, figsize=(10, 8))
letter_prop['M'].plot(kind='bar', rot=0, ax=axes[0], title='Male')
letter_prop['F'].plot(kind='bar', rot=0, ax=axes[1], title='Female',legend=False)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410024619.png" alt="" loading="lazy"><br>
可以看出，从20世纪60年代开始，以字母&quot;n&quot;结尾的男孩名字出现了显著的增长。回到之前创建的那个完整表，按年度和性别对其进行规范化处理，并在男孩名字中选取几个字母，最后进行转置以便将各个列做成一个时间序列：</p>
<pre><code class="language-python">letter_prop = table / table.sum()
dny_ts = letter_prop.loc[['d', 'n', 'y'], 'M'].T
dny_ts.head()
last_letter         d         n         y
year                                     
1880         0.083055  0.153213  0.075760
1881         0.083247  0.153214  0.077451
1882         0.085340  0.149560  0.077537
1883         0.084066  0.151646  0.079144
1884         0.086120  0.149915  0.080405
</code></pre>
<p>有了这个时间序列的<code>DataFrame</code>之后，就可以通过其<code>plot</code>方法绘制出一张趋势图了（如下图所示）：</p>
<pre><code class="language-python">dny_ts.plot()
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410024730.png" alt="" loading="lazy"></figure>
<h4 id="变成女孩名字的男孩名字以及相反的情况">变成女孩名字的男孩名字（以及相反的情况）</h4>
<p>另一个有趣的趋势是，早年流行于男孩的名字近年来“变性了”，例如Lesley或Leslie。回到top1000数据集，找出其中以&quot;lesl&quot;开头的一组名字：</p>
<pre><code class="language-python">all_names = pd.Series(top1000.name.unique())
lesley_like = all_names[all_names.str.lower().str.contains('lesl')]
lesley_like
632     Leslie
2294    Lesley
4262    Leslee
4728     Lesli
6103     Lesly
dtype: object
</code></pre>
<p>然后利用这个结果过滤其他的名字，并按名字分组计算出生数以查看相对频率：</p>
<pre><code class="language-python">filtered = top1000[top1000.name.isin(lesley_like)]
filtered.groupby('name').births.sum()
name
Leslee      1082
Lesley     35022
Lesli        929
Leslie    370429
Lesly      10067
Name: births, dtype: int64
</code></pre>
<p>接下来，我们按性别和年度进行聚合，并按年度进行规范化处理：</p>
<pre><code class="language-python">table = filtered.pivot_table('births', index='year',columns='sex', aggfunc='sum')
table = table.div(table.sum(1), axis=0)
table.tail()
sex     F   M
year         
2006  1.0 NaN
2007  1.0 NaN
2008  1.0 NaN
2009  1.0 NaN
2010  1.0 NaN
</code></pre>
<p>最后，就可以轻松绘制一张分性别的年度曲线图了（如下图所示）：</p>
<pre><code class="language-python">table.plot(style={'M': 'k-', 'F': 'k--'})
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410025009.png" alt="" loading="lazy"></figure>
<h3 id="usda食品数据库">USDA食品数据库</h3>
<p>美国农业部（USDA）制作了一份有关食物营养信息的数据库。Ashley Williams制作了该数据的<code>JSON</code>版</p>
<pre><code class="language-js">{
  &quot;id&quot;: 21441,
  &quot;description&quot;: &quot;KENTUCKY FRIED CHICKEN, Fried Chicken, EXTRA CRISPY,
Wing, meat and skin with breading&quot;,
  &quot;tags&quot;: [&quot;KFC&quot;],
  &quot;manufacturer&quot;: &quot;Kentucky Fried Chicken&quot;,
&quot;group&quot;: &quot;Fast Foods&quot;,
  &quot;portions&quot;: [
    {
      &quot;amount&quot;: 1,
      &quot;unit&quot;: &quot;wing, with skin&quot;,
      &quot;grams&quot;: 68.0
    },

    ...
  ],
  &quot;nutrients&quot;: [
    {
      &quot;value&quot;: 20.8,
      &quot;units&quot;: &quot;g&quot;,
      &quot;description&quot;: &quot;Protein&quot;,
      &quot;group&quot;: &quot;Composition&quot;
    },

    ...
  ]
}
</code></pre>
<p>每种食物都带有若干标识性属性以及两个有关营养成分和分量的列表。这种形式的数据不是很适合分析工作，因此我们需要做一些规整化以使其具有更好用的形式。</p>
<p>从上面列举的那个网址下载并解压数据之后，你可以用任何喜欢的<code>JSON</code>库将其加载到<code>Python</code>中。我用的是<code>Python</code>内置的<code>json</code>模块：</p>
<pre><code class="language-python">import json
db = json.load(open('datasets/usda_food/database.json'))
len(db)
6636
</code></pre>
<p><code>db</code>中的每个条目都是一个含有某种食物全部数据的字典。<code>nutrients</code>字段是一个字典列表，其中的每个字典对应一种营养成分：</p>
<pre><code class="language-python">db[0].keys()
dict_keys(['id', 'description', 'tags', 'manufacturer', 'group', 'portions', 'nutrients'])
db[0]['nutrients'][0]
{'description': 'Protein',
 'group': 'Composition',
 'units': 'g',
 'value': 25.18}
nutrients = pd.DataFrame(db[0]['nutrients'])
nutrients[:7]
                   description        group units    value
0                      Protein  Composition     g    25.18
1            Total lipid (fat)  Composition     g    29.20
2  Carbohydrate, by difference  Composition     g     3.06
3                          Ash        Other     g     3.28
4                       Energy       Energy  kcal   376.00
5                        Water  Composition     g    39.28
6                       Energy       Energy    kJ  1573.00
</code></pre>
<p>在将字典列表转换为<code>DataFrame</code>时，可以只抽取其中的一部分字段。这里，我们将取出食物的名称、分类、编号以及制造商等信息：</p>
<pre><code class="language-python">info_keys = ['description', 'group', 'id', 'manufacturer']
info = pd.DataFrame(db, columns=info_keys)
info[:5]
                          description                   group    id  \
0                     Cheese, caraway  Dairy and Egg Products  1008   
1                     Cheese, cheddar  Dairy and Egg Products  1009
2                        Cheese, edam  Dairy and Egg Products  1018   
3                        Cheese, feta  Dairy and Egg Products  1019   
4  Cheese, mozzarella, part skim milk  Dairy and Egg Products  1028   
  manufacturer  
0               
1               
2               
3               
4               
info.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6636 entries, 0 to 6635
Data columns (total 4 columns):
description     6636 non-null object
group           6636 non-null object
id              6636 non-null int64
manufacturer    5195 non-null object
dtypes: int64(1), object(3)
memory usage: 207.5+ KB
</code></pre>
<p>通过<code>value_counts</code>，你可以查看食物类别的分布情况：</p>
<pre><code class="language-python">pd.value_counts(info.group)[:10]
Vegetables and Vegetable Products    812
Beef Products                        618
Baked Products                       496
Breakfast Cereals                    403
Fast Foods                           365
Legumes and Legume Products          365
Lamb, Veal, and Game Products        345
Sweets                               341
Pork Products                        328
Fruits and Fruit Juices              328
Name: group, dtype: int64
</code></pre>
<p>现在，为了对全部营养数据做一些分析，最简单的办法是将所有食物的营养成分整合到一个大表中。我们分几个步骤来实现该目的。首先，将各食物的营养成分列表转换为一个<code>DataFrame</code>，并添加一个表示编号的列，然后将该<code>DataFrame</code>添加到一个列表中。最后通过<code>concat</code>将这些东西连接起来就可以了：</p>
<p>顺利的话，<code>nutrients</code>的结果是：</p>
<pre><code class="language-python">nutrients
                               description        group units    value     id
0                                  Protein  Composition     g   25.180   1008
1                        Total lipid (fat)  Composition     g   29.200   1008
2              Carbohydrate, by difference  Composition     g    3.060   1008
3                                      Ash        Other     g    3.280   1008
4                                   Energy       Energy  kcal  376.000   1008
...                                    ...          ...
...      ...    ...
389350                 Vitamin B-12, added     Vitamins   mcg    0.000  43546
389351                         Cholesterol        Other    mg    0.000  43546
389352        Fatty acids, total saturated        Other     g    0.072  43546
389353  Fatty acids, total monounsaturated        Other     g    0.028  43546
389354  Fatty acids, total polyunsaturated        Other     g    0.041  43546
[389355 rows x 5 columns]
</code></pre>
<p>我发现这个<code>DataFrame</code>中无论如何都会有一些重复项，所以直接丢弃就可以了：</p>
<pre><code class="language-python">nutrients.duplicated().sum()  # number of duplicates
14179
nutrients = nutrients.drop_duplicates()
</code></pre>
<p>由于两个DataFrame对象中都有<code>&quot;group&quot;</code>和<code>&quot;description&quot;</code>，所以为了明确到底谁是谁，我们需要对它们进行重命名：</p>
<pre><code class="language-python">col_mapping = {'description' : 'food','group'       : 'fgroup'}
info = info.rename(columns=col_mapping, copy=False)
info.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6636 entries, 0 to 6635
Data columns (total 4 columns):
food            6636 non-null object
fgroup          6636 non-null object
id              6636 non-null int64
manufacturer    5195 non-null object
dtypes: int64(1), object(3)
memory usage: 207.5+ KB
col_mapping = {'description' : 'nutrient','group' : 'nutgroup'}
nutrients = nutrients.rename(columns=col_mapping, copy=False)
nutrients
                                  nutrient     nutgroup units    value     id
0                                  Protein  Composition     g   25.180   1008
1                        Total lipid (fat)  Composition     g   29.200   1008
2              Carbohydrate, by difference  Composition     g    3.060   1008
3                                      Ash        Other     g    3.280   1008
4                                   Energy       Energy  kcal  376.000   1008
...                                    ...          ...   ...      ...    ...
389350                 Vitamin B-12, added     Vitamins   mcg    0.000  43546
389351                         Cholesterol        Other    mg    0.000  43546
389352        Fatty acids, total saturated        Other     g    0.072  43546
389353  Fatty acids, total monounsaturated        Other     g    0.028  43546
389354  Fatty acids, total polyunsaturated        Other     g    0.041  43546
[375176 rows x 5 columns]
</code></pre>
<p>做完这些，就可以将<code>info</code>跟<code>nutrients</code>合并起来：</p>
<pre><code class="language-python">ndata = pd.merge(nutrients, info, on='id', how='outer')
ndata.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
Int64Index: 375176 entries, 0 to 375175
Data columns (total 8 columns):
nutrient        375176 non-null object
nutgroup        375176 non-null object
units           375176 non-null object
value           375176 non-null float64
id              375176 non-null int64
food            375176 non-null object
fgroup          375176 non-null object
manufacturer    293054 non-null object
dtypes: float64(1), int64(1), object(6)
memory usage: 25.8+ MB
ndata.iloc[30000]
nutrient                                       Glycine
nutgroup                                   Amino Acids
units                                                g
value                                             0.04
id                                                6158
food            Soup, tomato bisque, canned, condensed
fgroup                      Soups, Sauces, and Gravies
manufacturer                                          
Name: 30000, dtype: object
</code></pre>
<p>我们现在可以根据食物分类和营养类型画出一张中位值图（如下图所示）：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410025126.png" alt="" loading="lazy"><br>
只要稍微动一动脑子，就可以发现各营养成分最为丰富的食物是什么了：</p>
<pre><code class="language-python">by_nutrient = ndata.groupby(['nutgroup', 'nutrient'])

get_maximum = lambda x: x.loc[x.value.idxmax()]
get_minimum = lambda x: x.loc[x.value.idxmin()]

max_foods = by_nutrient.apply(get_maximum)[['value', 'food']]

#make the food a little smaller
max_foods.food = max_foods.food.str[:50]
</code></pre>
<p>由于得到的<code>DataFrame</code>很大，所以不方便在书里面全部打印出来。这里只给出&quot;Amino Acids&quot;营养分组：</p>
<pre><code class="language-python">max_foods.loc['Amino Acids']['food']
nutrient
Alanine                          Gelatins, dry powder, unsweetened
Arginine                              Seeds, sesame flour, low-fat
Aspartic acid                                  Soy protein isolate
Cystine               Seeds, cottonseed flour, low fat (glandless)
Glutamic acid                                  Soy protein isolate
                                       ...                        
Serine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...
Threonine        Soy protein isolate, PROTEIN TECHNOLOGIES INTE...
Tryptophan        Sea lion, Steller, meat with fat (Alaska Native)
Tyrosine         Soy protein isolate, PROTEIN TECHNOLOGIES INTE...
Valine           Soy protein isolate, PROTEIN TECHNOLOGIES INTE...
Name: food, Length: 19, dtype: object
</code></pre>
<h3 id="2012联邦选举委员会数据库">2012联邦选举委员会数据库</h3>
<p>美国联邦选举委员会发布了有关政治竞选赞助方面的数据。其中包括赞助者的姓名、职业、雇主、地址以及出资额等信息。我们对2012年美国总统大选的数据集比较感兴趣。我在2012年6月下载的数据集是一个150MB的CSV文件（P00000001-ALL.csv），我们先用<code>pandas.read_csv</code>将其加载进来：</p>
<pre><code class="language-python">fec = pd.read_csv('datasets/fec/P00000001-ALL.csv')
fec.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 1001731 entries, 0 to 1001730
Data columns (total 16 columns):
cmte_id              1001731 non-null object
cand_id              1001731 non-null object
cand_nm              1001731 non-null object
contbr_nm            1001731 non-null object
contbr_city          1001712 non-null object
contbr_st            1001727 non-null object
contbr_zip           1001620 non-null object
contbr_employer      988002 non-null object
contbr_occupation    993301 non-null object
contb_receipt_amt    1001731 non-null float64
contb_receipt_dt     1001731 non-null object
receipt_desc         14166 non-null object
memo_cd              92482 non-null object
memo_text            97770 non-null object
form_tp              1001731 non-null object
file_num             1001731 non-null int64
dtypes: float64(1), int64(1), object(14)
memory usage: 122.3+ MB
</code></pre>
<p>该<code>DataFrame</code>中的记录如下所示：</p>
<pre><code class="language-python">fec.iloc[123456]
cmte_id             C00431445
cand_id             P80003338
cand_nm         Obama, Barack
contbr_nm         ELLMAN, IRA
contbr_city             TEMPE
                    ...      
receipt_desc              NaN
memo_cd                   NaN
memo_text                 NaN
form_tp                 SA17A
file_num               772372
Name: 123456, Length: 16, dtype: object
</code></pre>
<p>你可能已经想出了许多办法从这些竞选赞助数据中抽取有关赞助人和赞助模式的统计信息。我将在接下来的内容中介绍几种不同的分析工作（运用到目前为止已经学到的方法）。</p>
<p>不难看出，该数据中没有党派信息，因此最好把它加进去。通过<code>unique</code>，你可以获取全部的候选人名单：</p>
<pre><code class="language-python">unique_cands = fec.cand_nm.unique()
unique_cands
array(['Bachmann, Michelle', 'Romney, Mitt', 'Obama, Barack',
       &quot;Roemer, Charles E. 'Buddy' III&quot;, 'Pawlenty, Timothy',
       'Johnson, Gary Earl', 'Paul, Ron', 'Santorum, Rick', 'Cain, Herman',
       'Gingrich, Newt', 'McCotter, Thaddeus G', 'Huntsman, Jon',
       'Perry, Rick'], dtype=object)
unique_cands[2]
'Obama, Barack'
</code></pre>
<p>指明党派信息的方法之一是使用字典：</p>
<pre><code class="language-python">parties = {'Bachmann, Michelle': 'Republican',
           'Cain, Herman': 'Republican',
           'Gingrich, Newt': 'Republican',
           'Huntsman, Jon': 'Republican',
           'Johnson, Gary Earl': 'Republican',
           'McCotter, Thaddeus G': 'Republican',
           'Obama, Barack': 'Democrat',
           'Paul, Ron': 'Republican',
           'Pawlenty, Timothy': 'Republican',
           'Perry, Rick': 'Republican',
           &quot;Roemer, Charles E. 'Buddy' III&quot;: 'Republican',
           'Romney, Mitt': 'Republican',
           'Santorum, Rick': 'Republican'}
</code></pre>
<p>现在，通过这个映射以及<code>Series</code>对象的<code>map</code>方法，你可以根据候选人姓名得到一组党派信息：</p>
<pre><code class="language-python">fec.cand_nm[123456:123461]
123456    Obama, Barack
123457    Obama, Barack
123458    Obama, Barack
123459    Obama, Barack
123460    Obama, Barack
Name: cand_nm, dtype: object
fec.cand_nm[123456:123461].map(parties)
123456    Democrat
123457    Democrat
123458    Democrat
123459    Democrat
123460    Democrat
Name: cand_nm, dtype: object

#Add it as a column
fec['party'] = fec.cand_nm.map(parties)
fec['party'].value_counts()
Democrat      593746
Republican    407985
Name: party, dtype: int64
</code></pre>
<p>这里有两个需要注意的地方。第一，该数据既包括赞助也包括退款（负的出资额）：</p>
<pre><code class="language-python">(fec.contb_receipt_amt &gt; 0).value_counts()
True     991475
False     10256
Name: contb_receipt_amt, dtype: int64
</code></pre>
<p>为了简化分析过程，我限定该数据集只能有正的出资额：</p>
<pre><code class="language-python">fec = fec[fec.contb_receipt_amt &gt; 0]
</code></pre>
<p>由于Barack Obama和Mitt Romney是最主要的两名候选人，所以我还专门准备了一个子集，只包含针对他们两人的竞选活动的赞助信息：</p>
<pre><code class="language-python">fec_mrbo = fec[fec.cand_nm.isin(['Obama, Barack','Romney, Mitt'])]
</code></pre>
<h4 id="根据职业和雇主统计赞助信息">根据职业和雇主统计赞助信息</h4>
<p>基于职业的赞助信息统计是另一种经常被研究的统计任务。例如，律师们更倾向于资助民主党，而企业主则更倾向于资助共和党。你可以不相信我，自己看那些数据就知道了。首先，根据职业计算出资总额，这很简单：</p>
<pre><code class="language-python">fec.contbr_occupation.value_counts()[:10]
RETIRED                                   233990
INFORMATION REQUESTED                      35107
ATTORNEY                                   34286
HOMEMAKER                                  29931
PHYSICIAN                                  23432
INFORMATION REQUESTED PER BEST EFFORTS     21138
ENGINEER                                   14334
TEACHER                                    13990
CONSULTANT                                 13273
PROFESSOR                                  12555
Name: contbr_occupation, dtype: int64
</code></pre>
<p>不难看出，许多职业都涉及相同的基本工作类型，或者同一样东西有多种变体。下面的代码片段可以清理一些这样的数据（将一个职业信息映射到另一个）。注意，这里巧妙地利用了<code>dict.get</code>，它允许没有映射关系的职业也能“通过”：</p>
<pre><code class="language-python">occ_mapping = {
   'INFORMATION REQUESTED PER BEST EFFORTS' : 'NOT PROVIDED',
   'INFORMATION REQUESTED' : 'NOT PROVIDED',
   'INFORMATION REQUESTED (BEST EFFORTS)' : 'NOT PROVIDED',
   'C.E.O.': 'CEO'
}

#If no mapping provided, return x
f = lambda x: occ_mapping.get(x, x)
fec.contbr_occupation = fec.contbr_occupation.map(f)
</code></pre>
<p>我对雇主信息也进行了同样的处理：</p>
<pre><code class="language-python">emp_mapping = {
   'INFORMATION REQUESTED PER BEST EFFORTS' : 'NOT PROVIDED',
   'INFORMATION REQUESTED' : 'NOT PROVIDED',
   'SELF' : 'SELF-EMPLOYED',
   'SELF EMPLOYED' : 'SELF-EMPLOYED',
}

#If no mapping provided, return x
f = lambda x: emp_mapping.get(x, x)
fec.contbr_employer = fec.contbr_employer.map(f)
</code></pre>
<p>现在，你可以通过<code>pivot_table</code>根据党派和职业对数据进行聚合，然后过滤掉总出资额不足200万美元的数据：</p>
<pre><code class="language-python">by_occupation = fec.pivot_table('contb_receipt_amt',index='contbr_occupation',columns='party', aggfunc='sum')
over_2mm = by_occupation[by_occupation.sum(1) &gt; 2000000]
over_2mm
party                 Democrat    Republican
contbr_occupation                           
ATTORNEY           11141982.97  7.477194e+06
CEO                 2074974.79  4.211041e+06
CONSULTANT          2459912.71  2.544725e+06
ENGINEER             951525.55  1.818374e+06
EXECUTIVE           1355161.05  4.138850e+06
...                        ...           ...
PRESIDENT           1878509.95  4.720924e+06
PROFESSOR           2165071.08  2.967027e+05
REAL ESTATE          528902.09  1.625902e+06
RETIRED            25305116.38  2.356124e+07
SELF-EMPLOYED        672393.40  1.640253e+06
[17 rows x 2 columns]
</code></pre>
<p>把这些数据做成柱状图看起来会更加清楚（<code>'barh'</code>表示水平柱状图，如下图所示）：</p>
<pre><code class="language-python">over_2mm.plot(kind='barh')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410030144.png" alt="" loading="lazy"><br>
你可能还想了解一下对Obama和Romney总出资额最高的职业和企业。为此，我们先对候选人进行分组，然后使用本章前面介绍的类似<code>top</code>的方法：</p>
<pre><code class="language-python">def get_top_amounts(group, key, n=5):
    totals = group.groupby(key)['contb_receipt_amt'].sum()
    return totals.nlargest(n)
</code></pre>
<p>然后根据职业和雇主进行聚合：</p>
<pre><code class="language-python">grouped = fec_mrbo.groupby('cand_nm')
grouped.apply(get_top_amounts, 'contbr_occupation', n=7)
cand_nm        contbr_occupation    
Obama, Barack  RETIRED                  25305116.38
               ATTORNEY                 11141982.97
               INFORMATION REQUESTED     4866973.96
               HOMEMAKER                 4248875.80
               PHYSICIAN                 3735124.94
                                           ...     
Romney, Mitt   HOMEMAKER                 8147446.22
               ATTORNEY                  5364718.82
               PRESIDENT                 2491244.89
               EXECUTIVE                 2300947.03
               C.E.O.                    1968386.11
Name: contb_receipt_amt, Length: 14, dtype: float64
grouped.apply(get_top_amounts, 'contbr_employer', n=10)
cand_nm        contbr_employer      
Obama, Barack  RETIRED                  22694358.85
               SELF-EMPLOYED            17080985.96
               NOT EMPLOYED              8586308.70
               INFORMATION REQUESTED     5053480.37
               HOMEMAKER                 2605408.54
                                           ...     
Romney, Mitt   CREDIT SUISSE              281150.00
               MORGAN STANLEY             267266.00
               GOLDMAN SACH &amp; CO.         238250.00
               BARCLAYS CAPITAL           162750.00
               H.I.G. CAPITAL             139500.00
Name: contb_receipt_amt, Length: 20, dtype: float64
</code></pre>
<h4 id="对出资额分组">对出资额分组</h4>
<p>还可以对该数据做另一种非常实用的分析：利用<code>cut</code>函数根据出资额的大小将数据离散化到多个面元中：</p>
<pre><code class="language-python">bins = np.array([0, 1, 10, 100, 1000, 10000,100000, 1000000, 10000000])
labels = pd.cut(fec_mrbo.contb_receipt_amt, bins)
labels
411         (10, 100]
412       (100, 1000]
413       (100, 1000]
414         (10, 100]
415         (10, 100]
             ...     
701381      (10, 100]
701382    (100, 1000]
701383        (1, 10]
701384      (10, 100]
701385    (100, 1000]
Name: contb_receipt_amt, Length: 694282, dtype: category
Categories (8, interval[int64]): [(0, 1] &lt; (1, 10] &lt; (10, 100] &lt; (100, 1000] &lt; (1
000, 10000] &lt;
                                  (10000, 100000] &lt; (100000, 1000000] &lt; (1000000,
 10000000]]
</code></pre>
<p>现在可以根据候选人姓名以及面元标签对奥巴马和罗姆尼数据进行分组，以得到一个柱状图：</p>
<pre><code class="language-python">grouped = fec_mrbo.groupby(['cand_nm', labels])
grouped.size().unstack(0)
cand_nm              Obama, Barack  Romney, Mitt
contb_receipt_amt                               
(0, 1]                       493.0          77.0
(1, 10]                    40070.0        3681.0
(10, 100]                 372280.0       31853.0
(100, 1000]               153991.0       43357.0
(1000, 10000]              22284.0       26186.0
(10000, 100000]                2.0           1.0
(100000, 1000000]              3.0           NaN
(1000000, 10000000]            4.0           NaN
</code></pre>
<p>从这个数据中可以看出，在小额赞助方面，Obama获得的数量比Romney多得多。你还可以对出资额求和并在面元内规格化，以便图形化显示两位候选人各种赞助额度的比例（见下图）：</p>
<pre><code class="language-python">bucket_sums = grouped.contb_receipt_amt.sum().unstack(0)
normed_sums = bucket_sums.div(bucket_sums.sum(axis=1), axis=0)
normed_sums
cand_nm              Obama, Barack  Romney, Mitt
contb_receipt_amt                               
(0, 1]                    0.805182      0.194818
(1, 10]                   0.918767      0.081233
(10, 100]                 0.910769      0.089231
(100, 1000]               0.710176      0.289824
(1000, 10000]             0.447326      0.552674
(10000, 100000]           0.823120      0.176880
(100000, 1000000]         1.000000           NaN
(1000000, 10000000]       1.000000           NaN
normed_sums[:-2].plot(kind='barh')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200410030356.png" alt="" loading="lazy"><br>
我排除了两个最大的面元，因为这些不是由个人捐赠的。</p>
<p>还可以对该分析过程做许多的提炼和改进。比如说，可以根据赞助人的姓名和邮编对数据进行聚合，以便找出哪些人进行了多次小额捐款，哪些人又进行了一次或多次大额捐款。我强烈建议你下载这些数据并自己摸索一下。</p>
<h4 id="根据州统计赞助信息">根据州统计赞助信息</h4>
<p>根据候选人和州对数据进行聚合是常规操作：</p>
<pre><code class="language-python">grouped = fec_mrbo.groupby(['cand_nm', 'contbr_st'])
totals = grouped.contb_receipt_amt.sum().unstack(0).fillna(0)
totals = totals[totals.sum(1) &gt; 100000]
totals[:10]
cand_nm    Obama, Barack  Romney, Mitt
contbr_st                             
AK             281840.15      86204.24
AL             543123.48     527303.51
AR             359247.28     105556.00
AZ            1506476.98    1888436.23
CA           23824984.24   11237636.60
CO            2132429.49    1506714.12
CT            2068291.26    3499475.45
DC            4373538.80    1025137.50
DE             336669.14      82712.00
FL            7318178.58    8338458.81
</code></pre>
<p>如果对各行除以总赞助额，就会得到各候选人在各州的总赞助额比例：</p>
<pre><code class="language-python">percent = totals.div(totals.sum(1), axis=0)
percent[:10]
cand_nm    Obama, Barack  Romney, Mitt
contbr_st                             
AK              0.765778      0.234222
AL              0.507390      0.492610
AR              0.772902      0.227098
AZ              0.443745      0.556255
CA              0.679498      0.320502
CO              0.585970      0.414030
CT              0.371476      0.628524
DC              0.810113      0.189887
DE              0.802776      0.197224
FL              0.467417      0.532583
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数学]]></title>
        <id>https://bailingnan.github.io/post/shu-xue/</id>
        <link href="https://bailingnan.github.io/post/shu-xue/">
        </link>
        <updated>2020-04-06T15:56:27.000Z</updated>
        <content type="html"><![CDATA[<!-- TOC -->
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%AC%A6%E5%8F%B7%E8%A1%A8">常用符号表</a>
<ul>
<li><a href="#nndl">nndl</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0">线性代数</a>
<ul>
<li><a href="#%E5%9F%BA%E5%8F%98%E6%8D%A2">基变换</a></li>
<li><a href="#%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F">特征值与特征向量</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="常用符号表">常用符号表</h1>
<h2 id="nndl">nndl</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200406222643.png" alt="" loading="lazy"></figure>
<h1 id="线性代数">线性代数</h1>
<h2 id="基变换">基变换</h2>
<p>二维空间中的向量有它的坐标，例如向量的坐标是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}3 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，它代表着从起点到向量的末端，需要向右移动三个单位，并向上移动两个单位。或者代表缩放三倍的向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，和两倍的向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，而它们的和就是坐标所描述的向量。</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200406230418.png" alt="" loading="lazy"></figure>
<p>可以把这两个向量看做这个坐标的隐含假设，它们是标量缩放的对象，是标准坐标系的基向量。现在我们要讨论的是选取另一组基向量，比如Jennifer选择另一组向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">b_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">b_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则她得到的坐标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}5 / 3 \\ 1 / 3\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，就与标准坐标系不同。</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200406230951.png" alt="" loading="lazy"></figure>
<p>在我们的坐标系中，Jennifer的基向量的坐标分别是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}2 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-1 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> ，但在她自己的坐标系中，基向量的坐标是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}1 \\ 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}0 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>。她坐标轴的原点与我们相重合，但是网格的尺寸和方向，依赖于对基向量的选择。那么我们如何在不同的坐标系中进行转变呢？</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200406231349.png" alt="" loading="lazy"></figure>
<p>例如，求Jennifer坐标系下的向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，在我们的坐标系（标准坐标系）下的坐标。这过程就是用某个向量的特定坐标与他的基向量数乘，然后将结果相加<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>+</mo><mn>2</mn><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>4</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">-1\left[\begin{array}{l}2 \\ 1\end{array}\right]+2\left[\begin{array}{c}-1 \\ 1\end{array}\right]=\left[\begin{array}{c}-4 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">4</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> ，这就是矩阵向量乘法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]\left[\begin{array}{c}-1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>。矩阵的列向量就是在我们坐标系下所表达的Jennifer的基向量。</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200406231554.png" alt="" loading="lazy"></figure>
<p>作者在这里一顿描述，最后归结为这个矩阵，“把我们误解Jennifer的向量，变成Jennifer真正所想的向量。”</p>
<p>我是这么记的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mtext>one</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>two</mtext></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>4</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]\left[\begin{array}{c}-\text {one} \\ \text {two}\end{array}\right]=\left[\begin{array}{c}-4 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord text"><span class="mord">one</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">two</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">4</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，说英文的是Jennifer，数字都是我们坐标系下的坐标，列向量线性组合起来得到的也是我们坐标系下的坐标。输入的是Jennifer的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mtext>one</mtext></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>two</mtext></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-\text {one} \\ \text {two}\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord text"><span class="mord">one</span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">two</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，输出就是我们坐标系下的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>4</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-4 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">4</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，Jennifer来我们的坐标系说事，翻译是我们出的，翻译内容就是她的单词在我们这边是啥意思，即她的基向量在我们这里是啥坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 。没有误解，只有交流。</p>
<p>那么反过来如何操作呢，我们坐标系下的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}3 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>如何能够变成Jennifer坐标系下的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}5 / 3 \\ 1 / 3\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> ？答案是取逆矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]^{-1}=\left[\begin{array}{cc}1 / 3 &amp; 1 / 3 \\ -1 / 3 &amp; 2 / 3\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，它意味着一个反向变换。我们坐标系下的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}3 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，即为Jennifer坐标系下的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}5 / 3 \\ 1 / 3\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}1 / 3 &amp; 1 / 3 \\ -1 / 3 &amp; 2 / 3\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>就是我们的基向量在Jennifer坐标系下的坐标，即我们的单词在她那啥意思。<br>
在线性变换过程中，例如90度逆时针旋转，我们追踪基向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 在线性变换之后的坐标，得到矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}0 &amp; -1 \\ 1 &amp; 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，这是用我们的坐标系记录的结果。Jennifer如果要描述90度逆时针旋转，她会追踪她的基向量经过线性变化后的坐标，并且这个坐标是在她的坐标系中记录的。</p>
<p>例如，对于Jennifer坐标系下的向量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，首先翻译成我们坐标系下的坐标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]\left[\begin{array}{c}-1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> ，然后对这个向量施加逆时针旋转<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}0 &amp; -1 \\ 1 &amp; 0\end{array}\right]\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]\left[\begin{array}{c}-1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，最后再翻译回到Jennifer的语言中,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]^{-1}\left[\begin{array}{cc}0 &amp; -1 \\ 1 &amp; 0\end{array}\right]\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]\left[\begin{array}{c}-1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 。</p>
<p>则三个矩阵的复合就是Jennifer坐标体系下的线性变换矩阵：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>2</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn><mi mathvariant="normal">/</mi><mn>3</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]^{-1}\left[\begin{array}{cc}0 &amp; -1 \\ 1 &amp; 0\end{array}\right]\left[\begin{array}{cc}2 &amp; -1 \\ 1 &amp; 1\end{array}\right]=\left[\begin{array}{cc}1 / 3 &amp; -2 / 3 \\ 5 / 3 &amp; -1 / 3\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">2</span><span class="mord">/</span><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span><span class="mord">/</span><span class="mord">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></p>
<p>表达式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="bold-italic">A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi mathvariant="bold-italic">M</mi><mi mathvariant="bold-italic">A</mi></mrow><annotation encoding="application/x-tex">\boldsymbol{A}^{-1} \boldsymbol{M} \boldsymbol{A}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.890118em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol" style="margin-right:0.11424em;">M</span></span></span><span class="mord"><span class="mord"><span class="mord boldsymbol">A</span></span></span></span></span></span> 暗示着一种数学上的转移作用，中间的矩阵是已了解的一种线性变换，而两侧的矩阵代表着转移作用，也就是视角的转化，三者乘积仍旧代表这种线性变换，但是是从别人的视角。</p>
<h2 id="特征值与特征向量">特征值与特征向量</h2>
<p>二维空间中的一个线性变换将基向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 变换为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}3 \\ 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，基向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>变换为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{l}1 \\ 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 。如果用矩阵来表达的话就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}3 &amp; 1 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>。考虑一个特殊的向量以及这个向量张成的一维空间——直线，大部分向量在变换中都会离开了自己张成的空间，而如果向量经过变换后仍能落在这条直线上，就意味着线性变换对它的作用，仅仅是拉伸或者压缩，就如同一个标量一样。</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407005052.png" alt="" loading="lazy"></figure>
<p>在本例中，向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>所在的方向就是这样一个特殊的方向，它张成的空间是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>轴。矩阵对它的线性变换作用，使得向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>变成了原来的三倍，但仍然在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>轴上。x轴上的其他向量也都只是被拉伸为原来的三倍。</p>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407005156.png" alt="" loading="lazy"></figure>
<p>另一个略显隐蔽的向量是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-1 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，他在变换后也留在自己张成的空间里，被拉伸为原长的两倍。</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407005538.png" alt="" loading="lazy"></figure>
<p>以上就是所有拥有“留在自己张成的空间”这个性质的特殊向量。其他的向量，在变换中都有或多或少的旋转。</p>
<p>这些向量就被称为这个线性变换的<strong>特征向量</strong>，衡量特征向量在变换中拉伸或压缩的比例因子就是它对应的特征值。如果特征向量为负值，比如-1/2，意味着这个向量被反向，并且压缩到原来的1/2。但它仍旧停留在自身张成的直线上，没有发生旋转。</p>
<p>考虑一个三维空间中的旋转变换。如果能找到该变换的特征向量，那你找到的就是旋转轴。把一个三维旋转看成绕某个轴旋转一定角度，比考虑相应的3×3矩阵直观得多。在这种旋转变换中，特征值为1，因为空间只发生旋转，并不发生拉伸和压缩。</p>
<p>线性变换对应的矩阵，其列向量就是基向量变换后的坐标。但是理解线性变换作用的关键，往往较少依赖于特定的坐标系。最好的方法是求出它的特征向量和特征值。</p>
<p>矩阵、特征向量和特征值的关系为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>v</mi><mo>=</mo><mi>λ</mi><mi>v</mi></mrow><annotation encoding="application/x-tex">A v=\lambda v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">\mathcal{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span>是特征向量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>是该特征向量对应的特征值。特征向量经过矩阵变换后方向不变但被伸缩了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>倍。求解特征值和特征向量就是求解满足于上式的解。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>A</mi><mo>−</mo><mi>λ</mi><mi>I</mi><mo>)</mo><mi>v</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(A-\lambda I) v=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,我们的目标变成寻找一个非零的向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">\mathcal{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span></span>，使得这个新矩阵与之相乘的结果为零向量。当且仅当这个新矩阵所代表的线性变换将空间压缩到更低维度的时候，这个方程有非零解。而这个矩阵所对应的行列式等于0。求解的过程就变为找到一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>使得行列式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">det</mi><mo>⁡</mo><mo>(</mo><mi>A</mi><mo>−</mo><mi>λ</mi><mi>I</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{det}(A-\lambda I)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
<p>例如前面提到的矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}3 &amp; 1 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，求解其特征值，则转变为求解行列式方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">det</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mo>−</mo><mi>λ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mo>−</mo><mi>λ</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo fence="true">)</mo></mrow><mo>=</mo><mo>(</mo><mn>3</mn><mo>−</mo><mi>λ</mi><mo>)</mo><mo>(</mo><mn>2</mn><mo>−</mo><mi>λ</mi><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{det}\left(\left[\begin{array}{cc}3-\lambda &amp; 1 \\ 0 &amp; 2-\lambda\end{array}\right]\right)=(3-\lambda)(2-\lambda)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">λ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，求得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>=2,3，代入可求得特征向量，例如代入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>=2，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mo>−</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>2</mn><mo>−</mo><mn>2</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}3-2 &amp; 1 \\ 0 &amp; 2-2\end{array}\right]\left[\begin{array}{l}x \\ y\end{array}\right]=\left[\begin{array}{l}0 \\ 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，求解得到特征向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}-1 \\ 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> 。</p>
<p>二维线性变换不一定有特征值，比如90度逆时针旋转变换，所有的向量都发生了旋转，没有向量能够保持在其张成空间。逆时针旋转对应矩阵为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}0 &amp; -1 \\ 1 &amp; 0\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，代入计算特征值可得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">det</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>λ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>λ</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo fence="true">)</mo></mrow><mo>=</mo><msup><mi>λ</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{det}\left(\left[\begin{array}{cc}-\lambda &amp; -1 \\ 1 &amp; -\lambda\end{array}\right]\right)=\lambda^{2}+1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault">λ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathdefault">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，方程的解只有虚数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">-i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">i</span></span></span></span>。</p>
<p>剪切变换对应的矩阵为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}1 &amp; 1 \\ 0 &amp; 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，行列式方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">det</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mi>λ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>−</mo><mi>λ</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo fence="true">)</mo></mrow><mo>=</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><msup><mo>)</mo><mn>2</mn></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\operatorname{det}\left(\left[\begin{array}{cc}1-\lambda &amp; -1 \\ 1 &amp; 1-\lambda\end{array}\right]\right)=(1-\lambda)^{2}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">e</span><span class="mord mathrm">t</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">λ</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，得唯一解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>=1，这与几何上相一致，只有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>轴未发生方向变化，同时缩放比为1。</p>
<p>有时候只有一个特征值，但特征向量不止在一条直线上。例如，拉伸变换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}2 &amp; 0 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，唯一的特征值为2，但平面内的向量都是其特征向量。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407010739.png" alt="" loading="lazy"></p>
<p>如果基向量是特征向量会发生什么？</p>
<p>比如，向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>变换变为原来的（-1）倍，而向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>变为原来的两倍，则变换对应的矩阵是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}-1 &amp; 0 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span> ，它们变换的倍数就是特征值-1和2，这个矩阵是一个对角阵。</p>
<p>除了对角元素，其它元素均为0的矩阵被称为对角阵。对于对角阵，所有的基向量就是其特征向量，而对角元素就是它们所属的特征值。对角阵有很多特点，例如矩阵方幂很容易计算，<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mn>100</mn></msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>3</mn><mn>100</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>2</mn><mn>100</mn></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>y</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}3 &amp; 0 \\ 0 &amp; 2\end{array}\right]^{100}\left[\begin{array}{l}x \\ y\end{array}\right]=\left[\begin{array}{cc}3^{100} &amp; 0 \\ 0 &amp; 2^{100}\end{array}\right]\left[\begin{array}{l}x \\ y\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></p>
<p>如果矩阵的特征向量足够多，可以张成整个空间，那么可以通过变换坐标系，使得这些特征向量成为基向量。</p>
<p>矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}3 &amp; 1 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，取其特征向量作为列向量，构建基变换矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}1 &amp; -1 \\ 0 &amp; 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>，在原矩阵右侧乘上基变换矩阵，左侧乘上逆矩阵，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}1 &amp; -1 \\ 0 &amp; 1\end{array}\right]^{-1}\left[\begin{array}{ll}3 &amp; 1 \\ 0 &amp; 2\end{array}\right]\left[\begin{array}{cc}1 &amp; -1 \\ 0 &amp; 1\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>。这个矩阵仍旧描述的是同一个线性变换，但是是从新的基向量构成的坐标系的角度来看的。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200407010804.png" alt="" loading="lazy"><br>
这样做的意义在于，这个矩阵会是对角阵，且对角元就是对应的特征值。<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{cc}1 &amp; -1 \\ 0 &amp; 1\end{array}\right]^{-1}\left[\begin{array}{cc}3 &amp; 1 \\ 0 &amp; 2\end{array}\right]\left[\begin{array}{cc}1 &amp; -1 \\ 0 &amp; 1\end{array}\right]=\left[\begin{array}{cc}3 &amp; 0 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.604038em;vertical-align:-0.95003em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6540080000000001em;"><span style="top:-3.9029000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span><br>
它所处的坐标系的基向量在该线性变换中只进行了缩放。</p>
<p>一组特征向量构成的基向量的集合，称为一组“特征基”。计算矩阵<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\left[\begin{array}{ll}3 &amp; 1 \\ 0 &amp; 2\end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span>的100次幂，可以先变换到特征基，在那个坐标系中对对角阵计算100次幂，然后再转换回标准坐标系。</p>
<p>并不是所有的变换都可以完成以上过程，例如剪切变换，它的特征向量不够多，不能张成整个空间。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pandas笔记]]></title>
        <id>https://bailingnan.github.io/post/pandas-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/pandas-bi-ji/">
        </link>
        <updated>2020-04-03T10:18:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python笔记"><code>Python</code>笔记</h1>
<!-- TOC -->
<ul>
<li><a href="#python%E7%AC%94%E8%AE%B0"><code>Python</code>笔记</a>
<ul>
<li><a href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">编码规范</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99">代码优化原则</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a>
<ul>
<li><a href="#%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">可变与不可变对象</a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D">拷贝</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a>
<ul>
<li><a href="#%E6%8B%86%E5%88%86%E5%85%83%E7%BB%84">拆分元组</a></li>
<li><a href="#tuple%E6%96%B9%E6%B3%95"><code>tuple</code>方法</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a></li>
</ul>
</li>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">添加和删除元素</a></li>
<li><a href="#%E4%B8%B2%E8%81%94%E5%92%8C%E7%BB%84%E5%90%88%E5%88%97%E8%A1%A8">串联和组合列表</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E5%92%8C%E7%BB%B4%E6%8A%A4%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8">二分搜索和维护已排序的列表</a></li>
<li><a href="#zip%E5%87%BD%E6%95%B0">zip函数</a></li>
<li><a href="#reversed%E5%87%BD%E6%95%B0"><code>reversed</code>函数</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8B%B7%E8%B4%9D">列表拷贝</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-1">常用函数</a></li>
<li><a href="#%E4%B8%B2%E8%81%94%E5%87%BD%E6%95%B0">串联函数</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a>
<ul>
<li><a href="#%E5%88%A0%E9%99%A4%E5%80%BC">删除值</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E5%85%B8">更新字典</a></li>
<li><a href="#%E7%94%A8%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8">用序列创建字典</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC">默认值</a></li>
<li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E9%94%AE%E7%B1%BB%E5%9E%8B">有效的键类型</a></li>
<li><a href="#%E6%8C%89%E9%94%AE%E5%80%BC%E6%8E%92%E5%BA%8F">按键值排序</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7">其他技巧</a>
<ul>
<li><a href="#argmin-%E5%92%8C-argmax"><code>argmin</code> 和 <code>argmax</code></a></li>
<li><a href="#%E8%BD%AC%E7%BD%AE%E4%BA%8C%E7%BB%B4%E5%88%97%E8%A1%A8">转置二维列表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表、集合和字典推导式</a>
<ul>
<li><a href="#%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">嵌套列表推导式</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">默认参数</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">关键字参数</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">命名关键字参数</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">强制位置参数</a></li>
<li><a href="#%E5%8F%82%E6%95%B0%E7%BB%84%E5%90%88">参数组合</a></li>
<li><a href="#%E5%8C%BF%E5%90%8Dlambda%E5%87%BD%E6%95%B0">匿名(lambda)函数</a></li>
<li><a href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8">柯里化：部分参数应用</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">生成器表达式</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E7%B1%BB%E4%BD%9C%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">类作为迭代器</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95">通过字符串调用对象方法</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>
<ul>
<li><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>
<ul>
<li><a href="#map%E5%87%BD%E6%95%B0"><code>map</code>函数</a></li>
<li><a href="#reduce%E5%87%BD%E6%95%B0"><code>reduce</code>函数</a></li>
<li><a href="#filter%E5%87%BD%E6%95%B0"><code>filter</code>函数</a></li>
<li><a href="#sorted%E5%87%BD%E6%95%B0"><code>sorted</code>函数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0">返回函数</a>
<ul>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF">多重继承</a></li>
<li><a href="#%E5%AE%9A%E5%88%B6%E7%B1%BB">定制类</a>
<ul>
<li><a href="#str"><code>__str__</code></a></li>
<li><a href="#iter"><code>__iter__</code></a></li>
<li><a href="#getitem"><code>__getitem__</code></a></li>
<li><a href="#getattr"><code>__getattr__</code></a></li>
<li><a href="#call"><code>__call__</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F">命名空间和作用域</a>
<ul>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">三种命名空间：</a>
<ul>
<li><a href="#%E5%9B%9B%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F">四种作用域：</a></li>
<li><a href="#global-%E5%92%8C-nonlocal%E5%85%B3%E9%94%AE%E5%AD%97"><code>global</code> 和 <code>nonlocal</code>关键字</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">错误和异常处理</a>
<ul>
<li><a href="#%E8%B0%83%E8%AF%95">调试</a></li>
</ul>
</li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">文件和操作系统</a>
<ul>
<li><a href="#%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95">操作文件和目录</a></li>
<li><a href="#datetime"><code>datetime</code></a></li>
</ul>
</li>
<li><a href="#os"><code>os</code></a></li>
<li><a href="#path"><code>Path</code></a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93">第三方库</a>
<ul>
<li><a href="#h5py"><code>h5py</code></a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA">创建</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96">读取</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86">创建数据集：</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC">赋值</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B1">综合示例1</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAgroup">创建<code>group</code></a></li>
<li><a href="#pandas%E5%AF%B9h5py%E7%9A%84%E6%93%8D%E4%BD%9C"><code>Pandas</code>对<code>h5py</code>的操作</a>
<ul>
<li><a href="#%E5%86%99%E5%87%BA">写出</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96-1">读取</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="编码规范">编码规范</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318181309.png" alt="" loading="lazy"></figure>
<h2 id="代码优化原则">代码优化原则</h2>
<ul>
<li>专注于优化产生性能瓶颈的地方，而不是全部代码。</li>
<li>避免使用全局变量。局部变量的查找比全局变量更快，将全局变量的代码定义在函数中运行通常会快 15%-30%。</li>
<li>避免使用<code>.</code>访问属性。使用 <code>from module import name</code> 会更快，将频繁访问的类的成员变量 <code>self.member</code> 放入到一个局部变量中。</li>
<li>尽量使用内置数据结构。<code>str</code>, <code>list</code>, <code>set</code>, <code>dict</code> 等使用 <code>C</code> 实现，运行起来很快。</li>
<li>避免创建没有必要的中间变量，和 <code>copy.deepcopy()</code>。</li>
<li>字符串拼接，例如 <code>a + ':' + b + ':' + c</code> 会创造大量无用的中间变量，<code>':',join([a, b, c])</code> 效率会高不少。另外需要考虑字符串拼接是否必要，例如 <code>print(':'.join([a, b, c]))</code> 效率比 <code>print(a, b, c, sep=':')</code> 低。</li>
<li>多个<code>if elif</code>条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率。</li>
</ul>
<h2 id="对象">对象</h2>
<h3 id="可变与不可变对象">可变与不可变对象</h3>
<ul>
<li><code>Python</code>中的大多数对象，比如列表、字典、<code>NumPy</code>数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改。</li>
<li>字符串和元组，是不可变的。</li>
</ul>
<pre><code class="language-Python">a= 'abc'
b = a.replace('a', 'A')
print(b)
'Abc'
</code></pre>
<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象，有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：<br>
当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了。<br>
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<ul>
<li>变量可以连续赋值:</li>
</ul>
<pre><code class="language-Python">a=b=c=1
</code></pre>
<h3 id="拷贝">拷贝</h3>
<ul>
<li>简单的赋值只是将引用传给新对象，新旧对象除变量名外毫无区别</li>
<li>由于 <code>Python</code> 内部引用计数的特性，对于不可变对象，浅拷贝和深拷贝的作用是一致的，就相当于复制了一份副本，原对象内部的不可变对象的改变，不会影响到复制对象</li>
<li>浅拷贝的拷贝。其实是拷贝了原始元素的引用（内存地址），所以当拷贝可变对象时，原对象内可变对象的对应元素的改变，会在复制对象的对应元素上，有所体现</li>
<li>深拷贝在遇到可变对象时，又在内部做了新建了一个副本。所以，不管它内部的元素如何变化，都不会影响到原来副本的可变对象</li>
<li>如果对子对象修改，则浅拷贝后的结果也会跟着发生变化，而深拷贝则不会。他们的子对象还是指向统一对象（是引用）。<code>list</code>的<code>a=b[:]</code>相当于<code>copy()</code></li>
<li>如果对父对象修改，则不管是浅拷贝还是深拷贝的结果，都不会跟着发生变化。</li>
<li>不管对什么对象修改，指针引用后的结果都会跟着发生相同变化。<br>
标准库中的<code>copy</code>模块提供了两个方法来实现拷贝.一个方法是<code>copy</code>,它返回和参数包含内容一样的对象.</li>
</ul>
<pre><code class="language-Python">import copy
new_list = copy.copy(existing_list)
</code></pre>
<p>有些时候,你希望对象中的属性也被复制,可以使用<code>deepcopy</code>方法:</p>
<pre><code class="language-Python">import copy
new_list_of_dicts = copy.deepcopy(existing_list_of_dicts)
</code></pre>
<p>当你对一个对象赋值的时候(做为参数传递,或者做为返回值),<code>Python</code>和<code>Java</code>一样,总是传递原始对象的引用,而不是一个副本.其它一些语言当赋值的时候总是传递副本,<code>Python</code>从不猜测用户的需求 ,如果你想要一个副本,你必须显式的要求.<br>
<code>Python</code>的行为很简单,迅速,而且一致.然而,如果你需要一个对象拷贝而并没有显式的写出来,会出现问题的,比如:</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
print(id(a)==id(b))
True
b.append(5)
print(a,b) 
[1, 2, 3, 5] [1, 2, 3, 5]
</code></pre>
<p>在这里,变量<code>a</code>和<code>b</code>都指向同一个对象(一个列表),所以,一旦你修改了二者之一,另外一个也会受到影响.无论怎样,都会修改原来的对象。</p>
<pre><code class="language-Python">import copy
c=copy.copy(a)
print(id(c)==id(a))
False
c[1]=222
print(c)
[1,222,3,5]
print(a)
[1,2,3,5]
a=[1,2,[3,4]]
d=copy.copy(a)
print(id(a)==id(d))
False
print(id(a[2])==id(d[2]))
True
a[0]=11
print(a)
[11,2,[3,4]]
print(d)
[1,2,[3,4]]
# 只会复制值的第一层，而不会复制往下的几层数据。
# 复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。
a[2][0]=333
print(d)
[1,2,[333,4]]
e=copy.deepcopy(a)
print(e[2]==a[2])
False
</code></pre>
<p>这种情况就不一样了，这是对<code>a</code>重新指向新的值那么其<code>id</code>就会变而此时<code>b</code>就不会变。</p>
<pre><code class="language-Python">a = [1,2,3]
b = a
print(id(b))
a = {1:2}
print(id(a))
print(id(b))
print(b)
输出：
1998591409928
1998589307016
1998591409928
[1, 2, 3]
</code></pre>
<p>再举一个例子：</p>
<pre><code class="language-Python">import copy
a=[1,[1,2],3]
b=a
b
[1, [1, 2], 3]
id(a)
4549388120
id(b)
4549388120
b[0]=3
a
[3, [1, 2], 3]
c=copy.copy(a)
id(c)
4549389992
id(a)
4549388120
c[0]=4
a
[3, [1, 2], 3]
c
[4, [1, 2], 3]
c[1].append(3)
a
[3, [1, 2, 3], 3]
c
[4, [1, 2, 3], 3]
id(a[2])
140345184649736
id(c[2])
140345184649736
id(c[1])
4549388192
id(a[1])
4549388192
d=copy.deepcopy(a)
id(d)
4549389632
id(a)
4549388120
d[1].append(4)
a
[3, [1, 2, 3], 3]
d
[3, [1, 2, 3, 4], 3]
</code></pre>
<p><code>Python</code> 存储变量的方法跟其他 <code>OOP</code> 语言不同。它与其说是把值赋给变量，不如说是给变量建立了一个到具体值的 <code>reference</code>。<br>
当在 <code>Python</code> 中 <code>a = something</code> 应该理解为给 <code>something</code> 贴上了一个标签 <code>a</code>。当再赋值给 <code>a</code> 的时候，就好像把 <code>a</code> 这个标签从原来的 <code>something</code> 上拿下来，贴到其他对象上，建立新的 <code>reference</code>。 这就解释了一些 <code>Python</code> 中可能遇到的诡异情况：</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
a = [4, 5, 6] # 赋新的值给 a
a
[4, 5, 6]
b
[1, 2, 3]
# a 的值改变后，b 并没有随着 a 变
a = [1, 2, 3]
b = a
a[0], a[1], a[2] = 4, 5, 6 # 改变原来 list 中的元素
a
[4, 5, 6]
b
[4, 5, 6]
# a 的值改变后，b 随着 a 变了
</code></pre>
<p>上面两段代码中，<code>a</code> 的值都发生了变化。区别在于，第一段代码中是直接赋给了 <code>a</code> 新的值(从 <code>[1, 2, 3]</code> 变为 <code>[4, 5, 6]</code>)；而第二段则是把 <code>list</code> 中每个元素分别改变。<br>
首次把 <code>[1, 2, 3]</code> 看成一个物品。<code>a = [1, 2, 3]</code> 就相当于给这个物品上贴上 <code>a</code> 这个标签。而 <code>b = a</code> 就是给这个物品又贴上了一个 <code>b</code> 的标签。<br>
<code>a = [4, 5, 6]</code> 就相当于把 <code>a</code> 标签从 <code>[1 ,2, 3]</code> 上撕下来，贴到了 <code>[4, 5, 6]</code> 上。<br>
在这个过程中，<code>[1, 2, 3]</code> 这个物品并没有消失。 <code>b</code>自始至终都好好的贴在 <code>[1, 2, 3]</code> 上，既然这个 <code>reference</code> 也没有改变过。 <code>b</code> 的值自然不变。<br>
第二种情况：<br>
<code>a[0], a[1], a[2] = 4, 5, 6</code>则是直接改变了 <code>[1, 2, 3]</code> 这个物品本身。把它内部的每一部分都重新改装了一下。内部改装完毕后，<code>[1, 2, 3]</code> 本身变成了 <code>[4, 5, 6]</code>。<br>
而在此过程当中，<code>a</code> 和 <code>b</code> 都没有动，他们还贴在那个物品上。因此自然 <code>a</code>,<code>b</code> 的值都变成了 <code>[4, 5, 6]</code>。<br>
搞明白这个之后就要问了，对于一个复杂对象的浅<code>copy</code>，在<code>copy</code>的时候到底发生了什么？<br>
再看一段代码：</p>
<pre><code class="language-Python">import copy
origin = [1, 2, [3, 4]]
#origin 里边有三个元素：1， 2，[3, 4]
cop1 = copy.copy(origin)
cop2 = copy.deepcopy(origin)
cop1 == cop2
True
cop1 is cop2
False 
#cop1 和 cop2 看上去相同，但已不再是同一个object
origin[2][0] = &quot;hey!&quot; 
origin
[1, 2, ['hey!', 4]]
cop1
[1, 2, ['hey!', 4]]
cop2
[1, 2, [3, 4]]
#把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2
</code></pre>
<p><code>copy</code>对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，<code>Python</code>会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。<br>
所以说看这里的<code>origin[2]</code>，也就是 <code>[3, 4]</code> 这个 <code>list</code>。根据 <code>shallow copy</code> 的定义，在 <code>cop1[2]</code> 指向的是同一个 <code>list [3, 4]</code>。那么，如果这里我们改变了这个 <code>list</code>，就会导致 <code>origin</code> 和 <code>cop1</code> 同时改变。这就是为什么上边 <code>origin[2][0] = “hey!”</code>之后，cop1 也随之变成了 <code>[1, 2, [‘hey!’, 4]]</code>。<br>
<code>deepcopy</code>的时候会将复杂对象的每一层复制一个单独的个体出来。<br>
这时候的 <code>origin[2]</code> 和 <code>cop2[2]</code> 虽然值都等于 <code>[3, 4]</code>，但已经不是同一个 <code>list了</code>。即我们寻常意义上的复制。<br>
总结：</p>
<pre><code class="language-Python">lst = [10, ['A']]

# 指针引用: 不拷贝
a = lst
assert a is lst

# 浅拷贝: 只拷贝 父对象，不会拷贝 子对象
import copy
b = copy.copy(lst)
assert b is not lst and b == lst

# 深拷贝: 拷贝 父对象 及 子对象
c = copy.deepcopy(lst)
assert c is not lst and c == lst

# 修改 list 对象
lst.append(5)
lst[1].append('B')

print(&quot;原始的list对象:  lst =  [10, ['A']]&quot;)
print('修改后list对象:  lst = ', a, '\n')
print('指针引用:  a = ', a)
print('浅拷贝  :  b = ', b)
print('深拷贝  :  c = ', c)
原始的list对象:  lst =  [10, ['A']]
修改后list对象:  lst =  [10, ['A', 'B'], 5] 

指针引用:  a =  [10, ['A', 'B'], 5]
浅拷贝  :  b =  [10, ['A', 'B']]
深拷贝  :  c =  [10, ['A']]
</code></pre>
<p>即:</p>
<ul>
<li>如果对子对象修改，则浅拷贝后的结果也会跟着发生变化，而深拷贝则不会。<code>list</code>的<code>a=b[:]</code>相当于<code>copy()</code></li>
<li>如果对父对象修改，则不管是浅拷贝还是深拷贝的结果，都不会跟着发生变化。</li>
<li>不管对什么对象修改，指针引用后的结果都会跟着发生相同变化。<br>
举例：</li>
</ul>
<pre><code class="language-Python">import copy
base = ['a', 'b', 'c', 'd', 'e']
# 切片
bak1 = base[:]
print(&quot;bak1: &quot;, bak1)
# list工厂函数
bak2 = list(base)
print(&quot;bak2: &quot;, bak2)
# Python list对象的copy方法
bak3 = base.copy()
print(&quot;bak3: &quot;, bak3)
# copy模块的copy方法
bak4 = copy.copy(base)
print(&quot;bak4: &quot;, bak4)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">bak1:  ['a', 'b', 'c', 'd', 'e']
bak2:  ['a', 'b', 'c', 'd', 'e']
bak3:  ['a', 'b', 'c', 'd', 'e']
bak4:  ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>上面的代码使用了四种方式来对数据进行拷贝，这些方法都可以用来拷贝数据，结果都一样。</p>
<ul>
<li>切片<br>
需要拷贝的数据进行切片处理，返回的结果相当于拷贝了一份数据。</li>
<li>工厂方法<br>
使用 <code>Python</code> 的工厂函数 <code>list</code> 来拷贝数据。(<code>Python</code>的工厂函数是比较特殊的，即是类也是函数，关于工厂函数的理解可以另行扩展一下)<br>
拷贝列表时使用 <code>list</code>，如果拷贝字符串则将上面的 <code>list</code> 换成 <code>str</code> ，以此类推。</li>
<li>list对象的copy方法<br>
<code>Python</code> 中的 <code>list</code> 实现了 <code>copy</code> 方法，在拷贝列表时可以直接使用。这里需要注意，比如 <code>str</code> 没有实现 <code>copy</code> 方法，拷贝字符串时使用其他方法拷贝。</li>
<li><code>copy</code>模块的<code>copy</code>方法<br>
在 <code>Python</code> 标准库中有一个 <code>copy</code> 模块，可以使用 <code>copy</code> 模块的 <code>copy()</code> 方法来拷贝数据，<code>copy</code> 模块可以拷贝所有类型的数据。</li>
</ul>
<pre><code class="language-Python">import copy
son = ['Python', 'copy']
base = ['a', 'b', 'c', 'd', 'e', son]
bak1 = base[:]
print(&quot;bak1: &quot;, bak1)
bak2 = list(base)
print(&quot;bak2: &quot;, bak2)
bak3 = base.copy()
print(&quot;bak3: &quot;, bak3)
bak4 = copy.copy(base)
print(&quot;bak4: &quot;, bak4)
print('-' * 20, '分割线', '-' * 20)
son[0] = 'PYTHON'
son[1] = 'COPY'
print('base: ', base)
print(&quot;bak1: &quot;, bak1)
print(&quot;bak2: &quot;, bak2)
print(&quot;bak3: &quot;, bak3)
print(&quot;bak4: &quot;, bak4)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">bak1:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak2:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak3:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak4:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
-------------------- 分割线 --------------------
base:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak1:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak2:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak3:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak4:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
</code></pre>
<p>在实际工作中，数据的嵌套层数是很多的，通常会嵌套好几层。上面就在 <code>base</code> 列表中嵌套了一个 <code>son</code> 子列表。<br>
用上面的四种拷贝方法拷贝 <code>base</code> 列表，然后修改 <code>base</code> 列表中的子列表 <code>son</code> 。重新打印这几个列表，发现不仅 <code>base</code> 列表被修改了，拷贝的列表也全部被修改了。<br>
现在的需求是拷贝一份数据，修改一份保留一份，如果两份数据都被修改，是不符合需求的。<br>
上面的四种拷贝方法都被称为浅拷贝（相对深拷贝而言），浅拷贝 <code>Python</code> 中的可变对象，如果数据中嵌套了可变对象，修改嵌套的可变对象，所有拷贝的数据都会一起被修改。<br>
在 <code>Python</code> 中，所有的数据都是对象，无论是数字，字符串，元组，列表，字典，还是函数，类，甚至是模块。<br>
不可变对象：<br>
<code>int</code>, <code>str</code>, <code>tuple</code> 等类型的数据是不可变对象，不可变对象的特性是数据不可被修改。</p>
<pre><code class="language-Python">a = 'a'
print(id(a))
a = 'b'
print(id(a))
</code></pre>
<p>运行结果：</p>
<pre><code>1543912659912
1543912658232
</code></pre>
<p>如果对不可变对象修改，其实不是修改变量对象，而是重新创建一个同名的变量对象。可以通过 <code>id</code> 函数来判断，<code>id</code> 不一样就证明已经不是同一个变量了。<br>
可变对象：<br>
<code>list</code>， <code>set</code>，<code>dict</code> 等类型的数据是可变对象，相对于不可变对象而言，可变对象的数据可以被修改，修改之后还是同一个<code>id</code>。</p>
<pre><code class="language-Python">base = [1, 2, 3]
print(id(base))
base[0] = 100
print(base)
print(id(base))
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">2182371173000
[100, 2, 3]
2182371173000
</code></pre>
<p>对可变对象进行修改，修改后还是同一个对象，只是可变对象里面的元素指向了不同的数据，这种指向是通过引用的方式来实现的。<br>
上面的代码是对列表进行修改，如果对元组这样修改，代码会报错，就是因为可变对象和不可变对象的区别。<br>
在 <code>Python</code> 程序中，每个对象都会在内存中开辟一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。<br>
在编写代码时，定义的变量名实际是定义指向对象的地址引用名。<br>
我们定义一个列表时，变量名是列表的名字，这个名字指向内存中的一块空间。这个列表里有多个元素，表示这块内存空间中，保存着多个元素的引用。</p>
<ol>
<li>修改引用<br>
当修改列表的元素时，其实是修改列表中的引用。</li>
</ol>
<pre><code class="language-Python">list_a = [1, 2, 3]
list_a[2] = 30
print('list_a: ', list_a)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_a:  [1, 2, 30]
</code></pre>
<p>修改 <code>list_a</code> 中的第三个元素，其实是修改第三个元素的引用（这块内存指向的对象）。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323023647.png" alt="" loading="lazy"><br>
2. 引用传递（拷贝）<br>
当拷贝列表时，其实是拷贝列表中的引用。</p>
<pre><code class="language-Python">list_b = [1, 2, 3]
list_c = list_b.copy()
print('list_c: ', list_c)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_c:  [1, 2, 3]
</code></pre>
<p>拷贝 <code>list_b</code> 到 <code>list_c</code>，其实是给 <code>list_c</code> 新开辟一块内存，然后拷贝一份 <code>list_b</code> 的引用给 <code>list_c</code> ，并不是将 <code>list_b</code>指向的对象拷贝一份。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323023828.png" alt="" loading="lazy"><br>
这里不是将 <code>list_b</code> 赋值给 <code>list_c</code>，那样的结果是 <code>list_b</code> 指向 <code>[1, 2, 3]</code> ，<code>list_c</code> 指向 <code>list_b</code>，是引用关系，而不是拷贝关系。上面列举拷贝的方法时，没有将赋值列为拷贝方法，因为赋值是引用的传递，而不是拷贝。</p>
<ol>
<li>拷贝后修改引用（数据无嵌套）</li>
</ol>
<pre><code class="language-Python">import copy
list_b = [1, 2, 3]
list_c = copy.copy(list_b)
list_b[2] = 30
print('list_b: ', list_b)
print('list_c: ', list_c)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_b:  [1, 2, 30]
list_c:  [1, 2, 3]
</code></pre>
<p>使用 <code>copy.copy()</code> 方法拷贝 <code>list_b</code> 到 <code>list_c</code>，然后修改 <code>list_b</code> 中的引用关系，这样， <code>list_c</code> 不会被修改。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024031.png" alt="" loading="lazy"><br>
2. 嵌套列表的拷贝</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_e = copy.copy(list_d)
print('list_d: ', list_d)
print('list_e: ', list_e)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 3]]
list_e:  [1, [2, 3]]
</code></pre>
<p>对于嵌套的列表，拷贝 <code>list_d</code> 到 <code>list_e</code>，也是拷贝一份 <code>list_d</code> 的引用给 <code>list_e</code> ，与不嵌套的相同。<br>
这里需要特别注意，在浅拷贝嵌套的列表时，只会拷贝最上层的引用，对于子列表的引用，不会拷贝。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024211.png" alt="" loading="lazy"><br>
3. 拷贝的列表随原列表一起被修改</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_e = copy.copy(list_d)
list_d[1][1] = 30
print('list_d: ', list_d)
print('list_e: ', list_e)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 30]]
list_e:  [1, [2, 30]]
</code></pre>
<p>拷贝 <code>list_d</code> 到 <code>list_e</code>，由于没有拷贝子列表的引用 ，当修改子列时， <code>list_d</code> 和 <code>list_e</code> 都引用了子列表 <code>sub</code>，所以 <code>list_d</code> 和 <code>list_e</code>都会被修改。如下图：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024334.png" alt="" loading="lazy"><br>
拷贝数据后，修改其中一个，另一个也跟着被修改，原因就是浅拷贝中，只拷贝了最外层的引用。当修改内层的引用时，所有外层的引用不变，都会指向修改后的结果。<br>
两份数据都被修改，这就是浅拷贝中存在的问题，需要使用深拷贝来解决。<br>
4. 深拷贝保证数据不会被修改</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_f = copy.deepcopy(list_d)
list_d[1][1] = 30
print('list_d: ', list_d)
print('list_e: ', list_f)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 30]]
list_e:  [1, [2, 3]]
</code></pre>
<p>使用 <code>copy</code> 模块的 <code>deepcopy()</code> 方法，在拷贝数据时，会递归地拷贝数据中所有嵌套的引用。<br>
使用 <code>deepcopy()</code> 拷贝 <code>list_d</code> 到 <code>list_f</code> ，然后修改 <code>list_d</code> 中子列表的引用，不会对 <code>list_f</code> 产生影响，所以 <code>list_f</code> 不会被修改。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024515.png" alt="" loading="lazy"></p>
<h3 id="元组">元组</h3>
<ul>
<li>如果要定义一个空的tuple，可以写成()：</li>
</ul>
<pre><code class="language-Python">t = ()
print(t)
()
</code></pre>
<ul>
<li>但是，要定义一个只有1个元素的<code>tuple</code>，如果这么定义：</li>
</ul>
<pre><code class="language-Python">t = (1)
print(t)
1
</code></pre>
<p>定义的不是<code>tuple</code>，是<code>1</code>这个数！这是因为括号()既可以表示<code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>
所以，只有1个元素的<code>tuple</code>定义时必须加一个逗号,，来消除歧义：</p>
<pre><code class="language-Python">t = (1,)
print(t）
(1,)
</code></pre>
<p><code>Python</code>在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<ul>
<li>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</li>
</ul>
<pre><code class="language-Python">tup = tuple(['foo', [1, 2], True])
tup[1].append(3)
print(tup)
('foo', [1, 2, 3], True)
</code></pre>
<h4 id="拆分元组">拆分元组</h4>
<ul>
<li>使用特殊的语法<code>*rest</code>，函数签名中以抓取任意长度列表的位置参数：</li>
</ul>
<pre><code class="language-Python">values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a, b)
(1, 2)
print(rest)
[3, 4, 5]
</code></pre>
<ul>
<li><code>rest</code>的部分是想要舍弃的部分:</li>
</ul>
<pre><code class="language-Python">a, b, *_ = values
</code></pre>
<h4 id="tuple方法"><code>tuple</code>方法</h4>
<ul>
<li>统计值出现频率：</li>
</ul>
<pre><code class="language-Python">a = (1, 2, 2, 2, 3, 4, 2)
print(a.count(2))
4
</code></pre>
<h4 id="常用函数">常用函数</h4>
<ul>
<li><code>len(tuple)</code>:计算元组元素个数。</li>
<li><code>max(tuple)</code>:返回元组中元素最大值。</li>
<li><code>min(tuple)</code>:返回元组中元素最小值。</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="添加和删除元素">添加和删除元素</h4>
<ul>
<li><code>insert</code>在特定的位置插入元素：</li>
</ul>
<pre><code class="language-Python">b_list=['foo', 'bar', 'baz']
b_list.insert(1, 'red')
print(b_list)
['foo', 'red', 'peekaboo', 'baz', 'dwarf']
</code></pre>
<p>与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，使用<code>collections.deque</code>，一个双尾部队列。</p>
<ul>
<li><code>insert</code>的逆运算是<code>pop</code>，它移除并返回指定位置的元素,<code>pop()</code>默认删除最后一个元素：</li>
</ul>
<pre><code class="language-Python">print(b_list.pop(2))
'peekaboo'
print(b_list)
['foo', 'red', 'baz', 'dwarf']
</code></pre>
<ul>
<li><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</li>
</ul>
<pre><code class="language-Python">b_list.append('foo')
print(b_list)
['foo', 'red', 'baz', 'dwarf', 'foo']
b_list.remove('foo')
print(b_list)
['red', 'baz', 'dwarf', 'foo']
</code></pre>
<h4 id="串联和组合列表">串联和组合列表</h4>
<ul>
<li>可以用加号将两个列表串联起来,如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</li>
</ul>
<pre><code class="language-Python">x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>
<ul>
<li>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</li>
</ul>
<pre><code class="language-Python">#快
everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
#慢
everything = []
for chunk in list_of_lists:
    everything = everything + chunk
</code></pre>
<p>考虑下列代码片段：</p>
<pre><code class="language-Python">list = [ [ ] ] * 5
list  # output?
list[0].append(10)
list  # output?
list[1].append(20)
list  # output?
list.append(30)
list  # output?
</code></pre>
<p>2,4,6,8行将输出什么结果？试解释。<br>
输出的结果如下：</p>
<pre><code class="language-Python">[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>
<p>解释如下：<br>
第一行的输出结果直觉上很容易理解，例如 <code>list = [ [ ] ] * 5</code> 就是简单的创造了5个空列表。然而，理解表达式<code>list=[ [ ] ] * 5</code>的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个创建了包含对同一个列表五次引用的列表。只有了解了这一点，我们才能更好的理解接下来的输出结果。<br>
<code>list[0].append(10)</code> 将10附加在第一个列表上。<br>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：</p>
<pre><code class="language-Python">[[10], [10], [10], [10], [10]]
</code></pre>
<p>同理，<code>list[1].append(20)</code>将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：</p>
<pre><code class="language-Python">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
</code></pre>
<p>作为对比， <code>list.append(30)</code>是将整个新的元素附加在外列表上，因此产生的结果是： <code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</code>。</p>
<h4 id="排序">排序</h4>
<ul>
<li><code>sort</code>函数将一个列表原地排序（不创建新的对象）</li>
</ul>
<pre><code class="language-Python">a = [7, 2, 5, 1, 3]
a.sort()
print(a)
[1, 2, 3, 5, 7]
</code></pre>
<ul>
<li><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序<code>key</code>，可以用这个<code>key</code>进行排序。例如，我们可以按长度对字符串进行排序：</li>
</ul>
<pre><code class="language-Python">b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)
print(b)
['He', 'saw', 'six', 'small', 'foxes']
</code></pre>
<h4 id="二分搜索和维护已排序的列表">二分搜索和维护已排序的列表</h4>
<ul>
<li><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值:</li>
</ul>
<pre><code class="language-Python">import bisect
c = [1, 2, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 2))
4
print(bisect.bisect(c, 5))
6
print(bisect.insort(c, 6))
print(c)
[1, 2, 2, 2, 3, 4, 6, 7]
</code></pre>
<h4 id="zip函数">zip函数</h4>
<ul>
<li><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</li>
</ul>
<pre><code class="language-Python">seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
print(list(zipped))
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</code></pre>
<ul>
<li><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</li>
</ul>
<pre><code class="language-Python">seq3 = [False, True]
print(list(zip(seq1, seq2, seq3)))
[('foo', 'one', False), ('bar', 'two', True)]
</code></pre>
<ul>
<li><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</li>
</ul>
<pre><code class="language-Python">for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
0: foo, one
1: bar, two
2: baz, three
</code></pre>
<ul>
<li>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。</li>
</ul>
<pre><code class="language-Python">pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'),('Schilling', 'Curt')]
first_names, last_names = zip(*pitchers)
print(first_names)
('Nolan', 'Roger', 'Schilling')
print(last_names)
('Ryan', 'Clemens', 'Curt')
</code></pre>
<h4 id="reversed函数"><code>reversed</code>函数</h4>
<p><code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或<code>for</code>循环）之后才能创建翻转的序列。</p>
<pre><code class="language-Python">print(list(reversed(range(10))))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<h4 id="列表拷贝">列表拷贝</h4>
<ul>
<li><code>b=a[:]</code>。</li>
<li><code>b=list(a)</code>。</li>
<li>使用<code>copy.copy()</code>函数，或<code>b=a.copy()</code>直接复制<code>list</code>，类似<code>a[:]</code>。</li>
<li>使用<code>copy.deepcopy()</code>。<br>
使用<code>b=a</code>是完全引用，除了名字没区别</li>
</ul>
<h4 id="常用函数-2">常用函数</h4>
<ul>
<li><code>max(list)</code>:返回列表元素最大值</li>
<li><code>min(list)</code>:返回列表元素最小值</li>
<li><code>list.count(obj)</code>:统计某个元素在列表中出现的次数</li>
<li><code>list.extend(seq)</code>:在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li><code>list.index(obj)</code>:从列表中找出某个值第一个匹配项的索引位置</li>
<li><code>list.reverse()</code>:反向列表中元素</li>
</ul>
<h4 id="串联函数">串联函数</h4>
<pre><code class="language-Python">操作函数对象
def f():
    print('i\'m f')
def g():
    print('i\'m g')
[f,g][1]()
i'm g
</code></pre>
<h3 id="字典">字典</h3>
<ul>
<li>多种构造方法:</li>
</ul>
<pre><code class="language-Python">a = dict(one=1, two=2, three=3)
b = {'one':1, 'two':2, 'three':3}
c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
d = dict([('one', 1), ('two', 2), ('three', 3)])
e = dict({'three':3, 'one':1, 'two':2})
print(a)
print(b)
print(c)
print(d)
print(e)
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'three': 3, 'one': 1, 'two': 2}
print(a==b==c==d==e)
&gt;&gt;&gt;True
</code></pre>
<p>特别注意这种构造方法：</p>
<pre><code class="language-Python">t = {x:y for x in range(10) for y in range(10)}
print(t)
{0: 9, 1: 9, 2: 9, 3: 9, 4: 9, 5: 9, 6: 9, 7: 9, 8: 9, 9: 9}
</code></pre>
<pre><code class="language-Python">d = dict(name='Bob', age=20, score=88)
</code></pre>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-Python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个<code>Python</code>命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-Python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
print(d)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-Python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。<br>
要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-Python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<h4 id="删除值">删除值</h4>
<ul>
<li>用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</li>
</ul>
<pre><code class="language-Python">d1={'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer',5: 'some value','dummy': 'another value'}
del d1[5]
print(d1)
{'a': 'some value',
 'b': [1, 2, 3, 4],
 7: 'an integer',
 'dummy': 'another value'}
ret = d1.pop('dummy')
print(ret)
'another value'
print(d1)
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
</code></pre>
<ul>
<li><code>popitem()</code>:返回并删除字典中的最后一对键和值。</li>
</ul>
<h4 id="更新字典">更新字典</h4>
<ul>
<li>用<code>update</code>方法可以将一个字典与另一个融合,<code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</li>
</ul>
<pre><code class="language-Python">d1.update({'b' : 'foo', 'c' : 12})
print(d1)
{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}
</code></pre>
<h4 id="用序列创建字典">用序列创建字典</h4>
<pre><code class="language-Python">mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value
</code></pre>
<ul>
<li>因为字典本质上是2元元组的集合，<code>dict</code>可以接受2元元组的列表：</li>
</ul>
<pre><code class="language-Python">mapping = dict(zip(range(5), reversed(range(5))))
print(mapping)
{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre>
<h4 id="默认值">默认值</h4>
<pre><code class="language-Python">if key in some_dict:
    value = some_dict[key]
else:
    value = default_value
</code></pre>
<ul>
<li><code>dict</code>的方法<code>get</code>和<code>pop</code>可以取默认值进行返回，上面的<code>if-else</code>语句可以简写成下面：</li>
</ul>
<pre><code class="language-Python">value = some_dict.get(key, default_value)
</code></pre>
<ul>
<li><code>get</code>默认会返回<code>None</code>，如果不存在键，<code>pop</code>会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</li>
</ul>
<pre><code class="language-Python">words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)
print(by_letter)
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
</code></pre>
<ul>
<li>使用<code>setdefault</code>方法：</li>
</ul>
<pre><code class="language-Python">for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
</code></pre>
<ul>
<li><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</li>
</ul>
<pre><code class="language-Python">from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
</code></pre>
<p>给定以下字典的子类，下面的代码能够运行么？为什么？</p>
<pre><code class="language-Python">class DefaultDict(dict):
  def __missing__(self, key):
    return []
d = DefaultDict()
d['florp'] = 127
</code></pre>
<p>能够运行。<br>
当<code>key</code>缺失时，执行<code>DefaultDict</code>类，字典的实例将自动实例化这个数列。</p>
<h4 id="有效的键类型">有效的键类型</h4>
<ul>
<li>字典的值可以是任意<code>Python</code>对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</li>
</ul>
<pre><code class="language-Python">print(hash('string'))
5023931463650008331
print(hash((1, 2, (2, 3))))
1097636502276347782
print(hash((1, 2, [2, 3]))) # fails because lists are mutable
---------------------------------------------------------------------------
TypeError                                 
Traceback (most recent call last)
&lt;iPython-input-129-800cd14ba8be&gt; in &lt;module&gt;()
----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable
TypeError: unhashable type: 'list'
</code></pre>
<h4 id="按键值排序">按键值排序</h4>
<ul>
<li>键：</li>
</ul>
<pre><code class="language-Python">sorted(dict.keys())
</code></pre>
<ul>
<li>值：</li>
</ul>
<pre><code class="language-Python">sorted(dict.items(),key=lamda:item:item[1])
</code></pre>
<h4 id="其他技巧">其他技巧</h4>
<h5 id="argmin-和-argmax"><code>argmin</code> 和 <code>argmax</code></h5>
<pre><code class="language-python">items = [2, 1, 3, 4]
argmin = min(range(len(items)), key=items.__getitem__)
</code></pre>
<p><code>argmax</code>同理。</p>
<h5 id="转置二维列表">转置二维列表</h5>
<pre><code class="language-python">A = [['a11', 'a12'], ['a21', 'a22'], ['a31', 'a32']]
A_transpose = list(zip(*A))  # list of tuple
A_transpose = list(list(col) for col in zip(*A))  # list of list
</code></pre>
<h3 id="集合">集合</h3>
<ul>
<li>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过<code>set</code>函数或使用尖括号<code>set</code>语句：</li>
</ul>
<pre><code class="language-Python">print(set([2, 2, 2, 1, 3, 3]))
{1, 2, 3}
print({2, 2, 2, 1, 3, 3})
{1, 2, 3}
</code></pre>
<ul>
<li>花括号只能用于初始化包含值的集合。使用不包含值的花括号是初始化字典（<code>dict</code>）的方法之一，而不是初始化集合的方法。</li>
<li>通过<code>add(key)</code>方法可以添加元素到<code>set</code>中,只能将不可变的值（例如一个字符串或一个元组）加入到集合中。如果试图将一个列表（<code>list</code>）添加到集合中，系统会返回类型错误<code>TyprError</code>。</li>
<li>通过<code>remove(key)</code>方法可以删除元素,如果你想要删除一个集合中不存在的值，系统会返回一个键值错误<code>KeyError</code>。</li>
<li>可以使用<code>discard</code>方法从集合中删除一个值。这种方法相对于<code>remove</code>方法的好处是，如果你试图删除一个集合中不存在的值，系统不会返回<code>KeyError</code>。</li>
<li>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</li>
</ul>
<pre><code class="language-Python">a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a.union(b))
{1, 2, 3, 4, 5, 6, 7, 8}
print(a | b)
{1, 2, 3, 4, 5, 6, 7, 8}
</code></pre>
<ul>
<li>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</li>
</ul>
<pre><code class="language-Python">print(a.intersection(b))
{3, 4, 5}
print(a &amp; b)
{3, 4, 5}
</code></pre>
<ul>
<li>
<p>常用集合方法</p>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317202703.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200329021757.png" alt="" loading="lazy"></p>
</li>
<li>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
</li>
</ul>
<pre><code class="language-Python">c = a.copy()
c |= b
print(c)
{1, 2, 3, 4, 5, 6, 7, 8}
d = a.copy()
d &amp;= b
print(d)
{3, 4, 5}
</code></pre>
<ul>
<li>检测一个集合是否是另一个集合的子集或父集：</li>
</ul>
<pre><code class="language-Python">a_set = {1, 2, 3, 4, 5}
print({1, 2, 3}.issubset(a_set))
True
print(a_set.issuperset({1, 2, 3}))
True
</code></pre>
<h3 id="列表-集合和字典推导式">列表、集合和字典推导式</h3>
<pre><code class="language-Python">[expr for val in collection if condition]
</code></pre>
<p>等同于：</p>
<pre><code class="language-Python">result = []
for val in collection:
    if condition:
        result.append(expr)
</code></pre>
<ul>
<li>字典:</li>
</ul>
<pre><code class="language-Python">dict_comp = {key-expr : value-expr for value in collection if condition}
</code></pre>
<ul>
<li>集合</li>
</ul>
<pre><code class="language-Python">set_comp = {expr for value in collection if condition}
</code></pre>
<ul>
<li><code>map</code>函数可以进一步简化：</li>
</ul>
<pre><code class="language-Python">print(set(map(len, strings)))
{1, 2, 3, 4, 6}
</code></pre>
<h4 id="嵌套列表推导式">嵌套列表推导式</h4>
<pre><code class="language-Python">all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'],['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]
names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') &gt;= 2]
    names_of_interest.extend(enough_es)
</code></pre>
<p>嵌套列表推导式：</p>
<pre><code class="language-Python">result = [name for names in all_data for name in names if name.count('e') &gt;= 2]
print(result)
result=['Steven']
</code></pre>
<p>以下代码正常输出偶数：</p>
<pre><code class="language-Python">[x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
</code></pre>
<p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p>
<pre><code class="language-Python">[x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？<br>
另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p>
<pre><code class="language-Python">[x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>:</p>
<pre><code class="language-Python">[x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。<br>
可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<pre><code class="language-Python">print([[x for x in tup] for tup in some_tuples])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<h3 id="函数">函数</h3>
<h4 id="参数">参数</h4>
<ul>
<li><code>Python</code>函数参数既不是传参也不是传引用。应该称其为传对象引用,如果是数字，字符串，元组则传值,如果是列表，字典则传址。对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容:</li>
</ul>
<pre><code class="language-Python">def append_element(some_list, element):
    some_list.append(element)
data = [1, 2, 3]
append_element(data, 4)
print(data)
[1, 2, 3, 4]
</code></pre>
<pre><code class="language-Python">def func(d):
    d['a'] = 10
    d['b'] = 20            
    d = {'a': 1, 'b': 2}


d = {}                    # 1
func(d)                   # 2
print(d)
########打印结果########
{'a': 10, 'b': 20}
</code></pre>
<p>想一想, 最后的结果为什么还是<code>{'a': 10, 'b': 20}</code>?<br>
首先在全局创建一个空字典,并将<code>d</code>贴上:</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/v2-5d4d7a9c04d8feac54b3350d8c5b1435_1440w.jpg" alt="" loading="lazy"></figure>
<p>将 <code>d</code> 传入到函数<code>func</code>中,在函数中局部的形参变量也为<code>d</code>,它同样贴在空字典对象上</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174500.png" alt="" loading="lazy"></figure>
<p>在函数中前两句,为字典赋值.因为字典是可变的,这一操作对全局的 <code>d</code> 也会产生同样的影响.因为此时全局的<code>d</code>与函数内部的<code>d</code>贴向的是同一个对象</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174540.png" alt="" loading="lazy"></figure>
<p>函数最后一句,本质上是将函数内部的<code>d</code>贴向另外一个字典对象,全局的<code>d</code>当然还是贴向原来的字典对象.</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174823.png" alt="" loading="lazy"></figure>
<p>函数结束,函数内部的<code>d</code>被回收,而且最后打印结果如下所示</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174908.png" alt="" loading="lazy"></figure>
<ul>
<li>函数可以有一些位置参数(<code>positional</code>)和一些关键字参数(<code>keyword</code>)。关键字参数通常用于指定默认值或可选参数</li>
</ul>
<h4 id="默认参数">默认参数</h4>
<pre><code class="language-Python">i = 1
def test(a=i):
    print(a)

i = 2
test()  # 1
</code></pre>
<p>由于参数默认值是在函数定义时而不是函数执行时确定的，所以这段代码<code>test</code>方法的参数默认值时<code>1</code>而不是<code>2</code>。</p>
<pre><code class="language-Python">def add_end(L=[]):
    L.append('END')
    return L
print(add_end())
['END']
print(add_end())
['END', 'END']
</code></pre>
<ul>
<li>Python函数在定义的时候，默认参数L的值就被计算出来了，即<code>[]</code>，因为默认参数L也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。<br>
<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></li>
<li>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</li>
</ul>
<pre><code class="language-Python">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>举例：</p>
<pre><code class="language-Python">def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')

print &quot;list1 = %s&quot; % list1
print &quot;list2 = %s&quot; % list2
print &quot;list3 = %s&quot; % list3

list1 = [10, 'a']
list2 = [123]
list3 = [10, 'a']
</code></pre>
<p>很多人都会误认为<code>list1=[10]</code>，<code>list3=[‘a’]</code>,因为他们以为每次<code>extendList</code>被调用时，列表参数的默认值都将被设置为<code>[]</code>.但实际上的情况是，新的默认列表只在函数被定义的那一刻创建一次。<br>
当<code>extendList</code>被没有指定特定参数<code>list</code>调用时，这组<code>list</code>的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。因此<code>list1</code>和<code>list3</code>是在同一个默认列表上进行操作（计算）的。而<code>list2</code>是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。<br>
<code>extendList</code>的定义可以作如下修改。<br>
尽管，创建一个新的列表，没有特定的列表参数。<br>
下面这段代码可能能够产生想要的结果。</p>
<pre><code class="language-Python">def extendList(val, list=None):
  if list is None:
    list = []
  list.append(val)
  return list
</code></pre>
<p>通过上面的修改，输出结果将变成：</p>
<pre><code class="language-Python">list1 = [10]
list2 = [123]
list3 = ['a']
</code></pre>
<ul>
<li>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。<br>
默认参数的值应该是不可变的对象，比如<code>None</code>、<code>True</code>、<code>False</code>、数字或字符串。 特别的，千万不要像下面这样写代码：</li>
</ul>
<pre><code class="language-python">def spam(a, b=[]): # NO!
    ...
</code></pre>
<p>如果你这么做了，当默认值在其他地方被修改后你将会遇到各种麻烦。这些修改会影响到下次调用这个函数时的默认值。比如：</p>
<pre><code class="language-python">def spam(a, b=[]):
    print(b)
    return b
x = spam(1)
x
[]
x.append(99)
x.append('Yow!')
x
[99, 'Yow!']
spam(1) # Modified list gets returned!
[99, 'Yow!']
</code></pre>
<p>这种结果应该不是你想要的。为了避免这种情况的发生，最好是将默认值设为<code>None</code>， 然后在函数里面检查它，前面的例子就是这样做的。<br>
在测试<code>None</code>值时使用 <code>is</code> 操作符是很重要的，也是这种方案的关键点。 有时候大家会犯下下面这样的错误：</p>
<pre><code class="language-python">def spam(a, b=None):
    if not b: # NO! Use 'b is None' instead
        b = []
</code></pre>
<p>这么写的问题在于尽管<code>None</code>值确实是被当成<code>False</code>， 但是还有其他的对象(比如长度为<code>0</code>的字符串、列表、元组、字典等)都会被当做<code>False</code>。 因此，上面的代码会误将一些其他输入也当成是没有输入。比如：</p>
<pre><code class="language-python">spam(1) # OK
x = []
spam(1, x) # Silent error. x value overwritten by default
spam(1, 0) # Silent error. 0 ignored
spam(1, '') # Silent error. '' ignored
</code></pre>
<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如<code>None</code>、 <code>0</code>或者<code>False</code>值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。<br>
为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的<code>_no_value</code>变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个<code>_no_value</code>实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。<br>
这里对 <code>object()</code> 的使用看上去有点不太常见。<code>object</code> 是<code>python</code>中所有类的基类。 你可以创建 <code>object</code> 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>
<h4 id="可变参数">可变参数</h4>
<pre><code class="language-Python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括<code>0</code>个参数。<br>
如果已经有一个<code>list</code>或者<code>tuple</code>：</p>
<pre><code class="language-Python">nums = [1, 2, 3]
print(calc(*nums))
14
</code></pre>
<h4 id="关键字参数">关键字参数</h4>
<ul>
<li>关键字参数允许你传入<code>0</code>个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</li>
</ul>
<pre><code class="language-Python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</li>
</ul>
<pre><code class="language-Python">person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<ul>
<li>也可以传入任意个数的关键字参数：</li>
</ul>
<pre><code class="language-Python">person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p>关键字参数可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<br>
和可变参数类似，也可以先组装出一个<code>dict</code>，然后，把该<code>dict</code>转换为关键字参数传进去：</p>
<pre><code class="language-Python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>上面复杂的调用可以用简化的写法：</p>
<pre><code class="language-python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把<code>extra</code>这个<code>dict</code>的所有<code>key-value</code>用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个<code>dict</code>，注意<code>kw</code>获得的<code>dict</code>是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>
<h4 id="命名关键字参数">命名关键字参数</h4>
<ul>
<li>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。<br>
仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</li>
</ul>
<pre><code class="language-Python">def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>和关键字参数<code>**kw不同</code>，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>
调用方式如下：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<ul>
<li>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<ul>
<li>由于调用时缺少参数名<code>city</code>和<code>job</code>，<code>Python</code>解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。</li>
</ul>
<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<pre><code class="language-Python">def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，<code>Python</code>解释器将无法识别位置参数和命名关键字参数：</li>
</ul>
<pre><code class="language-Python">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h4 id="强制位置参数">强制位置参数</h4>
<p><code>Python3.8</code> 新增了一个函数形参语法<code>/</code>用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。<br>
在以下的例子中，形参 <code>a</code> 和 <code>b</code> 必须使用指定位置参数，<code>c</code> 或 <code>d</code> 可以是位置形参或关键字形参，而 <code>e</code> 或 <code>f</code> 要求为关键字形参:</p>
<pre><code class="language-Python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>
<p>以下使用方法是正确的:</p>
<pre><code class="language-Python">f(10, 20, 30, d=40, e=50, f=60)
</code></pre>
<p>以下使用方法会发生错误:</p>
<pre><code class="language-Python">f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
</code></pre>
<h4 id="参数组合">参数组合</h4>
<ul>
<li>在<code>Python</code>中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</li>
</ul>
<pre><code class="language-Python">def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<ul>
<li>在函数调用的时候，<code>Python</code>解释器自动按照参数位置和参数名把对应的参数传进去。</li>
</ul>
<pre><code class="language-Python">f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<ul>
<li>通过一个<code>tuple</code>和<code>dict</code>，你也可以调用上述函数：</li>
</ul>
<pre><code class="language-Python">args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<ul>
<li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。<br>
<strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
<li>示例：<br>
<code>Python</code>五类参数：位置参数，关键字参数，默认参数，可变位置或关键字参数的使用。</li>
</ul>
<pre><code class="language-Python">def f(a,*b,c=10,**d):
  print(f'a:{a},b:{b},c:{c},d:{d}')
</code></pre>
<p>默认参数<code>c</code>不能位于可变关键字参数<code>d</code>后.<br>
调用<code>f</code>:</p>
<pre><code class="language-Python">f(1,2,5,width=10,height=20)
a:1,b:(2, 5),c:10,d:{'width': 10, 'height': 20}
</code></pre>
<p>可变位置参数<code>b</code>实参后被解析为元组<code>(2,5)</code>;而<code>c</code>取得默认值10; <code>d</code>被解析为字典.</p>
<p>再次调用<code>f</code>:</p>
<pre><code class="language-Python">f(a=1,c=12)
a:1,b:(),c:12,d:{}
</code></pre>
<p><code>a=1</code>传入时<code>a</code>就是关键字参数，<code>b</code>,<code>d</code>都未传值，<code>c</code>被传入12，而非默认值。<br>
注意观察参数<code>a</code>, 既可以<code>f(1)</code>,也可以<code>f(a=1)</code> 其可读性比第一种更好，建议使用<code>f(a=1)</code>。如果要强制使用<code>f(a=1)</code>，需要在前面添加一个星号:</p>
<pre><code class="language-Python">def f(*,a,*b):
  print(f'a:{a},b:{b}')
</code></pre>
<p>此时<code>f(1)</code>调用，将会报错：<code>TypeError: f() takes 0 positional arguments but 1 was given</code><br>
只能<code>f(a=1)</code>才能<code>OK</code>.</p>
<p>说明前面的<code>*</code>发挥作用，它变为只能传入关键字参数，那么如何查看这个参数的类型呢？借助<code>Python</code>的<code>inspect</code>模块：</p>
<pre><code class="language-Python">for name,val in signature(f).parameters.items():
    print(name,val.kind)
a KEYWORD_ONLY
b VAR_KEYWORD
</code></pre>
<p>可看到参数<code>a</code>的类型为<code>KEYWORD_ONLY</code>，也就是仅仅为关键字参数。<br>
但是，如果<code>f</code>定义为：</p>
<pre><code class="language-Python">def f(a,*b):
  print(f'a:{a},b:{b}')
</code></pre>
<p>查看参数类型：</p>
<pre><code class="language-python">for name,val in signature(f).parameters.items():
    print(name,val.kind)
a POSITIONAL_OR_KEYWORD
b VAR_POSITIONAL
</code></pre>
<p>可以看到参数<code>a</code>既可以是位置参数也可是关键字参数。</p>
<h4 id="匿名lambda函数">匿名(lambda)函数</h4>
<ul>
<li><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然<code>lambda</code>函数看起来只能写一行，却不等同于<code>C</code>或<code>C++</code>的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<pre><code class="language-Python">strings = ['foo', 'card', 'bar', 'aaaa', 'abab']
strings.sort(key=lambda x: len(set(list(x))))
print(strings)
['aaaa', 'foo', 'abab', 'bar', 'card']
</code></pre>
<p>先看下下面代码的效果：</p>
<pre><code class="language-python">x = 10
a = lambda y: x + y
x = 20
b = lambda y: x + y
print(a(10),b(10))
</code></pre>
<p>现在我问你，<code>a(10)</code>和<code>b(10)</code>返回的结果是什么？如果你认为结果是<code>20</code>和<code>30</code>，那么你就错了：</p>
<pre><code class="language-python">a(10)
30
b(10)
30
</code></pre>
<p>这其中的奥妙在于<code>lambda</code>表达式中的<code>x</code>是一个自由变量， 在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。 因此，在调用这个lambda表达式的时候，<code>x</code>的值是执行时的值。例如：</p>
<pre><code class="language-python">x = 15
a(10)
25
x = 3
a(10)
13
</code></pre>
<p>如果你想让某个匿名函数在定义时就捕获到值，可以将那个参数值定义成默认参数即可，就像下面这样：</p>
<pre><code class="language-python">x = 10
a = lambda y, x=x: x + y
x = 20
b = lambda y, x=x: x + y
a(10)
20
b(10)
30
</code></pre>
<p>在这里列出来的问题是新手很容易犯的错误，有些新手可能会不恰当的使用<code>lambda</code>表达式。 比如，通过在一个循环或列表推导中创建一个<code>lambda</code>表达式列表，并期望函数能在定义时就记住每次的迭代值。例如：</p>
<pre><code class="language-python">funcs = [lambda x: x+n for n in range(5)]
for f in funcs:
    print(f(0))
4
4
4
4
4
</code></pre>
<p>但是实际效果是运行是<code>n</code>的值为迭代的最后一个值。现在我们用另一种方式修改一下：</p>
<pre><code class="language-python">funcs = [lambda x, n=n: x+n for n in range(5)]
for f in funcs:
    print(f(0))
0
1
2
3
4
</code></pre>
<p>通过使用函数默认值参数形式，<code>lambda</code>函数在定义时就能绑定到值。</p>
<h4 id="柯里化部分参数应用">柯里化：部分参数应用</h4>
<ul>
<li>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数:</li>
</ul>
<pre><code class="language-Python">def add_numbers(x, y):
    return x + y
add_five = lambda y: add_numbers(5, y)
</code></pre>
<p><code>add_numbers</code>的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的<code>functools</code>模块可以用<code>partial</code>函数将此过程简化：</p>
<pre><code class="language-Python">from functools import partial
add_five = partial(add_numbers, 5)
</code></pre>
<h4 id="生成器">生成器</h4>
<ul>
<li>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是<code>Python</code>的一个重要特点。这是通过一种叫做迭代器协议(<code>iterator protocol</code>，它是一种使对象可迭代的通用方式)的方式实现的，一个原生的使对象可迭代的方法。</li>
<li>生成器(<code>generator</code>)是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的<code>return</code>替换为<code>yeild</code>即可：</li>
</ul>
<pre><code class="language-Python">def squares(n=10):
    print('Generating squares from 1 to {0}'.format(n ** 2))
    for i in range(1, n + 1):
        yield i ** 2
</code></pre>
<ul>
<li>调用该生成器时，没有任何代码会被立即执行：</li>
</ul>
<pre><code class="language-Python">gen = squares()
print(gen)
&lt;generator object squares at 0x7fbbd5ab4570&gt;
</code></pre>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<pre><code class="language-Python">for x in gen:
    print(x, end=' ')
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100
</code></pre>
<p>在一个对象上实现迭代最简单的方式是使用一个生成器函数。使用<code>Node</code>类来表示树形数据结构。你可能想实现一个以深度优先方式遍历树形节点的生成器。 下面是代码示例：</p>
<pre><code class="language-python">class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()
# Example
if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)
    '''
    Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
    '''
</code></pre>
<p>在这段代码中，<code>depth_first()</code> 方法简单直观。 它首先返回自己本身并迭代每一个子节点并通过调用子节点的 <code>depth_first()</code> 方法(使用 <code>yield from</code> 语句)返回对应元素。</p>
<h4 id="生成器表达式">生成器表达式</h4>
<p>另一种更简洁的构造生成器的方法是使用生成器表达式(<code>generator expression</code>)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：</p>
<pre><code class="language-Python">gen = (x ** 2 for x in range(100))
print(gen)
&lt;generator object &lt;genexpr&gt; at 0x7fbbd5ab29e8&gt;
</code></pre>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<pre><code class="language-Python">def _make_gen():
    for x in range(100):
        yield x ** 2
gen = _make_gen()
</code></pre>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<pre><code class="language-Python">print(sum(x ** 2 for x in range(100)))
328350
print(dict((i, i **2) for i in range(5)))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>
<h4 id="迭代器">迭代器</h4>
<ul>
<li>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。<br>
可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</li>
</ul>
<pre><code class="language-Python">from collections.abc import Iterator
isinstance((x for x in range(10)), Iterator)
True
isinstance([], Iterator)
False
isinstance({}, Iterator)
False
isinstance('abc', Iterator)
False
</code></pre>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<pre><code class="language-Python">isinstance(iter([]), Iterator)
True
isinstance(iter('abc'), Iterator)
True
</code></pre>
<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>
<p>这是因为<code>Python</code>的<code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>
<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用<code>list</code>是永远不可能存储全体自然数的。</p>
<h5 id="类作为迭代器">类作为迭代器</h5>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。<br>
如果你已经了解的面向对象编程，就知道类都有一个构造函数，<code>Python</code> 的构造函数为 <code>__init__()</code>, 它会在对象初始化的时候执行。<br>
<code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。<br>
<code>__next__()</code> 方法(<code>Python 2</code> 里是 <code>next()</code>)会返回下一个迭代器对象。<br>
创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code class="language-Python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
1
2
3
4
5
</code></pre>
<p><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。<br>
在 20 次迭代后停止执行：</p>
<pre><code class="language-Python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
  print(x)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre>
<h5 id="通过字符串调用对象方法">通过字符串调用对象方法</h5>
<p>最简单的情况，可以使用 <code>getattr()</code> ：</p>
<pre><code class="language-python">import math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Point({!r:},{!r:})'.format(self.x, self.y)

    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

p = Point(2, 3)
d = getattr(p, 'distance')(0, 0)  # Calls p.distance(0, 0)
</code></pre>
<p>调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用。 因此，为了调用某个方法，你可以首先通过 <code>getattr()</code> 来查找到这个属性，然后再去以函数方式调用它即可。</p>
<h4 id="函数式编程">函数式编程</h4>
<h5 id="高阶函数">高阶函数</h5>
<h6 id="map函数"><code>map</code>函数</h6>
<ul>
<li><code>map()</code> 会根据提供的函数对指定序列做映射。第一个参数 <code>function</code> 以参数序列中的每一个元素调用 <code>function</code> 函数，返回包含每次 <code>function</code> 函数返回值的新列表。</li>
</ul>
<pre><code class="language-Python">map(function, iterable, ...)
</code></pre>
<ul>
<li><code>function</code>:函数</li>
<li><code>iterable</code>:一个或多个序列</li>
</ul>
<pre><code class="language-Python">def square(x) :            # 计算平方数
    return x ** 2
print(map(square, [1,2,3,4,5]))   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
# 提供了两个列表，对相同位置的列表数据进行相加
print(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
</code></pre>
<h6 id="reduce函数"><code>reduce</code>函数</h6>
<ul>
<li><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是:</li>
</ul>
<pre><code class="language-Python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数13579，reduce就可以派上用场：</p>
<pre><code class="language-Python">from functools import reduce
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))
13579
</code></pre>
<p>考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<pre><code class="language-Python">from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<h6 id="filter函数"><code>filter</code>函数</h6>
<ul>
<li><code>Python</code>内建的<code>filter()</code>函数用于过滤序列。<br>
和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。<br>
注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回<code>list</code>。<br>
筛法求素数：</li>
</ul>
<pre><code class="language-python">def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
def _not_divisible(n):
    return lambda x: x % n &gt; 0
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<h6 id="sorted函数"><code>sorted</code>函数</h6>
<ul>
<li><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</li>
</ul>
<pre><code class="language-Python">print(sorted([7, 1, 2, 6, 0, 3, 2]))
[0, 1, 2, 2, 3, 6, 7]
print(sorted('horse race'))
[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']
</code></pre>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<pre><code class="language-Python">sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>进行反向排序，不必改动<code>key</code>函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-Python">sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h5 id="返回函数">返回函数</h5>
<pre><code class="language-Python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="language-Python">f = lazy_sum(1, 3, 5, 7, 9)
f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code class="language-Python">f()
25
</code></pre>
<p>函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包(Closure)”的程序结构拥有极大的威力。</p>
<h6 id="闭包">闭包</h6>
<ul>
<li>返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</li>
</ul>
<pre><code class="language-Python">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>
你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是1，4，9，但实际结果是：</p>
<pre><code class="language-Python">f1()
9
f2()
9
f3()
9
</code></pre>
<p>全部都是9！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了3，因此最终结果为9。<br>
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>
<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-Python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<pre><code class="language-Python"> f1, f2, f3 = count()
f1()
1
f2()
4
f3()
9
</code></pre>
<p>下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-Python">def multipliers():
  return [lambda x : i * x for i in range(4)]
print [m(2) for m in multipliers()]
</code></pre>
<p>你如何修改上面的<code>multipliers</code>的定义产生想要的结果？<br>
上面代码输出的结果是<code>[6, 6, 6, 6]</code>(不是我们想的<code>[0, 2, 4, 6]</code>)。<br>
上述问题产生的原因是<code>Python</code>闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。因此，当任何由<code>multipliers()</code>返回的函数被调用时，<code>i</code>的值将在附近的范围进行查找。那时，不管返回的函数是否被调用，for循环已经完成，<code>i</code>被赋予了最终的值3。<br>
因此，每次返回的函数乘以传递过来的值3，因为上段代码传过来的值是2，它们最终返回的都是6(3*2)。碰巧的是，《The Hitchhiker’s Guide to Python》也指出，在与<code>lambdas</code>函数相关也有一个被广泛被误解的知识点，不过跟这个<code>case</code>不一样。由<code>lambda</code>表达式创造的函数没有什么特殊的地方，它其实是和def创造的函数式一样的。<br>
下面是解决这一问题的一些方法。<br>
一种解决方法就是用<code>Python</code>生成器。</p>
<pre><code class="language-Python">def multipliers():
  for i in range(4): yield lambda x : i * x
</code></pre>
<p>另外一个解决方案就是创造一个闭包，利用默认函数立即绑定。</p>
<pre><code class="language-Python">def multipliers():
  return [lambda x, i=i : i * x for i in range(4)]
</code></pre>
<p>还有种替代的方案是，使用偏函数：</p>
<pre><code class="language-Python">from functools import partial
from operator import mul
def multipliers():
  return [partial(mul, i) for i in range(4)]
</code></pre>
<p>通常来讲，闭包的内部变量对于外界来讲是完全隐藏的。 但是，你可以通过编写访问函数并将其作为函数属性绑定到闭包上来实现这个目的。例如：</p>
<pre><code class="language-python">def sample():
    n = 0
    # Closure function
    def func():
        print('n=', n)

    # Accessor methods for n
    def get_n():
        return n

    def set_n(value):
        nonlocal n
        n = value

    # Attach as function attributes
    func.get_n = get_n
    func.set_n = set_n
    return func
</code></pre>
<p>下面是使用的例子:</p>
<pre><code class="language-python">f = sample()
f()
n= 0
f.set_n(10)
f()
n= 10
f.get_n()
10
</code></pre>
<p>讨论<br>
为了说明清楚它如何工作的，有两点需要解释一下。首先，<code>nonlocal</code> 声明可以让我们编写函数来修改内部变量的值。</p>
<h5 id="装饰器">装饰器</h5>
<ul>
<li>在代码运行期间动态增加功能的方式，称之为“装饰器”(<code>Decorator</code>)。<br>
本质上，<code>decorator</code>就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的<code>decorator</code>，可以定义如下：</li>
</ul>
<pre><code class="language-Python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
now()
call now():
2015-3-25
</code></pre>
<p>由于<code>log()</code>是一个<code>decorator</code>，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。<br>
<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。<br>
如果<code>decorator</code>本身需要传入参数，那就需要编写一个返回<code>decorator</code>的高阶函数，写出来会更复杂。比如，要自定义<code>log</code>的文本：</p>
<pre><code class="language-Python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
@log('execute')
def now():
    print('2015-3-25')
now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="language-Python">now = log('execute')(now)
</code></pre>
<p>首先执行<code>log('execute')</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p>
<p>以上两种<code>decorator</code>的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过<code>decorator</code>装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>：</p>
<pre><code class="language-Python">now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个<code>wrapper()</code>函数名字就是<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，<code>Python</code>内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的<code>decorator</code>的写法如下：</p>
<pre><code class="language-python">import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的<code>decorator</code>：</p>
<pre><code>import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>在面向对象(OOP)的设计模式中，<code>decorator</code>被称为装饰模式。<code>OOP</code>的装饰模式需要通过继承和组合来实现，而<code>Python</code>除了能支持<code>OOP</code>的<code>decorator</code>外，直接从语法层次支持<code>decorator</code>。<code>Python</code>的<code>decorator</code>可以用函数实现，也可以用类实现。<br>
<code>decorator</code>可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h6 id="property"><code>@property</code></h6>
<p><code>Python</code>内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<pre><code class="language-Python">class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="language-Python">s = Student()
s.score = 60 # OK，实际转化为s.set_score(60)
s.score # OK，实际转化为s.get_score()
60
s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过<code>getter</code>和<code>setter</code>方法来实现的。<br>
还可以定义只读属性，只定义<code>getter</code>方法，不定义<code>setter</code>方法就是一个只读属性：</p>
<pre><code class="language-Python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。<br>
自定义某个属性的一种简单方法是将它定义为一个<code>property</code>。 例如，下面的代码定义了一个<code>property</code>，增加对一个属性简单的类型检查：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)
</code></pre>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 <code>getter</code> 函数，它使得 <code>first_name</code> 成为一个属性。 其他两个方法给 <code>first_name</code> 属性添加了 <code>setter</code> 和 <code>deleter</code> 函数。 需要强调的是只有在 <code>first_name</code> 属性被创建后， 后面的两个装饰器 <code>@first_name.setter</code> 和 <code>@first_name.deleter</code> 才能被定义。<br>
<code>property</code>的一个关键特征是它看上去跟普通的<code>attribute</code>没什么两样， 但是访问它的时候会自动触发 <code>getter</code> 、<code>setter</code> 和 <code>deleter</code> 方法。例如：</p>
<pre><code class="language-python">a = Person('Guido')
a.first_name # Calls the getter
'Guido'
a.first_name = 42 # Calls the setter
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;prop.py&quot;, line 14, in first_name
        raise TypeError('Expected a string')
TypeError: Expected a string
del a.first_name
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can`t delete attribute
</code></pre>
<p>在实现一个<code>property</code>的时候，底层数据(如果有的话)仍然需要存储在某个地方。 因此，在<code>get</code>和<code>set</code>方法中，你会看到对 <code>_first_name</code> 属性的操作，这也是实际数据保存的地方。 另外，你可能还会问为什么 <code>__init__()</code> 方法中设置了 <code>self.first_name</code> 而不是 <code>self._first_name</code> 。 在这个例子中，我们创建一个<code>property</code>的目的就是在设置<code>attribute</code>的时候进行检查。 因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code>self.first_name</code> ，自动调用 <code>setter</code> 方法， 这个方法里面会进行参数的检查，否则就是直接访问 <code>self._first_name</code> 了。<br>
还能在已存在的<code>get</code>和<code>set</code>方法基础上定义<code>property</code>。例如：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)
</code></pre>
<p>一个<code>property</code>属性其实就是一系列相关绑定方法的集合。如果你去查看拥有<code>property</code>的类， 就会发现<code>property</code>本身的<code>fget</code>、<code>fset</code>和<code>fdel</code>属性就是类里面的普通方法。比如：</p>
<pre><code class="language-python">Person.first_name.fget
&lt;function Person.first_name at 0x1006a60e0&gt;
Person.first_name.fset
&lt;function Person.first_name at 0x1006a6170&gt;
Person.first_name.fdel
&lt;function Person.first_name at 0x1006a62e0&gt;
</code></pre>
<p>通常来讲，你不会直接取调用<code>fget</code>或者<code>fset</code>，它们会在访问<code>property</code>的时候自动被触发。<br>
只有当你确实需要对<code>attribute</code>执行其他额外的操作的时候才应该使用到<code>property</code>。 有时候一些从其他编程语言(比如<code>Java</code>)过来的程序员总认为所有访问都应该通过<code>getter</code>和<code>setter</code>， 所以他们认为代码应该像下面这样写：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
</code></pre>
<p>不要写这种没有做任何其他额外操作的<code>property</code>。 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。 其次，它还会让你的程序运行起来变慢很多。 最后，这样的设计并没有带来任何的好处。 特别是当你以后想给普通<code>attribute</code>访问添加额外的处理逻辑的时候， 你可以将它变成一个<code>property</code>而无需改变原来的代码。 因为访问<code>attribute</code>的代码还是保持原样。<br>
<code>Properties</code>还是一种定义动态计算<code>attribute</code>的方法。 这种类型的<code>attributes</code>并不会被实际的存储，而是在需要的时候计算出来。比如：</p>
<pre><code class="language-python">import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

    @property
    def diameter(self):
        return self.radius * 2

    @property
    def perimeter(self):
        return 2 * math.pi * self.radius
</code></pre>
<p>在这里，我们通过使用<code>properties</code>，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的<code>attribute</code>是一样的。 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。 下面是使用的实例：</p>
<pre><code class="language-python">c = Circle(4.0)
c.radius
4.0
c.area  # Notice lack of ()
50.26548245743669
c.perimeter  # Notice lack of ()
25.132741228718345
</code></pre>
<p>尽管<code>properties</code>可以实现优雅的编程接口，但有些时候你还是会想直接使用<code>getter</code>和<code>setter</code>函数。例如：</p>
<pre><code class="language-python">p = Person('Guido')
p.get_first_name()
'Guido'
p.set_first_name('Larry')
</code></pre>
<p>这种情况的出现通常是因为<code>Python</code>代码被集成到一个大型基础平台架构或程序中。 例如，有可能是一个<code>Python</code>类准备加入到一个基于远程过程调用的大型分布式系统中。 这种情况下，直接使用<code>get/set</code>方法(普通方法调用)而不是<code>property</code>或许会更容易兼容。<br>
最后一点，不要像下面这样写有大量重复代码的<code>property</code>定义：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Repeated property code, but for a different name (bad!)
    @property
    def last_name(self):
        return self._last_name

    @last_name.setter
    def last_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._last_name = value
</code></pre>
<p>重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。<br>
在子类中，扩展定义在父类中的<code>property</code>的功能。考虑如下的代码，它定义了一个<code>property</code>：</p>
<pre><code class="language-python">class Person:
    def __init__(self, name):
        self.name = name

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)
</code></pre>
<p>下面是一个示例类，它继承自<code>Person</code>并扩展了 <code>name</code> 属性的功能：</p>
<pre><code class="language-python">class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>
<p>接下来使用这个新类：</p>
<pre><code class="language-python">s = SubPerson('Guido')
Setting name to Guido
s.name
Getting name
'Guido'
s.name = 'Larry'
Setting name to Larry
s.name = 42
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 16, in name
        raise TypeError('Expected a string')
TypeError: Expected a string
</code></pre>
<p>如果你仅仅只想扩展<code>property</code>的某一个方法，那么可以像下面这样写：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>或者，你只想修改<code>setter</code>方法，就这么写：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)
</code></pre>
<p>在子类中扩展一个<code>property</code>可能会引起很多不易察觉的问题， 因为一个<code>property</code>其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的集合，而不是单个方法。 因此，当你扩展一个<code>property</code>的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个。<br>
在第一个例子中，所有的<code>property</code>方法都被重新定义。 在每一个方法中，使用了 <code>super()</code> 来调用父类的实现。 在 <code>setter</code> 函数中使用 <code>super(SubPerson, SubPerson).name.__set__(self, value)</code> 的语句是没有错的。 为了委托给之前定义的<code>setter</code>方法，需要将控制权传递给之前定义的<code>name</code>属性的 <code>__set__()</code> 方法。 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。 这也是为什么我们要使用 <code>super(SubPerson, SubPerson)</code> 的原因。</p>
<p>如果你只想重定义其中一个方法，那只使用 <code>@property</code> 本身是不够的。比如，下面的代码就无法工作：</p>
<pre><code class="language-python">class SubPerson(Person):
    @property  # Doesn't work
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>如果你试着运行会发现<code>setter</code>函数整个消失了：</p>
<pre><code class="language-python">s = SubPerson('Guido')
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 5, in __init__
        self.name = name
AttributeError: can't set attribute
</code></pre>
<p>你应该像之前说过的那样修改代码：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>这么写后，<code>property</code>之前已经定义过的方法会被复制过来，而<code>getter</code>函数被替换。然后它就能按照期望的工作了：</p>
<pre><code class="language-python">s = SubPerson('Guido')
s.name
Getting name
'Guido'
s.name = 'Larry'
s.name
Getting name
'Larry'
s.name = 42
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 16, in name
        raise TypeError('Expected a string')
TypeError: Expected a string
</code></pre>
<p>在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的 <code>Person</code> 类名。 如果你不知道到底是哪个基类定义了<code>property</code>， 那你只能通过重新定义所有<code>property</code>并使用 <code>super()</code> 来将控制权传递给前面的实现。<br>
值得注意的是上面演示的第一种技术还可以被用来扩展一个描述器。比如：</p>
<pre><code class="language-python">'''
A descriptor
'''
class String:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        instance.__dict__[self.name] = value
'''
A class with a descriptor
'''
class Person:
    name = String('name')

    def __init__(self, name):
        self.name = name
'''
Extending a descriptor with a property
'''
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>
<p>最后值得注意的是，读到这里时，你应该会发现子类化 <code>setter</code> 和 <code>deleter</code> 方法其实是很简单的。</p>
<h6 id="classmethod"><code>@classmethod</code></h6>
<p><code>@classmethod</code>对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。<br>
<code>@classmethod</code>因为持有<code>cls</code>参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>
<pre><code class="language-Python">class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 foo 方法
 
A.func2()               # 不需要实例化
</code></pre>
<h6 id="staticmethod"><code>@staticmethod</code></h6>
<p>将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。<br>
<code>@staticmethod</code>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。<br>
如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接<code>类名.属性名</code>或<code>类名.方法名</code>。</p>
<pre><code class="language-Python">class TestClass:
    name = &quot;test&quot;
    def __init__(self, name):
        self.name = name
    @staticmethod
    def fun(self, x, y):
        return  x + y
cls = TestClass(&quot;felix&quot;)
print &quot;通过实例引用方法&quot;
print cls.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
print &quot;类名直接引用静态方法&quot;
print TestClass.fun(None, 2, 3) # 参数个数必须与定义中的个数保持一致，否则报错
</code></pre>
<h6 id="dataclass"><code>@dataclass</code></h6>
<pre><code class="language-Python">class MyClass:
    def __init__(self, var_a, var_b):
        self.var_a = var_a
        self.var_b = var_b
@dataclass
class MyClass:
    var_a: str
    var_b: str
@dataclass
class Number:
    val:int = 0
</code></pre>
<h5 id="偏函数">偏函数</h5>
<ul>
<li><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换。<br>
但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入<code>base</code>参数，就可以做N进制的转换：<br>
<code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</li>
</ul>
<pre><code class="language-python">import functools
int2 = functools.partial(int, base=2)
int2('1000000')
64
int2('1010101')
85
</code></pre>
<ul>
<li>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>
注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为2，但也可以在函数调用时传入其他值：</li>
</ul>
<pre><code class="language-Python">int2('1000000', base=10)
1000000
</code></pre>
<ul>
<li>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</li>
</ul>
<pre><code class="language-Python">int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了<code>int()</code>函数的关键字参数<code>base</code>，也就是：</p>
<pre><code>int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code>kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code class="language-Python">max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>
<pre><code class="language-Python">max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code class="language-Python">args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。<br>
当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
<h4 id="itertools模块"><code>itertools</code>模块</h4>
<ul>
<li>标准库<code>itertools</code>模块中有一组用于许多常见数据算法的生成器。例如，<code>groupby</code>可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</li>
</ul>
<pre><code class="language-Python">import itertools
first_letter = lambda x: x[0]
names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
for letter, names in itertools.groupby(names, first_letter):
    print(letter, list(names)) # names is a generator
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']
</code></pre>
<ul>
<li>常用<code>itertools</code>函数:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373137383639312d313131383233643837363761313034642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f77.png" alt="" loading="lazy"><br>
子序列工具:</li>
</ul>
<pre><code class="language-python">import itertools
itertools.islice(iterable, start=None, stop, step=None)
'''
slice('ABCDEF', 2, None) -&gt; C, D, E, F
'''
itertools.filterfalse(predicate, iterable)         # 过滤掉predicate为False的元素
'''
filterfalse(lambda x: x &lt; 5, [1, 4, 6, 4, 1]) -&gt; 6
'''
itertools.takewhile(predicate, iterable)           # 当predicate为False时停止迭代
'''
takewhile(lambda x: x &lt; 5, [1, 4, 6, 4, 1]) -&gt; 1, 4
'''
itertools.dropwhile(predicate, iterable)           # 当predicate为False时开始迭代
'''
dropwhile(lambda x: x &lt; 5, [1, 4, 6, 4, 1]) -&gt; 6, 4, 1
'''
itertools.compress(iterable, selectors)            # 根据selectors每个元素是True或False进行选择
'''
compress('ABCDEF', [1, 0, 1, 0, 1, 1]) -&gt; A, C, E, F
'''
</code></pre>
<p>序列排序：</p>
<pre><code class="language-python">sorted(iterable, key=None, reverse=False)
itertools.groupby(iterable, key=None)              # 按值分组，iterable需要先被排序
'''
groupby(sorted([1, 4, 6, 4, 1])) -&gt; (1, iter1), (4, iter4), (6, iter6)
'''
itertools.permutations(iterable, r=None)           # 排列，返回值是Tuple
'''
permutations('ABCD', 2) -&gt; AB, AC, AD, BA, BC, BD, CA, CB, CD, DA, DB, DC
'''
itertools.combinations(iterable, r=None)           # 组合，返回值是Tuple
itertools.combinations_with_replacement(...)
'''
combinations('ABCD', 2) -&gt; AB, AC, AD, BC, BD, CD
'''
</code></pre>
<p>多个序列合并：</p>
<pre><code class="language-python">itertools.chain(*iterables)                        # 多个序列直接拼接
'''
chain('ABC', 'DEF') -&gt; A, B, C, D, E, F
'''
import heapq
heapq.merge(*iterables, key=None, reverse=False)   # 多个序列按顺序拼接
'''
merge('ABF', 'CDE') -&gt; A, B, C, D, E, F
'''
zip(*iterables)                                    # 当最短的序列耗尽时停止，结果只能被消耗一次
itertools.zip_longest(*iterables, fillvalue=None)  # 当最长的序列耗尽时停止，结果只能被消耗一次
</code></pre>
<h3 id="字符串">字符串</h3>
<pre><code class="language-Python"> a= 'ABC'
</code></pre>
<p>在内存中创建了一个<code>'ABC'</code>的字符串；<br>
在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。<br>
也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p>
<pre><code class="language-Python">a = 'ABC'
b = a
a = 'XYZ'
print(b)
'ABC`
</code></pre>
<h4 id="分割">分割</h4>
<pre><code class="language-Python">s = 'Python'
list(s)
['p', 'y', 't', 'h', 'o', 'n']
</code></pre>
<h4 id="模板化或格式化">模板化或格式化</h4>
<pre><code class="language-Python">template = '{0:.2f} {1:s} are worth US${2:d}'
</code></pre>
<ul>
<li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>{1:s}</code>表示格式化第二个参数为字符串。</li>
<li><code>{2:d}</code>表示格式化第三个参数为一个整数。<br>
在括号中的数字用于指向传入对象在 <code>format()</code> 中的位置，如下所示：</li>
</ul>
<pre><code class="language-Python">print('{0} 和 {1}'.format('Google', 'Runoob'))
Google 和 Runoob
print('{1} 和 {0}'.format('Google', 'Runoob'))
Runoob 和 Google
</code></pre>
<p>如果在<code>format()</code> 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code class="language-Python">print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
菜鸟教程网址： www.runoob.com
</code></pre>
<p>位置及关键字参数可以任意的结合:</p>
<pre><code class="language-Python">print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
站点列表 Google, Runoob, 和 Taobao。
</code></pre>
<p>可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 <code>Pi</code> 保留到小数点后三位：</p>
<pre><code class="language-Python">import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre>
<p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。<br>
最简单的就是传入一个字典, 然后使用方括号 <code>[]</code> 来访问键值 :</p>
<pre><code class="language-Python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<p>也可以通过在 <code>table</code> 变量前使用 <code>**</code> 来实现相同的功能：</p>
<pre><code class="language-Python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<h4 id="常用操作">常用操作</h4>
<ul>
<li><code>str.join(iterable)</code>:返回一个由 <code>iterable</code> 中的字符串拼接而成的字符串。比<code>+</code>效率要高。<br>
如果你想要合并的字符串是在一个序列或者 <code>iterable</code> 中，那么最快的方式就是使用 <code>join()</code> 方法。比如：</li>
</ul>
<pre><code class="language-python">parts = ['Is', 'Chicago', 'Not', 'Chicago?']
' '.join(parts)
'Is Chicago Not Chicago?'
','.join(parts)
'Is,Chicago,Not,Chicago?'
''.join(parts)
'IsChicagoNotChicago?'
</code></pre>
<p>初看起来，这种语法看上去会比较怪，但是 <code>join()</code> 被指定为字符串的一个方法。 这样做的部分原因是你想去连接的对象可能来自各种不同的数据序列(比如列表，元组，字典，文件，集合或生成器等)， 如果在所有这些对象上都定义一个 <code>join()</code> 方法明显是冗余的。 因此你只需要指定你想要的分割字符串并调用他的 <code>join()</code> 方法去将文本片段组合起来。<br>
如果你仅仅只是合并少数几个字符串，使用加号<code>(+)</code>通常已经足够了：</p>
<pre><code class="language-python">a = 'Is Chicago'
b = 'Not Chicago?'
a + ' ' + b
'Is Chicago Not Chicago?'
</code></pre>
<p>加号<code>(+)</code>操作符在作为一些复杂字符串格式化的替代方案的时候通常也工作的很好，比如：</p>
<pre><code class="language-python">print('{} {}'.format(a,b))
Is Chicago Not Chicago?
print(a + ' ' + b)
Is Chicago Not Chicago?
</code></pre>
<p>如果你想在源码中将两个字面字符串合并起来，你只需要简单的将它们放到一起，不需要用加号<code>(+)</code>。比如：</p>
<pre><code class="language-python">a = 'Hello' 'World'
a
'HelloWorld'
</code></pre>
<p>字符串合并可能看上去并不需要用一整节来讨论。 但是不应该小看这个问题，程序员通常在字符串格式化的时候因为选择不当而给应用程序带来严重性能损失。<br>
最重要的需要引起注意的是，当我们使用加号<code>(+)</code>操作符去连接大量的字符串的时候是非常低效率的， 因为加号连接会引起内存复制以及垃圾回收操作。 特别的，你永远都不应像下面这样写字符串连接代码：</p>
<pre><code class="language-python">s = ''
for p in parts:
    s += p
</code></pre>
<p>这种写法会比使用 <code>join()</code> 方法运行的要慢一些，因为每一次执行<code>+=</code>操作的时候会创建一个新的字符串对象。 你最好是先收集所有的字符串片段然后再将它们连接起来。<br>
一个相对比较聪明的技巧是利用生成器表达式转换数据为字符串的同时合并字符串，比如：</p>
<pre><code class="language-python">data = ['ACME', 50, 91.1]
','.join(str(d) for d in data)
'ACME,50,91.1'
</code></pre>
<p>同样还得注意不必要的字符串连接操作。有时候程序员在没有必要做连接操作的时候仍然多此一举。比如在打印的时候：</p>
<pre><code class="language-python">print(a + ':' + b + ':' + c) # Ugly
print(':'.join([a, b, c])) # Still ugly
print(a, b, c, sep=':') # Better
</code></pre>
<p>当混合使用<code>I/O</code>操作和字符串连接操作的时候，有时候需要仔细研究你的程序。 比如，考虑下面的两端代码片段：</p>
<pre><code class="language-python">'''
Version 1 (string concatenation)
'''
f.write(chunk1 + chunk2)
'''
Version 2 (separate I/O operations)
'''
f.write(chunk1)
f.write(chunk2)
</code></pre>
<p>如果两个字符串很小，那么第一个版本性能会更好些，因为<code>I/O</code>系统调用天生就慢。 另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效， 因为它避免了创建一个很大的临时结果并且要复制大量的内存块数据。 还是那句话，有时候是需要根据你的应用程序特点来决定应该使用哪种方案。<br>
最后谈一下，如果你准备编写构建大量小字符串的输出代码， 你最好考虑下使用生成器函数，利用yield语句产生输出片段。比如：</p>
<pre><code class="language-python">def sample():
    yield 'Is'
    yield 'Chicago'
    yield 'Not'
    yield 'Chicago?'
</code></pre>
<p>这种方法一个有趣的方面是它并没有对输出片段到底要怎样组织做出假设。 例如，你可以简单的使用 <code>join()</code> 方法将这些片段合并起来：</p>
<pre><code class="language-python">text = ''.join(sample())
</code></pre>
<p>或者你也可以将字符串片段重定向到<code>I/O</code>：</p>
<pre><code class="language-python">for part in sample():
    f.write(part)
</code></pre>
<p>再或者你还可以写出一些结合<code>I/O</code>操作的混合方案：</p>
<pre><code class="language-python">def combine(source, maxsize):
    parts = []
    size = 0
    for part in source:
        parts.append(part)
        size += len(part)
        if size &gt; maxsize:
            yield ''.join(parts)
            parts = []
            size = 0
    yield ''.join(parts)
'''
结合文件操作
'''
with open('filename', 'w') as f:
    for part in combine(sample(), 32768):
        f.write(part)
</code></pre>
<p>这里的关键点在于原始的生成器函数并不需要知道使用细节，它只负责生成字符串片段就行了。</p>
<ul>
<li><code>eval(str)</code>:用来计算在字符串中的有效<code>Python</code>表达式,并返回一个对象</li>
<li><code>str.center(width[, fillchar])</code>:返回长度为 <code>width</code> 的字符串，原字符串在其正中。 使用指定的 <code>fillchar</code> 填充两边的空位（默认使用 <code>ASCII</code> 空格符）。 如果 <code>width</code> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</li>
<li><code>str.count(str, beg= 0,end=len(string))</code>:返回 <code>str</code> 在 <code>string</code> 里面出现的次数，如果 <code>beg</code> 或者 <code>end</code>指定则返回指定范围内 <code>str</code> 出现的次数</li>
<li><code>str.find(str, beg=0, end=len(string))</code>:检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code> ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回<code>-1</code></li>
<li><code>str.index(sub, start=None, end=None)</code>:如果找不到抛出<code>ValueError</code>异常</li>
<li><code>str.upper()</code>:转换字符串中的小写字母为大写</li>
<li><code>str.lower()</code>:转换字符串中所有大写字符为小写</li>
<li><code>str.replace(old, new [, max])</code>:将字符串中的 <code>str1</code> 替换成 <code>str2</code>,如果<code>max</code>指定，则替换不超过<code>max</code>次。<br>
想处理中间的空格,使用 <code>replace()</code> 方法。示例如下：</li>
</ul>
<pre><code class="language-python">s.replace(' ', '')
'helloworld'
</code></pre>
<ul>
<li><code>str.split(str=&quot;&quot;, num=string.count(str))</code>:<code>num=string.count(str))</code> 以<code>str</code>为分隔符截取字符串，如果<code>num</code>有指定值，则仅截取<code>num+1</code>个子字符串</li>
<li><code>str.strip([chars])</code>:截掉字符串两边的空格或指定字符。</li>
<li>匹配的是字面字符串，那么你通常只需要调用基本字符串方法就行， 比如 <code>str.find()</code> , <code>str.endswith()</code> , <code>str.startswith()</code> 或者类似的方法：</li>
</ul>
<pre><code class="language-python">text = 'yeah, but no, but yeah, but no, but yeah'
'''
Exact match
'''
text == 'yeah'
False
'''
Match at start or end
'''
text.startswith('yeah')
True
text.endswith('no')
False
'''
Search for the location of the first occurrence
'''
text.find('no')
10
</code></pre>
<h3 id="运算符">运算符</h3>
<h4 id="和is"><code>==</code>和<code>is</code></h4>
<ul>
<li>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法:</li>
</ul>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
c = list(a)
print(a is b)
True
'''
因为list总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。
'''
print(a is not c)
True
print(a == c)
True
</code></pre>
<p><code>is</code> 用于判断两个变量引用对象是否为同一个， <code>==</code> 用于判断引用变量的值是否相等。<br>
<code>a is b</code> 相当于 <code>id(a)==id(b)</code>.<br>
如果 <code>a=10;b=a;</code> 则此时 <code>a</code> 和 <code>b</code> 的内存地址一样的;<br>
但当 <code>a=[1,2,3]</code>; 另 <code>b=a[:]</code> 时，虽然 <code>a</code> 和 <code>b</code> 的值一样，但内存地址不一样。</p>
<h4 id="any和all"><code>any()</code>和<code>all()</code></h4>
<p><code>any()</code>, <code>all()</code>很好理解，就是字面意思，即参数中任何一个为 <code>true</code> 或者全部为 <code>true</code> 则返回 <code>true</code>。</p>
<h4 id="十进制转二进制">十进制转二进制</h4>
<pre><code class="language-Python">bin(10)
'0b1010'
</code></pre>
<h4 id="判断类型">判断类型</h4>
<pre><code class="language-python">type(a) == int      # 忽略面向对象设计中的多态特征
isinstance(a, int)  # 考虑了面向对象设计中的多态特征
</code></pre>
<h2 id="模块">模块</h2>
<ul>
<li>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，<code>Python</code>就把这个目录当成普通目录，而不是一个包。</li>
<li>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</li>
<li>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。<br>
<code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该``.py文件的名称，例如：<br>
运行<code>Python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；<br>
运行<code>Python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael]</code>。<br>
注意当使用 <code>from package import item</code> 这种形式的时候，对应的 <code>item</code> 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。<br>
<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。<br>
反之，如果使用形如 <code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</li>
<li>内置的函数 <code>dir()</code> 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</li>
<li><code>sys.argv</code> 是一个包含命令行参数的列表。<code>sys.path</code> 包含了一个 <code>Python</code> 解释器自动查找所需模块的路径的列表。</li>
<li>搜索路径是由一系列目录名组成的，<code>Python</code>解释器就依次从这些目录中去寻找所引入的模块。<br>
搜索路径是在<code>Python</code>编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在<code>sys</code>模块中的<code>path</code>变量，做一个简单的实验，在交互式解释器中，输入以下代码：</li>
</ul>
<pre><code class="language-Python">import sys
sys.path
['', '/usr/lib/Python3.4', '/usr/lib/Python3.4/plat-x86_64-linux-gnu', '/usr/lib/Python3.4/lib-dynload', '/usr/local/lib/Python3.4/dist-packages', '/usr/lib/Python3/dist-packages']
</code></pre>
<p><code>sys.path</code> 输出是一个列表，其中第一项是空串<code>''</code>，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行<code>Python</code>解释器的目录（对于脚本的话就是运行的脚本所在的目录）。<br>
因此若在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。<br>
了解了搜索路径的概念，就可以在脚本中修改<code>sys.path</code>来引入一些不在搜索路径中的模块。<br>
如果我们要添加自己的搜索目录，有两种方法：<br>
一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<pre><code class="language-Python">import sys
sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是在运行时修改，运行结束后失效。<br>
第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，<code>Python</code>自己本身的搜索路径不受影响。<br>
现在，在解释器的当前目录或者 <code>sys.path</code>中的一个目录里面来创建一个<code>fibo.py</code>的文件，代码如下：</p>
<pre><code class="language-Python">'''
斐波那契(fibonacci)数列模块
'''
def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre>
<p>然后进入<code>Python</code>解释器，使用下面的命令导入这个模块：</p>
<pre><code class="language-Python">import fibo
</code></pre>
<p>这样做并没有把直接定义在<code>fibo</code>中的函数名称写入到当前符号表里，只是把模块<code>fibo</code>的名字写到了那里。</p>
<h3 id="name属性"><code>name</code>属性</h3>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code class="language-Python">'''
Filename: using_name.py
'''
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<pre><code class="language-shell">$ Python using_name.py
程序自身在运行
$ Python
&gt;&gt;&gt;import using_name
我来自另一模块
</code></pre>
<p>说明： 每个模块都有一个<code>__name_</code>_属性，当其值是<code>'__main__'</code>时，表明该模块自身在运行，否则是被引入。</p>
<h4 id="包">包</h4>
<ul>
<li>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</li>
</ul>
<pre><code class="language-Python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<p>如果 <code>__all__</code>真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 <code>sound.effects</code> 里的任何子模块。他只是把包<code>sound.effects</code>和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。<br>
这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code class="language-Python">import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre>
<p>这个例子中，在执行 <code>from...import</code> 前，包 <code>sound.effects</code> 中的 <code>echo</code> 和 <code>surround</code> 模块都被导入到当前的命名空间中了。（当然如果定义了 <code>__all__</code> 就更没问题了）</p>
<h2 id="oop">OOP</h2>
<h3 id="__new__和__init__区别"><code>__new__</code>和<code>__init__</code>区别</h3>
<p><code>__init__</code>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数。</p>
<ol>
<li><code>__new__</code>至少要有一个参数<code>cls</code>，代表当前类，此参数在实例化时由<code>Python</code>解释器自动识别</li>
<li><code>__new__</code>必须要有返回值，返回实例化出来的实例，这点在自己实现<code>__new__</code>时要特别注意，可以<code>return</code>父类（通过<code>super(当前类名, cls)</code>）<code>__new__</code>出来的实例，或者直接是<code>object</code>的<code>__new__</code>出来的实例</li>
<li><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>返回的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值</li>
<li>如果<code>__new__</code>创建的是当前类的实例，会自动调用<code>__init__</code>函数，通过<code>return</code>语句里面调用的<code>__new__</code>函数的第一个参数是<code>cls</code>来保证是当前类实例，如果是其他类的类名，那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<code>__init__</code>函数，也不会调用其他类的<code>__init__</code>函数。</li>
</ol>
<pre><code class="language-python">class A(object):
    def __init__(self):
        print('这是init方法:',self)
    def __new__(cls):
        print('这是cls的ID:',id(cls))
        print('这是new方法:',object.__new__(cls))
        return(object.__new__(cls))
A()
print('这是类A的ID',id(A))
这是cls的ID: 140345183503936
这是new方法: &lt;__main__.A object at 0x7fa4b0290ed0&gt;
这是init方法: &lt;__main__.A object at 0x7fa4b0290ed0&gt;# __init__方法的self和new方法返回地址一样，说明返回值是对象
这是类A的ID 140345183503936# cls和类ID一样，说明指向同一个类
</code></pre>
<h3 id="访问限制">访问限制</h3>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在<code>Python</code>中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量(<code>private</code>)，只有内部可以访问，外部不能访问:</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
<pre><code class="language-Python">bart = Student('Bart Simpson', 59)
bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>外部代码要获取<code>name</code>和<code>score</code>,修改属性,可以给<code>Student</code>类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<pre><code class="language-Python">class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
    def set_score(self, score):
        self.__score = score
</code></pre>
<p>那种直接通过<code>bart.score = 99</code>也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code class="language-Python">class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>在<code>Python</code>中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是<code>private</code>变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。<br>
下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为<code>Python</code>解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name来访问__name</code>变量：</p>
<pre><code class="language-Python">bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的<code>Python</code>解释器可能会把<code>__name</code>改成不同的变量名。<br>
总的来说就是，<code>Python</code>本身没有任何机制阻止你干坏事，一切全靠自觉。<br>
最后注意下面的这种错误写法：</p>
<pre><code class="language-Python">bart = Student('Bart Simpson', 59)
bart.get_name()
'Bart Simpson'
bart.__name = 'New Name' # 设置__name变量！
bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和<code>class</code>内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被<code>Python</code>解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<pre><code class="language-Python">bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<p>你还可能会遇到在类定义中使用两个下划线<code>(__)</code>开头的命名。比如：</p>
<pre><code class="language-python">class B:
    def __init__(self):
        self.__private = 0

    def __private_method(self):
        pass

    def public_method(self):
        pass
        self.__private_method()
</code></pre>
<p>使用双下划线开始会导致访问名称变成其他形式。 比如，在前面的类<code>B</code>中，私有属性会被分别重命名为 <code>_B__private</code> 和 <code>_B__private_method</code> 。 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p>
<pre><code class="language-python">class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1 # Does not override B.__private
    '''
    Does not override B.__private_method()
    '''
    def __private_method(self):
        pass
</code></pre>
<p>这里，私有名称 <code>__private</code> 和 <code>__private_method</code> 被重命名为 <code>_C__private</code> 和 <code>_C__private_method</code> ，这个跟父类<code>B</code>中的名称是完全不同的。<br>
大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<h3 id="继承和多态">继承和多态</h3>
<pre><code class="language-Python">'''
类定义
'''
class people:
'''
    定义基本属性
'''
    name = ''
    age = 0
    '''
    定义私有属性,私有属性在类外部无法直接进行访问
    '''
    __weight = 0
    '''
    定义构造方法
    '''
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
'''
单继承示例
'''
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
    '''
        调用父类的构函
    '''
        people.__init__(self,n,a,w)
        self.grade = g
    '''
    覆写父类的方法
    '''
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
</code></pre>
<pre><code class="language-Python">class Animal(object):
    def run(self):
        print('Animal is running...')
class Dog(Animal):
    def run(self):
        print('Dog is running...')
</code></pre>
<p>子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。]</p>
<pre><code class="language-Python">a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
isinstance(a, list)
True
isinstance(b, Animal)
True
isinstance(c, Dog)
True
</code></pre>
<p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p>
<pre><code class="language-Python">isinstance(c, Animal)
True
</code></pre>
<p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！<br>
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p>
<pre><code class="language-Python">def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<pre><code class="language-Python">run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>多态的好处就是，当我们需要传入<code>Dog</code>时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>还是<code>Dog</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>
对扩展开放：允许新增<code>Animal</code>子类；<br>
对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>
对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>
对于<code>Python</code>这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<pre><code class="language-Python">class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>
<code>Python</code>的<code>“file-like object“</code>就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为<code>“file-like object“</code>。许多函数接收的参数就是<code>“file-like object“</code>，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。<br>
下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-Python">class Parent(object):
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass
print Parent.x, Child1.x, Child2.x
Child1.x = 2
print Parent.x, Child1.x, Child2.x
Parent.x = 3
print Parent.x, Child1.x, Child2.x
1 1 1
1 2 1
3 2 3
</code></pre>
<p>让很多人困惑或惊讶的是最后一行输出为什么是3 2 3 而不是 3 2 1.为什么在改变<code>parent.x</code>的同时也改变了<code>child2.x</code>的值？但与此同时没有改变<code>Child1.x</code>的值？<br>
此答案的关键是，在<code>Python</code>中，类变量在内部是以字典的形式进行传递。<br>
如果一个变量名没有在当前类下的字典中发现。则在更高级的类（如它的父类）中尽心搜索直到引用的变量名被找到。（如果引用变量名在自身类和更高级类中没有找到，将会引发一个属性错误。）<br>
因此,在父类中设定<code>x = 1</code>,让变量<code>x</code>类(带有值1)能够在其类和其子类中被引用到。这就是为什么第一个打印语句输出结果是1 1 1<br>
因此，如果它的任何一个子类被覆写了值（例如说，当我们执行语句<code>Child1.x = 2</code>）,这个值只在子类中进行了修改。这就是为什么第二个打印语句输出结果是1 2 1<br>
最终，如果这个值在父类中进行了修改，（例如说，当我们执行语句<code>Parent.x = 3</code>）,这个改变将会影响那些还没有覆写子类的值（在这个例子中就是<code>Child2</code>）这就是为什么第三打印语句输出结果是3 2 3</p>
<h3 id="获取对象信息">获取对象信息</h3>
<h4 id="使用type">使用<code>type()</code></h4>
<p>判断对象类型，使用<code>type()</code>函数：</p>
<pre><code class="language-Python">type(123)
&lt;class 'int'&gt;
type('str')
&lt;class 'str'&gt;
type(None)
&lt;type(None) 'NoneType'&gt;
type(abs)
&lt;class 'builtin_function_or_method'&gt;
type(a)
&lt;class '__main__.Animal'&gt;
&gt;&gt;&gt; import types
def fn():
    pass
type(fn)==types.FunctionType
True
type(abs)==types.BuiltinFunctionType
True
type(lambda x: x)==types.LambdaType
True
type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h4 id="使用isinstance">使用<code>isinstance()</code></h4>
<p>判断<code>class</code>的类型，可以使用<code>isinstance()</code>函数。</p>
<pre><code class="language-Python">isinstance([1, 2, 3], (list, tuple))
True
isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</strong></p>
<h4 id="使用dir">使用dir()</h4>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个<code>str</code>对象的所有属性和方法：</p>
<pre><code class="language-Python">dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p>类似<code>__xxx__</code>的属性和方法在<code>Python</code>中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在<code>Python</code>中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<pre><code class="language-Python">len('ABC')
3
'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<pre><code class="language-Python">class MyDog(object):
    def __len__(self):
        return 100
dog = MyDog()
len(dog)
100
</code></pre>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p>
<pre><code class="language-Python">'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<pre><code class="language-Python">class MyObject(object):
    def __init__(self):
        self.x = 9
    def power(self):
        return self.x * self.x
obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code class="language-Python">hasattr(obj, 'x') # 有属性'x'吗？
True
obj.x
9
hasattr(obj, 'y') # 有属性'y'吗？
False
setattr(obj, 'y', 19) # 设置一个属性'y'
hasattr(obj, 'y') # 有属性'y'吗？
True
getattr(obj, 'y') # 获取属性'y'
19
obj.y # 获取属性'y'
19
</code></pre>
<p>如果试图获取不存在的属性，会抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-Python">getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个<code>default</code>参数，如果属性不存在，就返回默认值：</p>
<pre><code>getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code class="language-Python">hasattr(obj, 'power') # 有属性'power'吗？
True
getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<h4 id="实例属性和类属性">实例属性和类属性</h4>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>直接在<code>class</code>中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<pre><code class="language-Python">class Student(object):
    name = 'Student'
</code></pre>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<pre><code class="language-Python">class Student(object):
    name = 'Student'
s = Student() # 创建实例s
print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
print(Student.name) # 打印类的name属性
Student
s.name = 'Michael' # 给实例绑定name属性
print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
del s.name # 如果删除实例的name属性
print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>
实例属性属于各个实例所有，互不干扰；<br>
类属性属于类所有，所有实例共享一个属性；<br>
不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h4 id="使用__slots__">使用<code>__slots__</code></h4>
<p>给实例绑定一个方法：</p>
<pre><code class="language-Python">def set_age(self, age): # 定义一个函数作为实例方法
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25) # 调用实例方法
s.age # 测试结果
25
</code></pre>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<pre><code class="language-Python">s2 = Student() # 创建新的实例
s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p>为了给所有实例都绑定方法，可以给class绑定方法：</p>
<pre><code class="language-Python">def set_score(self, score):
    self.score = score
Student.set_score = set_score
</code></pre>
<p>给class绑定方法后，所有实例均可调用.<br>
通常情况下，上面的<code>set_score</code>方法可以直接定义在<code>class</code>中，但动态绑定允许我们在程序运行的过程中动态给<code>class</code>加上功能，这在静态语言中很难实现。<br>
限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。<br>
为了达到限制的目的，<code>Python</code>允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>
<pre><code class="language-Python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```Python
s = Student() # 创建新的实例
s.name = 'Michael' # 绑定属性'name'
s.age = 25 # 绑定属性'age'
s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>由于<code>'score'</code>没有被放到_<code>_slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<pre><code class="language-Python">class GraduateStudent(Student):
    pass
g = GraduateStudent()
g.score = 9999
</code></pre>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h4 id="多重继承">多重继承</h4>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318023741.png" alt="" loading="lazy"></figure>
<pre><code class="language-Python">class Animal(object):
    pass
# 大类:
class Mammal(Animal):
    pass
class Bird(Animal):
    pass
# 各种动物:
class Dog(Mammal):
    pass
class Bat(Mammal):
    pass
class Parrot(Bird):
    pass
class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上<code>Runnable</code>和<code>Flyable</code>的功能，只需要先定义好<code>Runnable</code>和<code>Flyable</code>的类：</p>
<pre><code class="language-Python">class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要<code>Runnable</code>功能的动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p>
<pre><code class="language-Python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要<code>Flyable</code>功能的动物，就多继承一个<code>Flyable</code>，例如<code>Bat</code>：</p>
<pre><code class="language-Python">class Bat(Mammal, Flyable):
    pass
</code></pre>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。<br>
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>为了更好地看出继承关系，我们把<code>Runnable</code>和<code>Flyable</code>改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让某个动物同时拥有好几个<code>MixIn</code>：</p>
<pre><code class="language-Python">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><code>MixIn</code>的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个<code>MixIn</code>的功能，而不是设计多层次的复杂的继承关系。</p>
<p><code>Python</code>自带的很多库也使用了<code>MixIn</code>。举个例子，<code>Python</code>自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的<code>TCP</code>服务，定义如下：</p>
<pre><code class="language-Python">class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的<code>UDP</code>服务，定义如下：</p>
<pre><code class="language-Python">class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个<code>CoroutineMixIn</code>：</p>
<pre><code class="language-Python">class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br>
由于<code>Python</code>允许使用多重继承，因此，<code>MixIn</code>就是一种常见的设计。<br>
只允许单一继承的语言（如<code>Java</code>）不能使用<code>MixIn</code>的设计。</p>
<ul>
<li>若是父类中有相同的方法名，而在子类使用时未指定，<code>Python</code>从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
</ul>
<pre><code class="language-Python">#类定义
class people:
'''
    定义基本属性
    '''
    name = ''
    age = 0
    '''
    定义私有属性,私有属性在类外部无法直接进行访问
    '''
    __weight = 0
    '''
    定义构造方法
    '''
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
'''
单继承示例
'''
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
    '''
        调用父类的构函
        '''
        people.__init__(self,n,a,w)
        self.grade = g
    '''
    覆写父类的方法
    '''
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
''' 
另一个类，多重继承之前的准备
'''
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
'''
多重继承
'''
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<ul>
<li><code>super()</code><br>
如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</li>
</ul>
<pre><code class="language-Python">class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
调用子类方法
调用父类方法
</code></pre>
<p>如果重写了<code>__init__</code>时，要继承父类的构造方法，可以使用 <code>super</code> 关键字：</p>
<pre><code class="language-Python">super(子类，self).__init__(参数1，参数2，....)
</code></pre>
<p>为了调用父类(超类)的一个方法，可以使用 <code>super()</code> 函数，比如：</p>
<pre><code class="language-python">class A:
    def spam(self):
        print('A.spam')
class B(A):
    def spam(self):
        print('B.spam')
        super().spam()  # Call parent spam()
</code></pre>
<p><code>super()</code> 函数的一个常见用法是在 <code>__init__()</code> 方法中确保父类被正确的初始化了：</p>
<pre><code class="language-python">class A:
    def __init__(self):
        self.x = 0
class B(A):
    def __init__(self):
        super().__init__()
        self.y = 1
</code></pre>
<p><code>super()</code> 的另外一个常见用法出现在覆盖<code>Python</code>特殊方法的代码中，比如：</p>
<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>
<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。 如果某个属性名以下划线<code>(_)</code>开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code> ， 否则的话就委派给内部的代理对象 <code>self._obj</code> 去处理。 这看上去有点意思，因为就算没有显式的指明某个类的父类， <code>super()</code> 仍然可以有效的工作。<br>
实际上，大家对于在<code>Python</code>中如何正确使用 <code>super()</code> 函数普遍知之甚少。 你有时候会看到像下面这样直接调用父类的一个方法：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')
</code></pre>
<p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。 比如，考虑如下的情况：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')
class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')

class B(Base):
    def __init__(self):
        Base.__init__(self)
        print('B.__init__')

class C(A,B):
    def __init__(self):
        A.__init__(self)
        B.__init__(self)
        print('C.__init__')
</code></pre>
<p>如果你运行这段代码就会发现 <code>Base.__init__()</code> 被调用两次，如下所示：</p>
<pre><code>c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
</code></pre>
<p>可能两次调用 <code>Base.__init__()</code> 没什么坏处，但有时候却不是。 另一方面，假设你在代码中换成使用 <code>super()</code> ，结果就很完美了：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        super().__init__()
        print('A.__init__')

class B(Base):
    def __init__(self):
        super().__init__()
        print('B.__init__')

class C(A,B):
    def __init__(self):
        super().__init__()  # Only one call to super() here
        print('C.__init__')
</code></pre>
<p>运行这个新版本后，你会发现每个 <code>__init__()</code> 方法只会被调用一次了：</p>
<pre><code class="language-python">c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
</code></pre>
<p>为了弄清它的原理，我们需要花点时间解释下<code>Python</code>是如何实现继承的。 对于你定义的每一个类，<code>Python</code>会计算出一个所谓的方法解析顺序(<code>MRO</code>)列表。 这个<code>MRO</code>列表就是一个简单的所有基类的线性顺序表。例如：</p>
<pre><code class="language-python">C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,
&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>为了实现继承，<code>Python</code>会在<code>MRO</code>列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个<code>MRO</code>列表的构造是通过一个<code>C3</code>线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的<code>MRO</code>列表并遵循如下三条准则：</p>
<ol>
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
<li>老实说，你所要知道的就是<code>MRO</code>列表中的类顺序会让你定义的任意类层级关系变得有意义。</li>
</ol>
<p>当你使用 <code>super()</code> 函数时，<code>Python</code>会在<code>MRO</code>列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个<code>MRO</code>列表，每个方法也只会被调用一次。 这也是为什么在第二个例子中你不会调用两次 <code>Base.__init__()</code> 的原因。</p>
<p><code>super()</code> 有个令人吃惊的地方是它并不一定去查找某个类在<code>MRO</code>中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p>
<pre><code class="language-python">class A:
    def spam(self):
        print('A.spam')
        super().spam()
</code></pre>
<p>如果你试着直接使用这个类就会出错：</p>
<pre><code class="language-python">a = A()
a.spam()
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;&lt;stdin&gt;&quot;, line 4, in spam
AttributeError: 'super' object has no attribute 'spam'
</code></pre>
<p>但是，如果你使用多继承的话看看会发生什么：</p>
<pre><code class="language-python">class B:
    def spam(self):
        print('B.spam')
class C(A,B):
    pass
c = C()
c.spam()
A.spam
B.spam
</code></pre>
<p>你可以看到在类A中使用 <code>super().spam()</code> 实际上调用的是跟类<code>A</code>毫无关系的类<code>B</code>中的 <code>spam()</code> 方法。 这个用类<code>C</code>的<code>MRO</code>列表就可以完全解释清楚了：</p>
<pre><code class="language-python">C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,
&lt;class 'object'&gt;)
</code></pre>
<p>在定义混入类的时候这样使用 <code>super()</code> 是很普遍的。</p>
<p>然而，由于 <code>super()</code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 <code>super()</code> 调用一个非直接父类方法时不会出错。 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在<code>MRO</code>上面的查找链肯定可以找到某个确定的方法。</p>
<h4 id="定制类">定制类</h4>
<h5 id="__str__"><code>__str__</code></h5>
<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。<br>
怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name: %s)' % self.name
print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>
但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p>
<pre><code class="language-Python">s = Student('Michael')
s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h5 id="__iter__"><code>__iter__</code></h5>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，<code>Python</code>的<code>for</code>循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br>
我们以斐波那契数列为例，写一个<code>Fib</code>类，可以作用于<code>for</code>循环：</p>
<pre><code class="language-Python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把<code>Fib</code>实例作用于<code>for</code>循环：</p>
<pre><code class="language-Python">for n in Fib():
    print(n)
1
1
2
3
5
...
46368
75025
</code></pre>
<h5 id="__getitem__"><code>__getitem__</code></h5>
<p><code>Fib</code>实例虽然能作用于<code>for</code>循环，看起来和<code>list</code>有点像，但是，把它当成<code>list</code>来使用还是不行,要表现得像<code>list</code>那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<pre><code class="language-Python">class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
f = Fib()
f[0]
1
f[1]
1
f[2]
2
f[3]
3
f[10]
89
f[100]
573147844013817084101
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
f = Fib()
f[0:5]
[1, 1, 2, 3, 5]
f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作<code>key</code>的<code>object</code>，例如<code>str</code>。<br>
与之对应的是<code>__setitem__()</code>方法，把对象视作<code>list</code>或<code>dict</code>来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。<br>
总之，通过上面的方法，我们自己定义的类表现得和<code>Python</code>自带的<code>list</code>、<code>tuple</code>、<code>dict</code>没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h5 id="__getattr__"><code>__getattr__</code></h5>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p>
<pre><code class="language-Python">s = Student()
print(s.name)
Michael
print(s.score)
Traceback (most recent call last):
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个<code>attribute</code>。</p>
<p>要避免这个错误，除了可以加上一个<code>score</code>属性外，<code>Python</code>还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如<code>score</code>，<code>Python</code>解释器会试图调用<code>__getattr__(self, 'score')</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值。<br>
返回函数也是完全可以的：</p>
<pre><code class="language-oython">class Student(object):
    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="language-Python">s.age()
25
</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在_<code>_getattr__</code>中查找。<br>
此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让<code>class</code>只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-Python">class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<h5 id="__call__"><code>__call__</code></h5>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在<code>Python</code>中，答案是肯定的。<br>
任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
调用方式如下：
```Python
s = Student('Michael')
s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。<br>
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。<br>
那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例。<br>
通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h5 id="实现比较操作">实现比较操作</h5>
<p><code>Python</code>类对每个比较操作都需要实现一个特殊方法来支持。 例如为了支持<code>&gt;=</code>操作符，你需要定义一个 <code>__ge__()</code> 方法。 尽管定义一个方法没什么问题，但如果要你实现所有可能的比较方法那就有点烦人了。</p>
<p>装饰器 <code>functools.total_ordering</code> 就是用来简化这个处理的。 使用它来装饰一个类，你只需定义一个 <code>__eq__()</code> 方法， 外加其他方法(<code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, or <code>__ge__</code>)中的一个即可。 然后装饰器会自动为你填充其它比较方法。<br>
作为例子，我们构建一些房子，然后给它们增加一些房间，最后通过房子大小来比较它们：</p>
<pre><code class="language-python">from functools import total_ordering

class Room:
    def __init__(self, name, length, width):
        self.name = name
        self.length = length
        self.width = width
        self.square_feet = self.length * self.width

@total_ordering
class House:
    def __init__(self, name, style):
        self.name = name
        self.style = style
        self.rooms = list()

    @property
    def living_space_footage(self):
        return sum(r.square_feet for r in self.rooms)

    def add_room(self, room):
        self.rooms.append(room)

    def __str__(self):
        return '{}: {} square foot {}'.format(self.name,
                self.living_space_footage,
                self.style)

    def __eq__(self, other):
        return self.living_space_footage == other.living_space_footage

    def __lt__(self, other):
        return self.living_space_footage &lt; other.living_space_footage
</code></pre>
<p>这里我们只是给<code>House</code>类定义了两个方法：<code>__eq__()</code> 和 <code>__lt__()</code> ，它就能支持所有的比较操作：</p>
<pre><code class="language-python">'''
Build a few houses, and add rooms to them
'''
h1 = House('h1', 'Cape')
h1.add_room(Room('Master Bedroom', 14, 21))
h1.add_room(Room('Living Room', 18, 20))
h1.add_room(Room('Kitchen', 12, 16))
h1.add_room(Room('Office', 12, 12))
h2 = House('h2', 'Ranch')
h2.add_room(Room('Master Bedroom', 14, 21))
h2.add_room(Room('Living Room', 18, 20))
h2.add_room(Room('Kitchen', 12, 16))
h3 = House('h3', 'Split')
h3.add_room(Room('Master Bedroom', 14, 21))
h3.add_room(Room('Living Room', 18, 20))
h3.add_room(Room('Office', 12, 16))
h3.add_room(Room('Kitchen', 15, 17))
houses = [h1, h2, h3]
print('Is h1 bigger than h2?', h1 &gt; h2) # prints True
print('Is h2 smaller than h3?', h2 &lt; h3) # prints True
print('Is h2 greater than or equal to h1?', h2 &gt;= h1) # Prints False
print('Which one is biggest?', max(houses)) # Prints 'h3: 1101-square-foot Split'
print('Which is smallest?', min(houses)) # Prints 'h2: 846-square-foot Ranch'
</code></pre>
<p>其实 <code>total_ordering</code> 装饰器也没那么神秘。 它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已。 比如你定义了 <code>__le__()</code> 方法，那么它就被用来构建所有其他的需要定义的那些特殊方法。 实际上就是在类里面像下面这样定义了一些特殊方法：</p>
<pre><code class="language-python">class House:
    def __eq__(self, other):
        pass
    def __lt__(self, other):
        pass
    # Methods created by @total_ordering
    __le__ = lambda self, other: self &lt; other or self == other
    __gt__ = lambda self, other: not (self &lt; other or self == other)
    __ge__ = lambda self, other: not (self &lt; other)
    __ne__ = lambda self, other: not self == other
</code></pre>
<p>当然，你自己去写也很容易，但是使用 <code>@total_ordering</code> 可以简化代码，何乐而不为呢。</p>
<h4 id="枚举类">枚举类</h4>
<pre><code class="language-Python">from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="language-Python">for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从1开始计数。<br>
如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<pre><code class="language-Python">from enum import Enum, unique
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。<br>
访问这些枚举类型可以有若干种方法：</p>
<pre><code class="language-Python">day1 = Weekday.Mon
print(day1)
Weekday.Mon
print(Weekday.Tue)
Weekday.Tue
print(Weekday['Tue'])
Weekday.Tue
print(Weekday.Tue.value)
2
rint(day1 == Weekday.Mon)
True
print(day1 == Weekday.Tue)
False
rint(Weekday(1))
Weekday.Mon
print(day1 == Weekday(1))
True
Weekday(7)
Traceback (most recent call last):
ValueError: 7 is not a valid Weekday
for name, member in Weekday.__members__.items():
    print(name, '=&gt;', member)
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据<code>value</code>的值获得枚举常量。<br>
<code>Enum</code>可以把一组相关常量定义在一个<code>class</code>中，且<code>class</code>不可变，而且成员可以直接比较。</p>
<h4 id="使用元类">使用元类</h4>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。<br>
比方说我们要定义一个<code>Hello</code>的<code>class</code>，就写一个<code>hello.py</code>模块：</p>
<pre><code class="language-Python">class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当<code>Python</code>解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的<code>class</code>对象，测试如下：</p>
<pre><code class="language-Python">from hello import Hello
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个<code>class</code>，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</p>
<p>我们说<code>class</code>的定义是运行时动态创建的，而创建<code>class</code>的方法就是使用<code>type()</code>函数。</p>
<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)</code>...的定义：</p>
<pre><code class="language-Python">def fn(self, name='world'): # 先定义函数
    print('Hello, %s.' % name)
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个<code>class</code>对象，<code>type()</code>函数依次传入3个参数：<br>
<code>class</code>的名称；<br>
继承的父类集合，注意<code>Python</code>支持多重继承，如果只有一个父类，别忘了<code>tuple</code>的单元素写法；<br>
class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。<br>
通过<code>type()</code>函数创建的类和直接写<code>class</code>是完全一样的，因为<code>Python</code>解释器遇到<code>class</code>定义时，仅仅是扫描一下<code>class</code>定义的语法，然后调用<code>type()</code>函数创建出<code>class</code>。<br>
正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。<br>
<code>metaclass</code><br>
除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用<code>metaclass</code>。<br>
<code>metaclass</code>，直译为元类，简单的解释就是：<br>
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>
但是如果我们想创建出类呢？那就必须根据<code>metaclass</code>创建出类，所以：先定义<code>metaclass</code>，然后创建类。<br>
连接起来就是：先定义<code>metaclass</code>，就可以创建类，最后创建实例。<br>
所以，<code>metaclass</code>允许你创建类或者修改类。换句话说，你可以把类看成是<code>metaclass</code>创建出来的“实例”。</p>
<p><code>metaclass</code>是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用<code>metaclass</code>的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。<br>
我们先看一个简单的例子，这个<code>metaclass</code>可以给我们自定义的<code>MyList</code>增加一个<code>add</code>方法：</p>
<p>定义<code>ListMetaclass</code>，按照默认习惯，<code>metaclass</code>的类名总是以<code>Metaclass</code>结尾，以便清楚地表示这是一个<code>metaclass</code>：</p>
<pre><code class="language-Python">'''
metaclass是类的模板，所以必须从type类型派生：
'''
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
有了`ListMetaclass`，我们在定义类的时候还要指示使用`ListMetaclass`来定制类，传入关键字参数`metaclass`：
```Python
class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示<code>Python</code>解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<br>
<code>__new__()</code>方法接收到的参数依次是：<br>
当前准备创建的类的对象；<br>
类的名字；<br>
类继承的父类集合；<br>
类的方法集合。<br>
测试一下MyList是否可以调用add()方法：</p>
<pre><code class="language-Python">L = MyList()
L.add(1)
L
[1]
</code></pre>
<p>而普通的list没有<code>add()</code>方法：</p>
<pre><code class="language-Python">L2 = list()
L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过<code>metaclass</code>修改纯属变态。</p>
<h2 id="命名空间和作用域">命名空间和作用域</h2>
<h3 id="三种命名空间">三种命名空间：</h3>
<ul>
<li>内置名称(<code>built-in names</code>)， <code>Python</code> 语言内置的名称，比如函数名 <code>abs</code>、<code>char</code> 和异常名称 <code>BaseException</code>、<code>Exception</code> 等等。</li>
<li>全局名称(<code>global names</code>)，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li>
<li>局部名称(<code>local names</code>)，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）<br>
<code>Python</code> 的查找顺序为：<strong>局部的命名空间</strong> -&gt; <strong>全局命名空间</strong> -&gt; <strong>内置命名空间</strong>。</li>
</ul>
<h4 id="四种作用域">四种作用域：</h4>
<ul>
<li>L(Local)：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li>E(Enclosing)：包含了非局部(<code>non-local</code>)也非全局(<code>non-global</code>)的变量。比如两个嵌套函数，一个函数（或类） <code>A</code> 里面又包含了一个函数 <code>B</code> ，那么对于<code>B</code> 中的名称来说 <code>A</code> 中的作用域就为 <code>nonlocal</code>。</li>
<li>G(<code>Global</code>)：当前脚本的最外层，比如当前模块的全局变量。</li>
<li>B(<code>Built-in</code>)： 包含了内建的变量/关键字等。最后被搜索。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200320015425.png" alt="" loading="lazy"><br>
<code>Python</code> 中只有模块(<code>module</code>)，类(<code>class</code>)以及函数(<code>def</code>、<code>lambda</code>)才会引入新的作用域，其它的代码块(如 <code>if</code>/<code>elif</code>/<code>else</code>/、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</li>
</ul>
<pre><code class="language-Python">if True:
    msg = 'I am from Runoob'
msg
'I am from Runoob'
</code></pre>
<p>实例中 <code>msg</code> 变量定义在 <code>if</code> 语句块中，但外部还是可以访问的。<br>
如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<pre><code class="language-Python">def test():
    msg_inner = 'I am from Runoob'
msg_inner
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'msg_inner' is not defined
</code></pre>
<p>从报错的信息上看，说明了 <code>msg_inner</code> 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="global-和-nonlocal关键字"><code>global</code> 和 <code>nonlocal</code>关键字</h4>
<pre><code class="language-Python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
fun1()
print(num)
1
123
123
</code></pre>
<p>如果要修改嵌套作用域(<code>enclosing</code> 作用域，外层非全局作用域)中的变量则需要 <code>nonlocal</code> 关键字了，如下实例：</p>
<pre><code class="language-Python">def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
100
100
</code></pre>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<pre><code class="language-Python">a = 10
def test():
    a = a + 1
    print(a)
test()
Traceback (most recent call last):
  File &quot;test.py&quot;, line 7, in &lt;module&gt;
    test()
  File &quot;test.py&quot;, line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>错误信息为局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。<br>
修改 <code>a</code> 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<pre><code class="language-Python">a = 10
def test(a):
    a = a + 1
    print(a)
test(a)
11
</code></pre>
<h2 id="错误和异常处理">错误和异常处理</h2>
<pre><code class="language-Python">def attempt_float(x):
    try:
        return float(x)
    except ValueError:
        return x
</code></pre>
<p>某些情况下，你可能不想抑制异常，你想无论<code>try</code>部分的代码是否成功，都执行一段代码。可以使用<code>finally</code>：</p>
<pre><code class="language-Python">f = open(path, 'w')

try:
    write_to_file(f)
finally:
    f.close()
</code></pre>
<p>这里，文件处理<code>f</code>总会被关闭。相似的，你可以用<code>else</code>让只在<code>try</code>部分成功的情况下，才执行代码：</p>
<pre><code class="language-Python">f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
</code></pre>
<ul>
<li>可以有多个<code>except</code>来捕获不同类型的错误：</li>
</ul>
<pre><code class="language-Python">try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<ul>
<li>Python的错误其实也是<code>class</code>，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</li>
</ul>
<pre><code class="language-Python">try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
第二个`except`永远也捕获不到`UnicodeError`，因为`UnicodeError`是`ValueError`的子类，如果有，也被第一个`except`给捕获了。
</code></pre>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>
<pre><code class="language-Python">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
</code></pre>
<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>
<pre><code class="language-Python">def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise
bar()
</code></pre>
<p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去。<br>
这种错误处理方式相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个<code>Error</code>，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="language-Python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p>
<ul>
<li><code>Python</code> 使用 <code>raise</code> 语句抛出一个指定的异常。<br>
<code>raise</code>语法格式如下：</li>
</ul>
<pre><code class="language-Python">raise [Exception [, args [, traceback]]]
</code></pre>
<p>以下实例如果 x 大于 5 就触发异常:</p>
<pre><code>x = 10
if x &gt; 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
</code></pre>
<p>执行以上代码会触发异常：</p>
<pre><code class="language-Python">Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre>
<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<br>
如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <code>raise</code> 语句就可以再次把它抛出。</p>
<pre><code class="language-Python">try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre>
<h3 id="调试">调试</h3>
<ul>
<li>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>(assert)</code>来替代：</li>
</ul>
<pre><code class="language-Python">def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n
def main():
    foo('0')
</code></pre>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>
如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>
<pre><code class="language-shell">$ Python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
</code></pre>
<ul>
<li><code>logging</code><br>
把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</li>
</ul>
<pre><code class="language-Python">import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
</code></pre>
<pre><code class="language-shell">$ Python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。<br>
<code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如<code>console</code>和文件。</p>
<h2 id="文件和操作系统">文件和操作系统</h2>
<ul>
<li>为了打开一个文件以便读写，可以使用内置的<code>open</code>函数以及一个相对或绝对的文件路径：</li>
</ul>
<pre><code class="language-Python">path = 'examples/segismundo.txt'
f = open(path)
</code></pre>
<ul>
<li>默认情况下，文件是以只读模式<code>('r')</code>打开的。然后，我们就可以像处理列表那样来处理这个文件句柄<code>f</code>了，比如对行进行迭代：</li>
</ul>
<pre><code class="language-Python">for line in f:
    pass
</code></pre>
<ul>
<li>如果使用<code>open</code>创建文件对象，一定要用<code>close</code>关闭它。关闭文件可以返回操作系统资源：</li>
</ul>
<pre><code class="language-Python">f.close()
</code></pre>
<ul>
<li>用<code>with</code>语句可以可以更容易地清理打开的文件,这样可以在退出代码块时，自动关闭文件：</li>
</ul>
<pre><code>with open(path) as f:
    lines = [x.rstrip() for x in f]
</code></pre>
<ul>
<li>读写模式：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211525.png" alt="" loading="lazy"></li>
<li>向文件写入，可以使用文件的<code>write</code>或<code>writelines</code>方法。例如，我们可以创建一个无空行版的<code>prof_mod.py</code>：</li>
</ul>
<pre><code class="language-Python">with open('tmp.txt', 'w') as handle:
    handle.writelines(x for x in open(path) if len(x) &gt; 1)
with open('tmp.txt') as f:
    lines = f.readlines()
</code></pre>
<pre><code class="language-Python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。<br>
以<code>'w'</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>'a'</code>以追加<code>(append)</code>模式写入。</p>
<ul>
<li>调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。</li>
<li>常用文件方法<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211726.png" alt="" loading="lazy"></li>
</ul>
<h3 id="操作文件和目录">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<ul>
<li>查看当前目录的绝对路径:</li>
</ul>
<pre><code class="language-Python">os.path.abspath('.')
'/Users/michael'
- 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
````Python
os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
</code></pre>
<ul>
<li>创建一个目录:</li>
</ul>
<pre><code class="language-Python">os.mkdir('/Users/michael/testdir')
</code></pre>
<ul>
<li>删掉一个目录:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>os.rmdir('/Users/michael/testdir')<br>
把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符.<br>
同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-Python">os.path.split('/Users/michael/testdir/file.txt')

('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<pre><code class="language-Python">os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。<br>
文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<ul>
<li>对文件重命名:</li>
</ul>
<pre><code>os.rename('test.txt', 'test.py')
</code></pre>
<ul>
<li>删掉文件:</li>
</ul>
<pre><code class="language-Python">os.remove('test.py')
</code></pre>
<p><code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<h3 id="序列化">序列化</h3>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-Python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-Python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-Python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。</p>
<p>要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-Python"> json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><code>Python</code>的<code>dict</code>对象可以直接序列化为<code>JSON</code>的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>
<pre><code class="language-Python">import json
class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p>
<pre><code class="language-Python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<code>Student</code>对象不是一个可序列化为<code>JSON</code>的对象。<br>
前面的代码之所以无法把<code>Student</code>类实例序列化为<code>JSON</code>，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个<code>JSON</code>的<code>{}</code>对象。<br>
可选参数<code>default</code>就是把任意一个对象变成一个可序列为<code>JSON</code>的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="language-Python">def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>：</p>
<pre><code class="language-Python">print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p>
<pre><code class="language-Python">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的<code>class</code>。<br>
同样的道理，如果我们要把<code>JSON</code>反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="language-Python">def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-Python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的<code>Student</code>实例对象。</p>
<h2 id="标准库">标准库</h2>
<h3 id="collections"><code>collections</code></h3>
<h4 id="namedtuple"><code>namedtuple</code></h4>
<pre><code class="language-Python">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
p.x
1
p.y
2
</code></pre>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>
这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<h4 id="deque"><code>deque</code></h4>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<pre><code class="language-Python">from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
q.clear()# 清除所有元素
q.count(x)# 计算x的个数
q.remove(value)#移除找到的第一个 value。
q.reverse()#逆序排列
</code></pre>
<p><code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="defaultdict"><code>defaultdict</code></h4>
<p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<pre><code class="language-Python">from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
dd['key1'] # key1存在
'abc'
dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<pre><code class="language-Python">from collections import deque

dlist=deque([1,'a'])
dlist.append('b') # 在末尾加数据
dlist.appendleft(0) # 在最前端插入数据
print(dlist)# 输出 :  deque([0, 1, 'a', 'b'])

dlist.pop() # 删除末尾的数据
dlist.popleft() # 删除最前端的数据
print(dlist)# 输出 :  deque([1, 'a'])

dlist.extend(['b','c']) # 在末尾追加list 数据
dlist.extendleft([-1,0])# 在前端插入list 数据
print(dlist)# 输出 : deque([0, -1, 1, 'a', 'b', 'c'])
print(dlist.index('a')) # 找出 a 的索引位置,输出 :  3

dlist.insert(2, 555) # 在索引2 的位置插入555
print(dlist)# 输出 :  deque([0, -1, 555, 1, 'a', 'b', 'c'])

print(dlist.count('a')) # 查找 ‘a’ 的数量

dlist.remove(1) # 删除第一个匹配值
dlist.reverse()  # 反向
print(dlist)# 输出 :  deque(['c', 'b', 'a', 555, -1, 0])


dlist.rotate(-2) # 将左端的元素移动到右端
print(dlist)# 输出 :  deque(['a', 555, -1, 0, 'c', 'b'])

dlist.rotate(2) # 将右端的元素移动到左端
print(dlist)# 输出 :  deque(['c', 'b', 'a', 555, -1, 0])

dl1=dlist # 赋值 dlist 值变化，dl1的值也会修改
dl2=dlist.copy() # 拷贝 dlist, 拷贝后对dl修改不影响dlist的值
dlist.pop() # 删除最后一个数据, dl1的值也被修改
print(dl1) # 输出： deque(['c', 'b', 'a', 555, -1])
print(dl2) # 输出： deque(['c', 'b', 'a', 555, -1, 0])
</code></pre>
<ul>
<li>合并字典<br>
这是一般的字典合并写法</li>
</ul>
<pre><code class="language-Python">dic1 = {'x': 1, 'y': 2 }
dic2 = {'y': 3, 'z': 4 }
merged1 = {**dic1, **dic2} # {'x': 1, 'y': 3, 'z': 4}
</code></pre>
<p>修改<code>merged[‘x’]=10</code>，<code>dic1</code>中的<code>x</code>值不变，<code>merged</code>是重新生成的一个新字典。<br>
但是，<code>ChainMap</code>却不同，它在内部创建了一个容纳这些字典的列表。因此使用<code>ChainMap</code>合并字典，修改<code>merged[‘x’]=10</code>后，<code>dic1</code>中的<code>x</code>值改变，如下所示：</p>
<pre><code class="language-Python">from collections import ChainMap
merged2 = ChainMap(dic1,dic2)
print(merged2) # ChainMap({'x': 1, 'y': 2}, {'y': 3, 'z': 4})
</code></pre>
<p>默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="ordereddict"><code>OrderedDict</code></h4>
<p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。<br>
如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>：</p>
<pre><code class="language-Python">from collections import OrderedDict
d = dict([('a', 1), ('b', 2), ('c', 3)])
d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，<code>OrderedDict的Key</code>会按照插入的顺序排列，不是<code>Key</code>本身排序：</p>
<pre><code class="language-Python">od = OrderedDict()
od['z'] = 1
od['y'] = 2
od['x'] = 3
list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p><code>OrderedDict</code>可以实现一个<code>FIFO</code>（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的<code>Key</code>：</p>
<pre><code class="language-Python">from collections import OrderedDict
class LastUpdatedOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity
    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h4 id="chainmap"><code>ChainMap</code></h4>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。<br>
什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。<br>
下面的代码演示了如何查找user和color这两个参数：</p>
<pre><code class="language-Python">from collections import ChainMap
import os, argparse
'''
构造缺省参数:
'''
defaults = {
    'color': 'red',
    'user': 'guest'
}
'''
构造命令行参数:
'''
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }
'''
组合成ChainMap:
'''
combined = ChainMap(command_line_args, os.environ, defaults)
'''
打印参数:
'''
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
</code></pre>
<p>没有任何参数时，打印出默认参数：</p>
<pre><code class="language-shell">$ Python3 use_chainmap.py 
color=red
user=guest
</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code class="language-shell">$ Python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<pre><code class="language-shell">$ user=admin color=green Python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<pre><code class="language-Python">from collections import ChainMap
m1 = {'Type': 'admin', 'codeID': '00001'}
m2 = {'name': 'woodname','codeID': '00002'}
m = ChainMap(m1, m2)
print(m)
'''
输出：
ChainMap({'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
'''
print(m.maps)
'''
输出：[{'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'}]
'''
for i in m.items():
    print(i)
'''
输出：
('name', 'woodname')
('codeID', '00001')
('Type', 'admin')
'''
print(m['name']) # 读取元素的值
print(m['codeID']) # 注意，当key重复时以最前一个为准
print(m.get('Type'))
'''
输出：
woodname
00001
admin
新增map
'''
m3 = {'data': '888'}
m=m.new_child(m3) # 将 m3 加入m
print(m)
'''
输出：
ChainMap({'data': '888'}, {'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
'''
print(m.parents) # m 的父亲
'''
输出：ChainMap({'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
'''
print(m.parents.parents)
'''
输出 ： ChainMap({'name': 'woodname', 'codeID': '00002'})
'''
</code></pre>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('c = {}'.format(m['c']))
c = C
</code></pre>
<p>可以通过 <code>maps</code> 属性将结果以列表形式返回。由于列表是可变的，所以可以对这个列表重新排序，或者添加新的值。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print(m.maps)    # [{'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'}]
print('c = {}\n'.format(m['c']))    # c = C

m.maps = list(reversed(m.maps))# reverse the list
print(m.maps)    # [{'b': 'B', 'c': 'D'}, {'a': 'A', 'c': 'C'}]
print('c = {}'.format(m['c']))    # c = D
</code></pre>
<p><code>ChainMap</code> 不会给子映射创建一个单独的空间，所以对子映射修改时，结果也会反馈到 <code>ChainMap</code> 上。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('Before: {}'.format(m['c']))    # Before: C
a['c'] = 'E'
print('After : {}'.format(m['c']))    # After : E
</code></pre>
<p>也可以通过 <code>ChainMap</code> 直接设置值，实际上只修改了第一个字典中的值。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('Before:', m)    # Before: ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
m['c'] = 'E'
print('After :', m)    # After : ChainMap({'a': 'A', 'c': 'E'}, {'b': 'B', 'c': 'D'})
print('a:', a)    # a: {'a': 'A', 'c': 'E'}
</code></pre>
<p><code>ChainMap</code>提供了一个简单的方法，用于在<code>maps</code>列表的前面创建一个新实例，这样做的好处是可以避免修改现有的底层数据结构。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m1 = collections.ChainMap(a, b)
m2 = m1.new_child()
print(m1)    # ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
print(m2)    # ChainMap({}, {'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
m2['c'] = 'E'
print(m1)    # ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
print(m2)    # ChainMap({'c': 'E'}, {'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
</code></pre>
<p>这种堆叠行为使得将<code>ChainMap</code> 实例用作模板或应用程序上下文变得非常方便。具体来说，在一次迭代中很容易添加或更新值，然后丢弃下一次迭代的更改。<br>
对于新上下文已知或预先构建的情况，也可以将映射传递给<code>new_child()</code>。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
c = {'c': 'E'}
m1 = collections.ChainMap(a, b)
m2 = m1.new_child(c)
print('m1[&quot;c&quot;] = {}'.format(m1['c']))    # m1[&quot;c&quot;] = C
print('m2[&quot;c&quot;] = {}'.format(m2['c']))    # m2[&quot;c&quot;] = E
</code></pre>
<p>这相当于：</p>
<pre><code class="language-Python">m2 = collections.ChainMap(c, *m1.maps)
</code></pre>
<h4 id="counter"><code>Counter</code></h4>
<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code class="language-Python">from collections import Counter
c = Counter()
for ch in 'programming':
c[ch] = c[ch] + 1
c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
c.update('hello') # 也可以一次性update
c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<ul>
<li><code>elements()</code>:返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于一，<code>elements()</code> 将会忽略它。</li>
</ul>
<pre><code class="language-Python">c = Counter(a=4, b=2, c=0, d=-2)
sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']
</code></pre>
<ul>
<li><code>most_common([n])</code>:返回一个列表，其中包含<code>n</code> 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 <code>n</code> 被省略或为 <code>None</code>，<code>most_common()</code> 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序：</li>
</ul>
<pre><code class="language-Python">Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
</code></pre>
<pre><code class="language-Python">c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
c &amp; d                       # intersection:  min(c[x], d[x]) 
Counter({'a': 1, 'b': 1})
c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
</code></pre>
<p><code>Counter</code> 支持三种初始化形式：</p>
<pre><code class="language-Python">print(collections.Counter(['a', 'b', 'c', 'a', 'b', 'b']))
print(collections.Counter({'a': 2, 'b': 3, 'c': 1}))
print(collections.Counter(a=2, b=3, c=1))
'''
output
Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'b': 3, 'a': 2, 'c': 1})
'''
</code></pre>
<p><code>Counter</code> 初始化时也可以不传参数，然后通过<code>update()</code>方法更新。</p>
<pre><code class="language-Python">c = collections.Counter()
print('Initial :', c)    # Initial : Counter()
c.update('abcdaab')
print('Sequence:', c)    # Sequence: Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})
c.update({'a': 1, 'd': 5})
print('Dict    :', c)    # Dict    : Counter({'d': 6, 'a': 4, 'b': 2, 'c': 1})
</code></pre>
<p>计数值基于新数据而不是替换而增加。在上例中，计数<code>a</code>从3到4。<br>
<code>Counter</code> 中的值，可以使用字典 <code>API</code> 获取它的值。</p>
<pre><code class="language-Python">c = collections.Counter('abcdaab')
for letter in 'abcde':
    print('{} : {}'.format(letter, c[letter]))
    '''
output
a : 3
b : 2
c : 1
d : 1
e : 0
'''
</code></pre>
<p>对于 <code>Counter</code> 中没有的键，不会报 <code>KeyError</code>。如本例中的 <code>e</code>，将其计数为0。<br>
<code>elements()</code>方法返回一个迭代器，遍历它可以获得 <code>Counter</code> 中的值。</p>
<pre><code class="language-Python">c = collections.Counter('extremely')
c['z'] = 0
print(c)    # Counter({'e': 3, 'x': 1, 't': 1, 'r': 1, 'm': 1, 'l': 1, 'y': 1, 'z': 0})
print(list(c.elements()))    # ['e', 'e', 'e', 'x', 't', 'r', 'm', 'l', 'y']
</code></pre>
<p>不保证元素的顺序，并且不包括计数小于或等于零的值。<br>
使用<code>most_common()</code>产生序列最常遇到的输入值和它们各自的计数。</p>
<pre><code class="language-Python">c = collections.Counter()
with open('/usr/share/dict/words', 'rt') as f:
    for line in f:
        c.update(line.rstrip().lower())
print('Most common:')
for letter, count in c.most_common(3):
    print('{}: {:&gt;7}'.format(letter, count))
'''
output
Most common:
e:  235331
i:  201032
a:  199554
'''
</code></pre>
<p>此示例计算在系统字典所有单词中的字母生成频率分布，然后打印三个最常见的字母。如果没有参数的话，会按频率顺序生成所有项目的列表。<br>
<code>Counter</code>实例支持算术和聚合结果。这个例子显示了标准的操作符计算新的<code>Counter</code>实例，就地操作符 <code>+=</code>，<code>-=</code>，<code>&amp;=</code>，和<code>|=</code>也支持。</p>
<pre><code class="language-Python">c1 = collections.Counter(['a', 'b', 'c', 'a', 'b', 'b'])
c2 = collections.Counter('alphabet')

print('C1:', c1)
print('C2:', c2)

print('\nCombined counts:')
print(c1 + c2)

print('\nSubtraction:')
print(c1 - c2)

print('\nIntersection (taking positive minimums):')
print(c1 &amp; c2)

print('\nUnion (taking maximums):')
print(c1 | c2)
'''
output
C1: Counter({'b': 3, 'a': 2, 'c': 1})
C2: Counter({'a': 2, 'l': 1, 'p': 1, 'h': 1, 'b': 1, 'e': 1, 't': 1})

Combined counts:
Counter({'a': 4, 'b': 4, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
 
Subtraction:
Counter({'b': 2, 'c': 1})

Intersection (taking positive minimums):
Counter({'a': 2, 'b': 1})
 
Union (taking maximums):
Counter({'b': 3, 'a': 2, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
'''
</code></pre>
<p>每次<code>Counter</code>通过操作产生新的时，任何具有零或负计数的项目都将被丢弃。计数<code>a</code>在<code>c1</code>和<code>c2</code>中是相同的，因此相减之后变为零。<br>
计数器可以统计一个可迭代对象中每个元素出现的次数。</p>
<pre><code class="language-python">import collections
'''
创建
'''
collections.Counter(iterable)
'''
频次
'''
collections.Counter[key]                 # key出现频次
''' 
返回n个出现频次最高的元素和其对应出现频次，如果n为None，返回所有元素
'''
collections.Counter.most_common(n=None)
'''
插入/更新
'''
collections.Counter.update(iterable)
counter1 + counter2; counter1 - counter2  # counter加减
'''
检查两个字符串的组成元素是否相同
'''
collections.Counter(list1) == collections.Counter(list2)
</code></pre>
<h3 id="heapq"><code>heapq</code></h3>
<p>这个模块提供了堆队列算法的实现，也称为优先队列算法。<br>
堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <code>k</code> ，都有 <code>heap[k]</code> &lt;= <code>heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。<br>
这个<code>API</code>与教材的堆算法实现有所不同，具体区别有两方面：</p>
<ol>
<li>我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 <code>Python</code> 使用从零开始的索引。</li>
<li>我们的 <code>pop</code> 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。但是可以通过取反来实现最大堆。<br>
要创建一个堆，可以使用<code>list</code>来初始化为 <code>[]</code> ，或者你可以通过一个函数 <code>heapify()</code> ，来把一个<code>list</code>转换成堆。</li>
</ol>
<ul>
<li><code>heapq.heappush(heap, item)</code>:将 <code>item</code> 的值加入 <code>heap</code> 中，保持堆的不变性。</li>
<li><code>heapq.heappop(heap)</code>:弹出并返回 <code>heap</code> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <code>IndexError</code> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</li>
<li><code>heapq.heappushpop(heap, item)</code>:将 <code>item</code> 放入堆中，然后弹出并返回 <code>heap</code> 的最小元素。该组合操作比先调用  <code>heappush()</code> 再调用 <code>heappop()</code> 运行起来更有效率。</li>
<li><code>heapq.heapify(x)</code>:将<code>list x</code> 转换成堆，原地，线性时间内。</li>
<li><code>heapq.heapreplace(heap, item)</code>:弹出并返回 <code>heap</code> 中最小的一项，同时推入新的 <code>item</code>。 堆的大小不变。 如果堆为空则引发 <code>IndexError</code>。<br>
这个单步骤操作比 <code>heappop()</code> 加 <code>heappush()</code> 更高效，并且在使用固定大小的堆时更为适宜。 <code>pop/push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>
返回的值可能会比添加的 <code>item</code> 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。<br>
-<code>heapq.merge(*iterables, key=None, reverse=False)</code><br>
将多个已排序的输入合并为一个已排序的输出。返回已排序值的<code>iterator</code>。<br>
类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</li>
<li><code>heapq.nlargest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code>个最大元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</li>
<li><code>heapq.nsmallest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code> 个最小元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。<br>
两个函数在 <code>n</code> 值较小时性能最好。 对于更大的值，使用 <code>sorted()</code> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <code>min()</code> 和 <code>max()</code> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。<br>
堆排序:<br>
堆排序 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</li>
</ul>
<pre><code class="language-Python">def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]
heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>如果我们想要<code>heapq</code>排序的是一个对象。那么heapq并不知道应该依据对象当中的哪个参数来作为排序的衡量标准，所以这个时候，需要我们自己定义一个获取关键字的函数，传递给<code>heapq</code>，这样才可以完成排序。<br>
比如说，我们现在有一批电脑，我们希望<code>heapq</code>能够根据电脑的价格排序：</p>
<pre><code class="language-Python">laptops = [
    {'name': 'ThinkPad', 'amount': 100, 'price': 91.1},
    {'name': 'Mac', 'amount': 50, 'price': 543.22},
    {'name': 'Surface', 'amount': 200, 'price': 21.09},
    {'name': 'Alienware', 'amount': 35, 'price': 31.75},
    {'name': 'Lenovo', 'amount': 45, 'price': 16.35},
    {'name': 'Huawei', 'amount': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>在调用<code>nlargest</code>和<code>nsmallest</code>的时候，我们额外传递了一个参数<code>key</code>，我们传入的是一个匿名函数，它返回的结果是这个对象的<code>price</code>，也就是说我们希望<code>heapq</code>根据对象的<code>price</code>来进行排序。<br>
这类似于 <code>sorted(iterable)</code>，但与 <code>sorted()</code> 不同的是这个实现是不稳定的。<br>
优先队列 是堆的常用场合，并且它的实现包含了多个挑战：</p>
<ol>
<li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li>
<li>如果优先级相同且任务没有默认比较顺序，则 (priority, task) 对的元组比较将会中断。<br>
针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。<br>
下面的类利用 <code>heapq</code> 模块实现了一个简单的优先级队列：</li>
</ol>
<pre><code class="language-python">import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>
<p>下面是它的使用方式：</p>
<pre><code class="language-python">class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name)
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
Item('bar')
q.pop()
('spam')
q.pop()
Item('foo')
q.pop()
Item('grok')
</code></pre>
<h3 id="bisect"><code>bisect</code></h3>
<ul>
<li><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code><br>
在 <code>a</code> 中找到 <code>x</code> 合适的插入点以维持有序。参数 <code>lo</code> 和 <code>hi</code> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <code>x</code> 已经在 <code>a</code> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <code>a</code> 是列表（<code>list</code>）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code>，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</li>
<li><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.bisect(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>bisect_left()</code>，但是返回的插入点是 <code>a</code> 中已存在元素 <code>x</code> 的右侧。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi]) for the right side</code>。</li>
<li><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code><br>
将 <code>x</code> 插入到一个有序序列 <code>a</code> 里，并维持其有序。如果 <code>a</code> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 <code>O(log n)</code> 的，插入却是 <code>O(n)</code> 的。</li>
<li><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.insort(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>insort_left()</code>，但是把 <code>x</code> 插入到 <code>a</code> 中已存在元素 <code>x</code>的右侧。<br>
函数 <code>bisect()</code> 还可以用于数字表查询。这个例子是使用 <code>bisect()</code> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：<code>90</code> 分及以上是 <code>'A'</code>，<code>80</code> 到 <code>89</code> 是 <code>'B'</code>，以此类推</li>
</ul>
<pre><code class="language-Python">def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']
</code></pre>
<h3 id="itertools"><code>itertools</code></h3>
<ul>
<li><code>itertools.count(start=0,step=1)</code>:创建一个迭代器，生成从 <code>n</code> 开始的连续整数，如果忽略 <code>n</code>，则从 <code>0</code> 开始计算。</li>
</ul>
<pre><code class="language-Python">for n in itertools.count():
    if 100000 &lt; n &lt; 100010:
        print n
    if n &gt; 1000000:
        break
100001
100002
100003
100004
100005
100006
100007
100008
100009
</code></pre>
<ul>
<li><code>itertools.cycle(iterable)</code>:把传入的一个序列无限重复下去。</li>
</ul>
<pre><code class="language-Python">for c in itertools.cycle(&quot;AB&quot;):
    if count &gt; 4:
        break
    print c
   count += 1     
A
B
A
B
A
</code></pre>
<ul>
<li><code>itertools.repeat(object [,times])</code>:创建一个迭代器，重复生成 <code>object</code>，<code>times</code>（如果已提供）指定重复计数，如果未提供 <code>times</code>，将无止尽返回该对象。</li>
</ul>
<pre><code class="language-Python">for x in itertools.repeat(&quot;hello world&quot;, 5):
    print x    
hello world
hello world
hello world
hello world
hello world
</code></pre>
<ul>
<li><code>itertools.chain(*iterables)</code>:把一组迭代对象串联起来，形成一个更大的迭代器。</li>
</ul>
<pre><code class="language-Python">for c in itertools.chain('ABC', 'XYZ'):
    print c    
A
B
C
X
Y
Z
</code></pre>
<ul>
<li><code>itertools.permutations(iterable[, r])：返回</code>iterable<code>中任意取</code>r<code>个元素做排列的元组的迭代器，如果不指定</code>r<code>，那么序列的长度与</code>iterable` 中的项目数量相同。</li>
</ul>
<pre><code class="language-Python">for elem in itertools.permutations('abc', 2):
    print elem
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
for elem in itertools.permutations('abc'):
    print elem
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
</code></pre>
<ul>
<li><code>itertools.combinations(iterable, r)</code>:组合，如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，<code>ab</code> 和 <code>ba</code> 则视为重复，此时只放回 <code>ab</code>. 示例：</li>
</ul>
<pre><code class="language-Python">for elem in itertools.combinations('abc', 2):
    print elem   
('a', 'b')
('a', 'c')
('b', 'c')
</code></pre>
<ul>
<li><code>itertools.combinations_with_replacement(iterable, r)</code>:与 <code>combinations</code> 类似，但允许重复值，即如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，会多出 <code>aa</code>, <code>bb</code>, <code>cc</code>。</li>
<li><code>itertools.compress(data, selectors)</code>:<br>
相当于 <code>bool</code> 选取，只有当 <code>selectors</code> 对应位置的元素为 <code>true</code> 时，才保留 <code>data</code> 中相应位置的元素，否则去除。</li>
</ul>
<pre><code class="language-Python">list(itertools.compress('abcdef', [1, 1, 0, 1, 0, 1]))
['a', 'b', 'd', 'f']
list(itertools.compress('abcdef', [True, False, True]))
['a', 'c']
</code></pre>
<ul>
<li><code>itertools.groupby(iterable[, keyfunc])</code>:对<code>iterable</code>中的元素进行分组。<code>keyfunc</code> 是分组函数，用于对 <code>iterable</code> 的连续项进行分组，如果不指定，则默认对 <code>iterable</code> 中的连续相同项进行分组，返回一个 <code>(key, sub-iterator)</code> 的迭代器。</li>
</ul>
<pre><code class="language-Python">for key, value_iter in itertools.groupby('aaabbbaaccd'):
    print key, list(value_iter)  
a ['a', 'a', 'a']
b ['b', 'b', 'b']
a ['a', 'a']
c ['c', 'c']
d ['d']
data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f']
for key, value_iter in itertools.groupby(data, len):
    print key, list(value_iter)   
1 ['a']
2 ['bb', 'cc']
3 ['ddd', 'eee']
1 ['f']
</code></pre>
<p>注意，注意，注意：必须先排序后才能分组，因为<code>groupby</code>是通过比较相邻元素来分组的。可以看第二个例子，因为 <code>a</code> 和<code>f</code> 没有排在一起，所以最后没有分组到同一个列表中。</p>
<ul>
<li><code>itertools.islice(iterable, [start,] stop [, step])</code>:切片选择，<code>start</code> 是开始索引，<code>stop</code> 是结束索引，<code>step</code> 是步长，<code>start</code>和 <code>step</code> 可选。</li>
</ul>
<pre><code class="language-Python">list(itertools.islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
list(itertools.islice(itertools.count(), 6))
[0, 1, 2, 3, 4, 5]
list(itertools.islice(itertools.count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
list(itertools.islice(itertools.count(), 3, 10, 2))
[3, 5, 7, 9]
</code></pre>
<ul>
<li><code>itertools.tee(iterable, n=2)</code>:从 <code>iterable</code> 创建 <code>n</code> 个独立的迭代器，以元组的形式返回。</li>
</ul>
<pre><code class="language-Python">itertools.tee(&quot;abcedf&quot;)
(&lt;itertools.tee at 0x7fed7b8f59e0&gt;, &lt;itertools.tee at 0x7fed7b8f56c8&gt;)
iter1, iter2 = itertools.tee(&quot;abcedf&quot;)
list(iter1)
['a', 'b', 'c', 'e', 'd', 'f']
list(iter2)
['a', 'b', 'c', 'e', 'd', 'f']
</code></pre>
<ul>
<li><code>itertools.product(*iterables, repeat=1)</code>:<br>
大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。<br>
嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。<br>
要计算可迭代对象自身的笛卡尔积，将可选参数 <code>repeat</code> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</li>
<li><code>itertools.dropwhile</code></li>
</ul>
<pre><code class="language-Python"> x = itertools.dropwhile(lambda e: e &lt; 5, range(10))
print(list(x))
[5, 6, 7, 8, 9]
</code></pre>
<ul>
<li><code>itertools.filterfalse</code>:<br>
保留对应真值为<code>False</code>的元素</li>
</ul>
<pre><code class="language-Python">x = itertools.filterfalse(lambda e: e &lt; 5, (1, 5, 3, 6, 9, 4))
print(list(x))
[5, 6, 9]
</code></pre>
<h3 id="functools"><code>functools</code></h3>
<ul>
<li>缓存机制加速递归函数<br>
<code>@functools.lru_cache(maxsize=128, typed=False)</code>:这个装饰器实现了备忘的功能，是一项优化技术，把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。<code>lru</code> 是（<code>least recently used</code>）的缩写，即最近最少使用原则。表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。<br>
这个装饰器支持传入参数，还能有这种操作的？<code>maxsize</code> 是保存最近多少个调用的结果，最好设置为 <code>2</code> 的倍数，默认为 <code>128</code>。如果设置为 <code>None</code> 的话就相当于是 <code>maxsize</code> 为正无穷了。还有一个参数是 <code>type</code>，如果 <code>type</code> 设置为 <code>true</code>，即把不同参数类型得到的结果分开保存，如 <code>f(3)</code> 和 <code>f(3.0)</code> 会被区分开。</li>
</ul>
<pre><code class="language-python">from functools import lru_cache
@lru_cache(100)
def fib(n)
    return (1 if n in (1,2) else fib(n-1)+fib(n-2))
</code></pre>
<h3 id="math"><code>math</code></h3>
<ul>
<li><code>math.ceil(x)</code>:返回 <code>x</code> 的上限，即大于或者等于 <code>x</code> 的最小整数。</li>
<li><code>math.comb(n, k)</code>:返回不重复且无顺序地从 <code>n</code> 项中选择 <code>k</code> 项的方式总数。</li>
<li><code>math.fabs(x)</code>:返回 <code>x</code> 的绝对值。</li>
<li><code>math.floor(x)</code>:返回 <code>x</code> 的向下取整，小于或等于 <code>x</code> 的最大整数。</li>
<li><code>math.gcd(a, b)</code>:最大公约数</li>
<li><code>math.exp(x)</code>:返回 <code>e</code> 次 <code>x</code> 幂</li>
<li><code>math.pow(x, y)</code>:将返回 <code>x</code> 的 <code>y</code> 次幂。</li>
<li><code>math.sqrt(x)</code>:返回 <code>x</code> 的平方根。</li>
<li><code>math.pi</code>:数学常数 π = 3.141592...，精确到可用精度。</li>
<li><code>math.e</code>:数学常数 e = 2.718281...，精确到可用精度。</li>
<li><code>math.inf</code>:浮点正无穷大。</li>
</ul>
<h3 id="time"><code>time</code></h3>
<p>在 <code>Python</code> 中，用三种方式来表示时间，分别是时间戳、格式化时间字符串和结构化时间</p>
<ul>
<li>时间戳（<code>timestamp</code>）：也就是 1970 年 1 月 1 日之后的秒，例如 1506388236.216345，可以通过<code>time.time()</code>获得。时间戳是一个浮点数，可以进行加减运算，但请注意不要让结果超出取值范围。</li>
<li>格式化的时间字符串（<code>string_time</code>）：也就是年月日时分秒这样的我们常见的时间字符串，例如2017-09-26 09:12:48，可以通过<code>time.strftime('%Y-%m-%d')</code>获得;<br>
结构化时间（<code>struct_time</code>）：一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code>，可以通过<code>time.localtime()</code>获得。</li>
<li>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>等方法可以获得一个格式化时间字符串。</li>
</ul>
<pre><code class="language-Python">time.strftime('%Y-%m-%d %H:%M:%S')
'2017-09-26 10:04:28'
</code></pre>
<p><code>time.strptime(string[,format])</code><br>
将格式化时间字符串转化成结构化时间。该方法是<code>time.strftime()</code>方法的逆操作。<code>time.strptime()</code>方法根据指定的格式把一个时间字符串解析为时间元组。要注意的是，你提供的字符串要和 <code>format</code> 参数的格式一一对应，如果 <code>string</code> 中日期间使用<code>“-”</code>分隔，<code>format</code> 中也必须使用<code>“-”</code>分隔，时间中使用冒号<code>“:”</code>分隔，后面也必须使用冒号分隔，否则会报格式不匹配的错误。并且值也要在合法的区间范围内。</p>
<pre><code class="language-Python">stime = &quot;2017-09-26 12:11:30&quot;
st = time.strptime(stime,&quot;%Y-%m-%d %H:%M:%S&quot;)
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321211914.png" alt="" loading="lazy"></figure>
<ul>
<li><code>time.time()</code>:返回当前系统时间戳。时间戳可以做算术运算。</li>
</ul>
<pre><code class="language-Python">time.time()
1506391907.020303
该方法经常用于计算程序运行时间：
```Python
import time
def func():
    time.sleep(1.14)
    pass

t1 = time.time()
func()
t2 = time.time()
print(t2 - t1)
</code></pre>
<h3 id="datetime"><code>datetime</code></h3>
<pre><code class="language-Python">from datetime import datetime, date, time
dt = datetime(2011, 10, 29, 20, 30, 21)
dt.day
29
dt.minute
30
</code></pre>
<ul>
<li>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</li>
</ul>
<pre><code class="language-Python">dt.date()
datetime.date(2011, 10, 29)
dt.time()
datetime.time(20, 30, 21)
</code></pre>
<ul>
<li><code>strftime</code>方法可以将<code>datetime</code>格式化为字符串：</li>
</ul>
<pre><code class="language-Python">dt.strftime('%m/%d/%Y %H:%M')
'10/29/2011 20:30'
</code></pre>
<ul>
<li><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</li>
</ul>
<pre><code class="language-Python">datetime.strptime('20091031', '%Y%m%d')
datetime.datetime(2009, 10, 31, 0, 0)
</code></pre>
<ul>
<li>计算差值</li>
</ul>
<pre><code class="language-Python">now = date.today()
birthday = date(1964, 7, 31)
age = now - birthday
age.days
14368
</code></pre>
<ul>
<li>格式化命令</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317190745.png" alt="" loading="lazy"></figure>
<h2 id="os"><code>os</code></h2>
<ul>
<li><code>os.path.exists(path)</code>:路径存在则返回<code>True</code>,路径损坏返回<code>False</code></li>
<li><code>os.path.join(path1[, path2[, ...]])</code>:把目录和文件名合成一个路径</li>
<li><code>os.system('mkdir today')</code>:命令行命令</li>
<li><code>os.environ</code>:<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;7&quot;</code></li>
</ul>
<h2 id="path"><code>Path</code></h2>
<p>在过去，文件的路径是纯字符串，现在它会是一个<code>pathlib.Path</code>对象:</p>
<pre><code class="language-Python">from pathlib import Path
p = Path('/home/ubuntu')
PosixPath('/home/ubuntu')
str(p)
'/home/ubuntu'
</code></pre>
<p>过去路径拼接最正确的方法是用<code>os.path.join</code>:</p>
<pre><code class="language-Python">os.path.join('/', 'home', 'dongwm/code')
'/home/dongwm/code'
os.path.join('/home', 'dongwm/code')
'/home/dongwm/code'
现在可以用`pathlib.Path`提供的`joinpath`来拼接:
```Python
Path('/').joinpath('home', 'dongwm/code')
PosixPath('/home/dongwm/code')
但是更简单和方便的方法是用`/`运算符:
```Python
Path('/') / 'home' / 'dongwm/code'
PosixPath('/home/dongwm/code')
Path('/') / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
'/' / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
</code></pre>
<p>使用<code>Path</code>对象的<code>parents</code>属性可以拿到各级目录列表(索引值越大越接近<code>root</code>)，而<code>parent</code>就表示父级目录:</p>
<pre><code class="language-Python">p = Path('/Users/dongweiming/test')
p.parents[0]
PosixPath('/Users/dongweiming')
p.parents[1]
PosixPath('/Users')
p.parents[2]
PosixPath('/')
p.parent
PosixPath('/Users/dongweiming')
p.parent.parent
PosixPath('/Users')
</code></pre>
<p>获得文件后缀名:</p>
<pre><code class="language-Python">p = Path('/usr/local/etc/my.cnf')
p.suffix, p.stem
('.cnf', 'my')
</code></pre>
<p>当文件有多个后缀，可以用<code>suffixes</code>返回文件所有后缀列表:</p>
<pre><code class="language-Python">Path('my.tar.bz2').suffixes
['.tar', '.bz2']
Path('my.tar').suffixes
['.tar']
Path('my').suffixes
[]
</code></pre>
<p>Python语言没有内置创建文件的方法(<code>linux</code>下的<code>touch</code>命令)，过去这么做:</p>
<pre><code class="language-Python">with open('new.txt', 'a') as f:
</code></pre>
<p>现在可以直接用<code>Path</code>的<code>touch</code>方法:</p>
<pre><code class="language-Python">Path('new.txt').touch()
</code></pre>
<p><code>touch</code>接受<code>mode</code>参数，能够在创建时确认文件权限，还能通过<code>exist_ok</code>参数方式确认是否可以重复<code>touch</code>(默认可以重复创建，会更新文件的<code>mtime</code>)</p>
<ul>
<li><code>filename.exists()</code>；路径是否存在</li>
<li>打开文件：</li>
</ul>
<pre><code class="language-Python">data_folder = Path(&quot;source_data/text_files/&quot;)
file_to_open = data_folder / &quot;raw_data.txt&quot;
print(file_to_open.read_text())
</code></pre>
<ul>
<li>与<code>os</code>模块对比<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321202526.png" alt="" loading="lazy"></li>
</ul>
<h2 id="第三方库">第三方库</h2>
<h3 id="h5py"><code>h5py</code></h3>
<p>h5py文件是存放两类对象的容器，数据集(<code>dataset</code>)和组(<code>group</code>)，<code>dataset</code>类似数组类的数据集合，和<code>numpy</code>的数组差不多。<code>group</code>是像文件夹一样的容器，它好比<code>Python</code>中的字典，有键(<code>key</code>)和值(<code>value</code>)。<code>group</code>中可以存放<code>dataset</code>或者其他的<code>group</code>。”键”就是组成员的名称，”值”就是组成员对象本身(组或者数据集)</p>
<pre><code class="language-Python">import h5py
</code></pre>
<h4 id="创建">创建</h4>
<pre><code class="language-Python">with h5py.File('test.h5','w') as f:
</code></pre>
<h4 id="读取">读取</h4>
<pre><code class="language-Python">with h5py.File('test.h5','r') as f:
</code></pre>
<p><code>h5py</code>文件就像一个 <code>Python</code> 字典，因此我们可以检查<code>key</code>,</p>
<pre><code class="language-Python">list(f.keys())
['mydataset']
</code></pre>
<p>文件中有一个数据集，即<code>mydataset</code>:</p>
<pre><code class="language-Python">dset = f['mydataset']
dset.shape
(100,)
dset.dtype
dtype('int32')
dset[...] = np.arange(100)
dset[0]
0
dset[10]
10
dset[0:100:10]
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
data = f['mydataset'][:]
</code></pre>
<h4 id="创建数据集">创建数据集：</h4>
<pre><code class="language-Python">d1=f.create_dataset(&quot;dset1&quot;, (20,), 'i')
for key in f.keys():
    print(key)
    print(f[key].name)
    print(f[key].shape)
    print(f[key].value)
dset1
/dset1
(20,)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</code></pre>
<pre><code class="language-Python">dset3 = f.create_dataset('subgroup2/dataset_three', (10,), dtype='i')
</code></pre>
<h4 id="赋值">赋值</h4>
<pre><code class="language-Python">d1=f.create_dataset(&quot;dset1&quot;,(20,),'i')
d1[...]=np.arange(20)
'''
或者我们可以直接按照下面的方式创建数据集并赋值
'''
f[&quot;dset2&quot;]=np.arange(15)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<p>如果我们有现成的<code>numpy</code>数组，那么可以在创建数据集的时候就赋值，这个时候就不必指定数据的类型和形状了，只需要把数组名传给参数<code>data</code>。</p>
<pre><code class="language-Python">a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
</code></pre>
<h4 id="综合示例1">综合示例1</h4>
<pre><code class="language-Python">'''
分别创建dset1,dset2,dset3这三个数据集
'''
a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)

d2=f.create_dataset(&quot;dset2&quot;,(3,4),'i')
d2[...]=np.arange(12).reshape((3,4))

f[&quot;dset3&quot;]=np.arange(15)

for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
/dset3
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<h4 id="创建group">创建<code>group</code></h4>
<p>需要首先以<code>append</code>模式打开文件</p>
<pre><code class="language-Python">f = h5py.File('mydataset.hdf5', 'a')
grp = f.create_group(&quot;subgroup&quot;)
</code></pre>
<pre><code class="language-Python">g1=f.create_group(&quot;bar&quot;)
'''
在bar这个组里面分别创建name为dset1,dset2的数据集并赋值。
'''
g1[&quot;dset1&quot;]=np.arange(10)
g1[&quot;dset2&quot;]=np.arange(12).reshape((3,4))

for key in g1.keys():
    print(g1[key].name)
    print(g1[key].value)
/bar/dset1
[0 1 2 3 4 5 6 7 8 9]
/bar/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>
<p>注意观察数据集<code>dset1</code>和<code>dset2</code>的名字是不是有点和前面的不一样，如果是直接创建的数据集，不在任何组里面，那么它的名字就是<code>/+名字</code>，现在这两个数据集都在<code>bar</code>这个<code>group</code>(组)里面，名字就变成了<code>/bar+/</code>名字，是不是有点文件夹的感觉！继续看下面的代码，你会对<code>group</code>和<code>dataset</code>的关系进一步了解。</p>
<pre><code class="language-Python">'''
创建组bar1,组bar2，数据集dset
'''
g1=f.create_group(&quot;bar1&quot;)
g2=f.create_group(&quot;bar2&quot;)
d=f.create_dataset(&quot;dset&quot;,data=np.arange(10))
'''
在bar1组里面创建一个组car1和一个数据集dset1。
'''
c1=g1.create_group(&quot;car1&quot;)
d1=g1.create_dataset(&quot;dset1&quot;,data=np.arange(10))
'''
在bar2组里面创建一个组car2和一个数据集dset2
'''
c2=g2.create_group(&quot;car2&quot;)
d2=g2.create_dataset(&quot;dset2&quot;,data=np.arange(10))
'''
根目录下的组和数据集
'''
for key in f.keys():
    print(f[key].name)
/bar1
/bar2
/dset
'''
bar1这个组下面的组和数据集
'''
for key in g1.keys():
    print(g1[key].name)
/bar1/car1
/bar1/dset1
'''
bar2这个组下面的组和数据集
'''
for key in g2.keys():
    print(g2[key].name)
/bar2/car2
/bar2/dset2
'''
顺便看下car1组和car2组下面都有什么，估计你都猜到了为空。
'''
print(c1.keys())
print(c2.keys())
[]
[]
</code></pre>
<ul>
<li>综合示例2</li>
</ul>
<pre><code class="language-Python">'''
遍历文件中的一级组
'''
for group in f.keys():
    print (group)
    '''
    根据一级组名获得其下面的组
    '''
    group_read = f[group]
    '''
    遍历该一级组下面的子组
    '''
    for subgroup in group_read.keys():
        print subgroup     
        '''
        根据一级组和二级组名获取其下面的dataset          
        '''
        dset_read = f[group+'/'+subgroup]
        '''                           
        遍历该子组下所有的dataset
        '''
        for dset in dset_read.keys():
        '''
            获取dataset数据
            '''
            dset1 = f[group+'/'+subgroup+'/'+dset]
            print dset1.name
            data = np.array(dset1)
            print data.shape
            x = data[...,0]
            y = data[...,1]        
</code></pre>
<h4 id="pandas对h5py的操作"><code>Pandas</code>对<code>h5py</code>的操作</h4>
<h5 id="写出">写出</h5>
<ul>
<li><code>path</code>：字符型输入，用于指定<code>h5</code>文件的名称（不在当前工作目录时需要带上完整路径信息）</li>
<li><code>mode</code>：用于指定<code>IO</code>操作的模式，与<code>Python</code>内建的<code>open()</code>中的参数一致，默认为<code>'a'</code>，即当指定文件已存在时不影响原有数据写入，指定文件不存在时则新建文件；<code>'r'</code>，只读模式；<code>'w'</code>，创建新文件（会覆盖同名旧文件）；<code>'r+'</code>，与<code>'a'</code>作用相似，但要求文件必须已经存在；</li>
<li><code>complevel</code>：<code>int</code>型，用于控制<code>h5</code>文件的压缩水平，取值范围在0-9之间，越大则文件的压缩程度越大，占用的空间越小，但相对应的在读取文件时需要付出更多解压缩的时间成本，默认为<code>0</code>，代表不压缩<br>
创建一个<code>HDF5 IO</code>对象<code>store</code>：</li>
</ul>
<pre><code class="language-Python">store = pd.HDFStore('demo.h5')
s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
df = pd.DataFrame(np.random.randn(8, 3),
                 columns=['A', 'B', 'C'])
store['s'],store['df'] = s,df
</code></pre>
<p>从<code>pandas</code>中的数据结构直接导出到本地<code>h5</code>文件中：</p>
<pre><code class="language-Python">'''
创建新的数据框
'''
df_ = pd.DataFrame(np.random.randn(5,5))
'''
导出到已存在的h5文件中，这里需要指定key
'''
df_.to_hdf(path_or_buf='demo.h5',key='df_')
'''
创建于本地demo.h5进行IO连接的store对象
'''
store = pd.HDFStore('demo.h5')
'''
查看指定h5对象中的所有键
'''
print(store.keys())
</code></pre>
<p>利用store对象的<code>put()</code>方法，其主要参数如下：</p>
<ul>
<li><code>key</code>：指定<code>h5</code>文件中待写入数据的<code>key</code></li>
<li><code>value</code>：指定与<code>key</code>对应的待写入的数据</li>
<li><code>format</code>：字符型输入，用于指定写出的模式，<code>'fixed'</code>对应的模式速度快，但是不支持追加也不支持检索；<code>'table'</code>对应的模式以表格的模式写出，速度稍慢，但是支持直接通过<code>store</code>对象进行追加和表格查询操作<br>
使用<code>put()</code>方法将数据存入<code>store</code>对象中：</li>
</ul>
<pre><code class="language-Python">store.put(key='s',value=s);store.put(key='df',value=df)
</code></pre>
<p>既然是键值对的格式，那么可以查看<code>store</code>的<code>items</code>属性（注意这里<code>store</code>对象只有<code>items</code>和<code>keys</code>属性，没有<code>values</code>属性）：</p>
<pre><code class="language-Python">store.items
</code></pre>
<p>调用<code>store</code>对象中的数据直接用对应的键名来索引即可：</p>
<pre><code class="language-Python">store['df']
</code></pre>
<p>删除<code>store</code>对象中指定数据的方法有两种，一是使用<code>remove()</code>方法，传入要删除数据对应的键：</p>
<pre><code class="language-Python">store.remove('s')
print(store.keys())
</code></pre>
<p>二是使用<code>Python</code>中的关键词<code>del</code>来删除指定数据：</p>
<pre><code class="language-Python">del store['s']
</code></pre>
<h5 id="读取-2">读取</h5>
<pre><code class="language-Python">store = pd.HDFStore('demo.h5')
'''方式1'''
df1 = store['df']
'''方式2'''
df2 = store.get('df')
</code></pre>
<pre><code class="language-Python">df = pd.read_hdf('demo.h5',key='df')
</code></pre>
<ul>
<li>删除对象</li>
</ul>
<pre><code class="language-Python">del subgroup[&quot;MyDataset&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python代码段]]></title>
        <id>https://bailingnan.github.io/post/python-dai-ma-duan/</id>
        <link href="https://bailingnan.github.io/post/python-dai-ma-duan/">
        </link>
        <updated>2020-03-27T18:19:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python代码段">Python代码段</h1>
<ul>
<li><a href="#python%E4%BB%A3%E7%A0%81%E6%AE%B5">Python代码段</a>
<ul>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a></li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
<li><a href="#collections"><code>collections</code></a>
<ul>
<li><a href="#deque"><code>deque</code></a></li>
<li><a href="#counter"><code>Counter</code></a></li>
</ul>
</li>
<li><a href="#heapq"><code>heapq</code></a></li>
<li><a href="#itertools"><code>itertools</code></a>
<ul>
<li><a href="#groupby"><code>groupby</code></a></li>
</ul>
</li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8">迭代器与生成器</a></li>
</ul>
</li>
</ul>
<h2 id="列表">列表</h2>
<ul>
<li>重复元素判定<br>
以下方法可以检查给定列表是不是存在重复元素，它会使用 <code>set()</code> 函数来移除所有重复元素。</li>
</ul>
<pre><code class="language-Python">def all_unique(lst):
    return len(lst) == len(set(lst))
x = [1,1,2,2,3,2,3,4,5,6]
y = [1,2,3,4,5]
all_unique(x) # False
all_unique(y) # True
</code></pre>
<ul>
<li>取两个列表交集：</li>
</ul>
<pre><code class="language-Python">def common_elements(list1, list2):
    common = set(list1).intersection(set(list2))
    return list(common)
</code></pre>
<ul>
<li>压缩<br>
这个方法可以将布尔型的值去掉，例如<code>(False，None，0，“”)</code>，它使用 <code>filter()</code> 函数。</li>
</ul>
<pre><code class="language-Python">def compact(lst):
    return list(filter(bool, lst))
compact([0, 1, False, 2, '', 3, 'a', 's', 34])
# [ 1, 2, 3, 'a', 's', 34 ]
</code></pre>
<ul>
<li>解包<br>
如下代码段可以将打包好的成对列表解开成两组不同的元组。</li>
</ul>
<pre><code class="language-Python">array = [['a', 'b'], ['c', 'd'], ['e', 'f']]
transposed = zip(*array)
print(transposed)
# [('a', 'c', 'e'), ('b', 'd', 'f')]
</code></pre>
<ul>
<li>逗号连接<br>
下面的代码可以将列表连接成单个字符串，且每一个元素间的分隔方式设置为了逗号。</li>
</ul>
<pre><code class="language-Python">hobbies = [&quot;basketball&quot;, &quot;football&quot;, &quot;swimming&quot;]
print(&quot;My hobbies are: &quot; + &quot;, &quot;.join(hobbies))
# My hobbies are: basketball, football, swimming
</code></pre>
<ul>
<li>展开列表<br>
该方法将通过递归的方式将列表的嵌套展开为单个列表。</li>
</ul>
<pre><code class="language-Python">def spread(arg):
    ret = []
    for i in arg:
        if isinstance(i, list):
            ret.extend(i)
        else:
            ret.append(i)
    return ret

def deep_flatten(lst):
    result = []
    result.extend(
        spread(list(map(lambda x: deep_flatten(x) if type(x) == list else x, lst))))
    return result
deep_flatten([1, [2], [[3], 4], 5]) # [1,2,3,4,5]
</code></pre>
<p>非递归：</p>
<pre><code class="language-Python">def spread(arg):
    ret = []
    for i in arg:
        if isinstance(i, list):
            ret.extend(i)
        else:
            ret.append(i)
    return ret
spread([1,2,3,[4,5,6],[7],8,9]) # [1,2,3,4,5,6,7,8,9]
</code></pre>
<p>可以写一个包含 <code>yield from</code> 语句的递归生成器来轻松解决这个问题。比如：</p>
<pre><code class="language-python">from collections import Iterable
def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]
# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x)
</code></pre>
<p>在上面代码中， <code>isinstance(x, Iterable)</code> 检查某个元素是否是可迭代的。 如果是的话， <code>yield from</code> 就会返回所有子例程的值。最终返回结果就是一个没有嵌套的简单序列了。<br>
额外的参数 <code>ignore_types</code> 和检测语句 <code>isinstance(x, ignore_types)</code> 用来将字符串和字节排除在可迭代对象外，防止将它们再展开成单个的字符。 这样的话字符串数组就能最终返回我们所期望的结果了。比如：</p>
<pre><code class="language-python">items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
for x in flatten(items):
    print(x)
Dave
Paula
Thomas
Lewis
</code></pre>
<p>语句 <code>yield from</code> 在你想在生成器中调用其他生成器作为子例程的时候非常有用。 如果你不使用它的话，那么就必须写额外的 <code>for</code> 循环了。比如：</p>
<pre><code class="language-python">def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            for i in flatten(x):
                yield i
        else:
            yield x
</code></pre>
<p>尽管只改了一点点，但是 <code>yield from</code> 语句看上去感觉更好，并且也使得代码更简洁清爽。<br>
之前提到的对于字符串和字节的额外检查是为了防止将它们再展开成单个字符。 如果还有其他你不想展开的类型，修改参数 <code>ignore_types</code> 即可。</p>
<ul>
<li>列表的差<br>
该方法将返回第一个列表的元素，其不在第二个列表内。如果同时要反馈第二个列表独有的元素，还需要加一句 <code>set_b.difference(set_a)</code>。</li>
</ul>
<pre><code class="language-Python">def difference(a, b):
    set_a = set(a)
    set_b = set(b)
    comparison = set_a.difference(set_b)
    return list(comparison)
difference([1,2,3], [1,2,4]) # [3]
</code></pre>
<ul>
<li>通过函数取差<br>
如下方法首先会应用一个给定的函数，然后再返回应用函数后结果有差别的列表元素。</li>
</ul>
<pre><code class="language-Python">def difference_by(a, b, fn):
    b = set(map(fn, b))
    return [item for item in a if fn(item) not in b]
from math import floor
difference_by([2.1, 1.2], [2.3, 3.4],floor) # [1.2]
difference_by([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], lambda v : v['x'])
# [ { x: 2 } ]
</code></pre>
<ul>
<li>Given a list of N numbers。<br>
给定一个含有<code>N</code>个数字的列表。<br>
使用单一的列表生成式来产生一个新的列表，该列表只包含满足以下条件的值：<br>
(a)偶数值<br>
(b)元素为原始列表中偶数切片。<br>
例如，如果<code>list[2]</code>包含的值是偶数。那么这个值应该被包含在新的列表当中。因为这个数字同时在原始列表的偶数序列（2为偶数）上。然而，如果<code>list[3]</code>包含一个偶数，<br>
那个数字不应该被包含在新的列表当中，因为它在原始列表的奇数序列上。<br>
对此问题的简单解决方法如下：</li>
</ul>
<pre><code class="language-Python">[x for x in list[::2] if x%2 == 0]
</code></pre>
<p>例如，给定列表如下：</p>
<pre><code class="language-Python">list = [ 1 , 3 , 5 , 8 , 10 , 13 , 18 , 36 , 78 ]
</code></pre>
<p>列表生成式<code>[x for x in list[::2] if x%2 == 0]</code> 的结果是，<code>[10, 18, 78]</code><br>
这个表达式工作的步骤是，第一步取出偶数切片的数字，<br>
第二步剔除其中所有奇数。</p>
<ul>
<li>更长列表</li>
</ul>
<pre><code class="language-Python">def max_length(*lst):
    return max(*lst, key=lambda v: len(v))
r = max_length([1, 2, 3], [4, 5, 6, 7], [8])
print(f'更长的列表是{r}')  # [4, 5, 6, 7]
r = max_length([1, 2, 3], [4, 5, 6, 7], [8, 9])
print(f'更长的列表是{r}')  # [4, 5, 6, 7]
</code></pre>
<ul>
<li>求众数</li>
</ul>
<pre><code>def top1(lst):
    return max(lst, default='列表为空', key=lambda v: lst.count(v))
lst = [1, 3, 3, 2, 1, 1, 2]
r = top1(lst)
print(f'{lst}中出现次数最多的元素为:{r}')  # [1, 3, 3, 2, 1, 1, 2]中出现次数最多的元素为:1
</code></pre>
<ul>
<li>列表之最</li>
</ul>
<pre><code class="language-Python">def max_lists(*lst):
    return max(max(*lst, key=lambda v: max(v)))
r = max_lists([1, 2, 3], [6, 7, 8], [4, 5])
print(r)  # 8
</code></pre>
<ul>
<li>按条件分组</li>
</ul>
<pre><code class="language-Python">def bif_by(lst, f):
    return [ [x for x in lst if f(x)],[x for x in lst if not f(x)]]
records = [25,89,31,34]
bif_by(records, lambda x: x&lt;80) # [[25, 31, 34], [89]]
</code></pre>
<ul>
<li>解压可迭代对象赋值给多个变量<br>
Python 的星号表达式可以用来解决这个问题。比如，你在学习一门课程，在学期末的时候， 你想统计下家庭作业的平均成绩，但是排除掉第一个和最后一个分数。如果只有四个分数，你可能就直接去简单的手动赋值， 但如果有 24 个呢？这时候星号表达式就派上用场了：</li>
</ul>
<pre><code class="language-Python">def drop_first_last(grades):
    first, *middle, last = grades
    return avg(middle)
</code></pre>
<p>另外一种情况，假设你现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。 你可以像下面这样分解这些记录：</p>
<pre><code class="language-Python">record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
name, email, *phone_numbers = record
name
'Dave'
email
'dave@example.com'
phone_numbers
['773-555-1212', '847-555-1212']
</code></pre>
<p>值得注意的是上面解压出的 <code>phone_numbers</code> 变量永远都是列表类型，不管解压的电话号码数量是多少（包括 0 个）。 所以，任何使用到 <code>phone_numbers</code> 变量的代码就不需要做多余的类型检查去确认它是否是列表类型了。<br>
星号表达式也能用在列表的开始部分。比如，你有一个公司前 8 个月销售数据的序列， 但是你想看下最近一个月数据和前面 7 个月的平均值的对比。你可以这样做：</p>
<pre><code class="language-Python">*trailing_qtrs, current_qtr = sales_record
trailing_avg = sum(trailing_qtrs) / len(trailing_qtrs)
return avg_comparison(trailing_avg, current_qtr)
</code></pre>
<p>下面是在 <code>Python</code> 解释器中执行的结果：</p>
<pre><code class="language-Python">*trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]
trailing
[10, 8, 7, 1, 9, 5, 10]
current
3
</code></pre>
<p>扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第1个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 而不是通过一些比较复杂的手段去获取这些关联的元素值。<br>
值得注意的是，星号表达式在迭代元素为可变长元组的序列时是很有用的。 比如，下面是一个带有标签的元组序列：</p>
<pre><code class="language-Python">records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]

def do_foo(x, y):
    print('foo', x, y)

def do_bar(s):
    print('bar', s)

for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)
</code></pre>
<p>星号解压语法在字符串操作的时候也会很有用，比如字符串的分割。<br>
代码示例：</p>
<pre><code class="language-Python">line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
uname, *fields, homedir, sh = line.split(':')
uname
'nobody'
homedir
'/var/empty'
sh
'/usr/bin/false'
</code></pre>
<p>有时候，你想解压一些元素后丢弃它们，你不能简单就使用 <code>*</code> ， 但是你可以使用一个普通的废弃名称，比如 <code>_</code> 或者 <code>ign(ignore)</code>。</p>
<pre><code class="language-Python">record = ('ACME', 50, 123.45, (12, 18, 2012))
name, *_, (*_, year) = record
name
'ACME'
year
2012
</code></pre>
<p>在很多函数式语言中，星号解压语法跟列表处理有许多相似之处。比如，如果你有一个列表， 你可以很容易的将它分割成前后两部分：</p>
<pre><code class="language-Python">items = [1, 10, 7, 4, 5, 9]
head, *tail = items
head
1
tail
[10, 7, 4, 5, 9]
</code></pre>
<p>如果你够聪明的话，还能用这种分割语法去巧妙的实现递归算法。比如：</p>
<pre><code class="language-Python">def sum(items):
    head, *tail = items
    return head + sum(tail) if tail else head
sum(items)
36
</code></pre>
<p>然后，由于语言层面的限制，递归并不是 <code>Python</code> 擅长的。 因此，最后那个递归演示仅仅是个好奇的探索罢了，对这个不要太认真了。</p>
<ul>
<li>删除序列相同元素并保持顺序<br>
如果序列上的值都是 <code>hashable</code> 类型，那么可以很简单的利用集合或者生成器来解决这个问题。比如：</li>
</ul>
<pre><code class="language-python">def dedupe(items):
    seen = set()
    for item in items:
        if item not in seen:
            yield item
            seen.add(item)
</code></pre>
<p>下面是使用上述函数的例子：</p>
<pre><code class="language-python">a = [1, 5, 2, 1, 9, 1, 5, 10]
list(dedupe(a))
[1, 5, 2, 9, 10]
</code></pre>
<p>这个方法仅仅在序列中元素为 <code>hashable</code> 的时候才管用。 如果你想消除元素不可哈希（比如 <code>dict</code> 类型）的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样：</p>
<pre><code class="language-python">def dedupe(items, key=None):
    seen = set()
    for item in items:
        val = item if key is None else key(item)
        if val not in seen:
            yield item
            seen.add(val)
</code></pre>
<p>这里的<code>key</code>参数指定了一个函数，将序列元素转换成 <code>hashable</code> 类型。下面是它的用法示例：</p>
<pre><code class="language-python">a = [ {'x':1, 'y':2}, {'x':1, 'y':3}, {'x':1, 'y':2}, {'x':2, 'y':4}]
list(dedupe(a, key=lambda d: (d['x'],d['y'])))
[{'x': 1, 'y': 2}, {'x': 1, 'y': 3}, {'x': 2, 'y': 4}]
list(dedupe(a, key=lambda d: d['x']))
[{'x': 1, 'y': 2}, {'x': 2, 'y': 4}]
</code></pre>
<p>如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任。<br>
如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合。比如：</p>
<pre><code class="language-python">a
[1, 5, 2, 1, 9, 1, 5, 10]
set(a)
{1, 2, 10, 5, 9}
</code></pre>
<p>然而，这种方法不能维护元素的顺序，生成的结果中的元素位置被打乱。而上面的方法可以避免这种情况。<br>
在本节中我们使用了生成器函数让我们的函数更加通用，不仅仅是局限于列表处理。 比如，如果如果你想读取一个文件，消除重复行，你可以很容易像这样做：</p>
<pre><code class="language-python">with open(somefile,'r') as f:
for line in dedupe(f):
    ...
</code></pre>
<p>上述key函数参数模仿了 <code>sorted()</code> , <code>min()</code> 和 <code>max()</code> 等内置函数的相似功能。</p>
<ul>
<li>命名切片<br>
假定你要从一个记录（比如文件或其他类似格式）中的某些固定位置提取字段：</li>
</ul>
<pre><code class="language-python">######    0123456789012345678901234567890123456789012345678901234567890'
record = '....................100 .......513.25 ..........'
cost = int(record[20:23]) * float(record[31:37])
</code></pre>
<p>与其那样写，为什么不想这样命名切片呢：</p>
<pre><code class="language-python">SHARES = slice(20, 23)
PRICE = slice(31, 37)
cost = int(record[SHARES]) * float(record[PRICE])
</code></pre>
<p>在这个版本中，你避免了使用大量难以理解的硬编码下标。这使得你的代码更加清晰可读。<br>
一般来讲，代码中如果出现大量的硬编码下标会使得代码的可读性和可维护性大大降低。 比如，如果你回过来看看一年前你写的代码，你会摸着脑袋想那时候自己到底想干嘛啊。 这是一个很简单的解决方案，它让你更加清晰的表达代码的目的。<br>
内置的 <code>slice()</code> 函数创建了一个切片对象。所有使用切片的地方都可以使用切片对象。比如：</p>
<pre><code class="language-python">items = [0, 1, 2, 3, 4, 5, 6]
a = slice(2, 4)
items[2:4]
[2, 3]
items[a]
[2, 3]
items[a] = [10,11]
items
[0, 1, 10, 11, 4, 5, 6]
del items[a]
items
[0, 1, 4, 5, 6]
</code></pre>
<p>如果你有一个切片对象<code>a</code>，你可以分别调用它的 <code>a.start</code> , <code>a.stop</code> , <code>a.step</code> 属性来获取更多的信息。比如：</p>
<pre><code class="language-python">a = slice(5, 50, 2)
a.start
5
a.stop
50
a.step
2
</code></pre>
<p>另外，你还可以通过调用切片的 <code>indices(size)</code> 方法将它映射到一个已知大小的序列上。 这个方法返回一个三元组 <code>(start, stop, step)</code> ，所有的值都会被缩小，直到适合这个已知序列的边界为止。 这样，使用的时就不会出现 <code>IndexError</code> 异常。比如：</p>
<pre><code class="language-python">s = 'HelloWorld'
a.indices(len(s))
(5, 10, 2)
for i in range(*a.indices(len(s))):
    print(s[i])
W
r
d
</code></pre>
<ul>
<li>排序</li>
</ul>
<pre><code class="language-python">s=['ab','abc','a','djkj']
b=sorted(s,key=lambda x:len(x))# 有返回值
s.sort(key=len)# 原地排序
</code></pre>
<ul>
<li>排序不支持原生比较的对象<br>
内置的 <code>sorted()</code> 函数有一个关键字参数 <code>key</code> ，可以传入一个 <code>callable</code> 对象给它， 这个 <code>callable</code> 对象对每个传入的对象返回一个值，这个值会被 <code>sorted</code> 用来排序这些对象。 比如，如果你在应用程序里面有一个 <code>User</code> 实例序列，并且你希望通过他们的 <code>user_id</code> 属性进行排序， 你可以提供一个以 <code>User</code> 实例作为输入并输出对应 <code>user_id</code> 值的 <code>callable</code> 对象。比如：</li>
</ul>
<pre><code class="language-python">class User:
    def __init__(self, user_id):
        self.user_id = user_id

    def __repr__(self):
        return 'User({})'.format(self.user_id)
def sort_notcompare():
    users = [User(23), User(3), User(99)]
    print(users)
    print(sorted(users, key=lambda u: u.user_id))
</code></pre>
<p>另外一种方式是使用 <code>operator.attrgetter()</code> 来代替 <code>lambda</code> 函数：</p>
<pre><code class="language-python">from operator import attrgetter
sorted(users, key=attrgetter('user_id'))
[User(3), User(23), User(99)]
</code></pre>
<p>选择使用 <code>lambda</code> 函数或者是 <code>attrgetter()</code> 可能取决于个人喜好。 但是， <code>attrgetter()</code> 函数通常会运行的快点，并且还能同时允许多个字段进行比较。 这个跟 <code>operator.itemgetter()</code> 函数作用于字典类型很类似。 例如，如果 <code>User</code> 实例还有一个 <code>first_name</code> 和 <code>last_name</code> 属性，那么可以向下面这样排序：</p>
<pre><code class="language-python">by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
</code></pre>
<p>同样需要注意的是，这一小节用到的技术同样适用于像 <code>min()</code> 和 <code>max()</code> 之类的函数。比如：</p>
<pre><code class="language-python">min(users, key=attrgetter('user_id'))
User(3)
max(users, key=attrgetter('user_id'))
User(99)
</code></pre>
<h2 id="元组">元组</h2>
<ul>
<li>取元组元素</li>
</ul>
<pre><code class="language-Python">a,b,c = ('cat','dog','tiger')
# 提取首、尾两个元素：
first,*_,end = (1,2,3,4,5,6)
# 提取首、中、尾三部分：
first,*middle,end = (1,2,3,4,5,6)
</code></pre>
<h2 id="字符串">字符串</h2>
<ul>
<li>字符元素组成判定<br>
检查两个字符串的组成元素是不是一样的。</li>
</ul>
<pre><code class="language-Python">from collections import Counter
def anagram(first, second):
    return Counter(first) == Counter(second)
anagram(&quot;abcd3&quot;, &quot;3acdb&quot;) # True
</code></pre>
<ul>
<li>N 次字符串<br>
该代码块不需要循环语句</li>
</ul>
<pre><code class="language-Python">n = 2;
s =&quot;Programming&quot;
print(s * n)
# ProgrammingProgramming  
</code></pre>
<ul>
<li>列表转字符串 <code>list -&gt; str</code></li>
</ul>
<pre><code class="language-Python">name_list = ['Zarten_1', 'Zarten_2', 'Zarten_3']
name_str = '&amp;'.join(name_list) # &amp;为列表元素之间分隔符
print(type(name_str), name_str)
</code></pre>
<ul>
<li>映射名称到序列元素<br>
<code>collections.namedtuple()</code> 函数通过使用一个普通的元组对象来帮你解决这个问题。 这个函数实际上是一个返回 <code>Python</code> 中标准元组类型子类的一个工厂方法。 你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等。 代码示例：</li>
</ul>
<pre><code class="language-python">from collections import namedtuple
Subscriber = namedtuple('Subscriber', ['addr', 'joined'])
sub = Subscriber('jonesy@example.com', '2012-10-19')
sub
Subscriber(addr='jonesy@example.com', joined='2012-10-19')
sub.addr
'jonesy@example.com'
sub.joined
'2012-10-19'
</code></pre>
<p>尽管 <code>namedtuple</code> 的实例看起来像一个普通的类实例，但是它跟元组类型是可交换的，支持所有的普通元组操作，比如索引和解压。 比如：</p>
<pre><code class="language-python">len(sub)
2
addr, joined = sub
addr
'jonesy@example.com'
joined
'2012-10-19'
</code></pre>
<p>命名元组的一个主要用途是将你的代码从下标操作中解脱出来。 因此，如果你从数据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素， 当你在表中添加了新的列的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有这样的顾虑。<br>
为了说明清楚，下面是使用普通元组的代码：</p>
<pre><code class="language-python">def compute_cost(records):
    total = 0.0
    for rec in records:
        total += rec[1] * rec[2]
    return total
</code></pre>
<p>下标操作通常会让代码表意不清晰，并且非常依赖记录的结构。 下面是使用命名元组的版本：</p>
<pre><code class="language-python">from collections import namedtuple
Stock = namedtuple('Stock', ['name', 'shares', 'price'])
def compute_cost(records):
    total = 0.0
    for rec in records:
        s = Stock(*rec)
        total += s.shares * s.price
    return total
</code></pre>
<p>命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。 如果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效。 但是需要注意的是，不像字典那样，一个命名元组是不可更改的。比如：</p>
<pre><code class="language-python">s = Stock('ACME', 100, 123.45)
s
Stock(name='ACME', shares=100, price=123.45)
s.shares = 75
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can't set attribute
</code></pre>
<p>如果你真的需要改变属性的值，那么可以使用命名元组实例的 <code>_replace()</code> 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代。比如：</p>
<pre><code class="language-python">s = s._replace(shares=75)
s
Stock(name='ACME', shares=75, price=123.45)
</code></pre>
<p><code>_replace()</code> 方法还有一个很有用的特性就是当你的命名元组拥有可选或者缺失字段时候， 它是一个非常方便的填充数据的方法。 你可以先创建一个包含缺省值的原型元组，然后使用 <code>_replace()</code> 方法创建新的值被更新过的实例。比如：</p>
<pre><code class="language-python">from collections import namedtuple
Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
# Create a prototype instance
stock_prototype = Stock('', 0, 0.0, None, None)
# Function to convert a dictionary to a Stock
def dict_to_stock(s):
    return stock_prototype._replace(**s)
</code></pre>
<p>下面是它的使用方法：</p>
<pre><code class="language-python">a = {'name': 'ACME', 'shares': 100, 'price': 123.45}
dict_to_stock(a)
Stock(name='ACME', shares=100, price=123.45, date=None, time=None)
b = {'name': 'ACME', 'shares': 100, 'price': 123.45, 'date': '12/17/2012'}
dict_to_stock(b)
Stock(name='ACME', shares=100, price=123.45, date='12/17/2012', time=None)
</code></pre>
<p>最后要说的是，如果你的目标是定义一个需要更新很多实例属性的高效数据结构，那么命名元组并不是你的最佳选择。 这时候你应该考虑定义一个包含 <code>__slots__</code> 方法的类。</p>
<ul>
<li><code>x=&quot;abc&quot;</code>,<code>y=&quot;def&quot;</code>,<code>z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]</code>,分别求出<code>x.join(y)</code>和<code>x.join(z)</code>返回的结果</li>
</ul>
<pre><code class="language-python">x=&quot;abc&quot;
y=&quot;def&quot;
z=[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;]
print(x.join(y),x.join(z))
dabceabcf dabceabcf
</code></pre>
<p><code>join()</code>括号里面的是可迭代对象，<code>x</code>插入可迭代对象中间，形成字符串，结果一致。</p>
<ul>
<li>去空格的两种方法</li>
</ul>
<pre><code class="language-python">str=&quot;hello world ha ha&quot;
res=str.replace(&quot; &quot;,&quot;&quot;)
list=str.split(&quot; &quot;)
res=&quot;&quot;.join(list)
</code></pre>
<h2 id="运算符">运算符</h2>
<ul>
<li>链式对比,我们可以在一行代码中使用不同的运算符对比多个不同的元素。</li>
</ul>
<pre><code class="language-Python">a = 3
print( 2 &lt; a &lt; 8) # True
print(1 == a &lt; 2) # False
</code></pre>
<ul>
<li>反向迭代</li>
</ul>
<pre><code class="language-Python">for i in reversed(range(1, 10)):
    print(i, end=',')
</code></pre>
<h2 id="函数">函数</h2>
<ul>
<li>链式函数调用<br>
你可以在一行代码内调用多个函数。</li>
</ul>
<pre><code class="language-Python">def add(a, b):
    return a + b
def subtract(a, b):
    return a - b
a, b = 4, 5
print((subtract if a &gt; b else add)(a, b)) # 9 
</code></pre>
<h2 id="字典">字典</h2>
<ul>
<li>合并字典</li>
</ul>
<pre><code class="language-Python">def merge_two_dicts(a, b):
    c = a.copy()   # make a copy of a 
    c.update(b)    # modify keys and values of a with the ones from b
    return c
a = { 'x': 1, 'y': 2}
b = { 'y': 3, 'z': 4}
print(merge_two_dicts(a, b))
# {'y': 3, 'x': 1, 'z': 4}
</code></pre>
<p>在 Python 3.5 或更高版本中，我们也可以用以下方式合并字典：</p>
<pre><code class="language-Python">def merge_dictionaries(a, b)
   return {**a, **b}
a = { 'x': 1, 'y': 2}
b = { 'y': 3, 'z': 4}
print(merge_dictionaries(a, b))
# {'y': 3, 'x': 1, 'z': 4}
</code></pre>
<p>这是一般的字典合并写法</p>
<pre><code class="language-Python">dic1 = {'x': 1, 'y': 2 }
dic2 = {'y': 3, 'z': 4 }
merged1 = {**dic1, **dic2} # {'x': 1, 'y': 3, 'z': 4}
</code></pre>
<p>修改<code>merged[‘x’]=10</code>，<code>dic1</code>中的<code>x</code>值不变，<code>merged</code>是重新生成的一个新字典。<br>
但是，<code>ChainMap</code>却不同，它在内部创建了一个容纳这些字典的列表。因此使用<code>ChainMap</code>合并字典，修改<code>merged[‘x’]=10</code>后，<code>dic1</code>中的<code>x</code>值改变，如下所示：</p>
<pre><code class="language-Python">from collections import ChainMap
merged2 = ChainMap(dic1,dic2)
print(merged2) # ChainMap({'x': 1, 'y': 2}, {'y': 3, 'z': 4})
</code></pre>
<p><strong>Python Cookbook</strong>:<br>
假如你有如下两个字典:</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
</code></pre>
<p>现在假设你必须在两个字典中执行查找操作（比如先从 <code>a</code> 中找，如果找不到再在 <code>b</code> 中找）。 一个非常简单的解决方案就是使用 <code>collections</code> 模块中的 <code>ChainMap</code> 类。比如：</p>
<pre><code class="language-python">from collections import ChainMap
c = ChainMap(a,b)
print(c['x']) # Outputs 1 (from a)
print(c['y']) # Outputs 2 (from b)
print(c['z']) # Outputs 3 (from a)
</code></pre>
<p>一个 <code>ChainMap</code> 接受多个字典并将它们在逻辑上变为一个字典。 然后，这些字典并不是真的合并在一起了， <code>ChainMap</code> 类只是在内部创建了一个容纳这些字典的列表 并重新定义了一些常见的字典操作来遍历这个列表。大部分字典操作都是可以正常使用的，比如：</p>
<pre><code class="language-python">len(c)
3
list(c.keys())
['x', 'y', 'z']
list(c.values())
[1, 2, 3]
</code></pre>
<p>如果出现重复键，那么第一次出现的映射值会被返回。 因此，例子程序中的 <code>c['z']</code> 总是会返回字典 <code>a</code> 中对应的值，而不是 <code>b</code> 中对应的值。<br>
对于字典的更新或删除操作总是影响的是列表中第一个字典。比如：</p>
<pre><code class="language-python">c['z'] = 10
c['w'] = 40
del c['x']
a
{'w': 40, 'z': 10}
del c['y']
Traceback (most recent call last):
...
KeyError: &quot;Key not found in the first mapping: 'y'&quot;
</code></pre>
<p><code>ChainMap</code> 对于编程语言中的作用范围变量（比如 <code>globals</code> , <code>locals</code> 等）是非常有用的。 事实上，有一些方法可以使它变得简单：</p>
<pre><code class="language-python">values = ChainMap()
values['x'] = 1
# Add a new mapping
values = values.new_child()
values['x'] = 2
# Add a new mapping
values = values.new_child()
values['x'] = 3
values
ChainMap({'x': 3}, {'x': 2}, {'x': 1})
values['x']
3
# Discard last mapping
values = values.parents
values['x']
2
# Discard last mapping
values = values.parents
values['x']
1
values
ChainMap({'x': 1})
</code></pre>
<p>作为 <code>ChainMap</code> 的替代，你可能会考虑使用 <code>update()</code> 方法将两个字典合并。比如：</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
merged = dict(b)
merged.update(a)
merged['x']
1
merged['y']
2
merged['z']
3
</code></pre>
<p>这样也能行得通，但是它需要你创建一个完全不同的字典对象（或者是破坏现有字典结构）。 同时，如果原字典做了更新，这种改变不会反应到新的合并字典中去。比如：</p>
<pre><code class="language-python">a['x'] = 13
merged['x']
1
</code></pre>
<p><code>ChainMap</code> 使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果，比如：</p>
<pre><code class="language-python">a = {'x': 1, 'z': 3 }
b = {'y': 2, 'z': 4 }
merged = ChainMap(a, b)
merged['x']
1
a['x'] = 42
merged['x'] # Notice change to merged dicts
42
</code></pre>
<ul>
<li>将两个列表转化为字典<br>
如下方法将会把两个列表转化为单个字典。</li>
</ul>
<pre><code class="language-Python">def to_dictionary(keys, values):
    return dict(zip(keys, values))
keys = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]    
values = [2, 3, 4]
print(to_dictionary(keys, values))
# {'a': 2, 'c': 4, 'b': 3}
</code></pre>
<ul>
<li>值最大的字典</li>
</ul>
<pre><code class="language-Python">def max_pairs(dic):
    if len(dic) == 0:
        return dic
    max_val = max(map(lambda v: v[1], dic.items()))
    return [item for item in dic.items() if item[1] == max_val]
r = max_pairs({'a': -10, 'b': 5, 'c': 3, 'd': 5})
print(r)  # [('b', 5), ('d', 5)]
</code></pre>
<ul>
<li><code>topn</code>字典</li>
</ul>
<pre><code class="language-Python">from heapq import nlargest
# 返回字典d前n个最大值对应的键
def topn_dict(d, n):
    return nlargest(n, d, key=lambda k: d[k])
topn_dict({'a': 10, 'b': 8, 'c': 9, 'd': 10}, 3)  # ['a', 'd', 'c']
</code></pre>
<ul>
<li>查找两字典的相同点</li>
</ul>
<pre><code class="language-python">a = {
    'x' : 1,
    'y' : 2,
    'z' : 3
}

b = {
    'w' : 10,
    'x' : 11,
    'y' : 2
}
</code></pre>
<p>为了寻找两个字典的相同点，可以简单的在两字典的 <code>keys()</code> 或者 <code>items()</code> 方法返回结果上执行集合操作。比如：</p>
<pre><code class="language-python"># Find keys in common
a.keys() &amp; b.keys() # { 'x', 'y' }
# Find keys in a that are not in b
a.keys() - b.keys() # { 'z' }
# Find (key,value) pairs in common
a.items() &amp; b.items() # { ('y', 2) }
</code></pre>
<p>这些操作也可以用于修改或者过滤字典元素。 比如，假如你想以现有字典构造一个排除几个指定键的新字典。 下面利用字典推导来实现这样的需求：</p>
<pre><code class="language-python"># Make a new dictionary with certain keys removed
c = {key:a[key] for key in a.keys() - {'z', 'w'}}
# c is {'x': 1, 'y': 2}
</code></pre>
<p>一个字典就是一个键集合与值集合的映射关系。 字典的 <code>keys()</code> 方法返回一个展现键集合的键视图对象。 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个 <code>set</code>。<br>
字典的 <code>items()</code> 方法返回一个包含 <code>(键，值)</code> 对的元素视图对象。 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。<br>
尽管字典的 <code>values()</code> 方法也是类似，但是它并不支持这里介绍的集合操作。 某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。 不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成<code>set</code>，然后再执行集合运算就行了。</p>
<ul>
<li>字典的运算<br>
考虑下面的股票名和价格映射字典：</li>
</ul>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
</code></pre>
<p>为了对字典值执行计算操作，通常需要使用 <code>zip()</code> 函数先将键和值反转过来。 比如，下面是查找最小和最大股票价格和股票值的代码：</p>
<pre><code class="language-python">min_price = min(zip(prices.values(), prices.keys()))
# min_price is (10.75, 'FB')
max_price = max(zip(prices.values(), prices.keys()))
# max_price is (612.78, 'AAPL')
</code></pre>
<p>类似的，可以使用 <code>zip()</code> 和 <code>sorted()</code> 函数来排列字典数据：</p>
<pre><code class="language-python">prices_sorted = sorted(zip(prices.values(), prices.keys()))
# prices_sorted is [(10.75, 'FB'), (37.2, 'HPQ'),
#                   (45.23, 'ACME'), (205.55, 'IBM'),
#                   (612.78, 'AAPL')]
</code></pre>
<p>执行这些计算的时候，需要注意的是 <code>zip()</code> 函数创建的是一个只能访问一次的迭代器。 比如，下面的代码就会产生错误：</p>
<pre><code class="language-python">prices_and_names = zip(prices.values(), prices.keys())
print(min(prices_and_names)) # OK
print(max(prices_and_names)) # ValueError: max() arg is an empty sequence
</code></pre>
<p>如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值。比如：</p>
<pre><code class="language-python">min(prices) # Returns 'AAPL'
max(prices) # Returns 'IBM'
</code></pre>
<p>这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算。 或许你会尝试着使用字典的 <code>values()</code> 方法来解决这个问题：</p>
<pre><code class="language-python">min(prices.values()) # Returns 10.75
max(prices.values()) # Returns 612.78
</code></pre>
<p>不幸的是，通常这个结果同样也不是你想要的。 你可能还想要知道对应的键的信息（比如那种股票价格是最低的？）。<br>
你可以在 <code>min()</code> 和 <code>max()</code> 函数中提供 <code>key</code> 函数参数来获取最小值或最大值对应的键的信息。比如：</p>
<pre><code class="language-python">min(prices, key=lambda k: prices[k]) # Returns 'FB'
max(prices, key=lambda k: prices[k]) # Returns 'AAPL'
</code></pre>
<p>但是，如果还想要得到最小值，你又得执行一次查找操作。比如：</p>
<pre><code class="language-python">min_value = prices[min(prices, key=lambda k: prices[k])]
</code></pre>
<p>前面的 <code>zip()</code> 函数方案通过将字典”反转”为 (值，键) 元组序列来解决了上述问题。 当比较两个元组的时候，值会先进行比较，然后才是键。 这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了。<br>
需要注意的是在计算操作中使用到了 (值，键) 对。当多个实体拥有相同的值的时候，键会决定返回结果。 比如，在执行 <code>min()</code> 和 <code>max()</code> 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：</p>
<pre><code class="language-python">prices = { 'AAA' : 45.23, 'ZZZ': 45.23 }
min(zip(prices.values(), prices.keys()))
(45.23, 'AAA')
max(zip(prices.values(), prices.keys()))
(45.23, 'ZZZ')
</code></pre>
<ul>
<li>通过某个关键字排序一个字典列表<br>
通过使用 <code>operator</code> 模块的 <code>itemgetter</code> 函数，可以非常容易的排序这样的数据结构。 假设你从数据库中检索出来网站会员信息列表，并且以下列的数据结构返回：</li>
</ul>
<pre><code class="language-python">rows = [
    {'fname': 'Brian', 'lname': 'Jones', 'uid': 1003},
    {'fname': 'David', 'lname': 'Beazley', 'uid': 1002},
    {'fname': 'John', 'lname': 'Cleese', 'uid': 1001},
    {'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
]
</code></pre>
<p>根据任意的字典字段来排序输入结果行是很容易实现的，代码示例：</p>
<pre><code class="language-python">from operator import itemgetter
rows_by_fname = sorted(rows, key=itemgetter('fname'))
rows_by_uid = sorted(rows, key=itemgetter('uid'))
print(rows_by_fname)
print(rows_by_uid)
</code></pre>
<p>代码的输出如下：</p>
<pre><code class="language-python">[{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'}]
[{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'}]
</code></pre>
<p><code>itemgetter()</code> 函数也支持多个 <code>keys</code>，比如下面的代码</p>
<pre><code class="language-python">rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))
print(rows_by_lfname)
</code></pre>
<p>会产生如下的输出：</p>
<pre><code class="language-python">[{'fname': 'David', 'uid': 1002, 'lname': 'Beazley'},
{'fname': 'John', 'uid': 1001, 'lname': 'Cleese'},
{'fname': 'Big', 'uid': 1004, 'lname': 'Jones'},
{'fname': 'Brian', 'uid': 1003, 'lname': 'Jones'}]
</code></pre>
<p>在上面例子中， <code>rows</code> 被传递给接受一个关键字参数的 <code>sorted()</code> 内置函数。 这个参数是 <code>callable</code> 类型，并且从 <code>rows</code> 中接受一个单一元素，然后返回被用来排序的值。 <code>itemgetter()</code> 函数就是负责创建这个 <code>callable</code> 对象的。</p>
<p><code>operator.itemgetter()</code> 函数有一个被 <code>rows</code> 中的记录用来查找值的索引参数。可以是一个字典键名称， 一个整形值或者任何能够传入一个对象的 <code>__getitem__()</code> 方法的值。 如果你传入多个索引参数给 <code>itemgetter()</code> ，它生成的 <code>callable</code> 对象会返回一个包含所有元素值的元组， 并且 <code>sorted()</code> 函数会根据这个元组中元素顺序去排序。 但你想要同时在几个字段上面进行排序（比如通过姓和名来排序，也就是例子中的那样）的时候这种方法是很有用的。<br>
<code>itemgetter()</code> 有时候也可以用 <code>lambda</code> 表达式代替，比如：</p>
<pre><code class="language-python">rows_by_fname = sorted(rows, key=lambda r: r['fname'])
rows_by_lfname = sorted(rows, key=lambda r: (r['lname'],r['fname']))
</code></pre>
<p>这种方案也不错。但是，使用 <code>itemgetter()</code> 方式会运行的稍微快点。因此，如果你对性能要求比较高的话就使用 <code>itemgetter()</code> 方式。<br>
最后，不要忘了这节中展示的技术也同样适用于 <code>min()</code> 和 <code>max()</code> 等函数。比如：</p>
<pre><code class="language-python">min(rows, key=itemgetter('uid'))
{'fname': 'John', 'lname': 'Cleese', 'uid': 1001}
max(rows, key=itemgetter('uid'))
{'fname': 'Big', 'lname': 'Jones', 'uid': 1004}
</code></pre>
<ul>
<li>字典中提取子集<br>
最简单的方式是使用字典推导。比如：</li>
</ul>
<pre><code class="language-python">prices = {
    'ACME': 45.23,
    'AAPL': 612.78,
    'IBM': 205.55,
    'HPQ': 37.20,
    'FB': 10.75
}
# Make a dictionary of all prices over 200
p1 = {key: value for key, value in prices.items() if value &gt; 200}
# Make a dictionary of tech stocks
tech_names = {'AAPL', 'IBM', 'HPQ', 'MSFT'}
p2 = {key: value for key, value in prices.items() if key in tech_names}
</code></pre>
<p>大多数情况下字典推导能做到的，通过创建一个元组序列然后把它传给 <code>dict()</code> 函数也能实现。比如：</p>
<pre><code class="language-python">p1 = dict((key, value) for key, value in prices.items() if value &gt; 200)
</code></pre>
<p>但是，字典推导方式表意更清晰，并且实际上也会运行的更快些 （在这个例子中，实际测试几乎比 <code>dict()</code> 函数方式快整整一倍）。<br>
有时候完成同一件事会有多种方式。比如，第二个例子程序也可以像这样重写：</p>
<pre><code class="language-python"># Make a dictionary of tech stocks
tech_names = { 'AAPL', 'IBM', 'HPQ', 'MSFT' }
p2 = { key:prices[key] for key in prices.keys() &amp; tech_names }
</code></pre>
<p>但是，运行时间测试结果显示这种方案大概比第一种方案慢 1.6 倍。 如果对程序运行性能要求比较高的话，需要花点时间去做计时测试。</p>
<h2 id="集合">集合</h2>
<ul>
<li>元素频率<br>
下面的方法会根据元素频率取列表中最常见的元素。</li>
</ul>
<pre><code class="language-Python">def most_frequent(list):
    return max(set(list), key = list.count)
list = [1,2,1,2,3,2,1,4,2]
most_frequent(list)
</code></pre>
<h2 id="collections"><code>collections</code></h2>
<h3 id="deque"><code>deque</code></h3>
<ul>
<li>保留最后 <code>N</code> 个元素<br>
使用 <code>deque(maxlen=N)</code> 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。</li>
</ul>
<pre><code class="language-Python">q = deque(maxlen=3)
q.append(1)
q.append(2)
q.append(3)
q
deque([1, 2, 3], maxlen=3)
q.append(4)
q
deque([2, 3, 4], maxlen=3)
q.append(5)
q
deque([3, 4, 5], maxlen=3)
</code></pre>
<p>尽管你也可以手动在一个列表上实现这一的操作（比如增加、删除等等）。但是这里的队列方案会更加优雅并且运行得更快些。<br>
更一般的， <code>deque</code> 类可以被用在任何你只需要一个简单队列数据结构的场合。 如果你不设置最大队列大小，那么就会得到一个无限大小队列，你可以在队列的两端执行添加和弹出元素的操作。</p>
<pre><code class="language-python">q = deque()
q.append(1)
q.append(2)
q.append(3)
q
deque([1, 2, 3])
q.appendleft(4)
q
deque([4, 1, 2, 3])
q.pop()
3
q
deque([4, 1, 2])
q.popleft()
4
</code></pre>
<p>在队列两端插入或删除元素时间复杂度都是 <code>O(1)</code> ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 <code>O(N)</code> 。</p>
<h3 id="counter"><code>Counter</code></h3>
<ul>
<li>序列中出现次数最多的元素<br>
<code>collections.Counter</code> 类就是专门为这类问题而设计的， 它甚至有一个有用的 <code>most_common()</code> 方法直接给了你答案。<br>
为了演示，先假设你有一个单词列表并且想找出哪个单词出现频率最高。你可以这样做：</li>
</ul>
<pre><code class="language-python">words = [
    'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
    'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around', 'the',
    'eyes', &quot;don't&quot;, 'look', 'around', 'the', 'eyes', 'look', 'into',
    'my', 'eyes', &quot;you're&quot;, 'under'
]
from collections import Counter
word_counts = Counter(words)
# 出现频率最高的3个单词
top_three = word_counts.most_common(3)
print(top_three)
# Outputs [('eyes', 8), ('the', 5), ('look', 4)]
</code></pre>
<p>作为输入， <code>Counter</code> 对象可以接受任意的由可哈希(<code>hashable</code>)元素构成的序列对象。 在底层实现上，一个 <code>Counter</code>对象就是一个字典，将元素映射到它出现的次数上。比如：</p>
<pre><code class="language-python">word_counts['not']
1
word_counts['eyes']
8
</code></pre>
<p>如果你想手动增加计数，可以简单的用加法：</p>
<pre><code class="language-python">morewords = ['why','are','you','not','looking','in','my','eyes']
for word in morewords:
    word_counts[word] += 1
word_counts['eyes']
9
</code></pre>
<p>或者你可以使用 <code>update()</code> 方法：</p>
<pre><code class="language-python">word_counts.update(morewords)
</code></pre>
<p><code>Counter</code> 实例一个鲜为人知的特性是它们可以很容易的跟数学运算操作相结合。比如：</p>
<pre><code class="language-python">a = Counter(words)
b = Counter(morewords)
a
Counter({'eyes': 8, 'the': 5, 'look': 4, 'into': 3, 'my': 3, 'around': 2,
&quot;you're&quot;: 1, &quot;don't&quot;: 1, 'under': 1, 'not': 1})
b
Counter({'eyes': 1, 'looking': 1, 'are': 1, 'in': 1, 'not': 1, 'you': 1,
'my': 1, 'why': 1})
# Combine counts
c = a + b
c
Counter({'eyes': 9, 'the': 5, 'look': 4, 'my': 4, 'into': 3, 'not': 2,
'around': 2, &quot;you're&quot;: 1, &quot;don't&quot;: 1, 'in': 1, 'why': 1,
'looking': 1, 'are': 1, 'under': 1, 'you': 1})
# Subtract counts
d = a - b
d
Counter({'eyes': 7, 'the': 5, 'look': 4, 'into': 3, 'my': 2, 'around': 2,
&quot;you're&quot;: 1, &quot;don't&quot;: 1, 'under': 1})
</code></pre>
<p>毫无疑问， <code>Counter</code> 对象在几乎所有需要制表或者计数数据的场合是非常有用的工具。 在解决这类问题的时候你应该优先选择它，而不是手动的利用字典去实现。</p>
<h2 id="heapq"><code>heapq</code></h2>
<ul>
<li>查找最大或最小的 <code>N</code> 个元素<br>
<code>heapq</code> 模块有两个函数：<code>nlargest()</code> 和 <code>nsmallest()</code> 可以完美解决这个问题。</li>
</ul>
<pre><code class="language-python">import heapq
nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]
print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]
</code></pre>
<p>两个函数都能接受一个关键字参数，用于更复杂的数据结构中：</p>
<pre><code class="language-python">portfolio = [
    {'name': 'IBM', 'shares': 100, 'price': 91.1},
    {'name': 'AAPL', 'shares': 50, 'price': 543.22},
    {'name': 'FB', 'shares': 200, 'price': 21.09},
    {'name': 'HPQ', 'shares': 35, 'price': 31.75},
    {'name': 'YHOO', 'shares': 45, 'price': 16.35},
    {'name': 'ACME', 'shares': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>上面代码在对每个元素进行对比的时候，会以 <code>price</code> 的值进行比较。<br>
如果你想在一个集合中查找最小或最大的 <code>N</code> 个元素，并且 <code>N</code> 小于集合元素数量，那么这些函数提供了很好的性能。 因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：</p>
<pre><code class="language-python">nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
import heapq
heap = list(nums)
heapq.heapify(heap)
heap
[-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
</code></pre>
<p>堆数据结构最重要的特征是 <code>heap[0]</code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code>heapq.heappop()</code> 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 <code>O(log N)</code>，<code>N</code> 是堆大小）。 比如，如果想要查找最小的 3 个元素，你可以这样做：</p>
<pre><code class="language-python">heapq.heappop(heap)
-4
heapq.heappop(heap)
1
heapq.heappop(heap)
2
</code></pre>
<p>当要查找的元素个数相对比较小的时候，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 是很合适的。 如果你仅仅想查找唯一的最小或最大（<code>N=1</code>）的元素的话，那么使用 <code>min()</code> 和 <code>max()</code> 函数会更快些。 类似的，如果 <code>N</code> 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （ <code>sorted(items)[:N]</code> 或者是 <code>sorted(items)[-N:]</code> ）。 需要在正确场合使用函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才能发挥它们的优势 （如果 <code>N</code> 快接近集合大小了，那么使用排序操作会更好些）。</p>
<ul>
<li>实现优先级队列<br>
下面的类利用 <code>heapq</code> 模块实现了一个简单的优先级队列：</li>
</ul>
<pre><code class="language-python">import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>
<p>下面是它的使用方式：</p>
<pre><code class="language-python">class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name)
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
Item('bar')
q.pop()
('spam')
q.pop()
Item('foo')
q.pop()
Item('grok')
</code></pre>
<p>仔细观察可以发现，第一个 <code>pop()</code> 操作返回优先级最高的元素。 另外注意到如果两个有着相同优先级的元素<code>(foo 和 grok)</code>，<code>pop</code> 操作按照它们被插入到队列的顺序返回的。<br>
这一小节我们主要关注 <code>heapq</code> 模块的使用。 函数 <code>heapq.heappush()</code> 和 <code>heapq.heappop()</code> 分别在队列 <code>_queue</code> 上插入和删除第一个元素， 并且队列 <code>_queue</code> 保证第一个元素拥有最高优先级。 <code>heappop()</code> 函数总是返回”最小的”的元素，这就是保证队列<code>pop</code>操作返回正确元素的关键。 另外，由于 <code>push</code> 和 <code>pop</code> 操作时间复杂度为 <code>O(log N)</code>，其中 <code>N</code> 是堆的大小，因此就算是 <code>N</code> 很大的时候它们运行速度也依旧很快。</p>
<p>在上面代码中，队列包含了一个 <code>(-priority, index, item)</code> 的元组。 优先级为负数的目的是使得元素按照优先级从高到低排序。 这个跟普通的按优先级从低到高排序的堆排序恰巧相反。</p>
<p><code>index</code> 变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的 <code>index</code> 下标变量，可以确保元素按照它们插入的顺序排序。 而且， <code>index</code> 变量也在相同优先级元素比较的时候起到重要作用。</p>
<p>为了阐明这些，先假定 <code>Item</code> 实例是不支持排序的：</p>
<pre><code class="language-python">a = Item('foo')
b = Item('bar')
a &lt; b
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
</code></pre>
<p>如果你使用元组 <code>(priority, item)</code> ，只要两个元素的优先级不同就能比较。 但是如果两个元素优先级一样的话，那么比较操作就会跟之前一样出错：</p>
<pre><code class="language-python">a = (1, Item('foo'))
b = (5, Item('bar'))
a &lt; b
True
c = (1, Item('grok'))
a &lt; c
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: unorderable types: Item() &lt; Item()
</code></pre>
<p>通过引入另外的 <code>index</code> 变量组成三元组 <code>(priority, index, item)</code> ，就能很好的避免上面的错误， 因为不可能有两个元素有相同的 <code>index</code> 值。<code>Python</code> 在做元组比较时候，如果前面的比较已经可以确定结果了， 后面的比较操作就不会发生了：</p>
<pre><code class="language-python">a = (1, 0, Item('foo'))
b = (5, 1, Item('bar'))
c = (1, 2, Item('grok'))
a &lt; b
True
a &lt; c
True
</code></pre>
<p>如果你想在多个线程中使用同一个队列，那么你需要增加适当的锁和信号量机制。</p>
<h2 id="itertools"><code>itertools</code></h2>
<h3 id="groupby"><code>groupby</code></h3>
<ul>
<li>通过某个字段将记录分组<br>
<code>itertools.groupby()</code> 函数对于这样的数据分组操作非常实用。 为了演示，假设你已经有了下列的字典列表：</li>
</ul>
<pre><code class="language-python">rows = [
    {'address': '5412 N CLARK', 'date': '07/01/2012'},
    {'address': '5148 N CLARK', 'date': '07/04/2012'},
    {'address': '5800 E 58TH', 'date': '07/02/2012'},
    {'address': '2122 N CLARK', 'date': '07/03/2012'},
    {'address': '5645 N RAVENSWOOD', 'date': '07/02/2012'},
    {'address': '1060 W ADDISON', 'date': '07/02/2012'},
    {'address': '4801 N BROADWAY', 'date': '07/01/2012'},
    {'address': '1039 W GRANVILLE', 'date': '07/04/2012'},
]
</code></pre>
<p>现在假设你想在按 <code>date</code> 分组后的数据块上进行迭代。为了这样做，你首先需要按照指定的字段(这里就是 <code>date</code> )排序， 然后调用 <code>itertools.groupby()</code> 函数：</p>
<pre><code class="language-python">from operator import itemgetter
from itertools import groupby

# Sort by the desired field first
rows.sort(key=itemgetter('date'))
# Iterate in groups
for date, items in groupby(rows, key=itemgetter('date')):
    print(date)
    for i in items:
        print(' ', i)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-python">07/01/2012
  {'date': '07/01/2012', 'address': '5412 N CLARK'}
  {'date': '07/01/2012', 'address': '4801 N BROADWAY'}
07/02/2012
  {'date': '07/02/2012', 'address': '5800 E 58TH'}
  {'date': '07/02/2012', 'address': '5645 N RAVENSWOOD'}
  {'date': '07/02/2012', 'address': '1060 W ADDISON'}
07/03/2012
  {'date': '07/03/2012', 'address': '2122 N CLARK'}
07/04/2012
  {'date': '07/04/2012', 'address': '5148 N CLARK'}
  {'date': '07/04/2012', 'address': '1039 W GRANVILLE'}
</code></pre>
<p><code>groupby()</code> 函数扫描整个序列并且查找连续相同值（或者根据指定 <code>key</code> 函数返回值相同）的元素序列。 在每次迭代的时候，它会返回一个值和一个迭代器对象， 这个迭代器对象可以生成元素值全部等于上面那个值的组中所有对象。<br>
一个非常重要的准备步骤是要根据指定的字段将数据排序。 因为 <code>groupby()</code> 仅仅检查连续的元素，如果事先并没有排序完成的话，分组函数将得不到想要的结果。<br>
如果你仅仅只是想根据 <code>date</code> 字段将数据分组到一个大的数据结构中去，并且允许随机访问， 那么你最好使用 <code>defaultdict()</code> 来构建一个多值字典，</p>
<pre><code class="language-python">from collections import defaultdict
rows_by_date = defaultdict(list)
for row in rows:
    rows_by_date[row['date']].append(row)
</code></pre>
<p>这样的话你可以很轻松的就能对每个指定日期访问对应的记录：</p>
<pre><code class="language-python">for r in rows_by_date['07/01/2012']:
    print(r)
{'date': '07/01/2012', 'address': '5412 N CLARK'}
{'date': '07/01/2012', 'address': '4801 N BROADWAY'}
</code></pre>
<p>在上面这个例子中，我们没有必要先将记录排序。因此，如果对内存占用不是很关心， 这种方式会比先排序然后再通过 <code>groupby()</code> 函数迭代的方式运行得快一些。</p>
<h2 id="迭代器与生成器">迭代器与生成器</h2>
<ul>
<li>过滤序列元素<br>
最简单的过滤序列元素的方法就是使用列表推导。比如：</li>
</ul>
<pre><code class="language-python">mylist = [1, 4, -5, 10, -7, 2, 3, -1]
[n for n in mylist if n &gt; 0]
[1, 4, 10, 2, 3]
[n for n in mylist if n &lt; 0]
[-5, -7, -1]
</code></pre>
<p>使用列表推导的一个潜在缺陷就是如果输入非常大的时候会产生一个非常大的结果集，占用大量内存。 如果你对内存比较敏感，那么你可以使用生成器表达式迭代产生过滤的元素。比如：</p>
<pre><code class="language-python">pos = (n for n in mylist if n &gt; 0)
pos
&lt;generator object &lt;genexpr&gt; at 0x1006a0eb0&gt;
for x in pos:
    print(x)
1
4
10
2
3
</code></pre>
<p>有时候，过滤规则比较复杂，不能简单的在列表推导或者生成器表达式中表达出来。 比如，假设过滤的时候需要处理一些异常或者其他复杂情况。这时候你可以将过滤代码放到一个函数中， 然后使用内建的 <code>filter()</code> 函数。示例如下：</p>
<pre><code class="language-python">values = ['1', '2', '-3', '-', '4', 'N/A', '5']
def is_int(val):
    try:
        x = int(val)
        return True
    except ValueError:
        return False
ivals = list(filter(is_int, values))
print(ivals)
# Outputs ['1', '2', '-3', '4', '5']
</code></pre>
<p><code>filter()</code> 函数创建了一个迭代器，因此如果你想得到一个列表的话，就得像示例那样使用 <code>list()</code> 去转换。<br>
列表推导和生成器表达式通常情况下是过滤数据最简单的方式。 其实它们还能在过滤的时候转换数据。比如：</p>
<pre><code class="language-python">mylist = [1, 4, -5, 10, -7, 2, 3, -1]
import math
[math.sqrt(n) for n in mylist if n &gt; 0]
[1.0, 2.0, 3.1622776601683795, 1.4142135623730951, 1.7320508075688772]
</code></pre>
<p>过滤操作的一个变种就是将不符合条件的值用新的值代替，而不是丢弃它们。 比如，在一列数据中你可能不仅想找到正数，而且还想将不是正数的数替换成指定的数。 通过将过滤条件放到条件表达式中去，可以很容易的解决这个问题，就像这样：</p>
<pre><code class="language-python">clip_neg = [n if n &gt; 0 else 0 for n in mylist]
clip_neg
[1, 4, 0, 10, 0, 2, 3, 0]
clip_pos = [n if n &lt; 0 else 0 for n in mylist]
clip_pos
[0, 0, -5, 0, -7, 0, 0, -1]
</code></pre>
<p>另外一个值得关注的过滤工具就是 <code>itertools.compress()</code> ， 它以一个 <code>iterable</code> 对象和一个相对应的 <code>Boolean</code> 选择器序列作为输入参数。 然后输出 <code>iterable</code> 对象中对应选择器为 <code>True</code> 的元素。 当你需要用另外一个相关联的序列来过滤某个序列的时候，这个函数是非常有用的。 比如，假如现在你有下面两列数据：</p>
<pre><code class="language-python">addresses = [
    '5412 N CLARK',
    '5148 N CLARK',
    '5800 E 58TH',
    '2122 N CLARK',
    '5645 N RAVENSWOOD',
    '1060 W ADDISON',
    '4801 N BROADWAY',
    '1039 W GRANVILLE',
]
counts = [ 0, 3, 10, 4, 1, 7, 6, 1]
</code></pre>
<p>现在你想将那些对应 <code>count</code> 值大于5的地址全部输出，那么你可以这样做：</p>
<pre><code class="language-python">from itertools import compress
more5 = [n &gt; 5 for n in counts]
more5
[False, False, True, False, False, True, True, False]
list(compress(addresses, more5))
['5800 E 58TH', '1060 W ADDISON', '4801 N BROADWAY']
</code></pre>
<p>这里的关键点在于先创建一个 <code>Boolean</code> 序列，指示哪些元素符合条件。 然后 <code>compress()</code> 函数根据这个序列去选择输出对应位置为 <code>True</code> 的元素。<br>
和 <code>filter()</code> 函数类似， <code>compress()</code> 也是返回的一个迭代器。因此，如果你需要得到一个列表， 那么你需要使用 <code>list()</code> 来将结果转换为列表类型。</p>
<ul>
<li>转换并同时计算数据<br>
一个非常优雅的方式去结合数据计算与转换就是使用一个生成器表达式参数。 比如，如果你想计算平方和，可以像下面这样做：</li>
</ul>
<pre><code class="language-python">nums = [1, 2, 3, 4, 5]
s = sum(x * x for x in nums)
</code></pre>
<p>下面是更多的例子：</p>
<pre><code class="language-python"># Determine if any .py files exist in a directory
import os
files = os.listdir('dirname')
if any(name.endswith('.py') for name in files):
    print('There be python!')
else:
    print('Sorry, no python.')
# Output a tuple as CSV
s = ('ACME', 50, 123.45)
print(','.join(str(x) for x in s))
# Data reduction across fields of a data structure
portfolio = [
    {'name':'GOOG', 'shares': 50},
    {'name':'YHOO', 'shares': 75},
    {'name':'AOL', 'shares': 20},
    {'name':'SCOX', 'shares': 65}
]
min_shares = min(s['shares'] for s in portfolio)
</code></pre>
<p>上面的示例向你演示了当生成器表达式作为一个单独参数传递给函数时候的巧妙语法（你并不需要多加一个括号）。 比如，下面这些语句是等效的：</p>
<pre><code class="language-python">s = sum((x * x for x in nums)) # 显式的传递一个生成器表达式对象
s = sum(x * x for x in nums) # 更加优雅的实现方式，省略了括号
</code></pre>
<p>使用一个生成器表达式作为参数会比先创建一个临时列表更加高效和优雅。 比如，如果你不使用生成器表达式的话，你可能会考虑使用下面的实现方式：</p>
<pre><code class="language-python">nums = [1, 2, 3, 4, 5]
s = sum([x * x for x in nums])
</code></pre>
<p>这种方式同样可以达到想要的效果，但是它会多一个步骤，先创建一个额外的列表。 对于小型列表可能没什么关系，但是如果元素数量非常大的时候， 它会创建一个巨大的仅仅被使用一次就被丢弃的临时数据结构。而生成器方案会以迭代的方式转换数据，因此更省内存。<br>
在使用一些聚集函数比如 <code>min()</code> 和 <code>max()</code> 的时候你可能更加倾向于使用生成器版本， 它们接受的一个 <code>key</code> 关键字参数或许对你很有帮助。 比如，在上面的证券例子中，你可能会考虑下面的实现版本：</p>
<pre><code class="language-python"># Original: Returns 20
min_shares = min(s['shares'] for s in portfolio)
# Alternative: Returns {'name': 'AOL', 'shares': 20}
min_shares = min(portfolio, key=lambda s: s['shares'])
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python笔记]]></title>
        <id>https://bailingnan.github.io/post/python-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/python-bi-ji/">
        </link>
        <updated>2020-03-22T07:24:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="python笔记"><code>Python</code>笔记</h1>
<!-- TOC -->
<ul>
<li><a href="#python%E7%AC%94%E8%AE%B0"><code>Python</code>笔记</a>
<ul>
<li><a href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">编码规范</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99">代码优化原则</a></li>
<li><a href="#%E5%AF%B9%E8%B1%A1">对象</a>
<ul>
<li><a href="#%E5%8F%AF%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1">可变与不可变对象</a></li>
<li><a href="#%E6%8B%B7%E8%B4%9D">拷贝</a></li>
<li><a href="#%E5%85%83%E7%BB%84">元组</a>
<ul>
<li><a href="#%E6%8B%86%E5%88%86%E5%85%83%E7%BB%84">拆分元组</a></li>
<li><a href="#tuple%E6%96%B9%E6%B3%95"><code>tuple</code>方法</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">常用函数</a></li>
</ul>
</li>
<li><a href="#%E5%88%97%E8%A1%A8">列表</a>
<ul>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0">添加和删除元素</a></li>
<li><a href="#%E4%B8%B2%E8%81%94%E5%92%8C%E7%BB%84%E5%90%88%E5%88%97%E8%A1%A8">串联和组合列表</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E5%92%8C%E7%BB%B4%E6%8A%A4%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8">二分搜索和维护已排序的列表</a></li>
<li><a href="#zip%E5%87%BD%E6%95%B0">zip函数</a></li>
<li><a href="#reversed%E5%87%BD%E6%95%B0"><code>reversed</code>函数</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8B%B7%E8%B4%9D">列表拷贝</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-1">常用函数</a></li>
<li><a href="#%E4%B8%B2%E8%81%94%E5%87%BD%E6%95%B0">串联函数</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a>
<ul>
<li><a href="#%E5%88%A0%E9%99%A4%E5%80%BC">删除值</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0%E5%AD%97%E5%85%B8">更新字典</a></li>
<li><a href="#%E7%94%A8%E5%BA%8F%E5%88%97%E5%88%9B%E5%BB%BA%E5%AD%97%E5%85%B8">用序列创建字典</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%80%BC">默认值</a></li>
<li><a href="#%E6%9C%89%E6%95%88%E7%9A%84%E9%94%AE%E7%B1%BB%E5%9E%8B">有效的键类型</a></li>
<li><a href="#%E6%8C%89%E9%94%AE%E5%80%BC%E6%8E%92%E5%BA%8F">按键值排序</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7">其他技巧</a>
<ul>
<li><a href="#argmin-%E5%92%8C-argmax"><code>argmin</code> 和 <code>argmax</code></a></li>
<li><a href="#%E8%BD%AC%E7%BD%AE%E4%BA%8C%E7%BB%B4%E5%88%97%E8%A1%A8">转置二维列表</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88">集合</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E9%9B%86%E5%90%88%E5%92%8C%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F">列表、集合和字典推导式</a>
<ul>
<li><a href="#%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F">嵌套列表推导式</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%8F%82%E6%95%B0">参数</a></li>
<li><a href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">默认参数</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">可变参数</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">关键字参数</a></li>
<li><a href="#%E5%91%BD%E5%90%8D%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0">命名关键字参数</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">强制位置参数</a></li>
<li><a href="#%E5%8F%82%E6%95%B0%E7%BB%84%E5%90%88">参数组合</a></li>
<li><a href="#%E5%8C%BF%E5%90%8Dlambda%E5%87%BD%E6%95%B0">匿名(lambda)函数</a></li>
<li><a href="#%E6%9F%AF%E9%87%8C%E5%8C%96%E9%83%A8%E5%88%86%E5%8F%82%E6%95%B0%E5%BA%94%E7%94%A8">柯里化：部分参数应用</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F">生成器表达式</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a>
<ul>
<li><a href="#%E7%B1%BB%E4%BD%9C%E4%B8%BA%E8%BF%AD%E4%BB%A3%E5%99%A8">类作为迭代器</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95">通过字符串调用对象方法</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>
<ul>
<li><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a>
<ul>
<li><a href="#map%E5%87%BD%E6%95%B0"><code>map</code>函数</a></li>
<li><a href="#reduce%E5%87%BD%E6%95%B0"><code>reduce</code>函数</a></li>
<li><a href="#filter%E5%87%BD%E6%95%B0"><code>filter</code>函数</a></li>
<li><a href="#sorted%E5%87%BD%E6%95%B0"><code>sorted</code>函数</a></li>
</ul>
</li>
<li><a href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0">返回函数</a>
<ul>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a></li>
</ul>
</li>
<li><a href="#%E8%A3%85%E9%A5%B0%E5%99%A8">装饰器</a>
<ul>
<li><a href="#property"><code>@property</code></a></li>
<li><a href="#classmethod"><code>@classmethod</code></a></li>
<li><a href="#staticmethod"><code>@staticmethod</code></a></li>
<li><a href="#dataclass"><code>@dataclass</code></a></li>
</ul>
</li>
<li><a href="#%E5%81%8F%E5%87%BD%E6%95%B0">偏函数</a></li>
</ul>
</li>
<li><a href="#itertools%E6%A8%A1%E5%9D%97"><code>itertools</code>模块</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a>
<ul>
<li><a href="#%E5%88%86%E5%89%B2">分割</a></li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E5%8C%96%E6%88%96%E6%A0%BC%E5%BC%8F%E5%8C%96">模板化或格式化</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">常用操作</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>
<ul>
<li><a href="#%E5%92%8Cis"><code>==</code>和<code>is</code></a></li>
<li><a href="#any%E5%92%8Call"><code>any()</code>和<code>all()</code></a></li>
<li><a href="#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6">十进制转二进制</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B">判断类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a>
<ul>
<li><a href="#name%E5%B1%9E%E6%80%A7"><code>name</code>属性</a>
<ul>
<li><a href="#%E5%8C%85">包</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oop">OOP</a>
<ul>
<li><a href="#__new__%E5%92%8C__init__%E5%8C%BA%E5%88%AB"><code>__new__</code>和<code>__init__</code>区别</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6">访问限制</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81">继承和多态</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF">获取对象信息</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8type">使用<code>type()</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8isinstance">使用<code>isinstance()</code></a></li>
<li><a href="#%E4%BD%BF%E7%94%A8dir">使用<code>dir()</code></a></li>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7">实例属性和类属性</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8__slots__">使用<code>__slots__</code></a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C">实现比较操作</a></li>
</ul>
</li>
<li><a href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB">枚举类</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%85%83%E7%B1%BB">使用元类</a></li>
</ul>
</li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96">序列化</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E5%87%86%E5%BA%93">标准库</a>
<ul>
<li><a href="#collections"><code>collections</code></a>
<ul>
<li><a href="#namedtuple"><code>namedtuple</code></a></li>
<li><a href="#deque"><code>deque</code></a></li>
<li><a href="#defaultdict"><code>defaultdict</code></a></li>
<li><a href="#ordereddict"><code>OrderedDict</code></a></li>
<li><a href="#chainmap"><code>ChainMap</code></a></li>
<li><a href="#counter"><code>Counter</code></a></li>
</ul>
</li>
<li><a href="#heapq"><code>heapq</code></a></li>
<li><a href="#bisect"><code>bisect</code></a></li>
<li><a href="#itertools"><code>itertools</code></a></li>
<li><a href="#functools"><code>functools</code></a></li>
<li><a href="#math"><code>math</code></a></li>
<li><a href="#time"><code>time</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="编码规范">编码规范</h2>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318181309.png" alt="" loading="lazy"></figure>
<h2 id="代码优化原则">代码优化原则</h2>
<ul>
<li>专注于优化产生性能瓶颈的地方，而不是全部代码。</li>
<li>避免使用全局变量。局部变量的查找比全局变量更快，将全局变量的代码定义在函数中运行通常会快 15%-30%。</li>
<li>避免使用<code>.</code>访问属性。使用 <code>from module import name</code> 会更快，将频繁访问的类的成员变量 <code>self.member</code> 放入到一个局部变量中。</li>
<li>尽量使用内置数据结构。<code>str</code>, <code>list</code>, <code>set</code>, <code>dict</code> 等使用 <code>C</code> 实现，运行起来很快。</li>
<li>避免创建没有必要的中间变量，和 <code>copy.deepcopy()</code>。</li>
<li>字符串拼接，例如 <code>a + ':' + b + ':' + c</code> 会创造大量无用的中间变量，<code>':',join([a, b, c])</code> 效率会高不少。另外需要考虑字符串拼接是否必要，例如 <code>print(':'.join([a, b, c]))</code> 效率比 <code>print(a, b, c, sep=':')</code> 低。</li>
<li>多个<code>if elif</code>条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率。</li>
</ul>
<h2 id="对象">对象</h2>
<h3 id="可变与不可变对象">可变与不可变对象</h3>
<ul>
<li><code>Python</code>中的大多数对象，比如列表、字典、<code>NumPy</code>数组，和用户定义的类型（类），都是可变的。意味着这些对象或包含的值可以被修改。</li>
<li>字符串和元组，是不可变的。</li>
</ul>
<pre><code class="language-Python">a= 'abc'
b = a.replace('a', 'A')
print(b)
'Abc'
</code></pre>
<p>要始终牢记的是，<code>a</code>是变量，而<code>'abc'</code>才是字符串对象，有些时候，我们经常说，对象<code>a</code>的内容是<code>'abc'</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>'abc'</code>：<br>
当我们调用<code>a.replace('a', 'A')</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>'abc'</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>'abc'</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>'Abc'</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>'abc'</code>，但变量<code>b</code>却指向新字符串<code>'Abc'</code>了。<br>
所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>
<ul>
<li>变量可以连续赋值:</li>
</ul>
<pre><code class="language-Python">a=b=c=1
</code></pre>
<h3 id="拷贝">拷贝</h3>
<ul>
<li>简单的赋值只是将引用传给新对象，新旧对象除变量名外毫无区别</li>
<li>由于 <code>Python</code> 内部引用计数的特性，对于不可变对象，浅拷贝和深拷贝的作用是一致的，就相当于复制了一份副本，原对象内部的不可变对象的改变，不会影响到复制对象</li>
<li>浅拷贝的拷贝。其实是拷贝了原始元素的引用（内存地址），所以当拷贝可变对象时，原对象内可变对象的对应元素的改变，会在复制对象的对应元素上，有所体现</li>
<li>深拷贝在遇到可变对象时，又在内部做了新建了一个副本。所以，不管它内部的元素如何变化，都不会影响到原来副本的可变对象</li>
<li>如果对子对象修改，则浅拷贝后的结果也会跟着发生变化，而深拷贝则不会。他们的子对象还是指向统一对象（是引用）。<code>list</code>的<code>a=b[:]</code>相当于<code>copy()</code></li>
<li>如果对父对象修改，则不管是浅拷贝还是深拷贝的结果，都不会跟着发生变化。</li>
<li>不管对什么对象修改，指针引用后的结果都会跟着发生相同变化。<br>
标准库中的<code>copy</code>模块提供了两个方法来实现拷贝.一个方法是<code>copy</code>,它返回和参数包含内容一样的对象.</li>
</ul>
<pre><code class="language-Python">import copy
new_list = copy.copy(existing_list)
</code></pre>
<p>有些时候,你希望对象中的属性也被复制,可以使用<code>deepcopy</code>方法:</p>
<pre><code class="language-Python">import copy
new_list_of_dicts = copy.deepcopy(existing_list_of_dicts)
</code></pre>
<p>当你对一个对象赋值的时候(做为参数传递,或者做为返回值),<code>Python</code>和<code>Java</code>一样,总是传递原始对象的引用,而不是一个副本.其它一些语言当赋值的时候总是传递副本,<code>Python</code>从不猜测用户的需求 ,如果你想要一个副本,你必须显式的要求.<br>
<code>Python</code>的行为很简单,迅速,而且一致.然而,如果你需要一个对象拷贝而并没有显式的写出来,会出现问题的,比如:</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
print(id(a)==id(b))
True
b.append(5)
print(a,b) 
[1, 2, 3, 5] [1, 2, 3, 5]
</code></pre>
<p>在这里,变量<code>a</code>和<code>b</code>都指向同一个对象(一个列表),所以,一旦你修改了二者之一,另外一个也会受到影响.无论怎样,都会修改原来的对象。</p>
<pre><code class="language-Python">import copy
c=copy.copy(a)
print(id(c)==id(a))
False
c[1]=222
print(c)
[1,222,3,5]
print(a)
[1,2,3,5]
a=[1,2,[3,4]]
d=copy.copy(a)
print(id(a)==id(d))
False
print(id(a[2])==id(d[2]))
True
a[0]=11
print(a)
[11,2,[3,4]]
print(d)
[1,2,[3,4]]
# 只会复制值的第一层，而不会复制往下的几层数据。
# 复杂的 object， 如 list 中套着 list 的情况，shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。这跟我们直觉上对「复制」的理解不同。
a[2][0]=333
print(d)
[1,2,[333,4]]
e=copy.deepcopy(a)
print(e[2]==a[2])
False
</code></pre>
<p>这种情况就不一样了，这是对<code>a</code>重新指向新的值那么其<code>id</code>就会变而此时<code>b</code>就不会变。</p>
<pre><code class="language-Python">a = [1,2,3]
b = a
print(id(b))
a = {1:2}
print(id(a))
print(id(b))
print(b)
输出：
1998591409928
1998589307016
1998591409928
[1, 2, 3]
</code></pre>
<p>再举一个例子：</p>
<pre><code class="language-Python">import copy
a=[1,[1,2],3]
b=a
b
[1, [1, 2], 3]
id(a)
4549388120
id(b)
4549388120
b[0]=3
a
[3, [1, 2], 3]
c=copy.copy(a)
id(c)
4549389992
id(a)
4549388120
c[0]=4
a
[3, [1, 2], 3]
c
[4, [1, 2], 3]
c[1].append(3)
a
[3, [1, 2, 3], 3]
c
[4, [1, 2, 3], 3]
id(a[2])
140345184649736
id(c[2])
140345184649736
id(c[1])
4549388192
id(a[1])
4549388192
d=copy.deepcopy(a)
id(d)
4549389632
id(a)
4549388120
d[1].append(4)
a
[3, [1, 2, 3], 3]
d
[3, [1, 2, 3, 4], 3]
</code></pre>
<p><code>Python</code> 存储变量的方法跟其他 <code>OOP</code> 语言不同。它与其说是把值赋给变量，不如说是给变量建立了一个到具体值的 <code>reference</code>。<br>
当在 <code>Python</code> 中 <code>a = something</code> 应该理解为给 <code>something</code> 贴上了一个标签 <code>a</code>。当再赋值给 <code>a</code> 的时候，就好像把 <code>a</code> 这个标签从原来的 <code>something</code> 上拿下来，贴到其他对象上，建立新的 <code>reference</code>。 这就解释了一些 <code>Python</code> 中可能遇到的诡异情况：</p>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
a = [4, 5, 6] # 赋新的值给 a
a
[4, 5, 6]
b
[1, 2, 3]
# a 的值改变后，b 并没有随着 a 变
a = [1, 2, 3]
b = a
a[0], a[1], a[2] = 4, 5, 6 # 改变原来 list 中的元素
a
[4, 5, 6]
b
[4, 5, 6]
# a 的值改变后，b 随着 a 变了
</code></pre>
<p>上面两段代码中，<code>a</code> 的值都发生了变化。区别在于，第一段代码中是直接赋给了 <code>a</code> 新的值(从 <code>[1, 2, 3]</code> 变为 <code>[4, 5, 6]</code>)；而第二段则是把 <code>list</code> 中每个元素分别改变。<br>
首次把 <code>[1, 2, 3]</code> 看成一个物品。<code>a = [1, 2, 3]</code> 就相当于给这个物品上贴上 <code>a</code> 这个标签。而 <code>b = a</code> 就是给这个物品又贴上了一个 <code>b</code> 的标签。<br>
<code>a = [4, 5, 6]</code> 就相当于把 <code>a</code> 标签从 <code>[1 ,2, 3]</code> 上撕下来，贴到了 <code>[4, 5, 6]</code> 上。<br>
在这个过程中，<code>[1, 2, 3]</code> 这个物品并没有消失。 <code>b</code>自始至终都好好的贴在 <code>[1, 2, 3]</code> 上，既然这个 <code>reference</code> 也没有改变过。 <code>b</code> 的值自然不变。<br>
第二种情况：<br>
<code>a[0], a[1], a[2] = 4, 5, 6</code>则是直接改变了 <code>[1, 2, 3]</code> 这个物品本身。把它内部的每一部分都重新改装了一下。内部改装完毕后，<code>[1, 2, 3]</code> 本身变成了 <code>[4, 5, 6]</code>。<br>
而在此过程当中，<code>a</code> 和 <code>b</code> 都没有动，他们还贴在那个物品上。因此自然 <code>a</code>,<code>b</code> 的值都变成了 <code>[4, 5, 6]</code>。<br>
搞明白这个之后就要问了，对于一个复杂对象的浅<code>copy</code>，在<code>copy</code>的时候到底发生了什么？<br>
再看一段代码：</p>
<pre><code class="language-Python">import copy
origin = [1, 2, [3, 4]]
#origin 里边有三个元素：1， 2，[3, 4]
cop1 = copy.copy(origin)
cop2 = copy.deepcopy(origin)
cop1 == cop2
True
cop1 is cop2
False 
#cop1 和 cop2 看上去相同，但已不再是同一个object
origin[2][0] = &quot;hey!&quot; 
origin
[1, 2, ['hey!', 4]]
cop1
[1, 2, ['hey!', 4]]
cop2
[1, 2, [3, 4]]
#把origin内的子list [3, 4] 改掉了一个元素，观察 cop1 和 cop2
</code></pre>
<p><code>copy</code>对于一个复杂对象的子对象并不会完全复制，什么是复杂对象的子对象呢？就比如序列里的嵌套序列，字典里的嵌套序列等都是复杂对象的子对象。对于子对象，<code>Python</code>会把它当作一个公共镜像存储起来，所有对他的复制都被当成一个引用，所以说当其中一个引用将镜像改变了之后另一个引用使用镜像的时候镜像已经被改变了。<br>
所以说看这里的<code>origin[2]</code>，也就是 <code>[3, 4]</code> 这个 <code>list</code>。根据 <code>shallow copy</code> 的定义，在 <code>cop1[2]</code> 指向的是同一个 <code>list [3, 4]</code>。那么，如果这里我们改变了这个 <code>list</code>，就会导致 <code>origin</code> 和 <code>cop1</code> 同时改变。这就是为什么上边 <code>origin[2][0] = “hey!”</code>之后，cop1 也随之变成了 <code>[1, 2, [‘hey!’, 4]]</code>。<br>
<code>deepcopy</code>的时候会将复杂对象的每一层复制一个单独的个体出来。<br>
这时候的 <code>origin[2]</code> 和 <code>cop2[2]</code> 虽然值都等于 <code>[3, 4]</code>，但已经不是同一个 <code>list了</code>。即我们寻常意义上的复制。<br>
总结：</p>
<pre><code class="language-Python">lst = [10, ['A']]

# 指针引用: 不拷贝
a = lst
assert a is lst

# 浅拷贝: 只拷贝 父对象，不会拷贝 子对象
import copy
b = copy.copy(lst)
assert b is not lst and b == lst

# 深拷贝: 拷贝 父对象 及 子对象
c = copy.deepcopy(lst)
assert c is not lst and c == lst

# 修改 list 对象
lst.append(5)
lst[1].append('B')

print(&quot;原始的list对象:  lst =  [10, ['A']]&quot;)
print('修改后list对象:  lst = ', a, '\n')
print('指针引用:  a = ', a)
print('浅拷贝  :  b = ', b)
print('深拷贝  :  c = ', c)
原始的list对象:  lst =  [10, ['A']]
修改后list对象:  lst =  [10, ['A', 'B'], 5] 

指针引用:  a =  [10, ['A', 'B'], 5]
浅拷贝  :  b =  [10, ['A', 'B']]
深拷贝  :  c =  [10, ['A']]
</code></pre>
<p>即:</p>
<ul>
<li>如果对子对象修改，则浅拷贝后的结果也会跟着发生变化，而深拷贝则不会。<code>list</code>的<code>a=b[:]</code>相当于<code>copy()</code></li>
<li>如果对父对象修改，则不管是浅拷贝还是深拷贝的结果，都不会跟着发生变化。</li>
<li>不管对什么对象修改，指针引用后的结果都会跟着发生相同变化。<br>
举例：</li>
</ul>
<pre><code class="language-Python">import copy
base = ['a', 'b', 'c', 'd', 'e']
# 切片
bak1 = base[:]
print(&quot;bak1: &quot;, bak1)
# list工厂函数
bak2 = list(base)
print(&quot;bak2: &quot;, bak2)
# Python list对象的copy方法
bak3 = base.copy()
print(&quot;bak3: &quot;, bak3)
# copy模块的copy方法
bak4 = copy.copy(base)
print(&quot;bak4: &quot;, bak4)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">bak1:  ['a', 'b', 'c', 'd', 'e']
bak2:  ['a', 'b', 'c', 'd', 'e']
bak3:  ['a', 'b', 'c', 'd', 'e']
bak4:  ['a', 'b', 'c', 'd', 'e']
</code></pre>
<p>上面的代码使用了四种方式来对数据进行拷贝，这些方法都可以用来拷贝数据，结果都一样。</p>
<ul>
<li>切片<br>
需要拷贝的数据进行切片处理，返回的结果相当于拷贝了一份数据。</li>
<li>工厂方法<br>
使用 <code>Python</code> 的工厂函数 <code>list</code> 来拷贝数据。(<code>Python</code>的工厂函数是比较特殊的，即是类也是函数，关于工厂函数的理解可以另行扩展一下)<br>
拷贝列表时使用 <code>list</code>，如果拷贝字符串则将上面的 <code>list</code> 换成 <code>str</code> ，以此类推。</li>
<li>list对象的copy方法<br>
<code>Python</code> 中的 <code>list</code> 实现了 <code>copy</code> 方法，在拷贝列表时可以直接使用。这里需要注意，比如 <code>str</code> 没有实现 <code>copy</code> 方法，拷贝字符串时使用其他方法拷贝。</li>
<li><code>copy</code>模块的<code>copy</code>方法<br>
在 <code>Python</code> 标准库中有一个 <code>copy</code> 模块，可以使用 <code>copy</code> 模块的 <code>copy()</code> 方法来拷贝数据，<code>copy</code> 模块可以拷贝所有类型的数据。</li>
</ul>
<pre><code class="language-Python">import copy
son = ['Python', 'copy']
base = ['a', 'b', 'c', 'd', 'e', son]
bak1 = base[:]
print(&quot;bak1: &quot;, bak1)
bak2 = list(base)
print(&quot;bak2: &quot;, bak2)
bak3 = base.copy()
print(&quot;bak3: &quot;, bak3)
bak4 = copy.copy(base)
print(&quot;bak4: &quot;, bak4)
print('-' * 20, '分割线', '-' * 20)
son[0] = 'PYTHON'
son[1] = 'COPY'
print('base: ', base)
print(&quot;bak1: &quot;, bak1)
print(&quot;bak2: &quot;, bak2)
print(&quot;bak3: &quot;, bak3)
print(&quot;bak4: &quot;, bak4)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">bak1:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak2:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak3:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
bak4:  ['a', 'b', 'c', 'd', 'e', ['Python', 'copy']]
-------------------- 分割线 --------------------
base:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak1:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak2:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak3:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
bak4:  ['a', 'b', 'c', 'd', 'e', ['PYTHON', 'COPY']]
</code></pre>
<p>在实际工作中，数据的嵌套层数是很多的，通常会嵌套好几层。上面就在 <code>base</code> 列表中嵌套了一个 <code>son</code> 子列表。<br>
用上面的四种拷贝方法拷贝 <code>base</code> 列表，然后修改 <code>base</code> 列表中的子列表 <code>son</code> 。重新打印这几个列表，发现不仅 <code>base</code> 列表被修改了，拷贝的列表也全部被修改了。<br>
现在的需求是拷贝一份数据，修改一份保留一份，如果两份数据都被修改，是不符合需求的。<br>
上面的四种拷贝方法都被称为浅拷贝（相对深拷贝而言），浅拷贝 <code>Python</code> 中的可变对象，如果数据中嵌套了可变对象，修改嵌套的可变对象，所有拷贝的数据都会一起被修改。<br>
在 <code>Python</code> 中，所有的数据都是对象，无论是数字，字符串，元组，列表，字典，还是函数，类，甚至是模块。<br>
不可变对象：<br>
<code>int</code>, <code>str</code>, <code>tuple</code> 等类型的数据是不可变对象，不可变对象的特性是数据不可被修改。</p>
<pre><code class="language-Python">a = 'a'
print(id(a))
a = 'b'
print(id(a))
</code></pre>
<p>运行结果：</p>
<pre><code>1543912659912
1543912658232
</code></pre>
<p>如果对不可变对象修改，其实不是修改变量对象，而是重新创建一个同名的变量对象。可以通过 <code>id</code> 函数来判断，<code>id</code> 不一样就证明已经不是同一个变量了。<br>
可变对象：<br>
<code>list</code>， <code>set</code>，<code>dict</code> 等类型的数据是可变对象，相对于不可变对象而言，可变对象的数据可以被修改，修改之后还是同一个<code>id</code>。</p>
<pre><code class="language-Python">base = [1, 2, 3]
print(id(base))
base[0] = 100
print(base)
print(id(base))
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">2182371173000
[100, 2, 3]
2182371173000
</code></pre>
<p>对可变对象进行修改，修改后还是同一个对象，只是可变对象里面的元素指向了不同的数据，这种指向是通过引用的方式来实现的。<br>
上面的代码是对列表进行修改，如果对元组这样修改，代码会报错，就是因为可变对象和不可变对象的区别。<br>
在 <code>Python</code> 程序中，每个对象都会在内存中开辟一块空间来保存该对象，该对象在内存中所在位置的地址被称为引用。<br>
在编写代码时，定义的变量名实际是定义指向对象的地址引用名。<br>
我们定义一个列表时，变量名是列表的名字，这个名字指向内存中的一块空间。这个列表里有多个元素，表示这块内存空间中，保存着多个元素的引用。</p>
<ol>
<li>修改引用<br>
当修改列表的元素时，其实是修改列表中的引用。</li>
</ol>
<pre><code class="language-Python">list_a = [1, 2, 3]
list_a[2] = 30
print('list_a: ', list_a)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_a:  [1, 2, 30]
</code></pre>
<p>修改 <code>list_a</code> 中的第三个元素，其实是修改第三个元素的引用（这块内存指向的对象）。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323023647.png" alt="" loading="lazy"><br>
2. 引用传递（拷贝）<br>
当拷贝列表时，其实是拷贝列表中的引用。</p>
<pre><code class="language-Python">list_b = [1, 2, 3]
list_c = list_b.copy()
print('list_c: ', list_c)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_c:  [1, 2, 3]
</code></pre>
<p>拷贝 <code>list_b</code> 到 <code>list_c</code>，其实是给 <code>list_c</code> 新开辟一块内存，然后拷贝一份 <code>list_b</code> 的引用给 <code>list_c</code> ，并不是将 <code>list_b</code>指向的对象拷贝一份。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323023828.png" alt="" loading="lazy"><br>
这里不是将 <code>list_b</code> 赋值给 <code>list_c</code>，那样的结果是 <code>list_b</code> 指向 <code>[1, 2, 3]</code> ，<code>list_c</code> 指向 <code>list_b</code>，是引用关系，而不是拷贝关系。上面列举拷贝的方法时，没有将赋值列为拷贝方法，因为赋值是引用的传递，而不是拷贝。</p>
<ol>
<li>拷贝后修改引用（数据无嵌套）</li>
</ol>
<pre><code class="language-Python">import copy
list_b = [1, 2, 3]
list_c = copy.copy(list_b)
list_b[2] = 30
print('list_b: ', list_b)
print('list_c: ', list_c)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_b:  [1, 2, 30]
list_c:  [1, 2, 3]
</code></pre>
<p>使用 <code>copy.copy()</code> 方法拷贝 <code>list_b</code> 到 <code>list_c</code>，然后修改 <code>list_b</code> 中的引用关系，这样， <code>list_c</code> 不会被修改。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024031.png" alt="" loading="lazy"><br>
2. 嵌套列表的拷贝</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_e = copy.copy(list_d)
print('list_d: ', list_d)
print('list_e: ', list_e)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 3]]
list_e:  [1, [2, 3]]
</code></pre>
<p>对于嵌套的列表，拷贝 <code>list_d</code> 到 <code>list_e</code>，也是拷贝一份 <code>list_d</code> 的引用给 <code>list_e</code> ，与不嵌套的相同。<br>
这里需要特别注意，在浅拷贝嵌套的列表时，只会拷贝最上层的引用，对于子列表的引用，不会拷贝。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024211.png" alt="" loading="lazy"><br>
3. 拷贝的列表随原列表一起被修改</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_e = copy.copy(list_d)
list_d[1][1] = 30
print('list_d: ', list_d)
print('list_e: ', list_e)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 30]]
list_e:  [1, [2, 30]]
</code></pre>
<p>拷贝 <code>list_d</code> 到 <code>list_e</code>，由于没有拷贝子列表的引用 ，当修改子列时， <code>list_d</code> 和 <code>list_e</code> 都引用了子列表 <code>sub</code>，所以 <code>list_d</code> 和 <code>list_e</code>都会被修改。如下图：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024334.png" alt="" loading="lazy"><br>
拷贝数据后，修改其中一个，另一个也跟着被修改，原因就是浅拷贝中，只拷贝了最外层的引用。当修改内层的引用时，所有外层的引用不变，都会指向修改后的结果。<br>
两份数据都被修改，这就是浅拷贝中存在的问题，需要使用深拷贝来解决。<br>
4. 深拷贝保证数据不会被修改</p>
<pre><code class="language-Python">import copy
sub = [2, 3]
list_d = [1, sub]
list_f = copy.deepcopy(list_d)
list_d[1][1] = 30
print('list_d: ', list_d)
print('list_e: ', list_f)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Python">list_d:  [1, [2, 30]]
list_e:  [1, [2, 3]]
</code></pre>
<p>使用 <code>copy</code> 模块的 <code>deepcopy()</code> 方法，在拷贝数据时，会递归地拷贝数据中所有嵌套的引用。<br>
使用 <code>deepcopy()</code> 拷贝 <code>list_d</code> 到 <code>list_f</code> ，然后修改 <code>list_d</code> 中子列表的引用，不会对 <code>list_f</code> 产生影响，所以 <code>list_f</code> 不会被修改。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323024515.png" alt="" loading="lazy"></p>
<h3 id="元组">元组</h3>
<ul>
<li>如果要定义一个空的tuple，可以写成()：</li>
</ul>
<pre><code class="language-Python">t = ()
print(t)
()
</code></pre>
<ul>
<li>但是，要定义一个只有1个元素的<code>tuple</code>，如果这么定义：</li>
</ul>
<pre><code class="language-Python">t = (1)
print(t)
1
</code></pre>
<p>定义的不是<code>tuple</code>，是<code>1</code>这个数！这是因为括号()既可以表示<code>tuple</code>，又可以表示数学公式中的小括号，这就产生了歧义，因此，<code>Python</code>规定，这种情况下，按小括号进行计算，计算结果自然是1。<br>
所以，只有1个元素的<code>tuple</code>定义时必须加一个逗号,，来消除歧义：</p>
<pre><code class="language-Python">t = (1,)
print(t）
(1,)
</code></pre>
<p><code>Python</code>在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。</p>
<ul>
<li>如果元组中的某个对象是可变的，比如列表，可以在原位进行修改：</li>
</ul>
<pre><code class="language-Python">tup = tuple(['foo', [1, 2], True])
tup[1].append(3)
print(tup)
('foo', [1, 2, 3], True)
</code></pre>
<h4 id="拆分元组">拆分元组</h4>
<ul>
<li>使用特殊的语法<code>*rest</code>，函数签名中以抓取任意长度列表的位置参数：</li>
</ul>
<pre><code class="language-Python">values = 1, 2, 3, 4, 5
a, b, *rest = values
print(a, b)
(1, 2)
print(rest)
[3, 4, 5]
</code></pre>
<ul>
<li><code>rest</code>的部分是想要舍弃的部分:</li>
</ul>
<pre><code class="language-Python">a, b, *_ = values
</code></pre>
<h4 id="tuple方法"><code>tuple</code>方法</h4>
<ul>
<li>统计值出现频率：</li>
</ul>
<pre><code class="language-Python">a = (1, 2, 2, 2, 3, 4, 2)
print(a.count(2))
4
</code></pre>
<h4 id="常用函数">常用函数</h4>
<ul>
<li><code>len(tuple)</code>:计算元组元素个数。</li>
<li><code>max(tuple)</code>:返回元组中元素最大值。</li>
<li><code>min(tuple)</code>:返回元组中元素最小值。</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="添加和删除元素">添加和删除元素</h4>
<ul>
<li><code>insert</code>在特定的位置插入元素：</li>
</ul>
<pre><code class="language-Python">b_list=['foo', 'bar', 'baz']
b_list.insert(1, 'red')
print(b_list)
['foo', 'red', 'peekaboo', 'baz', 'dwarf']
</code></pre>
<p>与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，使用<code>collections.deque</code>，一个双尾部队列。</p>
<ul>
<li><code>insert</code>的逆运算是<code>pop</code>，它移除并返回指定位置的元素,<code>pop()</code>默认删除最后一个元素：</li>
</ul>
<pre><code class="language-Python">print(b_list.pop(2))
'peekaboo'
print(b_list)
['foo', 'red', 'baz', 'dwarf']
</code></pre>
<ul>
<li><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去：</li>
</ul>
<pre><code class="language-Python">b_list.append('foo')
print(b_list)
['foo', 'red', 'baz', 'dwarf', 'foo']
b_list.remove('foo')
print(b_list)
['red', 'baz', 'dwarf', 'foo']
</code></pre>
<h4 id="串联和组合列表">串联和组合列表</h4>
<ul>
<li>可以用加号将两个列表串联起来,如果已经定义了一个列表，用<code>extend</code>方法可以追加多个元素：</li>
</ul>
<pre><code class="language-Python">x = [4, None, 'foo']
x.extend([7, 8, (2, 3)])
print(x)
[4, None, 'foo', 7, 8, (2, 3)]
</code></pre>
<ul>
<li>通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用<code>extend</code>追加元素，尤其是到一个大列表中，更为可取。因此：</li>
</ul>
<pre><code class="language-Python">#快
everything = []
for chunk in list_of_lists:
    everything.extend(chunk)
#慢
everything = []
for chunk in list_of_lists:
    everything = everything + chunk
</code></pre>
<p>考虑下列代码片段：</p>
<pre><code class="language-Python">list = [ [ ] ] * 5
list  # output?
list[0].append(10)
list  # output?
list[1].append(20)
list  # output?
list.append(30)
list  # output?
</code></pre>
<p>2,4,6,8行将输出什么结果？试解释。<br>
输出的结果如下：</p>
<pre><code class="language-Python">[[], [], [], [], []]
[[10], [10], [10], [10], [10]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]
</code></pre>
<p>解释如下：<br>
第一行的输出结果直觉上很容易理解，例如 <code>list = [ [ ] ] * 5</code> 就是简单的创造了5个空列表。然而，理解表达式<code>list=[ [ ] ] * 5</code>的关键一点是它不是创造一个包含五个独立列表的列表，而是它是一个创建了包含对同一个列表五次引用的列表。只有了解了这一点，我们才能更好的理解接下来的输出结果。<br>
<code>list[0].append(10)</code> 将10附加在第一个列表上。<br>
但由于所有5个列表是引用的同一个列表，所以这个结果将是：</p>
<pre><code class="language-Python">[[10], [10], [10], [10], [10]]
</code></pre>
<p>同理，<code>list[1].append(20)</code>将20附加在第二个列表上。但同样由于5个列表是引用的同一个列表，所以输出结果现在是：</p>
<pre><code class="language-Python">[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20]]
</code></pre>
<p>作为对比， <code>list.append(30)</code>是将整个新的元素附加在外列表上，因此产生的结果是： <code>[[10, 20], [10, 20], [10, 20], [10, 20], [10, 20], 30]</code>。</p>
<h4 id="排序">排序</h4>
<ul>
<li><code>sort</code>函数将一个列表原地排序（不创建新的对象）</li>
</ul>
<pre><code class="language-Python">a = [7, 2, 5, 1, 3]
a.sort()
print(a)
[1, 2, 3, 5, 7]
</code></pre>
<ul>
<li><code>sort</code>有一些选项，有时会很好用。其中之一是二级排序<code>key</code>，可以用这个<code>key</code>进行排序。例如，我们可以按长度对字符串进行排序：</li>
</ul>
<pre><code class="language-Python">b = ['saw', 'small', 'He', 'foxes', 'six']
b.sort(key=len)
print(b)
['He', 'saw', 'six', 'small', 'foxes']
</code></pre>
<h4 id="二分搜索和维护已排序的列表">二分搜索和维护已排序的列表</h4>
<ul>
<li><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。<code>bisect.bisect</code>可以找到插入值后仍保证排序的位置，<code>bisect.insort</code>是向这个位置插入值:</li>
</ul>
<pre><code class="language-Python">import bisect
c = [1, 2, 2, 2, 3, 4, 7]
print(bisect.bisect(c, 2))
4
print(bisect.bisect(c, 5))
6
print(bisect.insort(c, 6))
print(c)
[1, 2, 2, 2, 3, 4, 6, 7]
</code></pre>
<h4 id="zip函数">zip函数</h4>
<ul>
<li><code>zip</code>可以将多个列表、元组或其它序列成对组合成一个元组列表：</li>
</ul>
<pre><code class="language-Python">seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zipped = zip(seq1, seq2)
print(list(zipped))
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
</code></pre>
<ul>
<li><code>zip</code>可以处理任意多的序列，元素的个数取决于最短的序列：</li>
</ul>
<pre><code class="language-Python">seq3 = [False, True]
print(list(zip(seq1, seq2, seq3)))
[('foo', 'one', False), ('bar', 'two', True)]
</code></pre>
<ul>
<li><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</li>
</ul>
<pre><code class="language-Python">for i, (a, b) in enumerate(zip(seq1, seq2)):
    print('{0}: {1}, {2}'.format(i, a, b))
0: foo, one
1: bar, two
2: baz, three
</code></pre>
<ul>
<li>给出一个“被压缩的”序列，<code>zip</code>可以被用来解压序列。也可以当作把行的列表转换为列的列表。</li>
</ul>
<pre><code class="language-Python">pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens'),('Schilling', 'Curt')]
first_names, last_names = zip(*pitchers)
print(first_names)
('Nolan', 'Roger', 'Schilling')
print(last_names)
('Ryan', 'Clemens', 'Curt')
</code></pre>
<h4 id="reversed函数"><code>reversed</code>函数</h4>
<p><code>reversed</code>是一个生成器（后面详细介绍），只有实体化（即列表或<code>for</code>循环）之后才能创建翻转的序列。</p>
<pre><code class="language-Python">print(list(reversed(range(10))))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
</code></pre>
<h4 id="列表拷贝">列表拷贝</h4>
<ul>
<li><code>b=a[:]</code>。</li>
<li><code>b=list(a)</code>。</li>
<li>使用<code>copy.copy()</code>函数，或<code>b=a.copy()</code>直接复制<code>list</code>，类似<code>a[:]</code>。</li>
<li>使用<code>copy.deepcopy()</code>。<br>
使用<code>b=a</code>是完全引用，除了名字没区别</li>
</ul>
<h4 id="常用函数-2">常用函数</h4>
<ul>
<li><code>max(list)</code>:返回列表元素最大值</li>
<li><code>min(list)</code>:返回列表元素最小值</li>
<li><code>list.count(obj)</code>:统计某个元素在列表中出现的次数</li>
<li><code>list.extend(seq)</code>:在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li>
<li><code>list.index(obj)</code>:从列表中找出某个值第一个匹配项的索引位置</li>
<li><code>list.reverse()</code>:反向列表中元素</li>
</ul>
<h4 id="串联函数">串联函数</h4>
<pre><code class="language-Python">操作函数对象
def f():
    print('i\'m f')
def g():
    print('i\'m g')
[f,g][1]()
i'm g
</code></pre>
<h3 id="字典">字典</h3>
<ul>
<li>多种构造方法:</li>
</ul>
<pre><code class="language-Python">a = dict(one=1, two=2, three=3)
b = {'one':1, 'two':2, 'three':3}
c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
d = dict([('one', 1), ('two', 2), ('three', 3)])
e = dict({'three':3, 'one':1, 'two':2})
print(a)
print(b)
print(c)
print(d)
print(e)
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'one': 1, 'two': 2, 'three': 3}
&gt;&gt;&gt;{'three': 3, 'one': 1, 'two': 2}
print(a==b==c==d==e)
&gt;&gt;&gt;True
</code></pre>
<p>特别注意这种构造方法：</p>
<pre><code class="language-Python">t = {x:y for x in range(10) for y in range(10)}
print(t)
{0: 9, 1: 9, 2: 9, 3: 9, 4: 9, 5: 9, 6: 9, 7: 9, 8: 9, 9: 9}
</code></pre>
<pre><code class="language-Python">d = dict(name='Bob', age=20, score=88)
</code></pre>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-Python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个<code>Python</code>命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-Python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
print(d)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-Python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。<br>
要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-Python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<h4 id="删除值">删除值</h4>
<ul>
<li>用<code>del</code>关键字或<code>pop</code>方法（返回值的同时删除键）删除值：</li>
</ul>
<pre><code class="language-Python">d1={'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer',5: 'some value','dummy': 'another value'}
del d1[5]
print(d1)
{'a': 'some value',
 'b': [1, 2, 3, 4],
 7: 'an integer',
 'dummy': 'another value'}
ret = d1.pop('dummy')
print(ret)
'another value'
print(d1)
{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}
</code></pre>
<ul>
<li><code>popitem()</code>:返回并删除字典中的最后一对键和值。</li>
</ul>
<h4 id="更新字典">更新字典</h4>
<ul>
<li>用<code>update</code>方法可以将一个字典与另一个融合,<code>update</code>方法是原地改变字典，因此任何传递给<code>update</code>的键的旧的值都会被舍弃。</li>
</ul>
<pre><code class="language-Python">d1.update({'b' : 'foo', 'c' : 12})
print(d1)
{'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}
</code></pre>
<h4 id="用序列创建字典">用序列创建字典</h4>
<pre><code class="language-Python">mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value
</code></pre>
<ul>
<li>因为字典本质上是2元元组的集合，<code>dict</code>可以接受2元元组的列表：</li>
</ul>
<pre><code class="language-Python">mapping = dict(zip(range(5), reversed(range(5))))
print(mapping)
{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}
</code></pre>
<h4 id="默认值">默认值</h4>
<pre><code class="language-Python">if key in some_dict:
    value = some_dict[key]
else:
    value = default_value
</code></pre>
<ul>
<li><code>dict</code>的方法<code>get</code>和<code>pop</code>可以取默认值进行返回，上面的<code>if-else</code>语句可以简写成下面：</li>
</ul>
<pre><code class="language-Python">value = some_dict.get(key, default_value)
</code></pre>
<ul>
<li><code>get</code>默认会返回<code>None</code>，如果不存在键，<code>pop</code>会抛出一个例外。关于设定值，常见的情况是在字典的值是属于其它集合，如列表。例如，你可以通过首字母，将一个列表中的单词分类：</li>
</ul>
<pre><code class="language-Python">words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    if letter not in by_letter:
        by_letter[letter] = [word]
    else:
        by_letter[letter].append(word)
print(by_letter)
{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}
</code></pre>
<ul>
<li>使用<code>setdefault</code>方法：</li>
</ul>
<pre><code class="language-Python">for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)
</code></pre>
<ul>
<li><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</li>
</ul>
<pre><code class="language-Python">from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
    by_letter[word[0]].append(word)
</code></pre>
<p>给定以下字典的子类，下面的代码能够运行么？为什么？</p>
<pre><code class="language-Python">class DefaultDict(dict):
  def __missing__(self, key):
    return []
d = DefaultDict()
d['florp'] = 127
</code></pre>
<p>能够运行。<br>
当<code>key</code>缺失时，执行<code>DefaultDict</code>类，字典的实例将自动实例化这个数列。</p>
<h4 id="有效的键类型">有效的键类型</h4>
<ul>
<li>字典的值可以是任意<code>Python</code>对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为“可哈希性”。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</li>
</ul>
<pre><code class="language-Python">print(hash('string'))
5023931463650008331
print(hash((1, 2, (2, 3))))
1097636502276347782
print(hash((1, 2, [2, 3]))) # fails because lists are mutable
---------------------------------------------------------------------------
TypeError                                 
Traceback (most recent call last)
&lt;iPython-input-129-800cd14ba8be&gt; in &lt;module&gt;()
----&gt; 1 hash((1, 2, [2, 3])) # fails because lists are mutable
TypeError: unhashable type: 'list'
</code></pre>
<h4 id="按键值排序">按键值排序</h4>
<ul>
<li>键：</li>
</ul>
<pre><code class="language-Python">sorted(dict.keys())
</code></pre>
<ul>
<li>值：</li>
</ul>
<pre><code class="language-Python">sorted(dict.items(),key=lamda:item:item[1])
</code></pre>
<h4 id="其他技巧">其他技巧</h4>
<h5 id="argmin-和-argmax"><code>argmin</code> 和 <code>argmax</code></h5>
<pre><code class="language-python">items = [2, 1, 3, 4]
argmin = min(range(len(items)), key=items.__getitem__)
</code></pre>
<p><code>argmax</code>同理。</p>
<h5 id="转置二维列表">转置二维列表</h5>
<pre><code class="language-python">A = [['a11', 'a12'], ['a21', 'a22'], ['a31', 'a32']]
A_transpose = list(zip(*A))  # list of tuple
A_transpose = list(list(col) for col in zip(*A))  # list of list
</code></pre>
<h3 id="集合">集合</h3>
<ul>
<li>集合是无序的不可重复的元素的集合。你可以把它当做字典，但是只有键没有值。可以用两种方式创建集合：通过<code>set</code>函数或使用尖括号<code>set</code>语句：</li>
</ul>
<pre><code class="language-Python">print(set([2, 2, 2, 1, 3, 3]))
{1, 2, 3}
print({2, 2, 2, 1, 3, 3})
{1, 2, 3}
</code></pre>
<ul>
<li>花括号只能用于初始化包含值的集合。使用不包含值的花括号是初始化字典（<code>dict</code>）的方法之一，而不是初始化集合的方法。</li>
<li>通过<code>add(key)</code>方法可以添加元素到<code>set</code>中,只能将不可变的值（例如一个字符串或一个元组）加入到集合中。如果试图将一个列表（<code>list</code>）添加到集合中，系统会返回类型错误<code>TyprError</code>。</li>
<li>通过<code>remove(key)</code>方法可以删除元素,如果你想要删除一个集合中不存在的值，系统会返回一个键值错误<code>KeyError</code>。</li>
<li>可以使用<code>discard</code>方法从集合中删除一个值。这种方法相对于<code>remove</code>方法的好处是，如果你试图删除一个集合中不存在的值，系统不会返回<code>KeyError</code>。</li>
<li>合并是取两个集合中不重复的元素。可以用<code>union</code>方法，或者<code>|</code>运算符：</li>
</ul>
<pre><code class="language-Python">a = {1, 2, 3, 4, 5}
b = {3, 4, 5, 6, 7, 8}
print(a.union(b))
{1, 2, 3, 4, 5, 6, 7, 8}
print(a | b)
{1, 2, 3, 4, 5, 6, 7, 8}
</code></pre>
<ul>
<li>交集的元素包含在两个集合中。可以用<code>intersection</code>或<code>&amp;</code>运算符：</li>
</ul>
<pre><code class="language-Python">print(a.intersection(b))
{3, 4, 5}
print(a &amp; b)
{3, 4, 5}
</code></pre>
<ul>
<li>
<p>常用集合方法</p>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317202703.png" alt="" loading="lazy"><br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200329021757.png" alt="" loading="lazy"></p>
</li>
<li>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容。对于大的集合，这么做效率更高：</p>
</li>
</ul>
<pre><code class="language-Python">c = a.copy()
c |= b
print(c)
{1, 2, 3, 4, 5, 6, 7, 8}
d = a.copy()
d &amp;= b
print(d)
{3, 4, 5}
</code></pre>
<ul>
<li>检测一个集合是否是另一个集合的子集或父集：</li>
</ul>
<pre><code class="language-Python">a_set = {1, 2, 3, 4, 5}
print({1, 2, 3}.issubset(a_set))
True
print(a_set.issuperset({1, 2, 3}))
True
</code></pre>
<h3 id="列表-集合和字典推导式">列表、集合和字典推导式</h3>
<pre><code class="language-Python">[expr for val in collection if condition]
</code></pre>
<p>等同于：</p>
<pre><code class="language-Python">result = []
for val in collection:
    if condition:
        result.append(expr)
</code></pre>
<ul>
<li>字典:</li>
</ul>
<pre><code class="language-Python">dict_comp = {key-expr : value-expr for value in collection if condition}
</code></pre>
<ul>
<li>集合</li>
</ul>
<pre><code class="language-Python">set_comp = {expr for value in collection if condition}
</code></pre>
<ul>
<li><code>map</code>函数可以进一步简化：</li>
</ul>
<pre><code class="language-Python">print(set(map(len, strings)))
{1, 2, 3, 4, 6}
</code></pre>
<h4 id="嵌套列表推导式">嵌套列表推导式</h4>
<pre><code class="language-Python">all_data = [['John', 'Emily', 'Michael', 'Mary', 'Steven'],['Maria', 'Juan', 'Javier', 'Natalia', 'Pilar']]
names_of_interest = []
for names in all_data:
    enough_es = [name for name in names if name.count('e') &gt;= 2]
    names_of_interest.extend(enough_es)
</code></pre>
<p>嵌套列表推导式：</p>
<pre><code class="language-Python">result = [name for names in all_data for name in names if name.count('e') &gt;= 2]
print(result)
result=['Steven']
</code></pre>
<p>以下代码正常输出偶数：</p>
<pre><code class="language-Python">[x for x in range(1, 11) if x % 2 == 0]
[2, 4, 6, 8, 10]
</code></pre>
<p>但是，我们不能在最后的<code>if</code>加上<code>else</code>：</p>
<pre><code class="language-Python">[x for x in range(1, 11) if x % 2 == 0 else 0]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x for x in range(1, 11) if x % 2 == 0 else 0]
                                              ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件，不能带<code>else</code>，否则如何筛选？<br>
另一些童鞋发现把<code>if</code>写在<code>for</code>前面必须加<code>else</code>，否则报错：</p>
<pre><code class="language-Python">[x if x % 2 == 0 for x in range(1, 11)]
  File &quot;&lt;stdin&gt;&quot;, line 1
    [x if x % 2 == 0 for x in range(1, 11)]
                       ^
SyntaxError: invalid syntax
</code></pre>
<p>这是因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>:</p>
<pre><code class="language-Python">[x if x % 2 == 0 else -x for x in range(1, 11)]
[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]
</code></pre>
<p>上述for前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。<br>
可见，在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p>
<pre><code class="language-Python">print([[x for x in tup] for tup in some_tuples])
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
</code></pre>
<h3 id="函数">函数</h3>
<h4 id="参数">参数</h4>
<ul>
<li><code>Python</code>函数参数既不是传参也不是传引用。应该称其为传对象引用,如果是数字，字符串，元组则传值,如果是列表，字典则传址。对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。因此可以改变可变参数的内容:</li>
</ul>
<pre><code class="language-Python">def append_element(some_list, element):
    some_list.append(element)
data = [1, 2, 3]
append_element(data, 4)
print(data)
[1, 2, 3, 4]
</code></pre>
<pre><code class="language-Python">def func(d):
    d['a'] = 10
    d['b'] = 20            
    d = {'a': 1, 'b': 2}


d = {}                    # 1
func(d)                   # 2
print(d)
########打印结果########
{'a': 10, 'b': 20}
</code></pre>
<p>想一想, 最后的结果为什么还是<code>{'a': 10, 'b': 20}</code>?<br>
首先在全局创建一个空字典,并将<code>d</code>贴上:</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/v2-5d4d7a9c04d8feac54b3350d8c5b1435_1440w.jpg" alt="" loading="lazy"></figure>
<p>将 <code>d</code> 传入到函数<code>func</code>中,在函数中局部的形参变量也为<code>d</code>,它同样贴在空字典对象上</p>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174500.png" alt="" loading="lazy"></figure>
<p>在函数中前两句,为字典赋值.因为字典是可变的,这一操作对全局的 <code>d</code> 也会产生同样的影响.因为此时全局的<code>d</code>与函数内部的<code>d</code>贴向的是同一个对象</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174540.png" alt="" loading="lazy"></figure>
<p>函数最后一句,本质上是将函数内部的<code>d</code>贴向另外一个字典对象,全局的<code>d</code>当然还是贴向原来的字典对象.</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174823.png" alt="" loading="lazy"></figure>
<p>函数结束,函数内部的<code>d</code>被回收,而且最后打印结果如下所示</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200323174908.png" alt="" loading="lazy"></figure>
<ul>
<li>函数可以有一些位置参数(<code>positional</code>)和一些关键字参数(<code>keyword</code>)。关键字参数通常用于指定默认值或可选参数</li>
</ul>
<h4 id="默认参数">默认参数</h4>
<pre><code class="language-Python">i = 1
def test(a=i):
    print(a)

i = 2
test()  # 1
</code></pre>
<p>由于参数默认值是在函数定义时而不是函数执行时确定的，所以这段代码<code>test</code>方法的参数默认值时<code>1</code>而不是<code>2</code>。</p>
<pre><code class="language-Python">def add_end(L=[]):
    L.append('END')
    return L
print(add_end())
['END']
print(add_end())
['END', 'END']
</code></pre>
<ul>
<li>Python函数在定义的时候，默认参数L的值就被计算出来了，即<code>[]</code>，因为默认参数L也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。<br>
<strong>定义默认参数要牢记一点：默认参数必须指向不变对象！</strong></li>
<li>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</li>
</ul>
<pre><code class="language-Python">def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
</code></pre>
<p>举例：</p>
<pre><code class="language-Python">def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123,[])
list3 = extendList('a')

print &quot;list1 = %s&quot; % list1
print &quot;list2 = %s&quot; % list2
print &quot;list3 = %s&quot; % list3

list1 = [10, 'a']
list2 = [123]
list3 = [10, 'a']
</code></pre>
<p>很多人都会误认为<code>list1=[10]</code>，<code>list3=[‘a’]</code>,因为他们以为每次<code>extendList</code>被调用时，列表参数的默认值都将被设置为<code>[]</code>.但实际上的情况是，新的默认列表只在函数被定义的那一刻创建一次。<br>
当<code>extendList</code>被没有指定特定参数<code>list</code>调用时，这组<code>list</code>的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。因此<code>list1</code>和<code>list3</code>是在同一个默认列表上进行操作（计算）的。而<code>list2</code>是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。<br>
<code>extendList</code>的定义可以作如下修改。<br>
尽管，创建一个新的列表，没有特定的列表参数。<br>
下面这段代码可能能够产生想要的结果。</p>
<pre><code class="language-Python">def extendList(val, list=None):
  if list is None:
    list = []
  list.append(val)
  return list
</code></pre>
<p>通过上面的修改，输出结果将变成：</p>
<pre><code class="language-Python">list1 = [10]
list2 = [123]
list3 = ['a']
</code></pre>
<ul>
<li>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。<br>
默认参数的值应该是不可变的对象，比如<code>None</code>、<code>True</code>、<code>False</code>、数字或字符串。 特别的，千万不要像下面这样写代码：</li>
</ul>
<pre><code class="language-python">def spam(a, b=[]): # NO!
    ...
</code></pre>
<p>如果你这么做了，当默认值在其他地方被修改后你将会遇到各种麻烦。这些修改会影响到下次调用这个函数时的默认值。比如：</p>
<pre><code class="language-python">def spam(a, b=[]):
    print(b)
    return b
x = spam(1)
x
[]
x.append(99)
x.append('Yow!')
x
[99, 'Yow!']
spam(1) # Modified list gets returned!
[99, 'Yow!']
</code></pre>
<p>这种结果应该不是你想要的。为了避免这种情况的发生，最好是将默认值设为<code>None</code>， 然后在函数里面检查它，前面的例子就是这样做的。<br>
在测试<code>None</code>值时使用 <code>is</code> 操作符是很重要的，也是这种方案的关键点。 有时候大家会犯下下面这样的错误：</p>
<pre><code class="language-python">def spam(a, b=None):
    if not b: # NO! Use 'b is None' instead
        b = []
</code></pre>
<p>这么写的问题在于尽管<code>None</code>值确实是被当成<code>False</code>， 但是还有其他的对象(比如长度为<code>0</code>的字符串、列表、元组、字典等)都会被当做<code>False</code>。 因此，上面的代码会误将一些其他输入也当成是没有输入。比如：</p>
<pre><code class="language-python">spam(1) # OK
x = []
spam(1, x) # Silent error. x value overwritten by default
spam(1, 0) # Silent error. 0 ignored
spam(1, '') # Silent error. '' ignored
</code></pre>
<p>最后一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递进来。 这时候需要小心的是你不能用某个默认值比如<code>None</code>、 <code>0</code>或者<code>False</code>值来测试用户提供的值(因为这些值都是合法的值，是可能被用户传递进来的)。 因此，你需要其他的解决方案了。<br>
为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面的<code>_no_value</code>变量那样。 在函数里面，你可以通过检查被传递参数值跟这个实例是否一样来判断。 这里的思路是用户不可能去传递这个<code>_no_value</code>实例作为输入。 因此，这里通过检查这个值就能确定某个参数是否被传递进来了。<br>
这里对 <code>object()</code> 的使用看上去有点不太常见。<code>object</code> 是<code>python</code>中所有类的基类。 你可以创建 <code>object</code> 类的实例，但是这些实例没什么实际用处，因为它并没有任何有用的方法， 也没有任何实例数据(因为它没有任何的实例字典，你甚至都不能设置任何属性值)。 你唯一能做的就是测试同一性。这个刚好符合我的要求，因为我在函数中就只是需要一个同一性的测试而已。</p>
<h4 id="可变参数">可变参数</h4>
<pre><code class="language-Python">def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
</code></pre>
<p>定义可变参数和定义一个<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个<code>tuple</code>，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括<code>0</code>个参数。<br>
如果已经有一个<code>list</code>或者<code>tuple</code>：</p>
<pre><code class="language-Python">nums = [1, 2, 3]
print(calc(*nums))
14
</code></pre>
<h4 id="关键字参数">关键字参数</h4>
<ul>
<li>关键字参数允许你传入<code>0</code>个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</li>
</ul>
<pre><code class="language-Python">def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>函数<code>person</code>除了必选参数<code>name</code>和<code>age</code>外，还接受关键字参数<code>kw</code>。在调用该函数时，可以只传入必选参数：</li>
</ul>
<pre><code class="language-Python">person('Michael', 30)
name: Michael age: 30 other: {}
</code></pre>
<ul>
<li>也可以传入任意个数的关键字参数：</li>
</ul>
<pre><code class="language-Python">person('Bob', 35, city='Beijing')
name: Bob age: 35 other: {'city': 'Beijing'}
person('Adam', 45, gender='M', job='Engineer')
name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
</code></pre>
<p>关键字参数可以扩展函数的功能。比如，在<code>person</code>函数里，我们保证能接收到<code>name</code>和<code>age</code>这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。<br>
和可变参数类似，也可以先组装出一个<code>dict</code>，然后，把该<code>dict</code>转换为关键字参数传进去：</p>
<pre><code class="language-Python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, city=extra['city'], job=extra['job'])
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p>上面复杂的调用可以用简化的写法：</p>
<pre><code class="language-python">extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
</code></pre>
<p><code>**extra</code>表示把<code>extra</code>这个<code>dict</code>的所有<code>key-value</code>用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个<code>dict</code>，注意<code>kw</code>获得的<code>dict</code>是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p>
<h4 id="命名关键字参数">命名关键字参数</h4>
<ul>
<li>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。<br>
仍以<code>person()</code>函数为例，我们希望检查是否有<code>city</code>和<code>job</code>参数：</li>
</ul>
<pre><code class="language-Python">def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
    print('name:', name, 'age:', age, 'other:', kw)
</code></pre>
<ul>
<li>如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收<code>city</code>和<code>job</code>作为关键字参数。这种方式定义的函数如下：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *, city, job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>和关键字参数<code>**kw不同</code>，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。<br>
调用方式如下：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, city='Beijing', job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</li>
</ul>
<pre><code class="language-Python">def person(name, age, *args, city, job):
    print(name, age, args, city, job)
</code></pre>
<ul>
<li>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, 'Beijing', 'Engineer')
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: person() takes 2 positional arguments but 4 were given
</code></pre>
<ul>
<li>由于调用时缺少参数名<code>city</code>和<code>job</code>，<code>Python</code>解释器把这4个参数均视为位置参数，但<code>person()</code>函数仅接受2个位置参数。</li>
</ul>
<p>命名关键字参数可以有缺省值，从而简化调用：</p>
<pre><code class="language-Python">def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
</code></pre>
<ul>
<li>由于命名关键字参数<code>city</code>具有默认值，调用时，可不传入<code>city</code>参数：</li>
</ul>
<pre><code class="language-Python">person('Jack', 24, job='Engineer')
Jack 24 Beijing Engineer
</code></pre>
<ul>
<li>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，<code>Python</code>解释器将无法识别位置参数和命名关键字参数：</li>
</ul>
<pre><code class="language-Python">def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
</code></pre>
<h4 id="强制位置参数">强制位置参数</h4>
<p><code>Python3.8</code> 新增了一个函数形参语法<code>/</code>用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。<br>
在以下的例子中，形参 <code>a</code> 和 <code>b</code> 必须使用指定位置参数，<code>c</code> 或 <code>d</code> 可以是位置形参或关键字形参，而 <code>e</code> 或 <code>f</code> 要求为关键字形参:</p>
<pre><code class="language-Python">def f(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)
</code></pre>
<p>以下使用方法是正确的:</p>
<pre><code class="language-Python">f(10, 20, 30, d=40, e=50, f=60)
</code></pre>
<p>以下使用方法会发生错误:</p>
<pre><code class="language-Python">f(10, b=20, c=30, d=40, e=50, f=60)   # b 不能使用关键字参数的形式
f(10, 20, 30, 40, 50, f=60)           # e 必须使用关键字参数的形式
</code></pre>
<h4 id="参数组合">参数组合</h4>
<ul>
<li>在<code>Python</code>中定义函数，可以用<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>关键字参数</strong>和<strong>命名关键字参数</strong>，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：<strong>必选参数</strong>、<strong>默认参数</strong>、<strong>可变参数</strong>、<strong>命名关键字参数</strong>和<strong>关键字参数</strong>。</li>
</ul>
<pre><code class="language-Python">def f1(a, b, c=0, *args, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)

def f2(a, b, c=0, *, d, **kw):
    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)
</code></pre>
<ul>
<li>在函数调用的时候，<code>Python</code>解释器自动按照参数位置和参数名把对应的参数传进去。</li>
</ul>
<pre><code class="language-Python">f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
f1(1, 2, 3, 'a', 'b')
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}
f1(1, 2, 3, 'a', 'b', x=99)
a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}
f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}
</code></pre>
<ul>
<li>通过一个<code>tuple</code>和<code>dict</code>，你也可以调用上述函数：</li>
</ul>
<pre><code class="language-Python">args = (1, 2, 3, 4)
kw = {'d': 99, 'x': '#'}
f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}
args = (1, 2, 3)
kw = {'d': 88, 'x': '#'}
f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}
</code></pre>
<ul>
<li>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。<br>
<strong>虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。</strong></li>
<li>示例：<br>
<code>Python</code>五类参数：位置参数，关键字参数，默认参数，可变位置或关键字参数的使用。</li>
</ul>
<pre><code class="language-Python">def f(a,*b,c=10,**d):
  print(f'a:{a},b:{b},c:{c},d:{d}')
</code></pre>
<p>默认参数<code>c</code>不能位于可变关键字参数<code>d</code>后.<br>
调用<code>f</code>:</p>
<pre><code class="language-Python">f(1,2,5,width=10,height=20)
a:1,b:(2, 5),c:10,d:{'width': 10, 'height': 20}
</code></pre>
<p>可变位置参数<code>b</code>实参后被解析为元组<code>(2,5)</code>;而<code>c</code>取得默认值10; <code>d</code>被解析为字典.</p>
<p>再次调用<code>f</code>:</p>
<pre><code class="language-Python">f(a=1,c=12)
a:1,b:(),c:12,d:{}
</code></pre>
<p><code>a=1</code>传入时<code>a</code>就是关键字参数，<code>b</code>,<code>d</code>都未传值，<code>c</code>被传入12，而非默认值。<br>
注意观察参数<code>a</code>, 既可以<code>f(1)</code>,也可以<code>f(a=1)</code> 其可读性比第一种更好，建议使用<code>f(a=1)</code>。如果要强制使用<code>f(a=1)</code>，需要在前面添加一个星号:</p>
<pre><code class="language-Python">def f(*,a,*b):
  print(f'a:{a},b:{b}')
</code></pre>
<p>此时<code>f(1)</code>调用，将会报错：<code>TypeError: f() takes 0 positional arguments but 1 was given</code><br>
只能<code>f(a=1)</code>才能<code>OK</code>.</p>
<p>说明前面的<code>*</code>发挥作用，它变为只能传入关键字参数，那么如何查看这个参数的类型呢？借助<code>Python</code>的<code>inspect</code>模块：</p>
<pre><code class="language-Python">for name,val in signature(f).parameters.items():
    print(name,val.kind)
a KEYWORD_ONLY
b VAR_KEYWORD
</code></pre>
<p>可看到参数<code>a</code>的类型为<code>KEYWORD_ONLY</code>，也就是仅仅为关键字参数。<br>
但是，如果<code>f</code>定义为：</p>
<pre><code class="language-Python">def f(a,*b):
  print(f'a:{a},b:{b}')
</code></pre>
<p>查看参数类型：</p>
<pre><code class="language-python">for name,val in signature(f).parameters.items():
    print(name,val.kind)
a POSITIONAL_OR_KEYWORD
b VAR_POSITIONAL
</code></pre>
<p>可以看到参数<code>a</code>既可以是位置参数也可是关键字参数。</p>
<h4 id="匿名lambda函数">匿名(lambda)函数</h4>
<ul>
<li><code>lambda</code> 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li>
<li>虽然<code>lambda</code>函数看起来只能写一行，却不等同于<code>C</code>或<code>C++</code>的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<pre><code class="language-Python">strings = ['foo', 'card', 'bar', 'aaaa', 'abab']
strings.sort(key=lambda x: len(set(list(x))))
print(strings)
['aaaa', 'foo', 'abab', 'bar', 'card']
</code></pre>
<p>先看下下面代码的效果：</p>
<pre><code class="language-python">x = 10
a = lambda y: x + y
x = 20
b = lambda y: x + y
print(a(10),b(10))
</code></pre>
<p>现在我问你，<code>a(10)</code>和<code>b(10)</code>返回的结果是什么？如果你认为结果是<code>20</code>和<code>30</code>，那么你就错了：</p>
<pre><code class="language-python">a(10)
30
b(10)
30
</code></pre>
<p>这其中的奥妙在于<code>lambda</code>表达式中的<code>x</code>是一个自由变量， 在运行时绑定值，而不是定义时就绑定，这跟函数的默认值参数定义是不同的。 因此，在调用这个lambda表达式的时候，<code>x</code>的值是执行时的值。例如：</p>
<pre><code class="language-python">x = 15
a(10)
25
x = 3
a(10)
13
</code></pre>
<p>如果你想让某个匿名函数在定义时就捕获到值，可以将那个参数值定义成默认参数即可，就像下面这样：</p>
<pre><code class="language-python">x = 10
a = lambda y, x=x: x + y
x = 20
b = lambda y, x=x: x + y
a(10)
20
b(10)
30
</code></pre>
<p>在这里列出来的问题是新手很容易犯的错误，有些新手可能会不恰当的使用<code>lambda</code>表达式。 比如，通过在一个循环或列表推导中创建一个<code>lambda</code>表达式列表，并期望函数能在定义时就记住每次的迭代值。例如：</p>
<pre><code class="language-python">funcs = [lambda x: x+n for n in range(5)]
for f in funcs:
    print(f(0))
4
4
4
4
4
</code></pre>
<p>但是实际效果是运行是<code>n</code>的值为迭代的最后一个值。现在我们用另一种方式修改一下：</p>
<pre><code class="language-python">funcs = [lambda x, n=n: x+n for n in range(5)]
for f in funcs:
    print(f(0))
0
1
2
3
4
</code></pre>
<p>通过使用函数默认值参数形式，<code>lambda</code>函数在定义时就能绑定到值。</p>
<h4 id="柯里化部分参数应用">柯里化：部分参数应用</h4>
<ul>
<li>柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数:</li>
</ul>
<pre><code class="language-Python">def add_numbers(x, y):
    return x + y
add_five = lambda y: add_numbers(5, y)
</code></pre>
<p><code>add_numbers</code>的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的<code>functools</code>模块可以用<code>partial</code>函数将此过程简化：</p>
<pre><code class="language-Python">from functools import partial
add_five = partial(add_numbers, 5)
</code></pre>
<h4 id="生成器">生成器</h4>
<ul>
<li>能以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）是<code>Python</code>的一个重要特点。这是通过一种叫做迭代器协议(<code>iterator protocol</code>，它是一种使对象可迭代的通用方式)的方式实现的，一个原生的使对象可迭代的方法。</li>
<li>生成器(<code>generator</code>)是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的<code>return</code>替换为<code>yeild</code>即可：</li>
</ul>
<pre><code class="language-Python">def squares(n=10):
    print('Generating squares from 1 to {0}'.format(n ** 2))
    for i in range(1, n + 1):
        yield i ** 2
</code></pre>
<ul>
<li>调用该生成器时，没有任何代码会被立即执行：</li>
</ul>
<pre><code class="language-Python">gen = squares()
print(gen)
&lt;generator object squares at 0x7fbbd5ab4570&gt;
</code></pre>
<p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p>
<pre><code class="language-Python">for x in gen:
    print(x, end=' ')
Generating squares from 1 to 100
1 4 9 16 25 36 49 64 81 100
</code></pre>
<p>在一个对象上实现迭代最简单的方式是使用一个生成器函数。使用<code>Node</code>类来表示树形数据结构。你可能想实现一个以深度优先方式遍历树形节点的生成器。 下面是代码示例：</p>
<pre><code class="language-python">class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()
# Example
if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)
    '''
    Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
    '''
</code></pre>
<p>在这段代码中，<code>depth_first()</code> 方法简单直观。 它首先返回自己本身并迭代每一个子节点并通过调用子节点的 <code>depth_first()</code> 方法(使用 <code>yield from</code> 语句)返回对应元素。</p>
<h4 id="生成器表达式">生成器表达式</h4>
<p>另一种更简洁的构造生成器的方法是使用生成器表达式(<code>generator expression</code>)。这是一种类似于列表、字典、集合推导式的生成器。其创建方式为，把列表推导式两端的方括号改成圆括号：</p>
<pre><code class="language-Python">gen = (x ** 2 for x in range(100))
print(gen)
&lt;generator object &lt;genexpr&gt; at 0x7fbbd5ab29e8&gt;
</code></pre>
<p>它跟下面这个冗长得多的生成器是完全等价的：</p>
<pre><code class="language-Python">def _make_gen():
    for x in range(100):
        yield x ** 2
gen = _make_gen()
</code></pre>
<p>生成器表达式也可以取代列表推导式，作为函数参数：</p>
<pre><code class="language-Python">print(sum(x ** 2 for x in range(100)))
328350
print(dict((i, i **2) for i in range(5)))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
</code></pre>
<h4 id="迭代器">迭代器</h4>
<ul>
<li>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。<br>
可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</li>
</ul>
<pre><code class="language-Python">from collections.abc import Iterator
isinstance((x for x in range(10)), Iterator)
True
isinstance([], Iterator)
False
isinstance({}, Iterator)
False
isinstance('abc', Iterator)
False
</code></pre>
<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<pre><code class="language-Python">isinstance(iter([]), Iterator)
True
isinstance(iter('abc'), Iterator)
True
</code></pre>
<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？</p>
<p>这是因为<code>Python</code>的<code>Iterator</code>对象表示的是一个数据流，<code>Iterator</code>对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。<br>
<code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用<code>list</code>是永远不可能存储全体自然数的。</p>
<h5 id="类作为迭代器">类作为迭代器</h5>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法 <code>__iter__()</code> 与 <code>__next__()</code> 。<br>
如果你已经了解的面向对象编程，就知道类都有一个构造函数，<code>Python</code> 的构造函数为 <code>__init__()</code>, 它会在对象初始化的时候执行。<br>
<code>__iter__()</code> 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。<br>
<code>__next__()</code> 方法(<code>Python 2</code> 里是 <code>next()</code>)会返回下一个迭代器对象。<br>
创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<pre><code class="language-Python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    x = self.a
    self.a += 1
    return x
 
myclass = MyNumbers()
myiter = iter(myclass)
 
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
print(next(myiter))
1
2
3
4
5
</code></pre>
<p><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。<br>
在 20 次迭代后停止执行：</p>
<pre><code class="language-Python">class MyNumbers:
  def __iter__(self):
    self.a = 1
    return self
 
  def __next__(self):
    if self.a &lt;= 20:
      x = self.a
      self.a += 1
      return x
    else:
      raise StopIteration
 
myclass = MyNumbers()
myiter = iter(myclass)
for x in myiter:
  print(x)
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</code></pre>
<h5 id="通过字符串调用对象方法">通过字符串调用对象方法</h5>
<p>最简单的情况，可以使用 <code>getattr()</code> ：</p>
<pre><code class="language-python">import math
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Point({!r:},{!r:})'.format(self.x, self.y)

    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)

p = Point(2, 3)
d = getattr(p, 'distance')(0, 0)  # Calls p.distance(0, 0)
</code></pre>
<p>调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用。 因此，为了调用某个方法，你可以首先通过 <code>getattr()</code> 来查找到这个属性，然后再去以函数方式调用它即可。</p>
<h4 id="函数式编程">函数式编程</h4>
<h5 id="高阶函数">高阶函数</h5>
<h6 id="map函数"><code>map</code>函数</h6>
<ul>
<li><code>map()</code> 会根据提供的函数对指定序列做映射。第一个参数 <code>function</code> 以参数序列中的每一个元素调用 <code>function</code> 函数，返回包含每次 <code>function</code> 函数返回值的新列表。</li>
</ul>
<pre><code class="language-Python">map(function, iterable, ...)
</code></pre>
<ul>
<li><code>function</code>:函数</li>
<li><code>iterable</code>:一个或多个序列</li>
</ul>
<pre><code class="language-Python">def square(x) :            # 计算平方数
    return x ** 2
print(map(square, [1,2,3,4,5]))   # 计算列表各个元素的平方
[1, 4, 9, 16, 25]
print(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))  # 使用 lambda 匿名函数
[1, 4, 9, 16, 25]
# 提供了两个列表，对相同位置的列表数据进行相加
print(map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
[3, 7, 11, 15, 19]
</code></pre>
<h6 id="reduce函数"><code>reduce</code>函数</h6>
<ul>
<li><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是:</li>
</ul>
<pre><code class="language-Python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
</code></pre>
<p>如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数13579，reduce就可以派上用场：</p>
<pre><code class="language-Python">from functools import reduce
def fn(x, y):
    return x * 10 + y
print(reduce(fn, [1, 3, 5, 7, 9]))
13579
</code></pre>
<p>考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<pre><code class="language-Python">from functools import reduce
DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}
def char2num(s):
    return DIGITS[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<h6 id="filter函数"><code>filter</code>函数</h6>
<ul>
<li><code>Python</code>内建的<code>filter()</code>函数用于过滤序列。<br>
和<code>map()</code>类似，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。<br>
注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回<code>list</code>。</li>
</ul>
<p>筛法求素数：</p>
<pre><code class="language-python">def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
def _not_divisible(n):
    return lambda x: x % n &gt; 0
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<h6 id="sorted函数"><code>sorted</code>函数</h6>
<ul>
<li><code>sorted</code>函数可以从任意序列的元素返回一个新的排好序的列表：</li>
</ul>
<pre><code class="language-Python">print(sorted([7, 1, 2, 6, 0, 3, 2]))
[0, 1, 2, 2, 3, 6, 7]
print(sorted('horse race'))
[' ', 'a', 'c', 'e', 'e', 'h', 'o', 'r', 'r', 's']
</code></pre>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<pre><code class="language-Python">sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]
</code></pre>
<p>进行反向排序，不必改动<code>key</code>函数，可以传入第三个参数<code>reverse=True</code>：</p>
<pre><code class="language-Python">sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)
['Zoo', 'Credit', 'bob', 'about']
</code></pre>
<h5 id="返回函数">返回函数</h5>
<pre><code class="language-Python">def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
</code></pre>
<p>调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<pre><code class="language-Python">f = lazy_sum(1, 3, 5, 7, 9)
f
&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;
</code></pre>
<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<pre><code class="language-Python">f()
25
</code></pre>
<p>函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包(<code>Closure</code>)”的程序结构拥有极大的威力。</p>
<h6 id="闭包">闭包</h6>
<ul>
<li>返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</li>
</ul>
<pre><code class="language-Python">def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
</code></pre>
<p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。<br>
你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是1，4，9，但实际结果是：</p>
<pre><code class="language-Python">f1()
9
f2()
9
f3()
9
</code></pre>
<p>全部都是9！原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了3，因此最终结果为9。<br>
另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。<br>
<strong>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong><br>
如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="language-Python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<pre><code class="language-Python"> f1, f2, f3 = count()
f1()
1
f2()
4
f3()
9
</code></pre>
<p>下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-Python">def multipliers():
  return [lambda x : i * x for i in range(4)]
print [m(2) for m in multipliers()]
</code></pre>
<p>你如何修改上面的<code>multipliers</code>的定义产生想要的结果？<br>
上面代码输出的结果是<code>[6, 6, 6, 6]</code>(不是我们想的<code>[0, 2, 4, 6]</code>)。<br>
上述问题产生的原因是<code>Python</code>闭包的延迟绑定。这意味着内部函数被调用时，参数的值在闭包内进行查找。因此，当任何由<code>multipliers()</code>返回的函数被调用时，<code>i</code>的值将在附近的范围进行查找。那时，不管返回的函数是否被调用，for循环已经完成，<code>i</code>被赋予了最终的值3。<br>
因此，每次返回的函数乘以传递过来的值3，因为上段代码传过来的值是2，它们最终返回的都是6(3*2)。碰巧的是，《The Hitchhiker’s Guide to Python》也指出，在与<code>lambdas</code>函数相关也有一个被广泛被误解的知识点，不过跟这个<code>case</code>不一样。由<code>lambda</code>表达式创造的函数没有什么特殊的地方，它其实是和def创造的函数式一样的。<br>
下面是解决这一问题的一些方法。<br>
一种解决方法就是用<code>Python</code>生成器。</p>
<pre><code class="language-Python">def multipliers():
  for i in range(4): yield lambda x : i * x
</code></pre>
<p>另外一个解决方案就是创造一个闭包，利用默认函数立即绑定。</p>
<pre><code class="language-Python">def multipliers():
  return [lambda x, i=i : i * x for i in range(4)]
</code></pre>
<p>还有种替代的方案是，使用偏函数：</p>
<pre><code class="language-Python">from functools import partial
from operator import mul
def multipliers():
  return [partial(mul, i) for i in range(4)]
</code></pre>
<p>通常来讲，闭包的内部变量对于外界来讲是完全隐藏的。 但是，你可以通过编写访问函数并将其作为函数属性绑定到闭包上来实现这个目的。例如：</p>
<pre><code class="language-python">def sample():
    n = 0
    # Closure function
    def func():
        print('n=', n)

    # Accessor methods for n
    def get_n():
        return n

    def set_n(value):
        nonlocal n
        n = value

    # Attach as function attributes
    func.get_n = get_n
    func.set_n = set_n
    return func
</code></pre>
<p>下面是使用的例子:</p>
<pre><code class="language-python">f = sample()
f()
n= 0
f.set_n(10)
f()
n= 10
f.get_n()
10
</code></pre>
<p>讨论<br>
为了说明清楚它如何工作的，有两点需要解释一下。首先，<code>nonlocal</code> 声明可以让我们编写函数来修改内部变量的值。</p>
<h5 id="装饰器">装饰器</h5>
<ul>
<li>在代码运行期间动态增加功能的方式，称之为“装饰器”(<code>Decorator</code>)。<br>
本质上，<code>decorator</code>就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的<code>decorator</code>，可以定义如下：</li>
</ul>
<pre><code class="language-Python">def log(func):
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
@log
def now():
    print('2015-3-25')
now()
call now():
2015-3-25
</code></pre>
<p>由于<code>log()</code>是一个<code>decorator</code>，返回一个函数，所以，原来的<code>now()</code>函数仍然存在，只是现在同名的<code>now</code>变量指向了新的函数，于是调用<code>now()</code>将执行新函数，即在<code>log()</code>函数中返回的<code>wrapper()</code>函数。<br>
<code>wrapper()</code>函数的参数定义是<code>(*args, **kw)</code>，因此，<code>wrapper()</code>函数可以接受任意参数的调用。在<code>wrapper()</code>函数内，首先打印日志，再紧接着调用原始函数。<br>
如果<code>decorator</code>本身需要传入参数，那就需要编写一个返回<code>decorator</code>的高阶函数，写出来会更复杂。比如，要自定义<code>log</code>的文本：</p>
<pre><code class="language-Python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
@log('execute')
def now():
    print('2015-3-25')
now()
execute now():
2015-3-25
</code></pre>
<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<pre><code class="language-Python">now = log('execute')(now)
</code></pre>
<p>首先执行<code>log('execute')</code>，返回的是<code>decorator</code>函数，再调用返回的函数，参数是<code>now</code>函数，返回值最终是<code>wrapper</code>函数。</p>
<p>以上两种<code>decorator</code>的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<code>__name__</code>等属性，但你去看经过<code>decorator</code>装饰之后的函数，它们的<code>__name__</code>已经从原来的<code>'now'</code>变成了<code>'wrapper'</code>：</p>
<pre><code class="language-Python">now.__name__
'wrapper'
</code></pre>
<p>因为返回的那个<code>wrapper()</code>函数名字就是<code>'wrapper'</code>，所以，需要把原始函数的<code>__name__</code>等属性复制到<code>wrapper()</code>函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写<code>wrapper.__name__ = func.__name__</code>这样的代码，<code>Python</code>内置的<code>functools.wraps</code>就是干这个事的，所以，一个完整的<code>decorator</code>的写法如下：</p>
<pre><code class="language-python">import functools
def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
</code></pre>
<p>或者针对带参数的<code>decorator</code>：</p>
<pre><code class="language-python">import functools
def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>在面向对象(<code>OOP</code>)的设计模式中，<code>decorator</code>被称为装饰模式。<code>OOP</code>的装饰模式需要通过继承和组合来实现，而<code>Python</code>除了能支持<code>OOP</code>的<code>decorator</code>外，直接从语法层次支持<code>decorator</code>。<code>Python</code>的<code>decorator</code>可以用函数实现，也可以用类实现。<br>
<code>decorator</code>可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<h6 id="property"><code>@property</code></h6>
<p><code>Python</code>内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>
<pre><code class="language-Python">class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError('score must be an integer!')
        if value &lt; 0 or value &gt; 100:
            raise ValueError('score must between 0 ~ 100!')
        self._score = value
</code></pre>
<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p>
<pre><code class="language-Python">s = Student()
s.score = 60 # OK，实际转化为s.set_score(60)
s.score # OK，实际转化为s.get_score()
60
s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
</code></pre>
<p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过<code>getter</code>和<code>setter</code>方法来实现的。<br>
还可以定义只读属性，只定义<code>getter</code>方法，不定义<code>setter</code>方法就是一个只读属性：</p>
<pre><code class="language-Python">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
</code></pre>
<p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。<br>
自定义某个属性的一种简单方法是将它定义为一个<code>property</code>。 例如，下面的代码定义了一个<code>property</code>，增加对一个属性简单的类型检查：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    # Getter function
    @property
    def first_name(self):
        return self._first_name

    # Setter function
    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    @first_name.deleter
    def first_name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)
</code></pre>
<p>上述代码中有三个相关联的方法，这三个方法的名字都必须一样。 第一个方法是一个 <code>getter</code> 函数，它使得 <code>first_name</code> 成为一个属性。 其他两个方法给 <code>first_name</code> 属性添加了 <code>setter</code> 和 <code>deleter</code> 函数。 需要强调的是只有在 <code>first_name</code> 属性被创建后， 后面的两个装饰器 <code>@first_name.setter</code> 和 <code>@first_name.deleter</code> 才能被定义。<br>
<code>property</code>的一个关键特征是它看上去跟普通的<code>attribute</code>没什么两样， 但是访问它的时候会自动触发 <code>getter</code> 、<code>setter</code> 和 <code>deleter</code> 方法。例如：</p>
<pre><code class="language-python">a = Person('Guido')
a.first_name # Calls the getter
'Guido'
a.first_name = 42 # Calls the setter
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;prop.py&quot;, line 14, in first_name
        raise TypeError('Expected a string')
TypeError: Expected a string
del a.first_name
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: can`t delete attribute
</code></pre>
<p>在实现一个<code>property</code>的时候，底层数据(如果有的话)仍然需要存储在某个地方。 因此，在<code>get</code>和<code>set</code>方法中，你会看到对 <code>_first_name</code> 属性的操作，这也是实际数据保存的地方。 另外，你可能还会问为什么 <code>__init__()</code> 方法中设置了 <code>self.first_name</code> 而不是 <code>self._first_name</code> 。 在这个例子中，我们创建一个<code>property</code>的目的就是在设置<code>attribute</code>的时候进行检查。 因此，你可能想在初始化的时候也进行这种类型检查。通过设置 <code>self.first_name</code> ，自动调用 <code>setter</code> 方法， 这个方法里面会进行参数的检查，否则就是直接访问 <code>self._first_name</code> 了。<br>
还能在已存在的<code>get</code>和<code>set</code>方法基础上定义<code>property</code>。例如：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.set_first_name(first_name)

    # Getter function
    def get_first_name(self):
        return self._first_name

    # Setter function
    def set_first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Deleter function (optional)
    def del_first_name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)

    # Make a property from existing get/set methods
    name = property(get_first_name, set_first_name, del_first_name)
</code></pre>
<p>一个<code>property</code>属性其实就是一系列相关绑定方法的集合。如果你去查看拥有<code>property</code>的类， 就会发现<code>property</code>本身的<code>fget</code>、<code>fset</code>和<code>fdel</code>属性就是类里面的普通方法。比如：</p>
<pre><code class="language-python">Person.first_name.fget
&lt;function Person.first_name at 0x1006a60e0&gt;
Person.first_name.fset
&lt;function Person.first_name at 0x1006a6170&gt;
Person.first_name.fdel
&lt;function Person.first_name at 0x1006a62e0&gt;
</code></pre>
<p>通常来讲，你不会直接取调用<code>fget</code>或者<code>fset</code>，它们会在访问<code>property</code>的时候自动被触发。<br>
只有当你确实需要对<code>attribute</code>执行其他额外的操作的时候才应该使用到<code>property</code>。 有时候一些从其他编程语言(比如<code>Java</code>)过来的程序员总认为所有访问都应该通过<code>getter</code>和<code>setter</code>， 所以他们认为代码应该像下面这样写：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name):
        self.first_name = first_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        self._first_name = value
</code></pre>
<p>不要写这种没有做任何其他额外操作的<code>property</code>。 首先，它会让你的代码变得很臃肿，并且还会迷惑阅读者。 其次，它还会让你的程序运行起来变慢很多。 最后，这样的设计并没有带来任何的好处。 特别是当你以后想给普通<code>attribute</code>访问添加额外的处理逻辑的时候， 你可以将它变成一个<code>property</code>而无需改变原来的代码。 因为访问<code>attribute</code>的代码还是保持原样。<br>
<code>Properties</code>还是一种定义动态计算<code>attribute</code>的方法。 这种类型的<code>attributes</code>并不会被实际的存储，而是在需要的时候计算出来。比如：</p>
<pre><code class="language-python">import math
class Circle:
    def __init__(self, radius):
        self.radius = radius

    @property
    def area(self):
        return math.pi * self.radius ** 2

    @property
    def diameter(self):
        return self.radius * 2

    @property
    def perimeter(self):
        return 2 * math.pi * self.radius
</code></pre>
<p>在这里，我们通过使用<code>properties</code>，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的<code>attribute</code>是一样的。 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。 下面是使用的实例：</p>
<pre><code class="language-python">c = Circle(4.0)
c.radius
4.0
c.area  # Notice lack of ()
50.26548245743669
c.perimeter  # Notice lack of ()
25.132741228718345
</code></pre>
<p>尽管<code>properties</code>可以实现优雅的编程接口，但有些时候你还是会想直接使用<code>getter</code>和<code>setter</code>函数。例如：</p>
<pre><code class="language-python">p = Person('Guido')
p.get_first_name()
'Guido'
p.set_first_name('Larry')
</code></pre>
<p>这种情况的出现通常是因为<code>Python</code>代码被集成到一个大型基础平台架构或程序中。 例如，有可能是一个<code>Python</code>类准备加入到一个基于远程过程调用的大型分布式系统中。 这种情况下，直接使用<code>get/set</code>方法(普通方法调用)而不是<code>property</code>或许会更容易兼容。<br>
最后一点，不要像下面这样写有大量重复代码的<code>property</code>定义：</p>
<pre><code class="language-python">class Person:
    def __init__(self, first_name, last_name):
        self.first_name = first_name
        self.last_name = last_name

    @property
    def first_name(self):
        return self._first_name

    @first_name.setter
    def first_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._first_name = value

    # Repeated property code, but for a different name (bad!)
    @property
    def last_name(self):
        return self._last_name

    @last_name.setter
    def last_name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._last_name = value
</code></pre>
<p>重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。<br>
在子类中，扩展定义在父类中的<code>property</code>的功能。考虑如下的代码，它定义了一个<code>property</code>：</p>
<pre><code class="language-python">class Person:
    def __init__(self, name):
        self.name = name

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise AttributeError(&quot;Can't delete attribute&quot;)
</code></pre>
<p>下面是一个示例类，它继承自<code>Person</code>并扩展了 <code>name</code> 属性的功能：</p>
<pre><code class="language-python">class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>
<p>接下来使用这个新类：</p>
<pre><code class="language-python">s = SubPerson('Guido')
Setting name to Guido
s.name
Getting name
'Guido'
s.name = 'Larry'
Setting name to Larry
s.name = 42
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 16, in name
        raise TypeError('Expected a string')
TypeError: Expected a string
</code></pre>
<p>如果你仅仅只想扩展<code>property</code>的某一个方法，那么可以像下面这样写：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>或者，你只想修改<code>setter</code>方法，就这么写：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)
</code></pre>
<p>在子类中扩展一个<code>property</code>可能会引起很多不易察觉的问题， 因为一个<code>property</code>其实是 <code>getter</code>、<code>setter</code> 和 <code>deleter</code> 方法的集合，而不是单个方法。 因此，当你扩展一个<code>property</code>的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中某一个。<br>
在第一个例子中，所有的<code>property</code>方法都被重新定义。 在每一个方法中，使用了 <code>super()</code> 来调用父类的实现。 在 <code>setter</code> 函数中使用 <code>super(SubPerson, SubPerson).name.__set__(self, value)</code> 的语句是没有错的。 为了委托给之前定义的<code>setter</code>方法，需要将控制权传递给之前定义的<code>name</code>属性的 <code>__set__()</code> 方法。 不过，获取这个方法的唯一途径是使用类变量而不是实例变量来访问它。 这也是为什么我们要使用 <code>super(SubPerson, SubPerson)</code> 的原因。</p>
<p>如果你只想重定义其中一个方法，那只使用 <code>@property</code> 本身是不够的。比如，下面的代码就无法工作：</p>
<pre><code class="language-python">class SubPerson(Person):
    @property  # Doesn't work
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>如果你试着运行会发现<code>setter</code>函数整个消失了：</p>
<pre><code class="language-python">s = SubPerson('Guido')
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 5, in __init__
        self.name = name
AttributeError: can't set attribute
</code></pre>
<p>你应该像之前说过的那样修改代码：</p>
<pre><code class="language-python">class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
</code></pre>
<p>这么写后，<code>property</code>之前已经定义过的方法会被复制过来，而<code>getter</code>函数被替换。然后它就能按照期望的工作了：</p>
<pre><code class="language-python">s = SubPerson('Guido')
s.name
Getting name
'Guido'
s.name = 'Larry'
s.name
Getting name
'Larry'
s.name = 42
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;example.py&quot;, line 16, in name
        raise TypeError('Expected a string')
TypeError: Expected a string
</code></pre>
<p>在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的 <code>Person</code> 类名。 如果你不知道到底是哪个基类定义了<code>property</code>， 那你只能通过重新定义所有<code>property</code>并使用 <code>super()</code> 来将控制权传递给前面的实现。<br>
值得注意的是上面演示的第一种技术还可以被用来扩展一个描述器。比如：</p>
<pre><code class="language-python">'''
A descriptor
'''
class String:
    def __init__(self, name):
        self.name = name

    def __get__(self, instance, cls):
        if instance is None:
            return self
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        instance.__dict__[self.name] = value
'''
A class with a descriptor
'''
class Person:
    name = String('name')

    def __init__(self, name):
        self.name = name
'''
Extending a descriptor with a property
'''
class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
</code></pre>
<p>最后值得注意的是，读到这里时，你应该会发现子类化 <code>setter</code> 和 <code>deleter</code> 方法其实是很简单的。</p>
<h6 id="classmethod"><code>@classmethod</code></h6>
<p><code>@classmethod</code>对应的函数不需要实例化，不需要 <code>self</code> 参数，但第一个参数需要是表示自身类的 <code>cls</code> 参数，可以来调用类的属性，类的方法，实例化对象等。<br>
<code>@classmethod</code>因为持有<code>cls</code>参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</p>
<pre><code class="language-Python">class A(object):
    bar = 1
    def func1(self):  
        print ('foo') 
    @classmethod
    def func2(cls):
        print ('func2')
        print (cls.bar)
        cls().func1()   # 调用 foo 方法
 
A.func2()               # 不需要实例化
</code></pre>
<h6 id="staticmethod"><code>@staticmethod</code></h6>
<p>将类中的方法装饰为静态方法，即类不需要创建实例的情况下，可以通过类名直接引用。到达将函数功能与实例解绑的效果。<br>
<code>@staticmethod</code>不需要表示自身对象的<code>self</code>和自身类的<code>cls</code>参数，就跟使用函数一样。<br>
如果在<code>@staticmethod</code>中要调用到这个类的一些属性方法，只能直接<code>类名.属性名</code>或<code>类名.方法名</code>。</p>
<pre><code class="language-Python">class TestClass:
    name = &quot;test&quot;
    def __init__(self, name):
        self.name = name
    @staticmethod
    def fun(self, x, y):
        return  x + y
cls = TestClass(&quot;felix&quot;)
print(&quot;通过实例引用方法&quot;)
print(cls.fun(None, 2, 3)) # 参数个数必须与定义中的个数保持一致，否则报错
print(&quot;类名直接引用静态方法&quot;)
print(TestClass.fun(None, 2, 3)) # 参数个数必须与定义中的个数保持一致，否则报错
</code></pre>
<h6 id="dataclass"><code>@dataclass</code></h6>
<pre><code class="language-Python">class MyClass:
    def __init__(self, var_a, var_b):
        self.var_a = var_a
        self.var_b = var_b
@dataclass
class MyClass:
    var_a: str
    var_b: str
@dataclass
class Number:
    val:int = 0
</code></pre>
<h5 id="偏函数">偏函数</h5>
<ul>
<li><code>int()</code>函数可以把字符串转换为整数，当仅传入字符串时，<code>int()</code>函数默认按十进制转换。<br>
但<code>int()</code>函数还提供额外的<code>base</code>参数，默认值为10。如果传入<code>base</code>参数，就可以做N进制的转换：<br>
<code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</li>
</ul>
<pre><code class="language-python">import functools
int2 = functools.partial(int, base=2)
int2('1000000')
64
int2('1010101')
85
</code></pre>
<ul>
<li>简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。<br>
注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为2，但也可以在函数调用时传入其他值：</li>
</ul>
<pre><code class="language-Python">int2('1000000', base=10)
1000000
</code></pre>
<ul>
<li>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</li>
</ul>
<pre><code class="language-Python">int2 = functools.partial(int, base=2)
</code></pre>
<p>实际上固定了<code>int()</code>函数的关键字参数<code>base</code>，也就是：</p>
<pre><code class="language-python">int2('10010')
</code></pre>
<p>相当于：</p>
<pre><code class="language-python">kw = { 'base': 2 }
int('10010', **kw)
</code></pre>
<p>当传入：</p>
<pre><code class="language-Python">max2 = functools.partial(max, 10)
</code></pre>
<p>实际上会把10作为*args的一部分自动加到左边，也就是：</p>
<pre><code class="language-Python">max2(5, 6, 7)
</code></pre>
<p>相当于：</p>
<pre><code class="language-Python">args = (10, 5, 6, 7)
max(*args)
</code></pre>
<p>结果为10。<br>
当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
<h4 id="itertools模块"><code>itertools</code>模块</h4>
<ul>
<li>标准库<code>itertools</code>模块中有一组用于许多常见数据算法的生成器。例如，<code>groupby</code>可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子：</li>
</ul>
<pre><code class="language-Python">import itertools
first_letter = lambda x: x[0]
names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
for letter, names in itertools.groupby(names, first_letter):
    print(letter, list(names)) # names is a generator
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']
</code></pre>
<ul>
<li>常用<code>itertools</code>函数:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373137383639312d313131383233643837363761313034642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f77.png" alt="" loading="lazy"></li>
</ul>
<p>子序列工具:</p>
<pre><code class="language-python">import itertools
itertools.islice(iterable, start=None, stop, step=None)
'''
slice('ABCDEF', 2, None) -&gt; C, D, E, F
'''
itertools.filterfalse(predicate, iterable)         # 过滤掉predicate为False的元素
'''
filterfalse(lambda x: x &lt; 5, [1, 4, 6, 4, 1]) -&gt; 6
'''
itertools.takewhile(predicate, iterable)           # 当predicate为False时停止迭代
'''
takewhile(lambda x: x &lt; 5, [1, 4, 6, 4, 1]) -&gt; 1, 4
'''
itertools.dropwhile(predicate, iterable)           # 当predicate为False时开始迭代
'''
dropwhile(lambda x: x &lt; 5, [1, 4, 6, 4, 1]) -&gt; 6, 4, 1
'''
itertools.compress(iterable, selectors)            # 根据selectors每个元素是True或False进行选择
'''
compress('ABCDEF', [1, 0, 1, 0, 1, 1]) -&gt; A, C, E, F
'''
</code></pre>
<p>序列排序：</p>
<pre><code class="language-python">sorted(iterable, key=None, reverse=False)
itertools.groupby(iterable, key=None)              # 按值分组，iterable需要先被排序
'''
groupby(sorted([1, 4, 6, 4, 1])) -&gt; (1, iter1), (4, iter4), (6, iter6)
'''
itertools.permutations(iterable, r=None)           # 排列，返回值是Tuple
'''
permutations('ABCD', 2) -&gt; AB, AC, AD, BA, BC, BD, CA, CB, CD, DA, DB, DC
'''
itertools.combinations(iterable, r=None)           # 组合，返回值是Tuple
itertools.combinations_with_replacement(...)
'''
combinations('ABCD', 2) -&gt; AB, AC, AD, BC, BD, CD
'''
</code></pre>
<p>多个序列合并：</p>
<pre><code class="language-python">itertools.chain(*iterables)                        # 多个序列直接拼接
'''
chain('ABC', 'DEF') -&gt; A, B, C, D, E, F
'''
import heapq
heapq.merge(*iterables, key=None, reverse=False)   # 多个序列按顺序拼接
'''
merge('ABF', 'CDE') -&gt; A, B, C, D, E, F
'''
zip(*iterables)                                    # 当最短的序列耗尽时停止，结果只能被消耗一次
itertools.zip_longest(*iterables, fillvalue=None)  # 当最长的序列耗尽时停止，结果只能被消耗一次
</code></pre>
<h3 id="字符串">字符串</h3>
<pre><code class="language-Python"> a= 'ABC'
</code></pre>
<p>在内存中创建了一个<code>'ABC'</code>的字符串；<br>
在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>'ABC'</code>。<br>
也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p>
<pre><code class="language-Python">a = 'ABC'
b = a
a = 'XYZ'
print(b)
'ABC`
</code></pre>
<h4 id="分割">分割</h4>
<pre><code class="language-Python">s = 'Python'
list(s)
['p', 'y', 't', 'h', 'o', 'n']
</code></pre>
<h4 id="模板化或格式化">模板化或格式化</h4>
<pre><code class="language-Python">template = '{0:.2f} {1:s} are worth US${2:d}'
</code></pre>
<ul>
<li><code>{0:.2f}</code>表示格式化第一个参数为带有两位小数的浮点数。</li>
<li><code>{1:s}</code>表示格式化第二个参数为字符串。</li>
<li><code>{2:d}</code>表示格式化第三个参数为一个整数。<br>
在括号中的数字用于指向传入对象在 <code>format()</code> 中的位置，如下所示：</li>
</ul>
<pre><code class="language-Python">print('{0} 和 {1}'.format('Google', 'Runoob'))
Google 和 Runoob
print('{1} 和 {0}'.format('Google', 'Runoob'))
Runoob 和 Google
</code></pre>
<p>如果在<code>format()</code> 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。</p>
<pre><code class="language-Python">print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))
菜鸟教程网址： www.runoob.com
</code></pre>
<p>位置及关键字参数可以任意的结合:</p>
<pre><code class="language-Python">print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))
站点列表 Google, Runoob, 和 Taobao。
</code></pre>
<p>可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 <code>Pi</code> 保留到小数点后三位：</p>
<pre><code class="language-Python">import math
print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))
常量 PI 的值近似为 3.142。
</code></pre>
<p>如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。<br>
最简单的就是传入一个字典, 然后使用方括号 <code>[]</code> 来访问键值 :</p>
<pre><code class="language-Python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<p>也可以通过在 <code>table</code> 变量前使用 <code>**</code> 来实现相同的功能：</p>
<pre><code class="language-Python">table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}
print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))
Runoob: 2; Google: 1; Taobao: 3
</code></pre>
<h4 id="常用操作">常用操作</h4>
<ul>
<li><code>str.join(iterable)</code>:返回一个由 <code>iterable</code> 中的字符串拼接而成的字符串。比<code>+</code>效率要高。<br>
如果你想要合并的字符串是在一个序列或者 <code>iterable</code> 中，那么最快的方式就是使用 <code>join()</code> 方法。比如：</li>
</ul>
<pre><code class="language-python">parts = ['Is', 'Chicago', 'Not', 'Chicago?']
' '.join(parts)
'Is Chicago Not Chicago?'
','.join(parts)
'Is,Chicago,Not,Chicago?'
''.join(parts)
'IsChicagoNotChicago?'
</code></pre>
<p>初看起来，这种语法看上去会比较怪，但是 <code>join()</code> 被指定为字符串的一个方法。 这样做的部分原因是你想去连接的对象可能来自各种不同的数据序列(比如列表，元组，字典，文件，集合或生成器等)， 如果在所有这些对象上都定义一个 <code>join()</code> 方法明显是冗余的。 因此你只需要指定你想要的分割字符串并调用他的 <code>join()</code> 方法去将文本片段组合起来。<br>
如果你仅仅只是合并少数几个字符串，使用加号<code>(+)</code>通常已经足够了：</p>
<pre><code class="language-python">a = 'Is Chicago'
b = 'Not Chicago?'
a + ' ' + b
'Is Chicago Not Chicago?'
</code></pre>
<p>加号<code>(+)</code>操作符在作为一些复杂字符串格式化的替代方案的时候通常也工作的很好，比如：</p>
<pre><code class="language-python">print('{} {}'.format(a,b))
Is Chicago Not Chicago?
print(a + ' ' + b)
Is Chicago Not Chicago?
</code></pre>
<p>如果你想在源码中将两个字面字符串合并起来，你只需要简单的将它们放到一起，不需要用加号<code>(+)</code>。比如：</p>
<pre><code class="language-python">a = 'Hello' 'World'
a
'HelloWorld'
</code></pre>
<p>字符串合并可能看上去并不需要用一整节来讨论。 但是不应该小看这个问题，程序员通常在字符串格式化的时候因为选择不当而给应用程序带来严重性能损失。<br>
最重要的需要引起注意的是，当我们使用加号<code>(+)</code>操作符去连接大量的字符串的时候是非常低效率的， 因为加号连接会引起内存复制以及垃圾回收操作。 特别的，你永远都不应像下面这样写字符串连接代码：</p>
<pre><code class="language-python">s = ''
for p in parts:
    s += p
</code></pre>
<p>这种写法会比使用 <code>join()</code> 方法运行的要慢一些，因为每一次执行<code>+=</code>操作的时候会创建一个新的字符串对象。 你最好是先收集所有的字符串片段然后再将它们连接起来。<br>
一个相对比较聪明的技巧是利用生成器表达式转换数据为字符串的同时合并字符串，比如：</p>
<pre><code class="language-python">data = ['ACME', 50, 91.1]
','.join(str(d) for d in data)
'ACME,50,91.1'
</code></pre>
<p>同样还得注意不必要的字符串连接操作。有时候程序员在没有必要做连接操作的时候仍然多此一举。比如在打印的时候：</p>
<pre><code class="language-python">print(a + ':' + b + ':' + c) # Ugly
print(':'.join([a, b, c])) # Still ugly
print(a, b, c, sep=':') # Better
</code></pre>
<p>当混合使用<code>I/O</code>操作和字符串连接操作的时候，有时候需要仔细研究你的程序。 比如，考虑下面的两端代码片段：</p>
<pre><code class="language-python">'''
Version 1 (string concatenation)
'''
f.write(chunk1 + chunk2)
'''
Version 2 (separate I/O operations)
'''
f.write(chunk1)
f.write(chunk2)
</code></pre>
<p>如果两个字符串很小，那么第一个版本性能会更好些，因为<code>I/O</code>系统调用天生就慢。 另外一方面，如果两个字符串很大，那么第二个版本可能会更加高效， 因为它避免了创建一个很大的临时结果并且要复制大量的内存块数据。 还是那句话，有时候是需要根据你的应用程序特点来决定应该使用哪种方案。<br>
最后谈一下，如果你准备编写构建大量小字符串的输出代码， 你最好考虑下使用生成器函数，利用<code>yield</code>语句产生输出片段。比如：</p>
<pre><code class="language-python">def sample():
    yield 'Is'
    yield 'Chicago'
    yield 'Not'
    yield 'Chicago?'
</code></pre>
<p>这种方法一个有趣的方面是它并没有对输出片段到底要怎样组织做出假设。 例如，你可以简单的使用 <code>join()</code> 方法将这些片段合并起来：</p>
<pre><code class="language-python">text = ''.join(sample())
</code></pre>
<p>或者你也可以将字符串片段重定向到<code>I/O</code>：</p>
<pre><code class="language-python">for part in sample():
    f.write(part)
</code></pre>
<p>再或者你还可以写出一些结合<code>I/O</code>操作的混合方案：</p>
<pre><code class="language-python">def combine(source, maxsize):
    parts = []
    size = 0
    for part in source:
        parts.append(part)
        size += len(part)
        if size &gt; maxsize:
            yield ''.join(parts)
            parts = []
            size = 0
    yield ''.join(parts)
'''
结合文件操作
'''
with open('filename', 'w') as f:
    for part in combine(sample(), 32768):
        f.write(part)
</code></pre>
<p>这里的关键点在于原始的生成器函数并不需要知道使用细节，它只负责生成字符串片段就行了。</p>
<ul>
<li><code>eval(str)</code>:用来计算在字符串中的有效<code>Python</code>表达式,并返回一个对象</li>
<li><code>str.center(width[, fillchar])</code>:返回长度为 <code>width</code> 的字符串，原字符串在其正中。 使用指定的 <code>fillchar</code> 填充两边的空位（默认使用 <code>ASCII</code> 空格符）。 如果 <code>width</code> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</li>
<li><code>str.count(str, beg= 0,end=len(string))</code>:返回 <code>str</code> 在 <code>string</code> 里面出现的次数，如果 <code>beg</code> 或者 <code>end</code>指定则返回指定范围内 <code>str</code> 出现的次数</li>
<li><code>str.find(str, beg=0, end=len(string))</code>:检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code> ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回<code>-1</code></li>
<li><code>str.index(sub, start=None, end=None)</code>:如果找不到抛出<code>ValueError</code>异常</li>
<li><code>str.upper()</code>:转换字符串中的小写字母为大写</li>
<li><code>str.lower()</code>:转换字符串中所有大写字符为小写</li>
<li><code>str.replace(old, new [, max])</code>:将字符串中的 <code>str1</code> 替换成 <code>str2</code>,如果<code>max</code>指定，则替换不超过<code>max</code>次。<br>
想处理中间的空格,使用 <code>replace()</code> 方法。示例如下：</li>
</ul>
<pre><code class="language-python">s.replace(' ', '')
'helloworld'
</code></pre>
<ul>
<li><code>str.split(str=&quot;&quot;, num=string.count(str))</code>:<code>num=string.count(str))</code> 以<code>str</code>为分隔符截取字符串，如果<code>num</code>有指定值，则仅截取<code>num+1</code>个子字符串</li>
<li><code>str.strip([chars])</code>:截掉字符串两边的空格或指定字符。</li>
<li>匹配的是字面字符串，那么你通常只需要调用基本字符串方法就行， 比如 <code>str.find()</code> , <code>str.endswith()</code> , <code>str.startswith()</code> 或者类似的方法：</li>
</ul>
<pre><code class="language-python">text = 'yeah, but no, but yeah, but no, but yeah'
'''
Exact match
'''
text == 'yeah'
False
'''
Match at start or end
'''
text.startswith('yeah')
True
text.endswith('no')
False
'''
Search for the location of the first occurrence
'''
text.find('no')
10
</code></pre>
<h3 id="运算符">运算符</h3>
<h4 id="和is"><code>==</code>和<code>is</code></h4>
<ul>
<li>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法:</li>
</ul>
<pre><code class="language-Python">a = [1, 2, 3]
b = a
c = list(a)
print(a is b)
True
'''
因为list总是创建一个新的Python列表（即复制），我们可以断定c是不同于a的。
'''
print(a is not c)
True
print(a == c)
True
</code></pre>
<p><code>is</code> 用于判断两个变量引用对象是否为同一个， <code>==</code> 用于判断引用变量的值是否相等。<br>
<code>a is b</code> 相当于 <code>id(a)==id(b)</code>.<br>
如果 <code>a=10;b=a;</code> 则此时 <code>a</code> 和 <code>b</code> 的内存地址一样的;<br>
但当 <code>a=[1,2,3]</code>; 另 <code>b=a[:]</code> 时，虽然 <code>a</code> 和 <code>b</code> 的值一样，但内存地址不一样。</p>
<h4 id="any和all"><code>any()</code>和<code>all()</code></h4>
<p><code>any()</code>, <code>all()</code>很好理解，就是字面意思，即参数中任何一个为 <code>true</code> 或者全部为 <code>true</code> 则返回 <code>true</code>。</p>
<h4 id="十进制转二进制">十进制转二进制</h4>
<pre><code class="language-Python">bin(10)
'0b1010'
</code></pre>
<h4 id="判断类型">判断类型</h4>
<pre><code class="language-python">type(a) == int      # 忽略面向对象设计中的多态特征
isinstance(a, int)  # 考虑了面向对象设计中的多态特征
</code></pre>
<h2 id="模块">模块</h2>
<ul>
<li>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，<code>Python</code>就把这个目录当成普通目录，而不是一个包。</li>
<li>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞混。在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</li>
<li>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。<br>
<code>sys</code>模块有一个<code>argv</code>变量，用<code>list</code>存储了命令行的所有参数。<code>argv</code>至少有一个元素，因为第一个参数永远是该``.py文件的名称，例如：<br>
运行<code>Python3 hello.py</code>获得的<code>sys.argv</code>就是<code>['hello.py']</code>；<br>
运行<code>Python3 hello.py Michael</code>获得的<code>sys.argv</code>就是<code>['hello.py', 'Michael]</code>。<br>
注意当使用 <code>from package import item</code> 这种形式的时候，对应的 <code>item</code> 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。<br>
<code>import</code> 语法会首先把 <code>item</code> 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 <code>:exc:ImportError</code> 异常。<br>
反之，如果使用形如 <code>import item.subitem.subsubitem</code> 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</li>
<li>内置的函数 <code>dir()</code> 可以找到模块内定义的所有名称。以一个字符串列表的形式返回。</li>
<li><code>sys.argv</code> 是一个包含命令行参数的列表。<code>sys.path</code> 包含了一个 <code>Python</code> 解释器自动查找所需模块的路径的列表。</li>
<li>搜索路径是由一系列目录名组成的，<code>Python</code>解释器就依次从这些目录中去寻找所引入的模块。<br>
搜索路径是在<code>Python</code>编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在<code>sys</code>模块中的<code>path</code>变量，做一个简单的实验，在交互式解释器中，输入以下代码：</li>
</ul>
<pre><code class="language-Python">import sys
sys.path
['', '/usr/lib/Python3.4', '/usr/lib/Python3.4/plat-x86_64-linux-gnu', '/usr/lib/Python3.4/lib-dynload', '/usr/local/lib/Python3.4/dist-packages', '/usr/lib/Python3/dist-packages']
</code></pre>
<p><code>sys.path</code> 输出是一个列表，其中第一项是空串<code>''</code>，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行<code>Python</code>解释器的目录（对于脚本的话就是运行的脚本所在的目录）。<br>
因此若在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。<br>
了解了搜索路径的概念，就可以在脚本中修改<code>sys.path</code>来引入一些不在搜索路径中的模块。<br>
如果我们要添加自己的搜索目录，有两种方法：<br>
一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<pre><code class="language-Python">import sys
sys.path.append('/Users/michael/my_py_scripts')
</code></pre>
<p>这种方法是在运行时修改，运行结束后失效。<br>
第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置<code>Path</code>环境变量类似。注意只需要添加你自己的搜索路径，<code>Python</code>自己本身的搜索路径不受影响。<br>
现在，在解释器的当前目录或者 <code>sys.path</code>中的一个目录里面来创建一个<code>fibo.py</code>的文件，代码如下：</p>
<pre><code class="language-Python">'''
斐波那契(fibonacci)数列模块
'''
def fib(n):    # 定义到 n 的斐波那契数列
    a, b = 0, 1
    while b &lt; n:
        print(b, end=' ')
        a, b = b, a+b
    print()
 
def fib2(n): # 返回到 n 的斐波那契数列
    result = []
    a, b = 0, 1
    while b &lt; n:
        result.append(b)
        a, b = b, a+b
    return result
</code></pre>
<p>然后进入<code>Python</code>解释器，使用下面的命令导入这个模块：</p>
<pre><code class="language-Python">import fibo
</code></pre>
<p>这样做并没有把直接定义在<code>fibo</code>中的函数名称写入到当前符号表里，只是把模块<code>fibo</code>的名字写到了那里。</p>
<h3 id="name属性"><code>name</code>属性</h3>
<p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<code>__name__</code>属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code class="language-Python">'''
Filename: using_name.py
'''
if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<pre><code class="language-shell">$ Python using_name.py
程序自身在运行
$ Python
&gt;&gt;&gt;import using_name
我来自另一模块
</code></pre>
<p>说明： 每个模块都有一个<code>__name_</code>_属性，当其值是<code>'__main__'</code>时，表明该模块自身在运行，否则是被引入。</p>
<h4 id="包">包</h4>
<ul>
<li>如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</li>
</ul>
<pre><code class="language-Python">__all__ = [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]
</code></pre>
<p>如果 <code>__all__</code>真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 <code>sound.effects</code> 里的任何子模块。他只是把包<code>sound.effects</code>和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。<br>
这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<pre><code class="language-Python">import sound.effects.echo
import sound.effects.surround
from sound.effects import *
</code></pre>
<p>这个例子中，在执行 <code>from...import</code> 前，包 <code>sound.effects</code> 中的 <code>echo</code> 和 <code>surround</code> 模块都被导入到当前的命名空间中了。（当然如果定义了 <code>__all__</code> 就更没问题了）</p>
<h2 id="oop">OOP</h2>
<h3 id="__new__和__init__区别"><code>__new__</code>和<code>__init__</code>区别</h3>
<p><code>__init__</code>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数。</p>
<ol>
<li><code>__new__</code>至少要有一个参数<code>cls</code>，代表当前类，此参数在实例化时由<code>Python</code>解释器自动识别</li>
<li><code>__new__</code>必须要有返回值，返回实例化出来的实例，这点在自己实现<code>__new__</code>时要特别注意，可以<code>return</code>父类（通过<code>super(当前类名, cls)</code>）<code>__new__</code>出来的实例，或者直接是<code>object</code>的<code>__new__</code>出来的实例</li>
<li><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>返回的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值</li>
<li>如果<code>__new__</code>创建的是当前类的实例，会自动调用<code>__init__</code>函数，通过<code>return</code>语句里面调用的<code>__new__</code>函数的第一个参数是<code>cls</code>来保证是当前类实例，如果是其他类的类名，那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<code>__init__</code>函数，也不会调用其他类的<code>__init__</code>函数。</li>
</ol>
<pre><code class="language-python">class A(object):
    def __init__(self):
        print('这是init方法:',self)
    def __new__(cls):
        print('这是cls的ID:',id(cls))
        print('这是new方法:',object.__new__(cls))
        return(object.__new__(cls))
A()
print('这是类A的ID',id(A))
这是cls的ID: 140345183503936
这是new方法: &lt;__main__.A object at 0x7fa4b0290ed0&gt;
这是init方法: &lt;__main__.A object at 0x7fa4b0290ed0&gt;# __init__方法的self和new方法返回地址一样，说明返回值是对象
这是类A的ID 140345183503936# cls和类ID一样，说明指向同一个类
</code></pre>
<h3 id="访问限制">访问限制</h3>
<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在<code>Python</code>中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量(<code>private</code>)，只有内部可以访问，外部不能访问:</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print('%s: %s' % (self.__name, self.__score))
</code></pre>
<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问<code>实例变量.__name</code>和<code>实例变量.__score</code>了：</p>
<pre><code class="language-Python">bart = Student('Bart Simpson', 59)
bart.__name
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute '__name'
</code></pre>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。</p>
<p>外部代码要获取<code>name</code>和<code>score</code>,修改属性,可以给<code>Student</code>类增加<code>get_name</code>和<code>get_score</code>这样的方法：</p>
<pre><code class="language-Python">class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
    def set_score(self, score):
        self.__score = score
</code></pre>
<p>那种直接通过<code>bart.score = 99</code>也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：</p>
<pre><code class="language-Python">class Student(object):
    ...

    def set_score(self, score):
        if 0 &lt;= score &lt;= 100:
            self.__score = score
        else:
            raise ValueError('bad score')
</code></pre>
<p>在<code>Python</code>中，变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是<code>private</code>变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。<br>
下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。<br>
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问<code>__name</code>是因为<code>Python</code>解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name来访问__name</code>变量：</p>
<pre><code class="language-Python">bart._Student__name
'Bart Simpson'
</code></pre>
<p>但是强烈建议你不要这么干，因为不同版本的<code>Python</code>解释器可能会把<code>__name</code>改成不同的变量名。<br>
总的来说就是，<code>Python</code>本身没有任何机制阻止你干坏事，一切全靠自觉。<br>
最后注意下面的这种错误写法：</p>
<pre><code class="language-Python">bart = Student('Bart Simpson', 59)
bart.get_name()
'Bart Simpson'
bart.__name = 'New Name' # 设置__name变量！
bart.__name
'New Name'
</code></pre>
<p>表面上看，外部代码“成功”地设置了<code>__name</code>变量，但实际上这个<code>__name</code>变量和<code>class</code>内部的<code>__name</code>变量不是一个变量！内部的<code>__name</code>变量已经被<code>Python</code>解释器自动改成了<code>_Student__name</code>，而外部代码给<code>bart</code>新增了一个<code>__name</code>变量。不信试试：</p>
<pre><code class="language-Python">bart.get_name() # get_name()内部返回self.__name
'Bart Simpson'
</code></pre>
<p>你还可能会遇到在类定义中使用两个下划线<code>(__)</code>开头的命名。比如：</p>
<pre><code class="language-python">class B:
    def __init__(self):
        self.__private = 0

    def __private_method(self):
        pass

    def public_method(self):
        pass
        self.__private_method()
</code></pre>
<p>使用双下划线开始会导致访问名称变成其他形式。 比如，在前面的类<code>B</code>中，私有属性会被分别重命名为 <code>_B__private</code> 和 <code>_B__private_method</code> 。 这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的。比如：</p>
<pre><code class="language-python">class C(B):
    def __init__(self):
        super().__init__()
        self.__private = 1 # Does not override B.__private
    '''
    Does not override B.__private_method()
    '''
    def __private_method(self):
        pass
</code></pre>
<p>这里，私有名称 <code>__private</code> 和 <code>__private_method</code> 被重命名为 <code>_C__private</code> 和 <code>_C__private_method</code> ，这个跟父类<code>B</code>中的名称是完全不同的。<br>
大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</p>
<h3 id="继承和多态">继承和多态</h3>
<pre><code class="language-Python">'''
类定义
'''
class people:
'''
    定义基本属性
'''
    name = ''
    age = 0
    '''
    定义私有属性,私有属性在类外部无法直接进行访问
    '''
    __weight = 0
    '''
    定义构造方法
    '''
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
'''
单继承示例
'''
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
    '''
        调用父类的构函
    '''
        people.__init__(self,n,a,w)
        self.grade = g
    '''
    覆写父类的方法
    '''
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
</code></pre>
<pre><code class="language-Python">class Animal(object):
    def run(self):
        print('Animal is running...')
class Dog(Animal):
    def run(self):
        print('Dog is running...')
</code></pre>
<p>子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。]</p>
<pre><code class="language-Python">a = list() # a是list类型
b = Animal() # b是Animal类型
c = Dog() # c是Dog类型
isinstance(a, list)
True
isinstance(b, Animal)
True
isinstance(c, Dog)
True
</code></pre>
<p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p>
<pre><code class="language-Python">isinstance(c, Animal)
True
</code></pre>
<p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！<br>
所以，在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。</p>
<pre><code class="language-Python">def run_twice(animal):
    animal.run()
    animal.run()
</code></pre>
<p>传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p>
<pre><code class="language-Python">run_twice(Dog())
Dog is running...
Dog is running...
</code></pre>
<p>多态的好处就是，当我们需要传入<code>Dog</code>时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>还是<code>Dog</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：<br>
对扩展开放：允许新增<code>Animal</code>子类；<br>
对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。<br>
对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。<br>
对于<code>Python</code>这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<pre><code class="language-Python">class Timer(object):
    def run(self):
        print('Start...')
</code></pre>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。<br>
<code>Python</code>的<code>“file-like object“</code>就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为<code>“file-like object“</code>。许多函数接收的参数就是<code>“file-like object“</code>，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。<br>
下面这段代码的输出结果将是什么？请解释。</p>
<pre><code class="language-Python">class Parent(object):
    x = 1

class Child1(Parent):
    pass

class Child2(Parent):
    pass
print Parent.x, Child1.x, Child2.x
Child1.x = 2
print Parent.x, Child1.x, Child2.x
Parent.x = 3
print Parent.x, Child1.x, Child2.x
1 1 1
1 2 1
3 2 3
</code></pre>
<p>让很多人困惑或惊讶的是最后一行输出为什么是3 2 3 而不是 3 2 1.为什么在改变<code>parent.x</code>的同时也改变了<code>child2.x</code>的值？但与此同时没有改变<code>Child1.x</code>的值？<br>
此答案的关键是，在<code>Python</code>中，类变量在内部是以字典的形式进行传递。<br>
如果一个变量名没有在当前类下的字典中发现。则在更高级的类（如它的父类）中尽心搜索直到引用的变量名被找到。（如果引用变量名在自身类和更高级类中没有找到，将会引发一个属性错误。）<br>
因此,在父类中设定<code>x = 1</code>,让变量<code>x</code>类(带有值1)能够在其类和其子类中被引用到。这就是为什么第一个打印语句输出结果是1 1 1<br>
因此，如果它的任何一个子类被覆写了值（例如说，当我们执行语句<code>Child1.x = 2</code>）,这个值只在子类中进行了修改。这就是为什么第二个打印语句输出结果是1 2 1<br>
最终，如果这个值在父类中进行了修改，（例如说，当我们执行语句<code>Parent.x = 3</code>）,这个改变将会影响那些还没有覆写子类的值（在这个例子中就是<code>Child2</code>）这就是为什么第三打印语句输出结果是3 2 3</p>
<h3 id="获取对象信息">获取对象信息</h3>
<h4 id="使用type">使用<code>type()</code></h4>
<p>判断对象类型，使用<code>type()</code>函数：</p>
<pre><code class="language-Python">type(123)
&lt;class 'int'&gt;
type('str')
&lt;class 'str'&gt;
type(None)
&lt;type(None) 'NoneType'&gt;
type(abs)
&lt;class 'builtin_function_or_method'&gt;
type(a)
&lt;class '__main__.Animal'&gt;
&gt;&gt;&gt; import types
def fn():
    pass
type(fn)==types.FunctionType
True
type(abs)==types.BuiltinFunctionType
True
type(lambda x: x)==types.LambdaType
True
type((x for x in range(10)))==types.GeneratorType
True
</code></pre>
<h4 id="使用isinstance">使用<code>isinstance()</code></h4>
<p>判断<code>class</code>的类型，可以使用<code>isinstance()</code>函数。</p>
<pre><code class="language-Python">isinstance([1, 2, 3], (list, tuple))
True
isinstance((1, 2, 3), (list, tuple))
True
</code></pre>
<p><strong>总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。</strong></p>
<h4 id="使用dir">使用<code>dir()</code></h4>
<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个<code>str</code>对象的所有属性和方法：</p>
<pre><code class="language-Python">dir('ABC')
['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']
</code></pre>
<p>类似<code>__xxx__</code>的属性和方法在<code>Python</code>中都是有特殊用途的，比如<code>__len__</code>方法返回长度。在<code>Python</code>中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法，所以，下面的代码是等价的：</p>
<pre><code class="language-Python">len('ABC')
3
'ABC'.__len__()
3
</code></pre>
<p>我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法：</p>
<pre><code class="language-Python">class MyDog(object):
    def __len__(self):
        return 100
dog = MyDog()
len(dog)
100
</code></pre>
<p>剩下的都是普通属性或方法，比如<code>lower()</code>返回小写的字符串：</p>
<pre><code class="language-Python">'ABC'.lower()
'abc'
</code></pre>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态：</p>
<pre><code class="language-Python">class MyObject(object):
    def __init__(self):
        self.x = 9
    def power(self):
        return self.x * self.x
obj = MyObject()
</code></pre>
<p>紧接着，可以测试该对象的属性：</p>
<pre><code class="language-Python">hasattr(obj, 'x') # 有属性'x'吗？
True
obj.x
9
hasattr(obj, 'y') # 有属性'y'吗？
False
setattr(obj, 'y', 19) # 设置一个属性'y'
hasattr(obj, 'y') # 有属性'y'吗？
True
getattr(obj, 'y') # 获取属性'y'
19
obj.y # 获取属性'y'
19
</code></pre>
<p>如果试图获取不存在的属性，会抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-Python">getattr(obj, 'z') # 获取属性'z'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'MyObject' object has no attribute 'z'
</code></pre>
<p>可以传入一个<code>default</code>参数，如果属性不存在，就返回默认值：</p>
<pre><code>getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404
404
</code></pre>
<p>也可以获得对象的方法：</p>
<pre><code class="language-Python">hasattr(obj, 'power') # 有属性'power'吗？
True
getattr(obj, 'power') # 获取属性'power'
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fn
fn # fn指向obj.power
&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;
fn() # 调用fn()与调用obj.power()是一样的
81
</code></pre>
<p>一个正确的用法的例子如下：</p>
<pre><code>def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
</code></pre>
<h4 id="实例属性和类属性">实例属性和类属性</h4>
<p>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name

s = Student('Bob')
s.score = 90
</code></pre>
<p>直接在<code>class</code>中定义属性，这种属性是类属性，归<code>Student</code>类所有：</p>
<pre><code class="language-Python">class Student(object):
    name = 'Student'
</code></pre>
<p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。来测试一下：</p>
<pre><code class="language-Python">class Student(object):
    name = 'Student'
s = Student() # 创建实例s
print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性
Student
print(Student.name) # 打印类的name属性
Student
s.name = 'Michael' # 给实例绑定name属性
print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性
Michael
print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问
Student
del s.name # 如果删除实例的name属性
print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了
Student
</code></pre>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。<br>
实例属性属于各个实例所有，互不干扰；<br>
类属性属于类所有，所有实例共享一个属性；<br>
不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p>
<h4 id="使用__slots__">使用<code>__slots__</code></h4>
<p>给实例绑定一个方法：</p>
<pre><code class="language-Python">def set_age(self, age): # 定义一个函数作为实例方法
    self.age = age
from types import MethodType
s.set_age = MethodType(set_age, s) # 给实例绑定一个方法
s.set_age(25) # 调用实例方法
s.age # 测试结果
25
</code></pre>
<p>但是，给一个实例绑定的方法，对另一个实例是不起作用的：</p>
<pre><code class="language-Python">s2 = Student() # 创建新的实例
s2.set_age(25) # 尝试调用方法
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'set_age'
</code></pre>
<p>为了给所有实例都绑定方法，可以给class绑定方法：</p>
<pre><code class="language-Python">def set_score(self, score):
    self.score = score
Student.set_score = set_score
</code></pre>
<p>给class绑定方法后，所有实例均可调用.<br>
通常情况下，上面的<code>set_score</code>方法可以直接定义在<code>class</code>中，但动态绑定允许我们在程序运行的过程中动态给<code>class</code>加上功能，这在静态语言中很难实现。<br>
限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。<br>
为了达到限制的目的，<code>Python</code>允许在定义<code>class</code>的时候，定义一个特殊的<code>__slots__</code>变量，来限制该<code>class</code>实例能添加的属性：</p>
<pre><code class="language-Python">class Student(object):
    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
```Python
s = Student() # 创建新的实例
s.name = 'Michael' # 绑定属性'name'
s.age = 25 # 绑定属性'age'
s.score = 99 # 绑定属性'score'
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>由于<code>'score'</code>没有被放到_<code>_slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p>
<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：</p>
<pre><code class="language-Python">class GraduateStudent(Student):
    pass
g = GraduateStudent()
g.score = 9999
</code></pre>
<p>除非在子类中也定义<code>__slots__</code>，这样，子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<h4 id="多重继承">多重继承</h4>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200318023741.png" alt="" loading="lazy"></figure>
<pre><code class="language-Python">class Animal(object):
    pass
#大类:
class Mammal(Animal):
    pass
class Bird(Animal):
    pass
#各种动物:
class Dog(Mammal):
    pass
class Bat(Mammal):
    pass
class Parrot(Bird):
    pass
class Ostrich(Bird):
    pass
</code></pre>
<p>现在，我们要给动物再加上<code>Runnable</code>和<code>Flyable</code>的功能，只需要先定义好<code>Runnable</code>和<code>Flyable</code>的类：</p>
<pre><code class="language-Python">class Runnable(object):
    def run(self):
        print('Running...')

class Flyable(object):
    def fly(self):
        print('Flying...')
</code></pre>
<p>对于需要<code>Runnable</code>功能的动物，就多继承一个<code>Runnable</code>，例如<code>Dog</code>：</p>
<pre><code class="language-Python">class Dog(Mammal, Runnable):
    pass
</code></pre>
<p>对于需要<code>Flyable</code>功能的动物，就多继承一个<code>Flyable</code>，例如<code>Bat</code>：</p>
<pre><code class="language-Python">class Bat(Mammal, Flyable):
    pass
</code></pre>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。<br>
在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>为了更好地看出继承关系，我们把<code>Runnable</code>和<code>Flyable</code>改为<code>RunnableMixIn</code>和<code>FlyableMixIn</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixIn</code>和植食动物<code>HerbivoresMixIn</code>，让某个动物同时拥有好几个<code>MixIn</code>：</p>
<pre><code class="language-Python">class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
</code></pre>
<p><code>MixIn</code>的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个<code>MixIn</code>的功能，而不是设计多层次的复杂的继承关系。</p>
<p><code>Python</code>自带的很多库也使用了<code>MixIn</code>。举个例子，<code>Python</code>自带了<code>TCPServer</code>和<code>UDPServer</code>这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由<code>ForkingMixIn</code>和<code>ThreadingMixIn</code>提供。通过组合，我们就可以创造出合适的服务来。</p>
<p>比如，编写一个多进程模式的<code>TCP</code>服务，定义如下：</p>
<pre><code class="language-Python">class MyTCPServer(TCPServer, ForkingMixIn):
    pass
</code></pre>
<p>编写一个多线程模式的<code>UDP</code>服务，定义如下：</p>
<pre><code class="language-Python">class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
</code></pre>
<p>如果你打算搞一个更先进的协程模型，可以编写一个<code>CoroutineMixIn</code>：</p>
<pre><code class="language-Python">class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
</code></pre>
<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。<br>
由于<code>Python</code>允许使用多重继承，因此，<code>MixIn</code>就是一种常见的设计。<br>
只允许单一继承的语言（如<code>Java</code>）不能使用<code>MixIn</code>的设计。</p>
<ul>
<li>若是父类中有相同的方法名，而在子类使用时未指定，<code>Python</code>从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</li>
</ul>
<pre><code class="language-Python">#类定义
class people:
'''
    定义基本属性
    '''
    name = ''
    age = 0
    '''
    定义私有属性,私有属性在类外部无法直接进行访问
    '''
    __weight = 0
    '''
    定义构造方法
    '''
    def __init__(self,n,a,w):
        self.name = n
        self.age = a
        self.__weight = w
    def speak(self):
        print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))
'''
单继承示例
'''
class student(people):
    grade = ''
    def __init__(self,n,a,w,g):
    '''
        调用父类的构函
        '''
        people.__init__(self,n,a,w)
        self.grade = g
    '''
    覆写父类的方法
    '''
    def speak(self):
        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))
''' 
另一个类，多重继承之前的准备
'''
class speaker():
    topic = ''
    name = ''
    def __init__(self,n,t):
        self.name = n
        self.topic = t
    def speak(self):
        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))
'''
多重继承
'''
class sample(speaker,student):
    a =''
    def __init__(self,n,a,w,g,t):
        student.__init__(self,n,a,w,g)
        speaker.__init__(self,n,t)
 
test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)
test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法
我叫 Tim，我是一个演说家，我演讲的主题是 Python
</code></pre>
<ul>
<li><code>super()</code><br>
如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：</li>
</ul>
<pre><code class="language-Python">class Parent:        # 定义父类
   def myMethod(self):
      print ('调用父类方法')
 
class Child(Parent): # 定义子类
   def myMethod(self):
      print ('调用子类方法')
 
c = Child()          # 子类实例
c.myMethod()         # 子类调用重写方法
super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法
调用子类方法
调用父类方法
</code></pre>
<p>如果重写了<code>__init__</code>时，要继承父类的构造方法，可以使用 <code>super</code> 关键字：</p>
<pre><code class="language-Python">super(子类，self).__init__(参数1，参数2，....)
</code></pre>
<p>为了调用父类(超类)的一个方法，可以使用 <code>super()</code> 函数，比如：</p>
<pre><code class="language-python">class A:
    def spam(self):
        print('A.spam')
class B(A):
    def spam(self):
        print('B.spam')
        super().spam()  # Call parent spam()
</code></pre>
<p><code>super()</code> 函数的一个常见用法是在 <code>__init__()</code> 方法中确保父类被正确的初始化了：</p>
<pre><code class="language-python">class A:
    def __init__(self):
        self.x = 0
class B(A):
    def __init__(self):
        super().__init__()
        self.y = 1
</code></pre>
<p><code>super()</code> 的另外一个常见用法出现在覆盖<code>Python</code>特殊方法的代码中，比如：</p>
<pre><code class="language-python">class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value) # Call original __setattr__
        else:
            setattr(self._obj, name, value)
</code></pre>
<p>在上面代码中，<code>__setattr__()</code> 的实现包含一个名字检查。 如果某个属性名以下划线<code>(_)</code>开头，就通过 <code>super()</code> 调用原始的 <code>__setattr__()</code> ， 否则的话就委派给内部的代理对象 <code>self._obj</code> 去处理。 这看上去有点意思，因为就算没有显式的指明某个类的父类， <code>super()</code> 仍然可以有效的工作。<br>
实际上，大家对于在<code>Python</code>中如何正确使用 <code>super()</code> 函数普遍知之甚少。 你有时候会看到像下面这样直接调用父类的一个方法：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')
</code></pre>
<p>尽管对于大部分代码而言这么做没什么问题，但是在更复杂的涉及到多继承的代码中就有可能导致很奇怪的问题发生。 比如，考虑如下的情况：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')
class A(Base):
    def __init__(self):
        Base.__init__(self)
        print('A.__init__')

class B(Base):
    def __init__(self):
        Base.__init__(self)
        print('B.__init__')

class C(A,B):
    def __init__(self):
        A.__init__(self)
        B.__init__(self)
        print('C.__init__')
</code></pre>
<p>如果你运行这段代码就会发现 <code>Base.__init__()</code> 被调用两次，如下所示：</p>
<pre><code>c = C()
Base.__init__
A.__init__
Base.__init__
B.__init__
C.__init__
</code></pre>
<p>可能两次调用 <code>Base.__init__()</code> 没什么坏处，但有时候却不是。 另一方面，假设你在代码中换成使用 <code>super()</code> ，结果就很完美了：</p>
<pre><code class="language-python">class Base:
    def __init__(self):
        print('Base.__init__')

class A(Base):
    def __init__(self):
        super().__init__()
        print('A.__init__')

class B(Base):
    def __init__(self):
        super().__init__()
        print('B.__init__')

class C(A,B):
    def __init__(self):
        super().__init__()  # Only one call to super() here
        print('C.__init__')
</code></pre>
<p>运行这个新版本后，你会发现每个 <code>__init__()</code> 方法只会被调用一次了：</p>
<pre><code class="language-python">c = C()
Base.__init__
B.__init__
A.__init__
C.__init__
</code></pre>
<p>为了弄清它的原理，我们需要花点时间解释下<code>Python</code>是如何实现继承的。 对于你定义的每一个类，<code>Python</code>会计算出一个所谓的方法解析顺序(<code>MRO</code>)列表。 这个<code>MRO</code>列表就是一个简单的所有基类的线性顺序表。例如：</p>
<pre><code class="language-python">C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,
&lt;class '__main__.Base'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>为了实现继承，<code>Python</code>会在<code>MRO</code>列表上从左到右开始查找基类，直到找到第一个匹配这个属性的类为止。</p>
<p>而这个<code>MRO</code>列表的构造是通过一个<code>C3</code>线性化算法来实现的。 我们不去深究这个算法的数学原理，它实际上就是合并所有父类的<code>MRO</code>列表并遵循如下三条准则：</p>
<ol>
<li>子类会先于父类被检查</li>
<li>多个父类会根据它们在列表中的顺序被检查</li>
<li>如果对下一个类存在两个合法的选择，选择第一个父类</li>
<li>老实说，你所要知道的就是<code>MRO</code>列表中的类顺序会让你定义的任意类层级关系变得有意义。</li>
</ol>
<p>当你使用 <code>super()</code> 函数时，<code>Python</code>会在<code>MRO</code>列表上继续搜索下一个类。 只要每个重定义的方法统一使用 <code>super()</code> 并只调用它一次， 那么控制流最终会遍历完整个<code>MRO</code>列表，每个方法也只会被调用一次。 这也是为什么在第二个例子中你不会调用两次 <code>Base.__init__()</code> 的原因。</p>
<p><code>super()</code> 有个令人吃惊的地方是它并不一定去查找某个类在<code>MRO</code>中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类：</p>
<pre><code class="language-python">class A:
    def spam(self):
        print('A.spam')
        super().spam()
</code></pre>
<p>如果你试着直接使用这个类就会出错：</p>
<pre><code class="language-python">a = A()
a.spam()
Traceback (most recent call last):
    File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
    File &quot;&lt;stdin&gt;&quot;, line 4, in spam
AttributeError: 'super' object has no attribute 'spam'
</code></pre>
<p>但是，如果你使用多继承的话看看会发生什么：</p>
<pre><code class="language-python">class B:
    def spam(self):
        print('B.spam')
class C(A,B):
    pass
c = C()
c.spam()
A.spam
B.spam
</code></pre>
<p>你可以看到在类A中使用 <code>super().spam()</code> 实际上调用的是跟类<code>A</code>毫无关系的类<code>B</code>中的 <code>spam()</code> 方法。 这个用类<code>C</code>的<code>MRO</code>列表就可以完全解释清楚了：</p>
<pre><code class="language-python">C.__mro__
(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;,
&lt;class 'object'&gt;)
</code></pre>
<p>在定义混入类的时候这样使用 <code>super()</code> 是很普遍的。</p>
<p>然而，由于 <code>super()</code> 可能会调用不是你想要的方法，你应该遵循一些通用原则。 首先，确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 <code>super()</code> 调用一个非直接父类方法时不会出错。 其次，最好确保最顶层的类提供了这个方法的实现，这样的话在<code>MRO</code>上面的查找链肯定可以找到某个确定的方法。</p>
<h4 id="定制类">定制类</h4>
<h5 id="__str__"><code>__str__</code></h5>
<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
print(Student('Michael'))
&lt;__main__.Student object at 0x109afb190&gt;
</code></pre>
<p>打印出一堆<code>&lt;__main__.Student object at 0x109afb190&gt;</code>，不好看。<br>
怎么才能打印得好看呢？只需要定义好<code>__str__()</code>方法，返回一个好看的字符串就可以了：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name: %s)' % self.name
print(Student('Michael'))
Student object (name: Michael)
</code></pre>
<p>这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br>
但是细心的朋友会发现直接敲变量不用<code>print</code>，打印出来的实例还是不好看：</p>
<pre><code class="language-Python">s = Student('Michael')
s
&lt;__main__.Student object at 0x109afb310&gt;
</code></pre>
<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>
<p>解决办法是再定义一个<code>__repr__()</code>。但是通常<code>__str__()</code>和<code>__repr__()</code>代码都是一样的，所以，有个偷懒的写法：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return 'Student object (name=%s)' % self.name
    __repr__ = __str__
</code></pre>
<h5 id="__iter__"><code>__iter__</code></h5>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，<code>Python</code>的<code>for</code>循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到<code>StopIteration</code>错误时退出循环。<br>
我们以斐波那契数列为例，写一个<code>Fib</code>类，可以作用于<code>for</code>循环：</p>
<pre><code class="language-Python">class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b
    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己
    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
</code></pre>
<p>现在，试试把<code>Fib</code>实例作用于<code>for</code>循环：</p>
<pre><code class="language-Python">for n in Fib():
    print(n)
1
1
2
3
5
...
46368
75025
</code></pre>
<h5 id="__getitem__"><code>__getitem__</code></h5>
<p><code>Fib</code>实例虽然能作用于<code>for</code>循环，看起来和<code>list</code>有点像，但是，把它当成<code>list</code>来使用还是不行,要表现得像<code>list</code>那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>
<pre><code class="language-Python">class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a
f = Fib()
f[0]
1
f[1]
1
f[2]
2
f[3]
3
f[10]
89
f[100]
573147844013817084101
class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
f = Fib()
f[0:5]
[1, 1, 2, 3, 5]
f[:10]
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]
</code></pre>
<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作<code>key</code>的<code>object</code>，例如<code>str</code>。<br>
与之对应的是<code>__setitem__()</code>方法，把对象视作<code>list</code>或<code>dict</code>来对集合赋值。最后，还有一个<code>__delitem__()</code>方法，用于删除某个元素。<br>
总之，通过上面的方法，我们自己定义的类表现得和<code>Python</code>自带的<code>list</code>、<code>tuple</code>、<code>dict</code>没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。</p>
<h5 id="__getattr__"><code>__getattr__</code></h5>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。比如定义<code>Student</code>类：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self):
        self.name = 'Michael'
</code></pre>
<p>调用<code>name</code>属性，没问题，但是，调用不存在的<code>score</code>属性，就有问题了：</p>
<pre><code class="language-Python">s = Student()
print(s.name)
Michael
print(s.score)
Traceback (most recent call last):
AttributeError: 'Student' object has no attribute 'score'
</code></pre>
<p>错误信息很清楚地告诉我们，没有找到<code>score</code>这个<code>attribute</code>。</p>
<p>要避免这个错误，除了可以加上一个<code>score</code>属性外，<code>Python</code>还有另一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性。修改如下：</p>
<pre><code class="language-Python">class Student(object):

    def __init__(self):
        self.name = 'Michael'

    def __getattr__(self, attr):
        if attr=='score':
            return 99
</code></pre>
<p>当调用不存在的属性时，比如<code>score</code>，<code>Python</code>解释器会试图调用<code>__getattr__(self, 'score')</code>来尝试获得属性，这样，我们就有机会返回<code>score</code>的值。<br>
返回函数也是完全可以的：</p>
<pre><code class="language-oython">class Student(object):
    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
</code></pre>
<p>只是调用方式要变为：</p>
<pre><code class="language-Python">s.age()
25
</code></pre>
<p>注意，只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在_<code>_getattr__</code>中查找。<br>
此外，注意到任意调用如<code>s.abc</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。要让<code>class</code>只响应特定的几个属性，我们就要按照约定，抛出<code>AttributeError</code>的错误：</p>
<pre><code class="language-Python">class Student(object):

    def __getattr__(self, attr):
        if attr=='age':
            return lambda: 25
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)
</code></pre>
<p>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<h5 id="__call__"><code>__call__</code></h5>
<p>一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用<code>instance.method()</code>来调用。能不能直接在实例本身上调用呢？在<code>Python</code>中，答案是肯定的。<br>
任何类，只需要定义一个<code>__call__()</code>方法，就可以直接对实例进行调用。请看示例：</p>
<pre><code class="language-Python">class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print('My name is %s.' % self.name)
调用方式如下：
```Python
s = Student('Michael')
s() # self参数不要传入
My name is Michael.
</code></pre>
<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。<br>
如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。<br>
那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，比如函数和我们上面定义的带有<code>__call__()</code>的类实例。<br>
通过<code>callable()</code>函数，我们就可以判断一个对象是否是“可调用”对象。</p>
<h5 id="实现比较操作">实现比较操作</h5>
<p><code>Python</code>类对每个比较操作都需要实现一个特殊方法来支持。 例如为了支持<code>&gt;=</code>操作符，你需要定义一个 <code>__ge__()</code> 方法。 尽管定义一个方法没什么问题，但如果要你实现所有可能的比较方法那就有点烦人了。</p>
<p>装饰器 <code>functools.total_ordering</code> 就是用来简化这个处理的。 使用它来装饰一个类，你只需定义一个 <code>__eq__()</code> 方法， 外加其他方法(<code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, or <code>__ge__</code>)中的一个即可。 然后装饰器会自动为你填充其它比较方法。<br>
作为例子，我们构建一些房子，然后给它们增加一些房间，最后通过房子大小来比较它们：</p>
<pre><code class="language-python">from functools import total_ordering

class Room:
    def __init__(self, name, length, width):
        self.name = name
        self.length = length
        self.width = width
        self.square_feet = self.length * self.width

@total_ordering
class House:
    def __init__(self, name, style):
        self.name = name
        self.style = style
        self.rooms = list()

    @property
    def living_space_footage(self):
        return sum(r.square_feet for r in self.rooms)

    def add_room(self, room):
        self.rooms.append(room)

    def __str__(self):
        return '{}: {} square foot {}'.format(self.name,
                self.living_space_footage,
                self.style)

    def __eq__(self, other):
        return self.living_space_footage == other.living_space_footage

    def __lt__(self, other):
        return self.living_space_footage &lt; other.living_space_footage
</code></pre>
<p>这里我们只是给<code>House</code>类定义了两个方法：<code>__eq__()</code> 和 <code>__lt__()</code> ，它就能支持所有的比较操作：</p>
<pre><code class="language-python">'''
Build a few houses, and add rooms to them
'''
h1 = House('h1', 'Cape')
h1.add_room(Room('Master Bedroom', 14, 21))
h1.add_room(Room('Living Room', 18, 20))
h1.add_room(Room('Kitchen', 12, 16))
h1.add_room(Room('Office', 12, 12))
h2 = House('h2', 'Ranch')
h2.add_room(Room('Master Bedroom', 14, 21))
h2.add_room(Room('Living Room', 18, 20))
h2.add_room(Room('Kitchen', 12, 16))
h3 = House('h3', 'Split')
h3.add_room(Room('Master Bedroom', 14, 21))
h3.add_room(Room('Living Room', 18, 20))
h3.add_room(Room('Office', 12, 16))
h3.add_room(Room('Kitchen', 15, 17))
houses = [h1, h2, h3]
print('Is h1 bigger than h2?', h1 &gt; h2) # prints True
print('Is h2 smaller than h3?', h2 &lt; h3) # prints True
print('Is h2 greater than or equal to h1?', h2 &gt;= h1) # Prints False
print('Which one is biggest?', max(houses)) # Prints 'h3: 1101-square-foot Split'
print('Which is smallest?', min(houses)) # Prints 'h2: 846-square-foot Ranch'
</code></pre>
<p>其实 <code>total_ordering</code> 装饰器也没那么神秘。 它就是定义了一个从每个比较支持方法到所有需要定义的其他方法的一个映射而已。 比如你定义了 <code>__le__()</code> 方法，那么它就被用来构建所有其他的需要定义的那些特殊方法。 实际上就是在类里面像下面这样定义了一些特殊方法：</p>
<pre><code class="language-python">class House:
    def __eq__(self, other):
        pass
    def __lt__(self, other):
        pass
    # Methods created by @total_ordering
    __le__ = lambda self, other: self &lt; other or self == other
    __gt__ = lambda self, other: not (self &lt; other or self == other)
    __ge__ = lambda self, other: not (self &lt; other)
    __ne__ = lambda self, other: not self == other
</code></pre>
<p>当然，你自己去写也很容易，但是使用 <code>@total_ordering</code> 可以简化代码，何乐而不为呢。</p>
<h4 id="枚举类">枚举类</h4>
<pre><code class="language-Python">from enum import Enum
Month = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))
</code></pre>
<p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p>
<pre><code class="language-Python">for name, member in Month.__members__.items():
    print(name, '=&gt;', member, ',', member.value)
</code></pre>
<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从1开始计数。<br>
如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<pre><code class="language-Python">from enum import Enum, unique
@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
</code></pre>
<p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。<br>
访问这些枚举类型可以有若干种方法：</p>
<pre><code class="language-Python">day1 = Weekday.Mon
print(day1)
Weekday.Mon
print(Weekday.Tue)
Weekday.Tue
print(Weekday['Tue'])
Weekday.Tue
print(Weekday.Tue.value)
2
rint(day1 == Weekday.Mon)
True
print(day1 == Weekday.Tue)
False
rint(Weekday(1))
Weekday.Mon
print(day1 == Weekday(1))
True
Weekday(7)
Traceback (most recent call last):
ValueError: 7 is not a valid Weekday
for name, member in Weekday.__members__.items():
    print(name, '=&gt;', member)
Sun =&gt; Weekday.Sun
Mon =&gt; Weekday.Mon
Tue =&gt; Weekday.Tue
Wed =&gt; Weekday.Wed
Thu =&gt; Weekday.Thu
Fri =&gt; Weekday.Fri
Sat =&gt; Weekday.Sat
</code></pre>
<p>可见，既可以用成员名称引用枚举常量，又可以直接根据<code>value</code>的值获得枚举常量。<br>
<code>Enum</code>可以把一组相关常量定义在一个<code>class</code>中，且<code>class</code>不可变，而且成员可以直接比较。</p>
<h4 id="使用元类">使用元类</h4>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。<br>
比方说我们要定义一个<code>Hello</code>的<code>class</code>，就写一个<code>hello.py</code>模块：</p>
<pre><code class="language-Python">class Hello(object):
    def hello(self, name='world'):
        print('Hello, %s.' % name)
</code></pre>
<p>当<code>Python</code>解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的<code>class</code>对象，测试如下：</p>
<pre><code class="language-Python">from hello import Hello
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class 'hello.Hello'&gt;
</code></pre>
<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个<code>class</code>，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</p>
<p>我们说<code>class</code>的定义是运行时动态创建的，而创建<code>class</code>的方法就是使用<code>type()</code>函数。</p>
<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)</code>...的定义：</p>
<pre><code class="language-Python">def fn(self, name='world'): # 先定义函数
    print('Hello, %s.' % name)
Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class
h = Hello()
h.hello()
Hello, world.
print(type(Hello))
&lt;class 'type'&gt;
print(type(h))
&lt;class '__main__.Hello'&gt;
</code></pre>
<p>要创建一个<code>class</code>对象，<code>type()</code>函数依次传入3个参数：<br>
<code>class</code>的名称；<br>
继承的父类集合，注意<code>Python</code>支持多重继承，如果只有一个父类，别忘了<code>tuple</code>的单元素写法；<br>
class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。<br>
通过<code>type()</code>函数创建的类和直接写<code>class</code>是完全一样的，因为<code>Python</code>解释器遇到<code>class</code>定义时，仅仅是扫描一下<code>class</code>定义的语法，然后调用<code>type()</code>函数创建出<code>class</code>。<br>
正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。<br>
<code>metaclass</code><br>
除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用<code>metaclass</code>。<br>
<code>metaclass</code>，直译为元类，简单的解释就是：<br>
当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。<br>
但是如果我们想创建出类呢？那就必须根据<code>metaclass</code>创建出类，所以：先定义<code>metaclass</code>，然后创建类。<br>
连接起来就是：先定义<code>metaclass</code>，就可以创建类，最后创建实例。<br>
所以，<code>metaclass</code>允许你创建类或者修改类。换句话说，你可以把类看成是<code>metaclass</code>创建出来的“实例”。</p>
<p><code>metaclass</code>是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用<code>metaclass</code>的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。<br>
我们先看一个简单的例子，这个<code>metaclass</code>可以给我们自定义的<code>MyList</code>增加一个<code>add</code>方法：</p>
<p>定义<code>ListMetaclass</code>，按照默认习惯，<code>metaclass</code>的类名总是以<code>Metaclass</code>结尾，以便清楚地表示这是一个<code>metaclass</code>：</p>
<pre><code class="language-Python">'''
metaclass是类的模板，所以必须从type类型派生：
'''
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        attrs['add'] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
有了`ListMetaclass`，我们在定义类的时候还要指示使用`ListMetaclass`来定制类，传入关键字参数`metaclass`：
```Python
class MyList(list, metaclass=ListMetaclass):
    pass
</code></pre>
<p>当我们传入关键字参数<code>metaclass</code>时，魔术就生效了，它指示<code>Python</code>解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。<br>
<code>__new__()</code>方法接收到的参数依次是：<br>
当前准备创建的类的对象；<br>
类的名字；<br>
类继承的父类集合；<br>
类的方法集合。<br>
测试一下MyList是否可以调用add()方法：</p>
<pre><code class="language-Python">L = MyList()
L.add(1)
L
[1]
</code></pre>
<p>而普通的list没有<code>add()</code>方法：</p>
<pre><code class="language-Python">L2 = list()
L2.add(1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
AttributeError: 'list' object has no attribute 'add'
</code></pre>
<p>动态修改有什么意义？直接在<code>MyList</code>定义中写上<code>add()</code>方法不是更简单吗？正常情况下，确实应该直接写，通过<code>metaclass</code>修改纯属变态。</p>
<h2 id="命名空间和作用域">命名空间和作用域</h2>
<h3 id="三种命名空间">三种命名空间：</h3>
<ul>
<li>内置名称(<code>built-in names</code>)， <code>Python</code> 语言内置的名称，比如函数名 <code>abs</code>、<code>char</code> 和异常名称 <code>BaseException</code>、<code>Exception</code> 等等。</li>
<li>全局名称(<code>global names</code>)，模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</li>
<li>局部名称(<code>local names</code>)，函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）<br>
<code>Python</code> 的查找顺序为：<strong>局部的命名空间</strong> -&gt; <strong>全局命名空间</strong> -&gt; <strong>内置命名空间</strong>。</li>
</ul>
<h4 id="四种作用域">四种作用域：</h4>
<ul>
<li>L(Local)：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li>E(Enclosing)：包含了非局部(<code>non-local</code>)也非全局(<code>non-global</code>)的变量。比如两个嵌套函数，一个函数（或类） <code>A</code> 里面又包含了一个函数 <code>B</code> ，那么对于<code>B</code> 中的名称来说 <code>A</code> 中的作用域就为 <code>nonlocal</code>。</li>
<li>G(<code>Global</code>)：当前脚本的最外层，比如当前模块的全局变量。</li>
<li>B(<code>Built-in</code>)： 包含了内建的变量/关键字等。最后被搜索。<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200320015425.png" alt="" loading="lazy"><br>
<code>Python</code> 中只有模块(<code>module</code>)，类(<code>class</code>)以及函数(<code>def</code>、<code>lambda</code>)才会引入新的作用域，其它的代码块(如 <code>if</code>/<code>elif</code>/<code>else</code>/、<code>try</code>/<code>except</code>、<code>for</code>/<code>while</code>等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</li>
</ul>
<pre><code class="language-Python">if True:
    msg = 'I am from Runoob'
msg
'I am from Runoob'
</code></pre>
<p>实例中 <code>msg</code> 变量定义在 <code>if</code> 语句块中，但外部还是可以访问的。<br>
如果将 <code>msg</code> 定义在函数中，则它就是局部变量，外部不能访问：</p>
<pre><code class="language-Python">def test():
    msg_inner = 'I am from Runoob'
msg_inner
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'msg_inner' is not defined
</code></pre>
<p>从报错的信息上看，说明了 <code>msg_inner</code> 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="global-和-nonlocal关键字"><code>global</code> 和 <code>nonlocal</code>关键字</h4>
<pre><code class="language-Python">num = 1
def fun1():
    global num  # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
fun1()
print(num)
1
123
123
</code></pre>
<p>如果要修改嵌套作用域(<code>enclosing</code> 作用域，外层非全局作用域)中的变量则需要 <code>nonlocal</code> 关键字了，如下实例：</p>
<pre><code class="language-Python">def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
outer()
100
100
</code></pre>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<pre><code class="language-Python">a = 10
def test():
    a = a + 1
    print(a)
test()
Traceback (most recent call last):
  File &quot;test.py&quot;, line 7, in &lt;module&gt;
    test()
  File &quot;test.py&quot;, line 5, in test
    a = a + 1
UnboundLocalError: local variable 'a' referenced before assignment
</code></pre>
<p>错误信息为局部作用域引用错误，因为 <code>test</code> 函数中的 <code>a</code> 使用的是局部，未定义，无法修改。<br>
修改 <code>a</code> 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<pre><code class="language-Python">a = 10
def test(a):
    a = a + 1
    print(a)
test(a)
11
</code></pre>
<h2 id="错误和异常处理">错误和异常处理</h2>
<pre><code class="language-Python">def attempt_float(x):
    try:
        return float(x)
    except ValueError:
        return x
</code></pre>
<p>某些情况下，你可能不想抑制异常，你想无论<code>try</code>部分的代码是否成功，都执行一段代码。可以使用<code>finally</code>：</p>
<pre><code class="language-Python">f = open(path, 'w')

try:
    write_to_file(f)
finally:
    f.close()
</code></pre>
<p>这里，文件处理<code>f</code>总会被关闭。相似的，你可以用<code>else</code>让只在<code>try</code>部分成功的情况下，才执行代码：</p>
<pre><code class="language-Python">f = open(path, 'w')
try:
    write_to_file(f)
except:
    print('Failed')
else:
    print('Succeeded')
finally:
    f.close()
</code></pre>
<ul>
<li>可以有多个<code>except</code>来捕获不同类型的错误：</li>
</ul>
<pre><code class="language-Python">try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
</code></pre>
<ul>
<li>Python的错误其实也是<code>class</code>，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</li>
</ul>
<pre><code class="language-Python">try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
第二个`except`永远也捕获不到`UnicodeError`，因为`UnicodeError`是`ValueError`的子类，如果有，也被第一个`except`给捕获了。
</code></pre>
<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()</code>调用<code>foo()</code>，<code>foo()</code>调用<code>bar()</code>，结果<code>bar()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>
<pre><code class="language-Python">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
</code></pre>
<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>
<pre><code class="language-Python">def foo(s):
    n = int(s)
    if n==0:
        raise ValueError('invalid value: %s' % s)
    return 10 / n

def bar():
    try:
        foo('0')
    except ValueError as e:
        print('ValueError!')
        raise
bar()
</code></pre>
<p>在<code>bar()</code>函数中，我们明明已经捕获了错误，但是，打印一个<code>ValueError!</code>后，又把错误通过<code>raise</code>语句抛出去。<br>
这种错误处理方式相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>
<p><code>raise</code>语句如果不带参数，就会把当前错误原样抛出。此外，在<code>except</code>中<code>raise</code>一个<code>Error</code>，还可以把一种类型的错误转化成另一种类型：</p>
<pre><code class="language-Python">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError('input error!')
</code></pre>
<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code>。</p>
<ul>
<li><code>Python</code> 使用 <code>raise</code> 语句抛出一个指定的异常。<br>
<code>raise</code>语法格式如下：</li>
</ul>
<pre><code class="language-Python">raise [Exception [, args [, traceback]]]
</code></pre>
<p>以下实例如果 x 大于 5 就触发异常:</p>
<pre><code>x = 10
if x &gt; 5:
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
</code></pre>
<p>执行以上代码会触发异常：</p>
<pre><code class="language-Python">Traceback (most recent call last):
  File &quot;test.py&quot;, line 3, in &lt;module&gt;
    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))
Exception: x 不能大于 5。x 的值为: 10
</code></pre>
<p><code>raise</code> 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 <code>Exception</code> 的子类）。<br>
如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 <code>raise</code> 语句就可以再次把它抛出。</p>
<pre><code class="language-Python">try:
    raise NameError('HiThere')
except NameError:
    print('An exception flew by!')
    raise
An exception flew by!
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in ?
NameError: HiThere
</code></pre>
<h3 id="调试">调试</h3>
<ul>
<li>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>(assert)</code>来替代：</li>
</ul>
<pre><code class="language-Python">def foo(s):
    n = int(s)
    assert n != 0, 'n is zero!'
    return 10 / n
def main():
    foo('0')
</code></pre>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。<br>
如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>
<pre><code class="language-shell">$ Python err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
</code></pre>
<ul>
<li><code>logging</code><br>
把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</li>
</ul>
<pre><code class="language-Python">import logging
logging.basicConfig(level=logging.INFO)
s = '0'
n = int(s)
logging.info('n = %d' % n)
print(10 / n)
</code></pre>
<pre><code class="language-shell">$ Python err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &quot;err.py&quot;, line 8, in &lt;module&gt;
    print(10 / n)
ZeroDivisionError: division by zero
</code></pre>
<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug</code>和<code>info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。<br>
<code>logging</code>的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如<code>console</code>和文件。</p>
<h2 id="文件和操作系统">文件和操作系统</h2>
<ul>
<li>为了打开一个文件以便读写，可以使用内置的<code>open</code>函数以及一个相对或绝对的文件路径：</li>
</ul>
<pre><code class="language-Python">path = 'examples/segismundo.txt'
f = open(path)
</code></pre>
<ul>
<li>默认情况下，文件是以只读模式<code>('r')</code>打开的。然后，我们就可以像处理列表那样来处理这个文件句柄<code>f</code>了，比如对行进行迭代：</li>
</ul>
<pre><code class="language-Python">for line in f:
    pass
</code></pre>
<ul>
<li>如果使用<code>open</code>创建文件对象，一定要用<code>close</code>关闭它。关闭文件可以返回操作系统资源：</li>
</ul>
<pre><code class="language-Python">f.close()
</code></pre>
<ul>
<li>用<code>with</code>语句可以可以更容易地清理打开的文件,这样可以在退出代码块时，自动关闭文件：</li>
</ul>
<pre><code>with open(path) as f:
    lines = [x.rstrip() for x in f]
</code></pre>
<ul>
<li>读写模式：<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211525.png" alt="" loading="lazy"></li>
<li>向文件写入，可以使用文件的<code>write</code>或<code>writelines</code>方法。例如，我们可以创建一个无空行版的<code>prof_mod.py</code>：</li>
</ul>
<pre><code class="language-Python">with open('tmp.txt', 'w') as handle:
    handle.writelines(x for x in open(path) if len(x) &gt; 1)
with open('tmp.txt') as f:
    lines = f.readlines()
</code></pre>
<pre><code class="language-Python">with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
</code></pre>
<p>要写入特定编码的文本文件，请给<code>open()</code>函数传入<code>encoding</code>参数，将字符串自动转换成指定编码。<br>
以<code>'w'</code>模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件）。如果我们希望追加到文件末尾怎么办？可以传入<code>'a'</code>以追加<code>(append)</code>模式写入。</p>
<ul>
<li>调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。</li>
<li>常用文件方法<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317211726.png" alt="" loading="lazy"></li>
</ul>
<h3 id="操作文件和目录">操作文件和目录</h3>
<p>操作文件和目录的函数一部分放在<code>os</code>模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>
<ul>
<li>查看当前目录的绝对路径:</li>
</ul>
<pre><code class="language-Python">os.path.abspath('.')
'/Users/michael'
- 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:
````Python
os.path.join('/Users/michael', 'testdir')
'/Users/michael/testdir'
</code></pre>
<ul>
<li>创建一个目录:</li>
</ul>
<pre><code class="language-Python">os.mkdir('/Users/michael/testdir')
</code></pre>
<ul>
<li>删掉一个目录:</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>os.rmdir('/Users/michael/testdir')<br>
把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符.<br>
同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名：</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code class="language-Python">os.path.split('/Users/michael/testdir/file.txt')

('/Users/michael/testdir', 'file.txt')
</code></pre>
<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>
<pre><code class="language-Python">os.path.splitext('/path/to/file.txt')
('/path/to/file', '.txt')
</code></pre>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。<br>
文件操作使用下面的函数。假定当前目录下有一个<code>test.txt</code>文件：</p>
<ul>
<li>对文件重命名:</li>
</ul>
<pre><code>os.rename('test.txt', 'test.py')
</code></pre>
<ul>
<li>删掉文件:</li>
</ul>
<pre><code class="language-Python">os.remove('test.py')
</code></pre>
<p><code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>
<h3 id="序列化">序列化</h3>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>
<pre><code class="language-Python">f = open('dump.txt', 'wb')
pickle.dump(d, f)
f.close()
</code></pre>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象：</p>
<pre><code class="language-Python">f = open('dump.txt', 'rb')
d = pickle.load(f)
f.close()
d
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<pre><code class="language-Python">import json
d = dict(name='Bob', age=20, score=88)
json.dumps(d)
'{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
</code></pre>
<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的<code>JSON</code>。类似的，<code>dump()</code>方法可以直接把<code>JSON</code>写入一个<code>file-like Object</code>。</p>
<p>要把<code>JSON</code>反序列化为<code>Python</code>对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把<code>JSON</code>的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>
<pre><code class="language-Python"> json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
&gt;&gt;&gt; json.loads(json_str)
{'age': 20, 'score': 88, 'name': 'Bob'}
</code></pre>
<p><code>Python</code>的<code>dict</code>对象可以直接序列化为<code>JSON</code>的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>
<pre><code class="language-Python">import json
class Student(object):
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
s = Student('Bob', 20, 88)
print(json.dumps(s))
</code></pre>
<p>运行代码，毫不留情地得到一个<code>TypeError</code>：</p>
<pre><code class="language-Python">Traceback (most recent call last):
  ...
TypeError: &lt;__main__.Student object at 0x10603cc50&gt; is not JSON serializable
</code></pre>
<p>错误的原因是<code>Student</code>对象不是一个可序列化为<code>JSON</code>的对象。<br>
前面的代码之所以无法把<code>Student</code>类实例序列化为<code>JSON</code>，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个<code>JSON</code>的<code>{}</code>对象。<br>
可选参数<code>default</code>就是把任意一个对象变成一个可序列为<code>JSON</code>的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>
<pre><code class="language-Python">def student2dict(std):
    return {
        'name': std.name,
        'age': std.age,
        'score': std.score
    }
</code></pre>
<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>：</p>
<pre><code class="language-Python">print(json.dumps(s, default=student2dict))
{&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88}
</code></pre>
<p>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</p>
<pre><code class="language-Python">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的<code>class</code>。<br>
同样的道理，如果我们要把<code>JSON</code>反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>
<pre><code class="language-Python">def dict2student(d):
    return Student(d['name'], d['age'], d['score'])
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-Python">json_str = '{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}'
print(json.loads(json_str, object_hook=dict2student))
&lt;__main__.Student object at 0x10cd3c190&gt;
</code></pre>
<p>打印出的是反序列化的<code>Student</code>实例对象。</p>
<h2 id="标准库">标准库</h2>
<h3 id="collections"><code>collections</code></h3>
<h4 id="namedtuple"><code>namedtuple</code></h4>
<pre><code class="language-Python">from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
p.x
1
p.y
2
</code></pre>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。<br>
这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<h4 id="deque"><code>deque</code></h4>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>
<pre><code class="language-Python">from collections import deque
q = deque(['a', 'b', 'c'])
q.append('x')
q.appendleft('y')
q
deque(['y', 'a', 'b', 'c', 'x'])
q.clear()# 清除所有元素
q.count(x)# 计算x的个数
q.remove(value)#移除找到的第一个 value。
q.reverse()#逆序排列
</code></pre>
<p><code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<h4 id="defaultdict"><code>defaultdict</code></h4>
<p>使用<code>dict</code>时，如果引用的<code>Key</code>不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>
<pre><code class="language-Python">from collections import defaultdict
dd = defaultdict(lambda: 'N/A')
dd['key1'] = 'abc'
dd['key1'] # key1存在
'abc'
dd['key2'] # key2不存在，返回默认值
'N/A'
</code></pre>
<pre><code class="language-Python">from collections import deque

dlist=deque([1,'a'])
dlist.append('b') # 在末尾加数据
dlist.appendleft(0) # 在最前端插入数据
print(dlist)# 输出 :  deque([0, 1, 'a', 'b'])

dlist.pop() # 删除末尾的数据
dlist.popleft() # 删除最前端的数据
print(dlist)# 输出 :  deque([1, 'a'])

dlist.extend(['b','c']) # 在末尾追加list 数据
dlist.extendleft([-1,0])# 在前端插入list 数据
print(dlist)# 输出 : deque([0, -1, 1, 'a', 'b', 'c'])
print(dlist.index('a')) # 找出 a 的索引位置,输出 :  3

dlist.insert(2, 555) # 在索引2 的位置插入555
print(dlist)# 输出 :  deque([0, -1, 555, 1, 'a', 'b', 'c'])

print(dlist.count('a')) # 查找 ‘a’ 的数量

dlist.remove(1) # 删除第一个匹配值
dlist.reverse()  # 反向
print(dlist)# 输出 :  deque(['c', 'b', 'a', 555, -1, 0])


dlist.rotate(-2) # 将左端的元素移动到右端
print(dlist)# 输出 :  deque(['a', 555, -1, 0, 'c', 'b'])

dlist.rotate(2) # 将右端的元素移动到左端
print(dlist)# 输出 :  deque(['c', 'b', 'a', 555, -1, 0])

dl1=dlist # 赋值 dlist 值变化，dl1的值也会修改
dl2=dlist.copy() # 拷贝 dlist, 拷贝后对dl修改不影响dlist的值
dlist.pop() # 删除最后一个数据, dl1的值也被修改
print(dl1) # 输出： deque(['c', 'b', 'a', 555, -1])
print(dl2) # 输出： deque(['c', 'b', 'a', 555, -1, 0])
</code></pre>
<ul>
<li>合并字典</li>
</ul>
<p>这是一般的字典合并写法</p>
<pre><code class="language-Python">dic1 = {'x': 1, 'y': 2 }
dic2 = {'y': 3, 'z': 4 }
merged1 = {**dic1, **dic2} # {'x': 1, 'y': 3, 'z': 4}
</code></pre>
<p>修改<code>merged[‘x’]=10</code>，<code>dic1</code>中的<code>x</code>值不变，<code>merged</code>是重新生成的一个新字典。<br>
但是，<code>ChainMap</code>却不同，它在内部创建了一个容纳这些字典的列表。因此使用<code>ChainMap</code>合并字典，修改<code>merged[‘x’]=10</code>后，<code>dic1</code>中的<code>x</code>值改变，如下所示：</p>
<pre><code class="language-Python">from collections import ChainMap
merged2 = ChainMap(dic1,dic2)
print(merged2) # ChainMap({'x': 1, 'y': 2}, {'y': 3, 'z': 4})
</code></pre>
<p>默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>
<h4 id="ordereddict"><code>OrderedDict</code></h4>
<p>使用<code>dict</code>时，<code>Key</code>是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。<br>
如果要保持<code>Key</code>的顺序，可以用<code>OrderedDict</code>：</p>
<pre><code class="language-Python">from collections import OrderedDict
d = dict([('a', 1), ('b', 2), ('c', 3)])
d # dict的Key是无序的
{'a': 1, 'c': 3, 'b': 2}
od = OrderedDict([('a', 1), ('b', 2), ('c', 3)])
od # OrderedDict的Key是有序的
OrderedDict([('a', 1), ('b', 2), ('c', 3)])
</code></pre>
<p>注意，<code>OrderedDict的Key</code>会按照插入的顺序排列，不是<code>Key</code>本身排序：</p>
<pre><code class="language-Python">od = OrderedDict()
od['z'] = 1
od['y'] = 2
od['x'] = 3
list(od.keys()) # 按照插入的Key的顺序返回
['z', 'y', 'x']
</code></pre>
<p><code>OrderedDict</code>可以实现一个<code>FIFO</code>（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的<code>Key</code>：</p>
<pre><code class="language-Python">from collections import OrderedDict
class LastUpdatedOrderedDict(OrderedDict):
    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity
    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print('remove:', last)
        if containsKey:
            del self[key]
            print('set:', (key, value))
        else:
            print('add:', (key, value))
        OrderedDict.__setitem__(self, key, value)
</code></pre>
<h4 id="chainmap"><code>ChainMap</code></h4>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。<br>
什么时候使用<code>ChainMap</code>最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用<code>ChainMap</code>实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。<br>
下面的代码演示了如何查找<code>user</code>和<code>color</code>这两个参数：</p>
<pre><code class="language-Python">from collections import ChainMap
import os, argparse
'''
构造缺省参数:
'''
defaults = {
    'color': 'red',
    'user': 'guest'
}
'''
构造命令行参数:
'''
parser = argparse.ArgumentParser()
parser.add_argument('-u', '--user')
parser.add_argument('-c', '--color')
namespace = parser.parse_args()
command_line_args = { k: v for k, v in vars(namespace).items() if v }
'''
组合成ChainMap:
'''
combined = ChainMap(command_line_args, os.environ, defaults)
'''
打印参数:
'''
print('color=%s' % combined['color'])
print('user=%s' % combined['user'])
</code></pre>
<p>没有任何参数时，打印出默认参数：</p>
<pre><code class="language-shell">$ Python3 use_chainmap.py 
color=red
user=guest
</code></pre>
<p>当传入命令行参数时，优先使用命令行参数：</p>
<pre><code class="language-shell">$ Python3 use_chainmap.py -u bob
color=red
user=bob
</code></pre>
<p>同时传入命令行参数和环境变量，命令行参数的优先级较高：</p>
<pre><code class="language-shell">$ user=admin color=green Python3 use_chainmap.py -u bob
color=green
user=bob
</code></pre>
<pre><code class="language-Python">from collections import ChainMap
m1 = {'Type': 'admin', 'codeID': '00001'}
m2 = {'name': 'woodname','codeID': '00002'}
m = ChainMap(m1, m2)
print(m)
'''
输出：
ChainMap({'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
'''
print(m.maps)
'''
输出：[{'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'}]
'''
for i in m.items():
    print(i)
'''
输出：
('name', 'woodname')
('codeID', '00001')
('Type', 'admin')
'''
print(m['name']) # 读取元素的值
print(m['codeID']) # 注意，当key重复时以最前一个为准
print(m.get('Type'))
'''
输出：
woodname
00001
admin
新增map
'''
m3 = {'data': '888'}
m=m.new_child(m3) # 将 m3 加入m
print(m)
'''
输出：
ChainMap({'data': '888'}, {'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
'''
print(m.parents) # m 的父亲
'''
输出：ChainMap({'Type': 'admin', 'codeID': '00001'}, {'name': 'woodname', 'codeID': '00002'})
'''
print(m.parents.parents)
'''
输出 ： ChainMap({'name': 'woodname', 'codeID': '00002'})
'''
</code></pre>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('c = {}'.format(m['c']))
c = C
</code></pre>
<p>可以通过 <code>maps</code> 属性将结果以列表形式返回。由于列表是可变的，所以可以对这个列表重新排序，或者添加新的值。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print(m.maps)    # [{'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'}]
print('c = {}\n'.format(m['c']))    # c = C

m.maps = list(reversed(m.maps))# reverse the list
print(m.maps)    # [{'b': 'B', 'c': 'D'}, {'a': 'A', 'c': 'C'}]
print('c = {}'.format(m['c']))    # c = D
</code></pre>
<p><code>ChainMap</code> 不会给子映射创建一个单独的空间，所以对子映射修改时，结果也会反馈到 <code>ChainMap</code> 上。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('Before: {}'.format(m['c']))    # Before: C
a['c'] = 'E'
print('After : {}'.format(m['c']))    # After : E
</code></pre>
<p>也可以通过 <code>ChainMap</code> 直接设置值，实际上只修改了第一个字典中的值。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m = collections.ChainMap(a, b)
print('Before:', m)    # Before: ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
m['c'] = 'E'
print('After :', m)    # After : ChainMap({'a': 'A', 'c': 'E'}, {'b': 'B', 'c': 'D'})
print('a:', a)    # a: {'a': 'A', 'c': 'E'}
</code></pre>
<p><code>ChainMap</code>提供了一个简单的方法，用于在<code>maps</code>列表的前面创建一个新实例，这样做的好处是可以避免修改现有的底层数据结构。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
m1 = collections.ChainMap(a, b)
m2 = m1.new_child()
print(m1)    # ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
print(m2)    # ChainMap({}, {'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
m2['c'] = 'E'
print(m1)    # ChainMap({'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
print(m2)    # ChainMap({'c': 'E'}, {'a': 'A', 'c': 'C'}, {'b': 'B', 'c': 'D'})
</code></pre>
<p>这种堆叠行为使得将<code>ChainMap</code> 实例用作模板或应用程序上下文变得非常方便。具体来说，在一次迭代中很容易添加或更新值，然后丢弃下一次迭代的更改。<br>
对于新上下文已知或预先构建的情况，也可以将映射传递给<code>new_child()</code>。</p>
<pre><code class="language-Python">a = {'a': 'A', 'c': 'C'}
b = {'b': 'B', 'c': 'D'}
c = {'c': 'E'}
m1 = collections.ChainMap(a, b)
m2 = m1.new_child(c)
print('m1[&quot;c&quot;] = {}'.format(m1['c']))    # m1[&quot;c&quot;] = C
print('m2[&quot;c&quot;] = {}'.format(m2['c']))    # m2[&quot;c&quot;] = E
</code></pre>
<p>这相当于：</p>
<pre><code class="language-Python">m2 = collections.ChainMap(c, *m1.maps)
</code></pre>
<h4 id="counter"><code>Counter</code></h4>
<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>
<pre><code class="language-Python">from collections import Counter
c = Counter()
for ch in 'programming':
c[ch] = c[ch] + 1
c
Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})
c.update('hello') # 也可以一次性update
c
Counter({'r': 2, 'o': 2, 'g': 2, 'm': 2, 'l': 2, 'p': 1, 'a': 1, 'i': 1, 'n': 1, 'h': 1, 'e': 1})
</code></pre>
<p><code>Counter</code>实际上也是<code>dict</code>的一个子类，上面的结果可以看出每个字符出现的次数。</p>
<ul>
<li><code>elements()</code>:返回一个迭代器，其中每个元素将重复出现计数值所指定次。 元素会按首次出现的顺序返回。 如果一个元素的计数值小于<code>1</code>，<code>elements()</code> 将会忽略它。</li>
</ul>
<pre><code class="language-Python">c = Counter(a=4, b=2, c=0, d=-2)
sorted(c.elements())
['a', 'a', 'a', 'a', 'b', 'b']
</code></pre>
<ul>
<li><code>most_common([n])</code>:返回一个列表，其中包含<code>n</code> 个最常见的元素及出现次数，按常见程度由高到低排序。 如果 <code>n</code> 被省略或为 <code>None</code>，<code>most_common()</code> 将返回计数器中的 所有 元素。 计数值相等的元素按首次出现的顺序排序：</li>
</ul>
<pre><code class="language-Python">Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]
</code></pre>
<pre><code class="language-Python">c = Counter(a=3, b=1)
d = Counter(a=1, b=2)
c + d                       # add two counters together:  c[x] + d[x]
Counter({'a': 4, 'b': 3})
c - d                       # subtract (keeping only positive counts)
Counter({'a': 2})
c &amp; d                       # intersection:  min(c[x], d[x]) 
Counter({'a': 1, 'b': 1})
c | d                       # union:  max(c[x], d[x])
Counter({'a': 3, 'b': 2})
</code></pre>
<p><code>Counter</code> 支持三种初始化形式：</p>
<pre><code class="language-Python">print(collections.Counter(['a', 'b', 'c', 'a', 'b', 'b']))
print(collections.Counter({'a': 2, 'b': 3, 'c': 1}))
print(collections.Counter(a=2, b=3, c=1))
'''
output
Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'b': 3, 'a': 2, 'c': 1})
'''
</code></pre>
<p><code>Counter</code> 初始化时也可以不传参数，然后通过<code>update()</code>方法更新。</p>
<pre><code class="language-Python">c = collections.Counter()
print('Initial :', c)    # Initial : Counter()
c.update('abcdaab')
print('Sequence:', c)    # Sequence: Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})
c.update({'a': 1, 'd': 5})
print('Dict    :', c)    # Dict    : Counter({'d': 6, 'a': 4, 'b': 2, 'c': 1})
</code></pre>
<p>计数值基于新数据而不是替换而增加。在上例中，计数<code>a</code>从3到4。<br>
<code>Counter</code> 中的值，可以使用字典 <code>API</code> 获取它的值。</p>
<pre><code class="language-Python">c = collections.Counter('abcdaab')
for letter in 'abcde':
    print('{} : {}'.format(letter, c[letter]))
    '''
output
a : 3
b : 2
c : 1
d : 1
e : 0
'''
</code></pre>
<p>对于 <code>Counter</code> 中没有的键，不会报 <code>KeyError</code>。如本例中的 <code>e</code>，将其计数为0。<br>
<code>elements()</code>方法返回一个迭代器，遍历它可以获得 <code>Counter</code> 中的值。</p>
<pre><code class="language-Python">c = collections.Counter('extremely')
c['z'] = 0
print(c)    # Counter({'e': 3, 'x': 1, 't': 1, 'r': 1, 'm': 1, 'l': 1, 'y': 1, 'z': 0})
print(list(c.elements()))    # ['e', 'e', 'e', 'x', 't', 'r', 'm', 'l', 'y']
</code></pre>
<p>不保证元素的顺序，并且不包括计数小于或等于零的值。<br>
使用<code>most_common()</code>产生序列最常遇到的输入值和它们各自的计数。</p>
<pre><code class="language-Python">c = collections.Counter()
with open('/usr/share/dict/words', 'rt') as f:
    for line in f:
        c.update(line.rstrip().lower())
print('Most common:')
for letter, count in c.most_common(3):
    print('{}: {:&gt;7}'.format(letter, count))
'''
output
Most common:
e:  235331
i:  201032
a:  199554
'''
</code></pre>
<p>此示例计算在系统字典所有单词中的字母生成频率分布，然后打印三个最常见的字母。如果没有参数的话，会按频率顺序生成所有项目的列表。<br>
<code>Counter</code>实例支持算术和聚合结果。这个例子显示了标准的操作符计算新的<code>Counter</code>实例，就地操作符 <code>+=</code>，<code>-=</code>，<code>&amp;=</code>，和<code>|=</code>也支持。</p>
<pre><code class="language-Python">c1 = collections.Counter(['a', 'b', 'c', 'a', 'b', 'b'])
c2 = collections.Counter('alphabet')

print('C1:', c1)
print('C2:', c2)

print('\nCombined counts:')
print(c1 + c2)

print('\nSubtraction:')
print(c1 - c2)

print('\nIntersection (taking positive minimums):')
print(c1 &amp; c2)

print('\nUnion (taking maximums):')
print(c1 | c2)
'''
output
C1: Counter({'b': 3, 'a': 2, 'c': 1})
C2: Counter({'a': 2, 'l': 1, 'p': 1, 'h': 1, 'b': 1, 'e': 1, 't': 1})

Combined counts:
Counter({'a': 4, 'b': 4, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
 
Subtraction:
Counter({'b': 2, 'c': 1})

Intersection (taking positive minimums):
Counter({'a': 2, 'b': 1})
 
Union (taking maximums):
Counter({'b': 3, 'a': 2, 'c': 1, 'l': 1, 'p': 1, 'h': 1, 'e': 1, 't': 1})
'''
</code></pre>
<p>每次<code>Counter</code>通过操作产生新的时，任何具有零或负计数的项目都将被丢弃。计数<code>a</code>在<code>c1</code>和<code>c2</code>中是相同的，因此相减之后变为零。<br>
计数器可以统计一个可迭代对象中每个元素出现的次数。</p>
<pre><code class="language-python">import collections
'''
创建
'''
collections.Counter(iterable)
'''
频次
'''
collections.Counter[key]                 # key出现频次
''' 
返回n个出现频次最高的元素和其对应出现频次，如果n为None，返回所有元素
'''
collections.Counter.most_common(n=None)
'''
插入/更新
'''
collections.Counter.update(iterable)
counter1 + counter2; counter1 - counter2  # counter加减
'''
检查两个字符串的组成元素是否相同
'''
collections.Counter(list1) == collections.Counter(list2)
</code></pre>
<h3 id="heapq"><code>heapq</code></h3>
<p>这个模块提供了堆队列算法的实现，也称为优先队列算法。<br>
堆是一个二叉树，它的每个父节点的值都只会小于或大于所有孩子节点（的值）。它使用了数组来实现：从零开始计数，对于所有的 <code>k</code> ，都有 <code>heap[k]</code> &lt;= <code>heap[2*k+1]</code> 和 <code>heap[k] &lt;= heap[2*k+2]</code>。 为了便于比较，不存在的元素被认为是无限大。 堆最有趣的特性在于最小的元素总是在根结点：<code>heap[0]</code>。<br>
这个<code>API</code>与教材的堆算法实现有所不同，具体区别有两方面：</p>
<ol>
<li>我们使用了从零开始的索引。这使得节点和其孩子节点索引之间的关系不太直观但更加适合，因为 <code>Python</code> 使用从零开始的索引。</li>
<li>我们的 <code>pop</code> 方法返回最小的项而不是最大的项（这在教材中称为“最小堆”；而“最大堆”在教材中更为常见，因为它更适用于原地排序）。但是可以通过取反来实现最大堆。<br>
要创建一个堆，可以使用<code>list</code>来初始化为 <code>[]</code> ，或者你可以通过一个函数 <code>heapify()</code> ，来把一个<code>list</code>转换成堆。</li>
</ol>
<ul>
<li><code>heapq.heappush(heap, item)</code>:将 <code>item</code> 的值加入 <code>heap</code> 中，保持堆的不变性。</li>
<li><code>heapq.heappop(heap)</code>:弹出并返回 <code>heap</code> 的最小的元素，保持堆的不变性。如果堆为空，抛出 <code>IndexError</code> 。使用 <code>heap[0]</code> ，可以只访问最小的元素而不弹出它。</li>
<li><code>heapq.heappushpop(heap, item)</code>:将 <code>item</code> 放入堆中，然后弹出并返回 <code>heap</code> 的最小元素。该组合操作比先调用  <code>heappush()</code> 再调用 <code>heappop()</code> 运行起来更有效率。</li>
<li><code>heapq.heapify(x)</code>:将<code>list x</code> 转换成堆，原地，线性时间内。</li>
<li><code>heapq.heapreplace(heap, item)</code>:弹出并返回 <code>heap</code> 中最小的一项，同时推入新的 <code>item</code>。 堆的大小不变。 如果堆为空则引发 <code>IndexError</code>。<br>
这个单步骤操作比 <code>heappop()</code> 加 <code>heappush()</code> 更高效，并且在使用固定大小的堆时更为适宜。 <code>pop/push</code> 组合总是会从堆中返回一个元素并将其替换为 <code>item</code>。<br>
返回的值可能会比添加的 <code>item</code> 更大。 如果不希望如此，可考虑改用 <code>heappushpop()</code>。 它的 <code>push/pop</code> 组合会返回两个值中较小的一个，将较大的值留在堆中。<br>
-<code>heapq.merge(*iterables, key=None, reverse=False)</code><br>
将多个已排序的输入合并为一个已排序的输出。返回已排序值的<code>iterator</code>。<br>
类似于 <code>sorted(itertools.chain(*iterables))</code> 但返回一个可迭代对象，不会一次性地将数据全部放入内存，并假定每个输入流都是已排序的（从小到大）。</li>
<li><code>heapq.nlargest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code>个最大元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key, reverse=True)[:n]</code>。</li>
<li><code>heapq.nsmallest(n, iterable, key=None)</code>:从 <code>iterable</code> 所定义的数据集中返回前 <code>n</code> 个最小元素组成的列表。 如果提供了 <code>key</code> 则其应指定一个单参数的函数，用于从 <code>iterable</code> 的每个元素中提取比较键 (例如 <code>key=str.lower</code>)。 等价于: <code>sorted(iterable, key=key)[:n]</code>。<br>
两个函数在 <code>n</code> 值较小时性能最好。 对于更大的值，使用 <code>sorted()</code> 函数会更有效率。 此外，当 <code>n==1</code> 时，使用内置的 <code>min()</code> 和 <code>max()</code> 函数会更有效率。 如果需要重复使用这些函数，请考虑将可迭代对象转为真正的堆。<br>
堆排序:<br>
堆排序 可以通过将所有值推入堆中然后每次弹出一个最小值项来实现。</li>
</ul>
<pre><code class="language-Python">def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]
heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>如果我们想要<code>heapq</code>排序的是一个对象。那么heapq并不知道应该依据对象当中的哪个参数来作为排序的衡量标准，所以这个时候，需要我们自己定义一个获取关键字的函数，传递给<code>heapq</code>，这样才可以完成排序。<br>
比如说，我们现在有一批电脑，我们希望<code>heapq</code>能够根据电脑的价格排序：</p>
<pre><code class="language-Python">laptops = [
    {'name': 'ThinkPad', 'amount': 100, 'price': 91.1},
    {'name': 'Mac', 'amount': 50, 'price': 543.22},
    {'name': 'Surface', 'amount': 200, 'price': 21.09},
    {'name': 'Alienware', 'amount': 35, 'price': 31.75},
    {'name': 'Lenovo', 'amount': 45, 'price': 16.35},
    {'name': 'Huawei', 'amount': 75, 'price': 115.65}
]
cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
</code></pre>
<p>在调用<code>nlargest</code>和<code>nsmallest</code>的时候，我们额外传递了一个参数<code>key</code>，我们传入的是一个匿名函数，它返回的结果是这个对象的<code>price</code>，也就是说我们希望<code>heapq</code>根据对象的<code>price</code>来进行排序。<br>
这类似于 <code>sorted(iterable)</code>，但与 <code>sorted()</code> 不同的是这个实现是不稳定的。<br>
优先队列 是堆的常用场合，并且它的实现包含了多个挑战：</p>
<ol>
<li>排序稳定性：你该如何令相同优先级的两个任务按它们最初被加入时的顺序返回？</li>
<li>如果优先级相同且任务没有默认比较顺序，则 <code>(priority, task)</code> 对的元组比较将会中断。<br>
针对前两项挑战的一种解决方案是将条目保存为包含优先级、条目计数和任务对象 3 个元素的列表。 条目计数可用来打破平局，这样具有相同优先级的任务将按它们的添加顺序返回。 并且由于没有哪两个条目计数是相同的，元组比较将永远不会直接比较两个任务。<br>
下面的类利用 <code>heapq</code> 模块实现了一个简单的优先级队列：</li>
</ol>
<pre><code class="language-python">import heapq
class PriorityQueue:
    def __init__(self):
        self._queue = []
        self._index = 0

    def push(self, item, priority):
        heapq.heappush(self._queue, (-priority, self._index, item))
        self._index += 1

    def pop(self):
        return heapq.heappop(self._queue)[-1]
</code></pre>
<p>下面是它的使用方式：</p>
<pre><code class="language-python">class Item:
    def __init__(self, name):
        self.name = name
    def __repr__(self):
        return 'Item({!r})'.format(self.name)
q = PriorityQueue()
q.push(Item('foo'), 1)
q.push(Item('bar'), 5)
q.push(Item('spam'), 4)
q.push(Item('grok'), 1)
q.pop()
Item('bar')
q.pop()
('spam')
q.pop()
Item('foo')
q.pop()
Item('grok')
</code></pre>
<h3 id="bisect"><code>bisect</code></h3>
<ul>
<li><code>bisect.bisect_left(a, x, lo=0, hi=len(a))</code><br>
在 <code>a</code> 中找到 <code>x</code> 合适的插入点以维持有序。参数 <code>lo</code> 和 <code>hi</code> 可以被用于确定需要考虑的子集；默认情况下整个列表都会被使用。如果 <code>x</code> 已经在 <code>a</code> 里存在，那么插入点会在已存在元素之前（也就是左边）。如果 <code>a</code> 是列表（<code>list</code>）的话，返回值是可以被放在 <code>list.insert()</code> 的第一个参数的。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt; x for val in a[lo:i])</code>，右侧是 <code>all(val &gt;= x for val in a[i:hi])</code> 。</li>
<li><code>bisect.bisect_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.bisect(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>bisect_left()</code>，但是返回的插入点是 <code>a</code> 中已存在元素 <code>x</code> 的右侧。<br>
返回的插入点 <code>i</code> 可以将数组 <code>a</code> 分成两部分。左侧是 <code>all(val &lt;= x for val in a[lo:i])</code>，右侧是 <code>all(val &gt; x for val in a[i:hi]) for the right side</code>。</li>
<li><code>bisect.insort_left(a, x, lo=0, hi=len(a))</code><br>
将 <code>x</code> 插入到一个有序序列 <code>a</code> 里，并维持其有序。如果 <code>a</code> 有序的话，这相当于 <code>a.insert(bisect.bisect_left(a, x, lo, hi), x)</code>。要注意搜索是 <code>O(log n)</code> 的，插入却是 <code>O(n)</code> 的。</li>
<li><code>bisect.insort_right(a, x, lo=0, hi=len(a))</code><br>
<code>bisect.insort(a, x, lo=0, hi=len(a))</code><br>
类似于 <code>insort_left()</code>，但是把 <code>x</code> 插入到 <code>a</code> 中已存在元素 <code>x</code>的右侧。<br>
函数 <code>bisect()</code> 还可以用于数字表查询。这个例子是使用 <code>bisect()</code> 从一个给定的考试成绩集合里，通过一个有序数字表，查出其对应的字母等级：<code>90</code> 分及以上是 <code>'A'</code>，<code>80</code> 到 <code>89</code> 是 <code>'B'</code>，以此类推</li>
</ul>
<pre><code class="language-Python">def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
    i = bisect(breakpoints, score)
    return grades[i]
[grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
['F', 'A', 'C', 'C', 'B', 'A', 'A']
</code></pre>
<h3 id="itertools"><code>itertools</code></h3>
<ul>
<li><code>itertools.count(start=0,step=1)</code>:创建一个迭代器，生成从 <code>n</code> 开始的连续整数，如果忽略 <code>n</code>，则从 <code>0</code> 开始计算。</li>
</ul>
<pre><code class="language-Python">for n in itertools.count():
    if 100000 &lt; n &lt; 100010:
        print n
    if n &gt; 1000000:
        break
100001
100002
100003
100004
100005
100006
100007
100008
100009
</code></pre>
<ul>
<li><code>itertools.cycle(iterable)</code>:把传入的一个序列无限重复下去。</li>
</ul>
<pre><code class="language-Python">for c in itertools.cycle(&quot;AB&quot;):
    if count &gt; 4:
        break
    print c
   count += 1     
A
B
A
B
A
</code></pre>
<ul>
<li><code>itertools.repeat(object [,times])</code>:创建一个迭代器，重复生成 <code>object</code>，<code>times</code>（如果已提供）指定重复计数，如果未提供 <code>times</code>，将无止尽返回该对象。</li>
</ul>
<pre><code class="language-Python">for x in itertools.repeat(&quot;hello world&quot;, 5):
    print x    
hello world
hello world
hello world
hello world
hello world
</code></pre>
<ul>
<li><code>itertools.chain(*iterables)</code>:把一组迭代对象串联起来，形成一个更大的迭代器。</li>
</ul>
<pre><code class="language-Python">for c in itertools.chain('ABC', 'XYZ'):
    print c    
A
B
C
X
Y
Z
</code></pre>
<ul>
<li><code>itertools.permutations(iterable[, r])：返回</code>iterable<code>中任意取</code>r<code>个元素做排列的元组的迭代器，如果不指定</code>r<code>，那么序列的长度与</code>iterable` 中的项目数量相同。</li>
</ul>
<pre><code class="language-Python">for elem in itertools.permutations('abc', 2):
    print elem
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
for elem in itertools.permutations('abc'):
    print elem
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
</code></pre>
<ul>
<li><code>itertools.combinations(iterable, r)</code>:组合，如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，<code>ab</code> 和 <code>ba</code> 则视为重复，此时只放回 <code>ab</code>. 示例：</li>
</ul>
<pre><code class="language-Python">for elem in itertools.combinations('abc', 2):
    print elem   
('a', 'b')
('a', 'c')
('b', 'c')
</code></pre>
<ul>
<li><code>itertools.combinations_with_replacement(iterable, r)</code>:与 <code>combinations</code> 类似，但允许重复值，即如果 <code>iterable</code> 为 <code>&quot;abc&quot;</code>，<code>r</code> 为 2 时，会多出 <code>aa</code>, <code>bb</code>, <code>cc</code>。</li>
<li><code>itertools.compress(data, selectors)</code>:<br>
相当于 <code>bool</code> 选取，只有当 <code>selectors</code> 对应位置的元素为 <code>true</code> 时，才保留 <code>data</code> 中相应位置的元素，否则去除。</li>
</ul>
<pre><code class="language-Python">list(itertools.compress('abcdef', [1, 1, 0, 1, 0, 1]))
['a', 'b', 'd', 'f']
list(itertools.compress('abcdef', [True, False, True]))
['a', 'c']
</code></pre>
<ul>
<li><code>itertools.groupby(iterable[, keyfunc])</code>:对<code>iterable</code>中的元素进行分组。<code>keyfunc</code> 是分组函数，用于对 <code>iterable</code> 的连续项进行分组，如果不指定，则默认对 <code>iterable</code> 中的连续相同项进行分组，返回一个 <code>(key, sub-iterator)</code> 的迭代器。</li>
</ul>
<pre><code class="language-Python">for key, value_iter in itertools.groupby('aaabbbaaccd'):
    print key, list(value_iter)  
a ['a', 'a', 'a']
b ['b', 'b', 'b']
a ['a', 'a']
c ['c', 'c']
d ['d']
data = ['a', 'bb', 'cc', 'ddd', 'eee', 'f']
for key, value_iter in itertools.groupby(data, len):
    print key, list(value_iter)   
1 ['a']
2 ['bb', 'cc']
3 ['ddd', 'eee']
1 ['f']
</code></pre>
<p>注意，注意，注意：必须先排序后才能分组，因为<code>groupby</code>是通过比较相邻元素来分组的。可以看第二个例子，因为 <code>a</code> 和<code>f</code> 没有排在一起，所以最后没有分组到同一个列表中。</p>
<ul>
<li><code>itertools.islice(iterable, [start,] stop [, step])</code>:切片选择，<code>start</code> 是开始索引，<code>stop</code> 是结束索引，<code>step</code> 是步长，<code>start</code>和 <code>step</code> 可选。</li>
</ul>
<pre><code class="language-Python">list(itertools.islice([10, 6, 2, 8, 1, 3, 9], 5))
[10, 6, 2, 8, 1]
list(itertools.islice(itertools.count(), 6))
[0, 1, 2, 3, 4, 5]
list(itertools.islice(itertools.count(), 3, 10))
[3, 4, 5, 6, 7, 8, 9]
list(itertools.islice(itertools.count(), 3, 10, 2))
[3, 5, 7, 9]
</code></pre>
<ul>
<li><code>itertools.tee(iterable, n=2)</code>:从 <code>iterable</code> 创建 <code>n</code> 个独立的迭代器，以元组的形式返回。</li>
</ul>
<pre><code class="language-Python">itertools.tee(&quot;abcedf&quot;)
(&lt;itertools.tee at 0x7fed7b8f59e0&gt;, &lt;itertools.tee at 0x7fed7b8f56c8&gt;)
iter1, iter2 = itertools.tee(&quot;abcedf&quot;)
list(iter1)
['a', 'b', 'c', 'e', 'd', 'f']
list(iter2)
['a', 'b', 'c', 'e', 'd', 'f']
</code></pre>
<ul>
<li><code>itertools.product(*iterables, repeat=1)</code>:<br>
大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。<br>
嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。<br>
要计算可迭代对象自身的笛卡尔积，将可选参数 <code>repeat</code> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</li>
<li><code>itertools.dropwhile</code></li>
</ul>
<pre><code class="language-Python"> x = itertools.dropwhile(lambda e: e &lt; 5, range(10))
print(list(x))
[5, 6, 7, 8, 9]
</code></pre>
<ul>
<li><code>itertools.filterfalse</code>:<br>
保留对应真值为<code>False</code>的元素</li>
</ul>
<pre><code class="language-Python">x = itertools.filterfalse(lambda e: e &lt; 5, (1, 5, 3, 6, 9, 4))
print(list(x))
[5, 6, 9]
</code></pre>
<h3 id="functools"><code>functools</code></h3>
<ul>
<li>缓存机制加速递归函数<br>
<code>@functools.lru_cache(maxsize=128, typed=False)</code>:这个装饰器实现了备忘的功能，是一项优化技术，把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。<code>lru</code> 是（<code>least recently used</code>）的缩写，即最近最少使用原则。表明缓存不会无限制增长，一段时间不用的缓存条目会被扔掉。<br>
这个装饰器支持传入参数，还能有这种操作的？<code>maxsize</code> 是保存最近多少个调用的结果，最好设置为 <code>2</code> 的倍数，默认为 <code>128</code>。如果设置为 <code>None</code> 的话就相当于是 <code>maxsize</code> 为正无穷了。还有一个参数是 <code>type</code>，如果 <code>type</code> 设置为 <code>true</code>，即把不同参数类型得到的结果分开保存，如 <code>f(3)</code> 和 <code>f(3.0)</code> 会被区分开。</li>
</ul>
<pre><code class="language-python">from functools import lru_cache
@lru_cache(100)
def fib(n)
    return (1 if n in (1,2) else fib(n-1)+fib(n-2))
</code></pre>
<h3 id="math"><code>math</code></h3>
<ul>
<li><code>math.ceil(x)</code>:返回 <code>x</code> 的上限，即大于或者等于 <code>x</code> 的最小整数。</li>
<li><code>math.comb(n, k)</code>:返回不重复且无顺序地从 <code>n</code> 项中选择 <code>k</code> 项的方式总数。</li>
<li><code>math.fabs(x)</code>:返回 <code>x</code> 的绝对值。</li>
<li><code>math.floor(x)</code>:返回 <code>x</code> 的向下取整，小于或等于 <code>x</code> 的最大整数。</li>
<li><code>math.gcd(a, b)</code>:最大公约数</li>
<li><code>math.exp(x)</code>:返回 <code>e</code> 次 <code>x</code> 幂</li>
<li><code>math.pow(x, y)</code>:将返回 <code>x</code> 的 <code>y</code> 次幂。</li>
<li><code>math.sqrt(x)</code>:返回 <code>x</code> 的平方根。</li>
<li><code>math.pi</code>:数学常数 π = 3.141592...，精确到可用精度。</li>
<li><code>math.e</code>:数学常数 e = 2.718281...，精确到可用精度。</li>
<li><code>math.inf</code>:浮点正无穷大。</li>
</ul>
<h3 id="time"><code>time</code></h3>
<p>在 <code>Python</code> 中，用三种方式来表示时间，分别是时间戳、格式化时间字符串和结构化时间</p>
<ul>
<li>时间戳（<code>timestamp</code>）：也就是 1970 年 1 月 1 日之后的秒，例如 1506388236.216345，可以通过<code>time.time()</code>获得。时间戳是一个浮点数，可以进行加减运算，但请注意不要让结果超出取值范围。</li>
<li>格式化的时间字符串（<code>string_time</code>）：也就是年月日时分秒这样的我们常见的时间字符串，例如2017-09-26 09:12:48，可以通过<code>time.strftime('%Y-%m-%d')</code>获得;<br>
结构化时间（<code>struct_time</code>）：一个包含了年月日时分秒的多元元组，例如<code>time.struct_time(tm_year=2017, tm_mon=9, tm_mday=26, tm_hour=9, tm_min=14, tm_sec=50, tm_wday=1, tm_yday=269, tm_isdst=0)</code>，可以通过<code>time.localtime()</code>获得。</li>
<li>利用<code>time.strftime('%Y-%m-%d %H:%M:%S')</code>等方法可以获得一个格式化时间字符串。</li>
</ul>
<pre><code class="language-Python">time.strftime('%Y-%m-%d %H:%M:%S')
'2017-09-26 10:04:28'
</code></pre>
<p><code>time.strptime(string[,format])</code><br>
将格式化时间字符串转化成结构化时间。该方法是<code>time.strftime()</code>方法的逆操作。<code>time.strptime()</code>方法根据指定的格式把一个时间字符串解析为时间元组。要注意的是，你提供的字符串要和 <code>format</code> 参数的格式一一对应，如果 <code>string</code> 中日期间使用<code>“-”</code>分隔，<code>format</code> 中也必须使用<code>“-”</code>分隔，时间中使用冒号<code>“:”</code>分隔，后面也必须使用冒号分隔，否则会报格式不匹配的错误。并且值也要在合法的区间范围内。</p>
<pre><code class="language-Python">stime = &quot;2017-09-26 12:11:30&quot;
st = time.strptime(stime,&quot;%Y-%m-%d %H:%M:%S&quot;)
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321211914.png" alt="" loading="lazy"></figure>
<ul>
<li><code>time.time()</code>:返回当前系统时间戳。时间戳可以做算术运算。</li>
</ul>
<pre><code class="language-Python">time.time()
1506391907.020303
该方法经常用于计算程序运行时间：
```Python
import time
def func():
    time.sleep(1.14)
    pass

t1 = time.time()
func()
t2 = time.time()
print(t2 - t1)
</code></pre>
<h3 id="datetime"><code>datetime</code></h3>
<pre><code class="language-Python">from datetime import datetime, date, time
dt = datetime(2011, 10, 29, 20, 30, 21)
dt.day
29
dt.minute
30
</code></pre>
<ul>
<li>根据<code>datetime</code>实例，你可以用<code>date</code>和<code>time</code>提取出各自的对象：</li>
</ul>
<pre><code class="language-Python">dt.date()
datetime.date(2011, 10, 29)
dt.time()
datetime.time(20, 30, 21)
</code></pre>
<ul>
<li><code>strftime</code>方法可以将<code>datetime</code>格式化为字符串：</li>
</ul>
<pre><code class="language-Python">dt.strftime('%m/%d/%Y %H:%M')
'10/29/2011 20:30'
</code></pre>
<ul>
<li><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</li>
</ul>
<pre><code class="language-Python">datetime.strptime('20091031', '%Y%m%d')
datetime.datetime(2009, 10, 31, 0, 0)
</code></pre>
<ul>
<li>计算差值</li>
</ul>
<pre><code class="language-Python">now = date.today()
birthday = date(1964, 7, 31)
age = now - birthday
age.days
14368
</code></pre>
<ul>
<li>格式化命令</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200317190745.png" alt="" loading="lazy"></figure>
<h2 id="os"><code>os</code></h2>
<ul>
<li><code>os.path.exists(path)</code>:路径存在则返回<code>True</code>,路径损坏返回<code>False</code></li>
<li><code>os.path.join(path1[, path2[, ...]])</code>:把目录和文件名合成一个路径</li>
<li><code>os.system('mkdir today')</code>:命令行命令</li>
<li><code>os.environ</code>:<code>os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;7&quot;</code></li>
</ul>
<h2 id="path"><code>Path</code></h2>
<p>在过去，文件的路径是纯字符串，现在它会是一个<code>pathlib.Path</code>对象:</p>
<pre><code class="language-Python">from pathlib import Path
p = Path('/home/ubuntu')
PosixPath('/home/ubuntu')
str(p)
'/home/ubuntu'
</code></pre>
<p>过去路径拼接最正确的方法是用<code>os.path.join</code>:</p>
<pre><code class="language-Python">os.path.join('/', 'home', 'dongwm/code')
'/home/dongwm/code'
os.path.join('/home', 'dongwm/code')
'/home/dongwm/code'
现在可以用`pathlib.Path`提供的`joinpath`来拼接:
```Python
Path('/').joinpath('home', 'dongwm/code')
PosixPath('/home/dongwm/code')
但是更简单和方便的方法是用`/`运算符:
```Python
Path('/') / 'home' / 'dongwm/code'
PosixPath('/home/dongwm/code')
Path('/') / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
'/' / Path('home') / 'dongwm/code'
PosixPath('/home/dongwm/code')
</code></pre>
<p>使用<code>Path</code>对象的<code>parents</code>属性可以拿到各级目录列表(索引值越大越接近<code>root</code>)，而<code>parent</code>就表示父级目录:</p>
<pre><code class="language-Python">p = Path('/Users/dongweiming/test')
p.parents[0]
PosixPath('/Users/dongweiming')
p.parents[1]
PosixPath('/Users')
p.parents[2]
PosixPath('/')
p.parent
PosixPath('/Users/dongweiming')
p.parent.parent
PosixPath('/Users')
</code></pre>
<p>获得文件后缀名:</p>
<pre><code class="language-Python">p = Path('/usr/local/etc/my.cnf')
p.suffix, p.stem
('.cnf', 'my')
</code></pre>
<p>当文件有多个后缀，可以用<code>suffixes</code>返回文件所有后缀列表:</p>
<pre><code class="language-Python">Path('my.tar.bz2').suffixes
['.tar', '.bz2']
Path('my.tar').suffixes
['.tar']
Path('my').suffixes
[]
</code></pre>
<p>Python语言没有内置创建文件的方法(<code>linux</code>下的<code>touch</code>命令)，过去这么做:</p>
<pre><code class="language-Python">with open('new.txt', 'a') as f:
</code></pre>
<p>现在可以直接用<code>Path</code>的<code>touch</code>方法:</p>
<pre><code class="language-Python">Path('new.txt').touch()
</code></pre>
<p><code>touch</code>接受<code>mode</code>参数，能够在创建时确认文件权限，还能通过<code>exist_ok</code>参数方式确认是否可以重复<code>touch</code>(默认可以重复创建，会更新文件的<code>mtime</code>)</p>
<ul>
<li><code>filename.exists()</code>；路径是否存在</li>
<li>打开文件：</li>
</ul>
<pre><code class="language-Python">data_folder = Path(&quot;source_data/text_files/&quot;)
file_to_open = data_folder / &quot;raw_data.txt&quot;
print(file_to_open.read_text())
</code></pre>
<ul>
<li>与<code>os</code>模块对比<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200321202526.png" alt="" loading="lazy"></li>
</ul>
<h2 id="第三方库">第三方库</h2>
<h3 id="h5py"><code>h5py</code></h3>
<p>h5py文件是存放两类对象的容器，数据集(<code>dataset</code>)和组(<code>group</code>)，<code>dataset</code>类似数组类的数据集合，和<code>numpy</code>的数组差不多。<code>group</code>是像文件夹一样的容器，它好比<code>Python</code>中的字典，有键(<code>key</code>)和值(<code>value</code>)。<code>group</code>中可以存放<code>dataset</code>或者其他的<code>group</code>。”键”就是组成员的名称，”值”就是组成员对象本身(组或者数据集)</p>
<pre><code class="language-Python">import h5py
</code></pre>
<h4 id="创建">创建</h4>
<pre><code class="language-Python">with h5py.File('test.h5','w') as f:
</code></pre>
<h4 id="读取">读取</h4>
<pre><code class="language-Python">with h5py.File('test.h5','r') as f:
</code></pre>
<p><code>h5py</code>文件就像一个 <code>Python</code> 字典，因此我们可以检查<code>key</code>,</p>
<pre><code class="language-Python">list(f.keys())
['mydataset']
</code></pre>
<p>文件中有一个数据集，即<code>mydataset</code>:</p>
<pre><code class="language-Python">dset = f['mydataset']
dset.shape
(100,)
dset.dtype
dtype('int32')
dset[...] = np.arange(100)
dset[0]
0
dset[10]
10
dset[0:100:10]
array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
data = f['mydataset'][:]
</code></pre>
<h4 id="创建数据集">创建数据集：</h4>
<pre><code class="language-Python">d1=f.create_dataset(&quot;dset1&quot;, (20,), 'i')
for key in f.keys():
    print(key)
    print(f[key].name)
    print(f[key].shape)
    print(f[key].value)
dset1
/dset1
(20,)
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
</code></pre>
<pre><code class="language-Python">dset3 = f.create_dataset('subgroup2/dataset_three', (10,), dtype='i')
</code></pre>
<h4 id="赋值">赋值</h4>
<pre><code class="language-Python">d1=f.create_dataset(&quot;dset1&quot;,(20,),'i')
d1[...]=np.arange(20)
'''
或者我们可以直接按照下面的方式创建数据集并赋值
'''
f[&quot;dset2&quot;]=np.arange(15)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<p>如果我们有现成的<code>numpy</code>数组，那么可以在创建数据集的时候就赋值，这个时候就不必指定数据的类型和形状了，只需要把数组名传给参数<code>data</code>。</p>
<pre><code class="language-Python">a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)
for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
</code></pre>
<h4 id="综合示例1">综合示例1</h4>
<pre><code class="language-Python">'''
分别创建dset1,dset2,dset3这三个数据集
'''
a=np.arange(20)
d1=f.create_dataset(&quot;dset1&quot;,data=a)

d2=f.create_dataset(&quot;dset2&quot;,(3,4),'i')
d2[...]=np.arange(12).reshape((3,4))

f[&quot;dset3&quot;]=np.arange(15)

for key in f.keys():
    print(f[key].name)
    print(f[key].value)
/dset1
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19]
/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
/dset3
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
</code></pre>
<h4 id="创建group">创建<code>group</code></h4>
<p>需要首先以<code>append</code>模式打开文件</p>
<pre><code class="language-Python">f = h5py.File('mydataset.hdf5', 'a')
grp = f.create_group(&quot;subgroup&quot;)
</code></pre>
<pre><code class="language-Python">g1=f.create_group(&quot;bar&quot;)
'''
在bar这个组里面分别创建name为dset1,dset2的数据集并赋值。
'''
g1[&quot;dset1&quot;]=np.arange(10)
g1[&quot;dset2&quot;]=np.arange(12).reshape((3,4))

for key in g1.keys():
    print(g1[key].name)
    print(g1[key].value)
/bar/dset1
[0 1 2 3 4 5 6 7 8 9]
/bar/dset2
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre>
<p>注意观察数据集<code>dset1</code>和<code>dset2</code>的名字是不是有点和前面的不一样，如果是直接创建的数据集，不在任何组里面，那么它的名字就是<code>/+名字</code>，现在这两个数据集都在<code>bar</code>这个<code>group</code>(组)里面，名字就变成了<code>/bar+/</code>名字，是不是有点文件夹的感觉！继续看下面的代码，你会对<code>group</code>和<code>dataset</code>的关系进一步了解。</p>
<pre><code class="language-Python">'''
创建组bar1,组bar2，数据集dset
'''
g1=f.create_group(&quot;bar1&quot;)
g2=f.create_group(&quot;bar2&quot;)
d=f.create_dataset(&quot;dset&quot;,data=np.arange(10))
'''
在bar1组里面创建一个组car1和一个数据集dset1。
'''
c1=g1.create_group(&quot;car1&quot;)
d1=g1.create_dataset(&quot;dset1&quot;,data=np.arange(10))
'''
在bar2组里面创建一个组car2和一个数据集dset2
'''
c2=g2.create_group(&quot;car2&quot;)
d2=g2.create_dataset(&quot;dset2&quot;,data=np.arange(10))
'''
根目录下的组和数据集
'''
for key in f.keys():
    print(f[key].name)
/bar1
/bar2
/dset
'''
bar1这个组下面的组和数据集
'''
for key in g1.keys():
    print(g1[key].name)
/bar1/car1
/bar1/dset1
'''
bar2这个组下面的组和数据集
'''
for key in g2.keys():
    print(g2[key].name)
/bar2/car2
/bar2/dset2
'''
顺便看下car1组和car2组下面都有什么，估计你都猜到了为空。
'''
print(c1.keys())
print(c2.keys())
[]
[]
</code></pre>
<ul>
<li>综合示例2</li>
</ul>
<pre><code class="language-Python">'''
遍历文件中的一级组
'''
for group in f.keys():
    print (group)
    '''
    根据一级组名获得其下面的组
    '''
    group_read = f[group]
    '''
    遍历该一级组下面的子组
    '''
    for subgroup in group_read.keys():
        print subgroup     
        '''
        根据一级组和二级组名获取其下面的dataset          
        '''
        dset_read = f[group+'/'+subgroup]
        '''                           
        遍历该子组下所有的dataset
        '''
        for dset in dset_read.keys():
        '''
            获取dataset数据
            '''
            dset1 = f[group+'/'+subgroup+'/'+dset]
            print dset1.name
            data = np.array(dset1)
            print data.shape
            x = data[...,0]
            y = data[...,1]        
</code></pre>
<h4 id="pandas对h5py的操作"><code>Pandas</code>对<code>h5py</code>的操作</h4>
<h5 id="写出">写出</h5>
<ul>
<li><code>path</code>：字符型输入，用于指定<code>h5</code>文件的名称（不在当前工作目录时需要带上完整路径信息）</li>
<li><code>mode</code>：用于指定<code>IO</code>操作的模式，与<code>Python</code>内建的<code>open()</code>中的参数一致，默认为<code>'a'</code>，即当指定文件已存在时不影响原有数据写入，指定文件不存在时则新建文件；<code>'r'</code>，只读模式；<code>'w'</code>，创建新文件（会覆盖同名旧文件）；<code>'r+'</code>，与<code>'a'</code>作用相似，但要求文件必须已经存在；</li>
<li><code>complevel</code>：<code>int</code>型，用于控制<code>h5</code>文件的压缩水平，取值范围在0-9之间，越大则文件的压缩程度越大，占用的空间越小，但相对应的在读取文件时需要付出更多解压缩的时间成本，默认为<code>0</code>，代表不压缩<br>
创建一个<code>HDF5 IO</code>对象<code>store</code>：</li>
</ul>
<pre><code class="language-Python">store = pd.HDFStore('demo.h5')
s = pd.Series(np.random.randn(5), index=['a', 'b', 'c', 'd', 'e'])
df = pd.DataFrame(np.random.randn(8, 3),
                 columns=['A', 'B', 'C'])
store['s'],store['df'] = s,df
</code></pre>
<p>从<code>pandas</code>中的数据结构直接导出到本地<code>h5</code>文件中：</p>
<pre><code class="language-Python">'''
创建新的数据框
'''
df_ = pd.DataFrame(np.random.randn(5,5))
'''
导出到已存在的h5文件中，这里需要指定key
'''
df_.to_hdf(path_or_buf='demo.h5',key='df_')
'''
创建于本地demo.h5进行IO连接的store对象
'''
store = pd.HDFStore('demo.h5')
'''
查看指定h5对象中的所有键
'''
print(store.keys())
</code></pre>
<p>利用store对象的<code>put()</code>方法，其主要参数如下：</p>
<ul>
<li><code>key</code>：指定<code>h5</code>文件中待写入数据的<code>key</code></li>
<li><code>value</code>：指定与<code>key</code>对应的待写入的数据</li>
<li><code>format</code>：字符型输入，用于指定写出的模式，<code>'fixed'</code>对应的模式速度快，但是不支持追加也不支持检索；<code>'table'</code>对应的模式以表格的模式写出，速度稍慢，但是支持直接通过<code>store</code>对象进行追加和表格查询操作<br>
使用<code>put()</code>方法将数据存入<code>store</code>对象中：</li>
</ul>
<pre><code class="language-Python">store.put(key='s',value=s);store.put(key='df',value=df)
</code></pre>
<p>既然是键值对的格式，那么可以查看<code>store</code>的<code>items</code>属性（注意这里<code>store</code>对象只有<code>items</code>和<code>keys</code>属性，没有<code>values</code>属性）：</p>
<pre><code class="language-Python">store.items
</code></pre>
<p>调用<code>store</code>对象中的数据直接用对应的键名来索引即可：</p>
<pre><code class="language-Python">store['df']
</code></pre>
<p>删除<code>store</code>对象中指定数据的方法有两种，一是使用<code>remove()</code>方法，传入要删除数据对应的键：</p>
<pre><code class="language-Python">store.remove('s')
print(store.keys())
</code></pre>
<p>二是使用<code>Python</code>中的关键词<code>del</code>来删除指定数据：</p>
<pre><code class="language-Python">del store['s']
</code></pre>
<h5 id="读取-2">读取</h5>
<pre><code class="language-Python">store = pd.HDFStore('demo.h5')
'''方式1'''
df1 = store['df']
'''方式2'''
df2 = store.get('df')
</code></pre>
<pre><code class="language-Python">df = pd.read_hdf('demo.h5',key='df')
</code></pre>
<ul>
<li>删除对象</li>
</ul>
<pre><code class="language-Python">del subgroup[&quot;MyDataset&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode26. 删除排序数组中的重复项]]></title>
        <id>https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</id>
        <link href="https://bailingnan.github.io/post/leetcode26-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/">
        </link>
        <updated>2020-02-22T08:23:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        cnt=len(set(nums))
        j=0
        for i in range(len(nums)):
            if i!=0:
                if(nums[i]==nums[i-1]):
                    continue
            nums[j]=nums[i]
            j+=1
        if(j&lt;len(nums)):
            del(nums[j:len(nums)])
        return j
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NumPy笔记]]></title>
        <id>https://bailingnan.github.io/post/numpy-bi-ji/</id>
        <link href="https://bailingnan.github.io/post/numpy-bi-ji/">
        </link>
        <updated>2020-02-15T14:58:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="numpy常用函数"><code>NumPy</code>常用函数</h1>
<pre><code class="language-python">import numpy as np
</code></pre>
<h2 id="numpy基础数据结构">Numpy基础数据结构</h2>
<h3 id="多维数组">多维数组</h3>
<pre><code class="language-python">ar = np.array([1,2,3,4,5,6,7])
print(ar.ndim)     # 输出数组维度的个数（轴数），或者说“秩”，维度的数量也称rank
print(ar.shape)    # 数组的维度，对于n行m列的数组，shape为（n，m）
print(ar.size)     # 数组的元素总数，对于n行m列的数组，元素总数为n*m
print(ar.dtype)    # 数组中元素的类型，类似type()（注意了，type()是函数，.dtype是方法）
print(ar.itemsize) # 数组中每个元素的字节大小，int32l类型字节为4，float64的字节为8
print(ar.data)     # 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。
</code></pre>
<p>数值型<code>dtype</code>的命名方式相同：一个类型名（如<code>float</code>或<code>int</code>），后面跟一个用于表示各元素位长的数字。标准的双精度浮点值（即<code>Python</code>中的<code>float</code>对象）需要占用<code>8</code>字节（即<code>64</code>位）。因此，该类型在<code>NumPy</code>中就记作<code>float64</code>。下表列出了<code>NumPy</code>所支持的全部数据类型。</p>
<h3 id="arange类似range在给定间隔内返回均匀间隔的值"><code>arange()</code>，类似<code>range()</code>，在给定间隔内返回均匀间隔的值。</h3>
<pre><code class="language-python">print(np.arange(10))    # 返回0-9，整型
print(np.arange(10.0))  # 返回0.0-9.0，浮点型
print(np.arange(5,12))  # 返回5-11
print(np.arange(5.0,12,2))  # 返回5.0-12.0，步长为2
</code></pre>
<h3 id="linspace返回在间隔开始停止上计算的num个均匀间隔的样本"><code>linspace()</code>:返回在间隔[开始，停止]上计算的<code>num</code>个均匀间隔的样本。</h3>
<pre><code class="language-python">np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)
</code></pre>
<ul>
<li><code>start</code>：起始值</li>
<li><code>stop</code>：结束值</li>
<li><code>num</code>：生成样本数，默认为<code>50</code></li>
<li><code>endpoint</code>：如果为真，则停止是最后一个样本。否则，不包括在内。默认值为<code>True</code>。</li>
<li><code>retstep</code>：如果为真，返回（样本，步长），其中步长是样本之间的间距 → 输出为一个包含2个元素的元组，第一个元素为<code>array</code>，第二个为步长实际值</li>
</ul>
<h3 id="zeros_likeones_like返回具有和给定数组相同形状和类型的零矩阵和全为1矩阵"><code>zeros_like()</code>/<code>ones_like()</code>，返回具有和给定数组相同形状和类型的零矩阵和全为1矩阵</h3>
<pre><code class="language-python">ar= np.array([list(range(5)),list(range(5,10))])
ar1 = np.zeros_like(ar)
ar2=np.ones_like(ar)
</code></pre>
<h3 id="eye单位矩阵"><code>eye()</code>,单位矩阵</h3>
<pre><code class="language-python">np.eye(5)
</code></pre>
<h3 id="empty"><code>empty()</code></h3>
<p><code>empty</code>可以创建一个没有任何具体值的数组。要用这些方法创建多维数组，只需传入一个表示形状的元组即可</p>
<pre><code class="language-python">np.empty((2, 3, 2))
array([[[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]],
       [[ 0.,  0.],
        [ 0.,  0.],
        [ 0.,  0.]]])
</code></pre>
<blockquote>
<p>注意：认为np.empty会返回全0数组的想法是不安全的。很多情况下（如前所示），它返回的都是一些未初始化的垃圾值。</p>
</blockquote>
<h3 id="数组创建函数">数组创建函数</h3>
<p>列出了一些数组创建函数。由于<code>NumPy</code>关注的是数值计算，因此，如果没有特别指定，数据类型基本都是<code>float64</code>（浮点数）:<br>
<img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200327170700.png" alt="" loading="lazy"></p>
<h2 id="numpy通用函数">Numpy通用函数</h2>
<h3 id="数组形状">数组形状</h3>
<ul>
<li><code>.T</code>/<code>.reshape()</code>/<code>.resize()</code>,都是生成新的数组</li>
</ul>
<h4 id="改变形状">改变形状</h4>
<ul>
<li><code>numpy.reshape(a, newshape, order='C')</code>：为数组提供新形状，而不更改其数据，所以元素数量需要一致</li>
</ul>
<pre><code class="language-python">ar3 = ar1.reshape(2,5)     # 用法1：直接将已有数组改变形状             
ar4 = np.zeros((4,6)).reshape(3,8)   # 用法2：生成数组后直接改变形状
ar5 = np.reshape(np.arange(12),(3,4))   # 用法3：参数内添加数组，目标形状
</code></pre>
<ul>
<li><code>numpy.resize(a, new_shape)</code>：返回具有指定形状的新数组，如有必要可重复填充所需数量的元素,<code>resize</code> 方法将直接修改原数组本身的维度。</li>
</ul>
<h4 id="数组摊平">数组摊平</h4>
<ul>
<li><code>a.ravel()</code> :返回的是 <code>view</code>，会影响原始矩阵。</li>
<li><code>a.flatten()</code>: 都是将多维数组降为一维，<code>flatten()</code> 返回一份新的数组，且对它所做的修改不会影响原始数组。</li>
</ul>
<h3 id="数组的复制">数组的复制</h3>
<pre><code class="language-python">ar1 = np.arange(10)
ar2 = ar1
</code></pre>
<p>python的赋值逻辑：指向内存中生成的一个值 → 这里<code>ar1</code>和<code>ar2</code>指向同一个值，所以<code>ar1</code>改变，<code>ar2</code><strong>一起改变</strong></p>
<pre><code class="language-python">ar3 = ar1.copy()
</code></pre>
<ul>
<li><code>copy()</code>:生成数组及其数据的完整拷贝,<code>ar3</code>改变<code>ar1</code><strong>不随之改变</strong></li>
<li><code>view()</code>:创建一个新数组对象来查看相同数据。改变其中一个变量的 <code>shape</code> 并不会对应改变另一个。但这两个数组是共享所有元素的，所以改变一个数组的某个元素同样会改变另一个数组的对应元素。</li>
</ul>
<h3 id="数组类型转换">数组类型转换：</h3>
<ul>
<li><code>ar.astype()</code>:类型转换</li>
</ul>
<pre><code class="language-python">ar1 = np.arange(10,dtype=float)# 可以在参数位置设置数组类型
ar2 = ar1.astype(np.int32)# a.astype()：转换数组类型,数组类型用np.int32，而不是直接int32
</code></pre>
<h3 id="数组堆叠">数组堆叠:</h3>
<ul>
<li><code>np.stack((a,b),axis)</code>:形状必须相同</li>
<li><code>np.hstack((a,b))</code>:注意:((a,b))，这里形状必须一样,水平（按列顺序）堆叠数组</li>
<li><code>np.vstack((a,b))</code>:这里形状可以不一样,垂直（按行顺序）堆叠数组</li>
</ul>
<pre><code class="language-python">a = np.array([[1],[2],[3]]) 
b = np.array([['a'],['b'],['c']])  
ar2 = np.hstack((a,b))  
</code></pre>
<pre><code class="language-python">a = np.array([[1],[2],[3]])   
b = np.array([['a'],['b'],['c'],['d']])   
ar2 = np.vstack((a,b)) 
</code></pre>
<ul>
<li><code>np.column_stack(a,b,c)</code>:可以将每个元素作为一列，例如 <code>np.column_stack((a,b,c))</code> 就将向量 <code>a</code> 作为第一列、<code>b</code> 作为第二列、<code>c</code> 作为第三列</li>
</ul>
<h3 id="数组拆分">数组拆分</h3>
<ul>
<li><code>numpy.hsplit(ary, indices_or_sections)</code>：将数组水平（逐列）拆分为多个子数组 → 按列拆分,输出结果为列表，列表中元素为数组</li>
</ul>
<pre><code class="language-python">ar = np.arange(16).reshape(4,4)
ar1 = np.hsplit(ar,2)
</code></pre>
<ul>
<li><code>numpy.vsplit(ary, indices_or_sections)</code>：:将数组垂直（行方向）拆分为多个子数组 → 按行拆</li>
</ul>
<pre><code class="language-python">ar2 = np.vsplit(ar,4)
</code></pre>
<h3 id="数组运算">数组运算</h3>
<h4 id="基本运算">基本运算</h4>
<ul>
<li><code>a.T</code>/<code>a.transpose()</code>：转置</li>
<li><code>a*b</code>:点乘</li>
<li><code>np.dot(a,b)/a.dot(b)</code>:叉乘</li>
</ul>
<h4 id="统计量">统计量</h4>
<pre><code class="language-python">print(ar.mean())  # 求平均值
print(ar.max())  # 求最大值
print(ar.min())  # 求最小值
print(ar.std())  # 求标准差
print(ar.var())  # 求方差
print(ar.sum(), np.sum(ar,axis = 0))  # 求和，np.sum() → axis为0，按列求和；axis为1，按行求和
print(np.sort(np.array([1,4,3,2,5,6])))  # 排序
</code></pre>
<h4 id="其他">其他</h4>
<ul>
<li><code>np.clip(array,min,max))</code>:限制数组中最小值为<code>min</code>,最大值为<code>max</code></li>
<li><code>np.append(array,element/array)</code>:将元素或者新数组的每一个元素添加至新数组</li>
<li><code>np.diff(array,n=num)</code>:求取该数组两个元素之间的差，可用于计算相对误差，差分数组比原来少n个元素</li>
</ul>
<h3 id="基本索引及切片">基本索引及切片</h3>
<p>当有些维度没有指定索引时，空缺的维度被默认为取所有元素。<br>
<code>NumPy</code>还允许使用 <code>dots (...)</code> 表示足够多的冒号来构建完整的索引元组。<br>
比如，如果 <code>x</code> 是 5 维数组：</p>
<ul>
<li><code>x[1,2,...]</code> 等于 <code>x[1,2,:,:,:]</code></li>
<li><code>x[...,3]</code> 等于 <code>x[:,:,:,:,3]</code></li>
<li><code>x[4,...,5,:]</code> 等于 <code>x[4,:,:,5,:]</code><br>
<code>flat</code> 是一个在数组所有元素中运算的迭代器，如下将逐元素地对数组进行操作。</li>
</ul>
<pre><code class="language-python">for element in b.flat:
    print(element)
</code></pre>
<pre><code class="language-python">ar = np.arange(16).reshape(4,4)
print(ar, '数组轴数为%i' %ar.ndim)   # 4*4的数组
print(ar[2],  '数组轴数为%i' %ar[2].ndim)  # 切片为下一维度的一个元素，所以是一维数组
print(ar[2][1]) # 二次索引，得到一维数组中的一个值
print(ar[1:3],  '数组轴数为%i' %ar[1:3].ndim)  # 切片为两个一维数组组成的二维数组
print(ar[2,2])  # 切片数组中的第三行第三列 → 10
print(ar[:2,1:])  # 切片数组中的1,2行、2,3,4列 → 二维数组
</code></pre>
<h4 id="布尔型索引">布尔型索引</h4>
<pre><code class="language-python">m = ar &gt; 5
print(m)  # 这里m是一个判断矩阵
print(ar[m])  # 用m判断矩阵去筛选ar数组中&gt;5的元素 → 重点！后面的pandas判断方式原理就来自此处
</code></pre>
<h4 id="数组索引及切片的值更改-复制">数组索引及切片的值更改、复制</h4>
<pre><code class="language-python">ar = np.arange(10)
print(ar)
ar[5] = 100
ar[7:9] = 200# 一个标量赋值给一个索引/切片时，会自动改变/传播原始数组
</code></pre>
<h2 id="numpy随机数">Numpy随机数</h2>
<h3 id="随机数生成">随机数生成</h3>
<ul>
<li><code>np.random.normal(size=(4,4))</code>:#生成一个标准正态分布的4*4样本值</li>
<li><code>np.random.rand(d0, d1, ..., dn)</code>：生成一个<code>[0,1)</code>之间的随机浮点数或N维浮点数组 —— 均匀分布</li>
<li><code>np.random.randn(d0, d1, ..., dn)</code>：生成一个浮点数或N维浮点数组 —— 正态分布</li>
<li><code>np.random.randint(low, high=None, size=None, dtype='l')</code>：生成一个整数或N维整数数组,若<code>high</code>不为<code>None</code>时，取<code>[low,high)</code>之间随机整数，否则取值<code>[0,low)</code>之间随机整数，且<code>high</code>必须大于<code>low</code>,<code>dtype</code>参数：只能是<code>int</code>类型</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[待安装包]]></title>
        <id>https://bailingnan.github.io/post/dai-an-zhuang-bao/</id>
        <link href="https://bailingnan.github.io/post/dai-an-zhuang-bao/">
        </link>
        <updated>2020-02-07T02:42:25.000Z</updated>
        <content type="html"><![CDATA[<p>flake8<br>
SpeedTorch<br>
<strong>ohmyzsh</strong><br>
pypy<br>
skorch<br>
<strong>numexpr</strong><br>
<strong>bottleneck</strong><br>
<strong>tpot</strong><br>
<strong>wandb</strong><br>
<strong>FBLearner Flow</strong><br>
<strong>mlflow</strong><br>
<strong>Neptune.ai</strong><br>
<strong>nyaggle</strong><br>
<strong>fastai</strong>有协同过滤<br>
<strong>torch-optimizer</strong> 拓展pytorch优化器<br>
<strong>test tube</strong><br>
<strong>neptune-notebooks</strong><br>
<strong>comet_ml</strong><br>
<strong>tensorwatch</strong>notebook里可运行<br>
<strong>swifter</strong>加速pandas<br>
<strong>modin(加载数据和查询数据更快，统计方法pandas更快)</strong><br>
<strong>numba</strong><br>
<strong>cupy(1000万以上数据才更快)</strong><br>
Cython<br>
hyperparameter_hunter</p>
<p>DeepSpeed 微软分布式训练工具<br>
dvc<br>
<strong>hiddenlayer</strong><br>
syncthing<br>
ignite<br>
pytorch-lightning<br>
fastai<br>
prefetch_generator<br>
torchsummary<br>
apex<br>
dali<br>
optuna<br>
pip-review<br>
autogluon<br>
arthas<br>
greys-anatomy<br>
implicit<br>
eli5<br>
icecream<br>
stackprinter<br>
dlrm<br>
buffalo<br>
cupy<br>
acptum<br>
featuretools<br>
boruta_py<br>
Categorical-encoding<br>
Tsfresh<br>
Scikit-Optimize<br>
Hyperopt<br>
ray<br>
ENAS-pytorch<br>
MLBox<br>
h2o<br>
AutoKeras<br>
TPOT<br>
Auto-Sklearn</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Matplotlib笔记]]></title>
        <id>https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi-di-09-zhang-hui-tu-he-ke-shi-hua/</id>
        <link href="https://bailingnan.github.io/post/li-yong-python-jin-xing-shu-ju-fen-xi-di-09-zhang-hui-tu-he-ke-shi-hua/">
        </link>
        <updated>2020-02-04T09:09:53.000Z</updated>
        <content type="html"><![CDATA[<!-- TOC -->
<ul>
<li><a href="#matplotlib-api%E5%85%A5%E9%97%A8"><code>matplotlib</code> <code>API</code>入门</a>
<ul>
<li><a href="#figure%E5%92%8Csubplot"><code>Figure</code>和<code>Subplot</code></a></li>
<li><a href="#%E8%B0%83%E6%95%B4subplot%E5%91%A8%E5%9B%B4%E7%9A%84%E9%97%B4%E8%B7%9D">调整<code>subplot</code>周围的间距</a></li>
<li><a href="#%E9%A2%9C%E8%89%B2%E6%A0%87%E8%AE%B0%E5%92%8C%E7%BA%BF%E5%9E%8B">颜色、标记和线型</a></li>
<li><a href="#%E5%88%BB%E5%BA%A6%E6%A0%87%E7%AD%BE%E5%92%8C%E5%9B%BE%E4%BE%8B">刻度、标签和图例</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%A0%87%E9%A2%98%E8%BD%B4%E6%A0%87%E7%AD%BE%E5%88%BB%E5%BA%A6%E4%BB%A5%E5%8F%8A%E5%88%BB%E5%BA%A6%E6%A0%87%E7%AD%BE">设置标题、轴标签、刻度以及刻度标签</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E5%9B%BE%E4%BE%8B">添加图例</a></li>
<li><a href="#%E6%B3%A8%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%9C%A8subplot%E4%B8%8A%E7%BB%98%E5%9B%BE">注解以及在<code>Subplot</code>上绘图</a></li>
<li><a href="#%E5%B0%86%E5%9B%BE%E8%A1%A8%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6">将图表保存到文件</a></li>
<li><a href="#matplotlib%E9%85%8D%E7%BD%AE"><code>matplotlib</code>配置</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8pandas%E5%92%8Cseaborn%E7%BB%98%E5%9B%BE">使用<code>pandas</code>和<code>seaborn</code>绘图</a>
<ul>
<li><a href="#%E7%BA%BF%E5%9E%8B%E5%9B%BE">线型图</a></li>
<li><a href="#%E6%9F%B1%E7%8A%B6%E5%9B%BE">柱状图</a></li>
<li><a href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%92%8C%E5%AF%86%E5%BA%A6%E5%9B%BE">直方图和密度图</a></li>
<li><a href="#%E6%95%A3%E5%B8%83%E5%9B%BE%E6%88%96%E7%82%B9%E5%9B%BE">散布图或点图</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83%E7%9A%84python%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7">其它的<code>Python</code>可视化工具</a></li>
</ul>
<!-- /TOC -->
<h1 id="matplotlib-api入门"><code>matplotlib</code> <code>API</code>入门</h1>
<p><code>matplotlib</code>的通常引入约定是：</p>
<pre><code class="language-python">import matplotlib.pyplot as plt
</code></pre>
<pre><code class="language-python">import numpy as np
data = np.arange(10)
data
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
plt.plot(data)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200402235737.png" alt="" loading="lazy"></figure>
<h2 id="figure和subplot"><code>Figure</code>和<code>Subplot</code></h2>
<p><code>matplotlib</code>的图像都位于<code>Figure</code>对象中。用<code>plt.figure</code>创建一个新的<code>Figure</code>：</p>
<pre><code class="language-python">fig = plt.figure()
</code></pre>
<p><code>plt.figure</code>有一些选项，特别是<code>figsize</code>，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。</p>
<p>不能通过空<code>Figure</code>绘图。必须用<code>add_subplot</code>创建一个或多个<code>subplot</code>：</p>
<pre><code class="language-python">ax1 = fig.add_subplot(2, 2, 1)
</code></pre>
<p>这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个<code>subplot</code>中的第一个（编号从1开始）。如果再把后面两个<code>subplot</code>也创建出来，最终得到的图像如下图所示：</p>
<pre><code class="language-python">ax2 = fig.add_subplot(2, 2, 2)

ax3 = fig.add_subplot(2, 2, 3)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200402235957.png" alt="" loading="lazy"></figure>
<pre><code class="language-python">fig = plt.figure()
ax1 = fig.add_subplot(2, 2, 1)
ax2 = fig.add_subplot(2, 2, 2)
ax3 = fig.add_subplot(2, 2, 3)
</code></pre>
<p>如果这时执行一条绘图命令（如<code>plt.plot([1.5, 3.5, -2, 1.6])</code>），<code>matplotlib</code>就会在最后一个用过的<code>subplot</code>（如果没有则创建一个）上进行绘制，隐藏创建<code>figure</code>和<code>subplot</code>的过程。因此，如果我们执行下列命令，你就会得到如图所示的结果：</p>
<pre><code class="language-python">plt.plot(np.random.randn(50).cumsum(), 'k--')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403000704.png" alt="" loading="lazy"><br>
<code>k--</code>是一个线型选项，用于告诉<code>matplotlib</code>绘制黑色虚线图。上面那些由<code>fig.add_subplot</code>所返回的对象是<code>AxesSubplot</code>对象，直接调用它们的实例方法就可以在其它空着的格子里面画图了，如图所示：</p>
<pre><code class="language-python">ax1.hist(np.random.randn(100), bins=20, color='k', alpha=0.3)

ax2.scatter(np.arange(30), np.arange(30) + 3 * np.random.randn(30))
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403000752.png" alt="" loading="lazy"></figure>
<p>创建包含<code>subplot</code>网格的<code>figure</code>是一个非常常见的任务，<code>matplotlib</code>有一个更为方便的方法<code>plt.subplots</code>，它可以创建一个新的<code>Figure</code>，并返回一个含有已创建的<code>subplot</code>对象的<code>NumPy</code>数组：</p>
<pre><code class="language-python">fig, axes = plt.subplots(2, 3)
axes
array([[&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb626374048&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb62625db00&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6262f6c88&gt;],
       [&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6261a36a0&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb626181860&gt;,
        &lt;matplotlib.axes._subplots.AxesSubplot object at 0x7fb6260fd4e0&gt;]], dtype
=object)
</code></pre>
<p>这是非常实用的，因为可以轻松地对<code>axes</code>数组进行索引，就好像是一个二维数组一样，例如<code>axes[0,1]</code>。你还可以通过<code>sharex</code>和<code>sharey</code>指定<code>subplot</code>应该具有相同的<code>X</code>轴或<code>Y</code>轴。在比较相同范围的数据时，这也是非常实用的，否则，<code>matplotlib</code>会自动缩放各图表的界限。有关该方法的更多信息，请参见表。</p>
<pre><code class="language-python">matplotlib.pyplot.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)[source]
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403001023.png" alt="" loading="lazy"></figure>
<h2 id="调整subplot周围的间距">调整<code>subplot</code>周围的间距</h2>
<p>默认情况下，<code>matplotlib</code>会在<code>subplot</code>外围留下一定的边距，并在<code>subplot</code>之间留下一定的间距。间距跟图像的高度和宽度有关，因此，如果你调整了图像大小（不管是编程还是手工），间距也会自动调整。利用<code>Figure</code>的<code>subplots_adjust</code>方法可以轻而易举地修改间距，此外，它也是个顶级函数：</p>
<pre><code class="language-python">subplots_adjust(left=None, bottom=None, right=None, top=None,
                wspace=None, hspace=None)
</code></pre>
<p><code>wspace</code>和<code>hspace</code>用于控制宽度和高度的百分比，可以用作<code>subplot</code>之间的间距。下面是一个简单的例子，将间距收缩到了<code>0</code>（如图所示）：</p>
<pre><code class="language-python">fig, axes = plt.subplots(2, 2, sharex=True, sharey=True)
for i in range(2):
    for j in range(2):
        axes[i, j].hist(np.random.randn(500), bins=50, color='k', alpha=0.5)
plt.subplots_adjust(wspace=0, hspace=0)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403001133.png" alt="" loading="lazy"><br>
不难看出，其中的轴标签重叠了。<code>matplotlib</code>不会检查标签是否重叠，所以对于这种情况，你只能自己设定刻度位置和刻度标签。后面几节将会详细介绍该内容。</p>
<h2 id="颜色-标记和线型">颜色、标记和线型</h2>
<p><code>matplotlib</code>的<code>plot</code>函数接受一组<code>X</code>和<code>Y</code>坐标，还可以接受一个表示颜色和线型的字符串缩写。例如，要根据<code>x</code>和<code>y</code>绘制绿色虚线，你可以执行如下代码：</p>
<pre><code class="language-python">ax.plot(x, y, 'g--')
</code></pre>
<p>这种在一个字符串中指定颜色和线型的方式非常方便。在实际中，如果你是用代码绘图，你可能不想通过处理字符串来获得想要的格式。通过下面这种更为明确的方式也能得到同样的效果：</p>
<pre><code class="language-python">ax.plot(x, y, linestyle='--', color='g')
</code></pre>
<p>常用的颜色可以使用颜色缩写，你也可以指定颜色码（例如，'#CECECE'）。你可以通过查看<code>plot</code>的文档字符串查看所有线型的合集。</p>
<p>可选参数<code>[fmt]</code> 是一个字符串来定义图的基本属性如：颜色（<code>color</code>），点型（<code>marker</code>），线型（<code>linestyle</code>）。<br>
具体形式  <code>fmt = '[color][marker][line]'</code></p>
<pre><code class="language-python">=============    ===============================
    character        color
    =============    ===============================
    ``'b'``          blue 蓝
    ``'g'``          green 绿
    ``'r'``          red 红
    ``'c'``          cyan 蓝绿
    ``'m'``          magenta 洋红
    ``'y'``          yellow 黄
    ``'k'``          black 黑
    ``'w'``          white 白
    =============    ===============================
=============    ===============================
    character        description
    =============    ===============================
    ``'.'``          point marker点标记
    ``','``          pixel marker像素标记（极小点）
    ``'o'``          circle marker实心圈标记
    ``'v'``          triangle_down marker倒三角标记
    ``'^'``          triangle_up marker上三角标记
    ``'&lt;'``          triangle_left marker
    ``'&gt;'``          triangle_right marker
    ``'1'``          tri_down marker
    ``'2'``          tri_up marker
    ``'3'``          tri_left marker
    ``'4'``          tri_right marker
    ``'s'``          square marker
    ``'p'``          pentagon marker
    ``'*'``          star marker
    ``'h'``          hexagon1 marker
    ``'H'``          hexagon2 marker
    ``'+'``          plus marker十字标记
    ``'x'``          x markerx标记
    ``'D'``          diamond marker
    ``'d'``          thin_diamond marker
    ``'|'``          vline marker
    ``'_'``          hline marker
    =============    ===============================
=============    ===============================
    character        description
    =============    ===============================
    ``'-'``          solid line style 实线
    ``'--'``         dashed line style 虚线
    ``'-.'``         dash-dot line style 点画线
    ``':'``          dotted line style 点线
    ``''``           无线条
    =============    ===============================
</code></pre>
<p>线图可以使用标记强调数据点。因为<code>matplotlib</code>可以创建连续线图，在点之间进行插值，因此有时可能不太容易看出真实数据点的位置。标记也可以放到格式字符串中，但标记类型和线型必须放在颜色后面（见图）：</p>
<pre><code class="language-python">from numpy.random import randn
 plt.plot(randn(30).cumsum(), 'ko--')
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403001847.png" alt="" loading="lazy"></figure>
<p>还可以将其写成更为明确的形式：</p>
<pre><code class="language-python">plot(randn(30).cumsum(), color='k', linestyle='dashed', marker='o')
</code></pre>
<p>在线型图中，非实际数据点默认是按线性方式插值的。可以通过<code>drawstyle</code>选项修改（见图）：</p>
<pre><code class="language-python">data = np.random.randn(30).cumsum()
plt.plot(data, 'k--', label='Default')
[&lt;matplotlib.lines.Line2D at 0x7fb624d86160&gt;]

plt.plot(data, 'k-', drawstyle='steps-post', label='steps-post')
[&lt;matplotlib.lines.Line2D at 0x7fb624d869e8&gt;]
plt.legend(loc='best')
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403001957.png" alt="" loading="lazy"></figure>
<p>你可能注意到运行上面代码时有输出<code>&lt;matplotlib.lines.Line2D at ...&gt;</code>。<code>matplotlib</code>会返回引用了新添加的子组件的对象。大多数时候，你可以放心地忽略这些输出。这里，因为我们传递了<code>label</code>参数到<code>plot</code>，我们可以创建一个<code>plot</code>图例，指明每条使用<code>plt.legend</code>的线。</p>
<blockquote>
<p>笔记：你必须调用<code>plt.legend</code>（或使用<code>ax.legend</code>，如果引用了轴的话）来创建图例，无论你绘图时是否传递<code>label</code>标签选项。</p>
</blockquote>
<h2 id="刻度-标签和图例">刻度、标签和图例</h2>
<p>对于大多数的图表装饰项，其主要实现方式有二：使用过程型的<code>pyplot</code>接口（例如，<code>matplotlib.pyplot</code>）以及更为面向对象的原生<code>matplotlib API</code>。</p>
<p><code>pyplot</code>接口的设计目的就是交互式使用，含有诸如<code>xlim</code>、<code>xticks</code>和<code>xticklabels</code>之类的方法。它们分别控制图表的范围、刻度位置、刻度标签等。其使用方式有以下两种：</p>
<ul>
<li>调用时不带参数，则返回当前的参数值（例如，<code>plt.xlim()</code>返回当前的<code>X</code>轴绘图范围）。</li>
<li>调用时带参数，则设置参数值（例如，<code>plt.xlim([0,10])</code>会将<code>X</code>轴的范围设置为<code>0</code>到<code>10</code>）。</li>
</ul>
<p>所有这些方法都是对当前或最近创建的<code>AxesSubplot</code>起作用的。它们各自对应<code>subplot</code>对象上的两个方法，以<code>xlim</code>为例，就是<code>ax.get_xlim</code>和<code>ax.set_xlim</code>。我更喜欢使用<code>subplot</code>的实例方法（因为我喜欢明确的事情，而且在处理多个<code>subplot</code>时这样也更清楚一些）。当然你完全可以选择自己觉得方便的那个。</p>
<h2 id="设置标题-轴标签-刻度以及刻度标签">设置标题、轴标签、刻度以及刻度标签</h2>
<p>为了说明自定义轴，我将创建一个简单的图像并绘制一段随机漫步（如图所示）：</p>
<pre><code class="language-python">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)
ax.plot(np.random.randn(1000).cumsum())
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403002212.png" alt="" loading="lazy"><br>
要改变<code>x</code>轴刻度，最简单的办法是使用<code>set_xticks</code>和<code>set_xticklabels</code>。前者告诉<code>matplotlib</code>要将刻度放在数据范围中的哪些位置，默认情况下，这些位置也就是刻度标签。但我们可以通过<code>set_xticklabels</code>将任何其他的值用作标签：</p>
<pre><code class="language-python">ticks = ax.set_xticks([0, 250, 500, 750, 1000])

labels = ax.set_xticklabels(['one', 'two', 'three', 'four', 'five'],
                             rotation=30, fontsize='small')
</code></pre>
<p><code>rotation</code>选项设定<code>x</code>刻度标签倾斜30度。最后，再用<code>set_xlabel</code>为<code>X</code>轴设置一个名称，并用<code>set_title</code>设置一个标题（见下图的结果）：</p>
<pre><code class="language-python">ax.set_title('My first matplotlib plot')
&lt;matplotlib.text.Text at 0x7fb624d055f8&gt;
ax.set_xlabel('Stages')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403002212.png" alt="" loading="lazy"><br>
<code>Y</code>轴的修改方式与此类似，只需将上述代码中的<code>x</code>替换为<code>y</code>即可。轴的类有集合方法，可以批量设定绘图选项。前面的例子，也可以写为：</p>
<pre><code class="language-python">props = {
    'title': 'My first matplotlib plot',
    'xlabel': 'Stages'
}
ax.set(**props)
</code></pre>
<h2 id="添加图例">添加图例</h2>
<p>图例（<code>legend</code>）是另一种用于标识图表元素的重要工具。添加图例的方式有多种。最简单的是在添加<code>subplot</code>的时候传入<code>label</code>参数：</p>
<pre><code class="language-python">from numpy.random import randn
fig = plt.figure(); ax = fig.add_subplot(1, 1, 1)
ax.plot(randn(1000).cumsum(), 'k', label='one')
[&lt;matplotlib.lines.Line2D at 0x7fb624bdf860&gt;]
ax.plot(randn(1000).cumsum(), 'k--', label='two')
[&lt;matplotlib.lines.Line2D at 0x7fb624be90f0&gt;]
ax.plot(randn(1000).cumsum(), 'k.', label='three')
[&lt;matplotlib.lines.Line2D at 0x7fb624be9160&gt;]
</code></pre>
<p>在此之后，你可以调用<code>ax.legend()</code>或<code>plt.legend()</code>来自动创建图例（结果见图）：</p>
<pre><code class="language-python">ax.legend(loc='best')
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403003429.png" alt="" loading="lazy"></figure>
<p><code>legend</code>方法有几个其它的<code>loc</code>位置参数选项。。</p>
<p><code>loc</code>告诉<code>matplotlib</code>要将图例放在哪。如果你不是吹毛求疵的话，<code>&quot;best&quot;</code>是不错的选择，因为它会选择最不碍事的位置。要从图例中去除一个或多个元素，不传入<code>label</code>或传入<code>label='_nolegend_'</code>即可。</p>
<h2 id="注解以及在subplot上绘图">注解以及在<code>Subplot</code>上绘图</h2>
<p>除标准的绘图类型，你可能还希望绘制一些子集的注解，可能是文本、箭头或其他图形等。注解和文字可以通过<code>text</code>、<code>arrow</code>和<code>annotate</code>函数进行添加。<code>text</code>可以将文本绘制在图表的指定坐标<code>(x,y)</code>，还可以加上一些自定义格式：</p>
<pre><code class="language-python">ax.text(x, y, 'Hello world!',
        family='monospace', fontsize=10)
</code></pre>
<p>注解中可以既含有文本也含有箭头。例如，我们根据最近的标准普尔500指数价格（来自Yahoo!Finance）绘制一张曲线图，并标出2008年到2009年金融危机期间的一些重要日期。（下图是结果）：</p>
<pre><code class="language-python">from datetime import datetime

fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)

data = pd.read_csv('examples/spx.csv', index_col=0, parse_dates=True)
spx = data['SPX']

spx.plot(ax=ax, style='k-')

crisis_data = [
    (datetime(2007, 10, 11), 'Peak of bull market'),
    (datetime(2008, 3, 12), 'Bear Stearns Fails'),
    (datetime(2008, 9, 15), 'Lehman Bankruptcy')
]

for date, label in crisis_data:
    ax.annotate(label, xy=(date, spx.asof(date) + 75),
                xytext=(date, spx.asof(date) + 225),
                arrowprops=dict(facecolor='black', headwidth=4, width=2,
                                headlength=4),
                horizontalalignment='left', verticalalignment='top')

# Zoom in on 2007-2010
ax.set_xlim(['1/1/2007', '1/1/2011'])
ax.set_ylim([600, 1800])

ax.set_title('Important dates in the 2008-2009 financial crisis')
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403003556.png" alt="" loading="lazy"><br>
这张图中有几个重要的点要强调：<code>ax.annotate</code>方法可以在指定的<code>x</code>和<code>y</code>坐标轴绘制标签。我们使用<code>set_xlim</code>和<code>set_ylim</code>人工设定起始和结束边界，而不使用<code>matplotlib</code>的默认方法。最后，用<code>ax.set_title</code>添加图标标题。</p>
<p>图形的绘制要麻烦一些。<code>matplotlib</code>有一些表示常见图形的对象。这些对象被称为块（<code>patch</code>）。其中有些（如<code>Rectangle</code>和<code>Circle</code>），可以在<code>matplotlib.pyplot</code>中找到，但完整集合位于<code>matplotlib.patches</code>。<br>
要在图表中添加一个图形，你需要创建一个块对象<code>shp</code>，然后通过<code>ax.add_patch(shp)</code>将其添加到<code>subplot</code>中（如图所示）：</p>
<pre><code class="language-python">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1)

rect = plt.Rectangle((0.2, 0.75), 0.4, 0.15, color='k', alpha=0.3)
circ = plt.Circle((0.7, 0.2), 0.15, color='b', alpha=0.3)
pgon = plt.Polygon([[0.15, 0.15], [0.35, 0.4], [0.2, 0.6]],
                   color='g', alpha=0.5)

ax.add_patch(rect)
ax.add_patch(circ)
ax.add_patch(pgon)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403011413.png" alt="" loading="lazy"><br>
如果查看许多常见图表对象的具体实现代码，你就会发现它们其实就是由块<code>patch</code>组装而成的。</p>
<h2 id="将图表保存到文件">将图表保存到文件</h2>
<p>利用<code>plt.savefig</code>可以将当前图表保存到文件。该方法相当于<code>Figure</code>对象的实例方法<code>savefig</code>。例如，要将图表保存为<code>SVG</code>文件，你只需输入：</p>
<pre><code class="language-python">plt.savefig('figpath.svg')
</code></pre>
<p>文件类型是通过文件扩展名推断出来的。因此，如果你使用的是<code>.pdf</code>，就会得到一个<code>PDF</code>文件。我在发布图片时最常用到两个重要的选项是<code>dpi</code>（控制“每英寸点数”分辨率）和<code>bbox_inches</code>（可以剪除当前图表周围的空白部分）。要得到一张带有最小白边且分辨率为<code>400DPI</code>的<code>PNG</code>图片，你可以：</p>
<pre><code class="language-python">plt.savefig('figpath.png', dpi=400, bbox_inches='tight')
</code></pre>
<p><code>savefig</code>并非一定要写入磁盘，也可以写入任何文件型的对象，比如<code>BytesIO</code>：</p>
<pre><code class="language-python">from io import BytesIO
buffer = BytesIO()
plt.savefig(buffer)
plot_data = buffer.getvalue()
</code></pre>
<p>下表列出了savefig的其它选项。</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403011536.png" alt="" loading="lazy"></figure>
<h2 id="matplotlib配置"><code>matplotlib</code>配置</h2>
<p><code>matplotlib</code>自带一些配色方案，以及为生成出版质量的图片而设定的默认配置信息。幸运的是，几乎所有默认行为都能通过一组全局参数进行自定义，它们可以管理图像大小、<code>subplot</code>边距、配色方案、字体大小、网格类型等。一种<code>Python</code>编程方式配置系统的方法是使用<code>rc</code>方法。例如，要将全局的图像默认大小设置为10×10，你可以执行：</p>
<pre><code class="language-python">plt.rc('figure', figsize=(10, 10))
</code></pre>
<p><code>rc</code>的第一个参数是希望自定义的对象，如<code>'figure'</code>、<code>'axes'</code>、<code>'xtick'</code>、<code>'ytick'</code>、<code>'grid'</code>、<code>'legend'</code>等。其后可以跟上一系列的关键字参数。一个简单的办法是将这些选项写成一个字典：</p>
<pre><code class="language-python">font_options = {'family' : 'monospace',
                'weight' : 'bold',
                'size'   : 'small'}
plt.rc('font', **font_options)
</code></pre>
<h1 id="使用pandas和seaborn绘图">使用<code>pandas</code>和<code>seaborn</code>绘图</h1>
<p><code>matplotlib</code>实际上是一种比较低级的工具。要绘制一张图表，你组装一些基本组件就行：数据展示（即图表类型：线型图、柱状图、盒形图、散布图、等值线图等）、图例、标题、刻度标签以及其他注解型信息。</p>
<p>在<code>pandas</code>中，我们有多列数据，还有行和列标签。<code>pandas</code>自身就有内置的方法，用于简化从<code>DataFrame</code>和<code>Series</code>绘制图形。另一个库<code>seaborn</code>，Seaborn简化了许多常见可视类型的创建。</p>
<blockquote>
<p>提示：引入<code>seaborn</code>会修改<code>matplotlib</code>默认的颜色方案和绘图类型，以提高可读性和美观度。即使你不使用<code>seaborn API</code>，你可能也会引入<code>seaborn</code>，作为提高美观度和绘制常见<code>matplotlib</code>图形的简化方法。</p>
</blockquote>
<h2 id="线型图">线型图</h2>
<p><code>Series</code>和<code>DataFrame</code>都有一个用于生成各类图表的<code>plot</code>方法。默认情况下，它们所生成的是线型图（如图所示）：</p>
<pre><code class="language-python">s = pd.Series(np.random.randn(10).cumsum(), index=np.arange(0, 100, 10))
s.plot()
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012011.png" alt="" loading="lazy"><br>
该<code>Series</code>对象的索引会被传给<code>matplotlib</code>，并用以绘制<code>X</code>轴。可以通过<code>use_index=False</code>禁用该功能。<code>X</code>轴的刻度和界限可以通过<code>xticks</code>和<code>xlim</code>选项进行调节，<code>Y</code>轴就用<code>yticks</code>和<code>ylim</code>。<code>plot</code>参数的完整列表请参见下表。</p>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012147.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012208.png" alt="" loading="lazy"></figure>
<p><code>pandas</code>的大部分绘图方法都有一个可选的<code>ax</code>参数，它可以是一个<code>matplotlib</code>的<code>subplot</code>对象。这使你能够在网格布局中更为灵活地处理<code>subplot</code>的位置。</p>
<p><code>DataFrame</code>的<code>plot</code>方法会在一个<code>subplot</code>中为各列绘制一条线，并自动创建图例（如图所示）：</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.randn(10, 4).cumsum(0),columns=['A', 'B', 'C', 'D'],index=np.arange(0, 100, 10))
df.plot()
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012308.png" alt="" loading="lazy"></figure>
<p><code>plot</code>属性包含一批不同绘图类型的方法。例如，<code>df.plot()</code>等价于<code>df.plot.line()</code>。</p>
<blockquote>
<p>笔记：<code>plot</code>的其他关键字参数会被传给相应的<code>matplotlib</code>绘图函数，所以要更深入地自定义图表，就必须学习更多有关<code>matplotlib API</code>的知识。</p>
</blockquote>
<p><code>DataFrame</code>还有一些用于对列进行灵活处理的选项，例如，是要将所有列都绘制到一个<code>subplot</code>中还是创建各自的<code>subplot</code>。详细信息请参见表9-4。</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012401.png" alt="" loading="lazy"></figure>
<h2 id="柱状图">柱状图</h2>
<p><code>plot.bar()</code>和<code>plot.barh()</code>分别绘制水平和垂直的柱状图。这时，<code>Series</code>和<code>DataFrame</code>的索引将会被用作<code>X</code>（<code>bar</code>）或<code>Y</code>（·barh·）刻度（如图所示）：</p>
<pre><code class="language-python">fig, axes = plt.subplots(2, 1)
data = pd.Series(np.random.rand(16), index=list('abcdefghijklmnop'))
data.plot.bar(ax=axes[0], color='k', alpha=0.7)
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb62493d470&gt;
data.plot.barh(ax=axes[1], color='k', alpha=0.7)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012516.png" alt="" loading="lazy"><br>
<code>color='k'</code>和<code>alpha=0.7</code>设定了图形的颜色为黑色，并使用部分的填充透明度。对于<code>DataFrame</code>，柱状图会将每一行的值分为一组，并排显示，如图所示：</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.rand(6, 4),index=['one', 'two', 'three', 'four', 'five', 'six'],columns=pd.Index(['A', 'B', 'C', 'D'], name='Genus'))
df
Genus         A         B         C         D
one    0.370670  0.602792  0.229159  0.486744
two    0.420082  0.571653  0.049024  0.880592
three  0.814568  0.277160  0.880316  0.431326
four   0.374020  0.899420  0.460304  0.100843
five   0.433270  0.125107  0.494675  0.961825
six    0.601648  0.478576  0.205690  0.560547
df.plot.bar()
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012607.png" alt="" loading="lazy"></figure>
<p>注意，<code>DataFrame</code>各列的名称<code>&quot;Genus&quot;</code>被用作了图例的标题。</p>
<p>设置<code>stacked=True</code>即可为<code>DataFrame</code>生成堆积柱状图，这样每行的值就会被堆积在一起（如图所示）：</p>
<pre><code class="language-python">df.plot.barh(stacked=True, alpha=0.5)
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012657.png" alt="" loading="lazy"></figure>
<blockquote>
<p>笔记：柱状图有一个非常不错的用法：利用<code>value_counts</code>图形化显示<code>Series</code>中各值的出现频率，比如<code>s.value_counts().plot.bar()</code>。</p>
</blockquote>
<p>再以本书前面用过的那个有关小费的数据集为例，假设我们想要做一张堆积柱状图以展示每天各种聚会规模的数据点的百分比。我用<code>read_csv</code>将数据加载进来，然后根据日期和聚会规模创建一张交叉表：</p>
<pre><code class="language-python">tips = pd.read_csv('examples/tips.csv')
party_counts = pd.crosstab(tips['day'], tips['size'])
party_counts# Not many 1- and 6-person parties
size  1   2   3   4  5  6
day                      
Fri   1  16   1   1  0  0
Sat   2  53  18  13  1  0
Sun   0  39  15  18  3  1
Thur  1  48   4   5  1  3
party_counts = party_counts.loc[:, 2:5]
</code></pre>
<p>然后进行规格化，使得各行的和为1，并生成图表（如图所示）：</p>
<pre><code class="language-python">'''
Normalize to sum to 1
'''
party_pcts = party_counts.div(party_counts.sum(1), axis=0)
party_pcts
size         2         3         4         5
day                                         
Fri   0.888889  0.055556  0.055556  0.000000
Sat   0.623529  0.211765  0.152941  0.011765
Sun   0.520000  0.200000  0.240000  0.040000
Thur  0.827586  0.068966  0.086207  0.017241
party_pcts.plot.bar()
</code></pre>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403012824.png" alt="" loading="lazy"></figure>
<p>于是，通过该数据集就可以看出，聚会规模在周末会变大。</p>
<p>对于在绘制一个图形之前，需要进行合计的数据，使用<code>seaborn</code>可以减少工作量。用<code>seaborn</code>来看每天的小费比例（下图是结果）：</p>
<pre><code class="language-python">import seaborn as sns
tips['tip_pct'] = tips['tip'] / (tips['total_bill'] - tips['tip'])
tips.head()
   total_bill   tip smoker  day    time  size   tip_pct
0       16.99  1.01     No  Sun  Dinner     2  0.063204
1       10.34  1.66     No  Sun  Dinner     3  0.191244
2       21.01  3.50     No  Sun  Dinner     3  0.199886
3       23.68  3.31     No  Sun  Dinner     2  0.162494
4       24.59  3.61     No  Sun  Dinner     4  0.172069
sns.barplot(x='tip_pct', y='day', data=tips, orient='h')
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403013759.png" alt="" loading="lazy"></figure>
<p><code>seaborn</code>的绘制函数使用<code>data</code>参数，它可能是<code>pandas</code>的<code>DataFrame</code>。其它的参数是关于列的名字。因为一天的每个值有多次观察，柱状图的值是<code>tip_pct</code>的平均值。绘制在柱状图上的黑线代表<code>95%</code>置信区间（可以通过可选参数配置）。</p>
<p><code>seaborn.barplot</code>有颜色选项，使我们能够通过一个额外的值设置（见图）：</p>
<pre><code class="language-python">sns.barplot(x='tip_pct', y='day', hue='time', data=tips, orient='h')
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403013854.png" alt="" loading="lazy"></figure>
<p>注意，<code>seaborn</code>已经自动修改了图形的美观度：默认调色板，图形背景和网格线的颜色。你可以用<code>seaborn.set</code>在不同的图形外观之间切换：</p>
<pre><code class="language-python">sns.set(style=&quot;whitegrid&quot;)
</code></pre>
<h2 id="直方图和密度图">直方图和密度图</h2>
<p>直方图（<code>histogram</code>）是一种可以对值频率进行离散化显示的柱状图。数据点被拆分到离散的、间隔均匀的面元中，绘制的是各面元中数据点的数量。再以前面那个小费数据为例，通过在<code>Series</code>使用<code>plot.hist</code>方法，我们可以生成一张“小费占消费总额百分比”的直方图（如图所示）：</p>
<pre><code class="language-python">tips['tip_pct'].plot.hist(bins=50)
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403014052.png" alt="" loading="lazy"><br>
与此相关的一种图表类型是密度图，它是通过计算“可能会产生观测数据的连续概率分布的估计”而产生的。一般的过程是将该分布近似为一组核（即诸如正态分布之类的较为简单的分布）。因此，密度图也被称作<code>KDE</code>（<code>Kernel Density Estimate</code>，核密度估计）图。使用<code>plot.kde</code>和标准混合正态分布估计即可生成一张密度图（见图）：</p>
<pre><code class="language-python">tips['tip_pct'].plot.density()
</code></pre>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403014125.png" alt="" loading="lazy"></figure>
<p><code>seaborn</code>的<code>distplot</code>方法绘制直方图和密度图更加简单，还可以同时画出直方图和连续密度估计图。作为例子，考虑一个双峰分布，由两个不同的标准正态分布组成（见图）：</p>
<pre><code class="language-python">comp1 = np.random.normal(0, 1, size=200)
comp2 = np.random.normal(10, 2, size=200)
values = pd.Series(np.concatenate([comp1, comp2]))
sns.distplot(values, bins=100, color='k')
</code></pre>
<figure data-type="image" tabindex="19"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403014812.png" alt="" loading="lazy"></figure>
<h2 id="散布图或点图">散布图或点图</h2>
<p>点图或散布图是观察两个一维数据序列之间的关系的有效手段。在下面这个例子中，我加载了来自<code>statsmodels</code>项目的<code>macrodata</code>数据集，选择了几个变量，然后计算对数差：</p>
<pre><code class="language-python">macro = pd.read_csv('examples/macrodata.csv')

data = macro[['cpi', 'm1', 'tbilrate', 'unemp']]

trans_data = np.log(data).diff().dropna()

trans_data[-5:]

          cpi        m1  tbilrate     unemp
198 -0.007904  0.045361 -0.396881  0.105361
199 -0.021979  0.066753 -2.277267  0.139762
200  0.002340  0.010286  0.606136  0.160343
201  0.008419  0.037461 -0.200671  0.127339
202  0.008894  0.012202 -0.405465  0.042560
</code></pre>
<p>然后可以使用<code>seaborn</code>的<code>regplot</code>方法，它可以做一个散布图，并加上一条线性回归的线（见图）：</p>
<pre><code class="language-python">sns.regplot('m1', 'unemp', data=trans_data)
&lt;matplotlib.axes._subplots.AxesSubplot at 0x7fb613720be0&gt;
plt.title('Changes in log %s versus log %s' % ('m1', 'unemp'))
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403014756.png" alt="" loading="lazy"></figure>
<p>在探索式数据分析工作中，同时观察一组变量的散布图是很有意义的，这也被称为散布图矩阵（<code>scatter plot matrix</code>）。纯手工创建这样的图表很费工夫，所以<code>seaborn</code>提供了一个便捷的<code>pairplot</code>函数，它支持在对角线上放置每个变量的直方图或密度估计（见图）：</p>
<pre><code class="language-python">sns.pairplot(trans_data, diag_kind='kde', plot_kws={'alpha': 0.2})
</code></pre>
<p><img src="https://raw.githubusercontent.com/bailingnan/PicGo/master/20200403014739.png" alt="" loading="lazy"><br>
你可能注意到了<code>plot_kws</code>参数。它可以让我们传递配置选项到非对角线元素上的图形使用。</p>
<h1 id="其它的python可视化工具">其它的<code>Python</code>可视化工具</h1>
<p>与其它开源库类似，<code>Python</code>创建图形的方式非常多（根本罗列不完）。自从2010年，许多开发工作都集中在创建交互式图形以便在Web上发布。利用工具如<code>Boken</code>和<code>Plotly</code>，现在可以创建动态交互图形，用于网页浏览器。</p>
<p>对于创建用于打印或网页的静态图形，我建议默认使用<code>matplotlib</code>和附加的库，比如<code>pandas</code>和<code>seaborn</code>。对于其它数据可视化要求，学习其它的可用工具可能是有用的。我鼓励你探索绘图的生态系统，因为它将持续发展。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Pycharm常用快捷键及技巧(macOS)]]></title>
        <id>https://bailingnan.github.io/post/pycharm-chang-yong-kuai-jie-jian-ji-ji-qiao-macos/</id>
        <link href="https://bailingnan.github.io/post/pycharm-chang-yong-kuai-jie-jian-ji-ji-qiao-macos/">
        </link>
        <updated>2020-01-31T16:42:34.000Z</updated>
        <content type="html"><![CDATA[<!-- TOC -->
<ul>
<li><a href="#mac%E9%94%AE%E7%9B%98%E7%AC%A6%E5%8F%B7%E5%92%8C%E4%BF%AE%E9%A5%B0%E9%94%AE%E8%AF%B4%E6%98%8E">Mac键盘符号和修饰键说明</a></li>
<li><a href="#editing%E7%BC%96%E8%BE%91">Editing（编辑）</a></li>
<li><a href="#searchreplace%E6%9F%A5%E8%AF%A2%E6%9B%BF%E6%8D%A2">Search/Replace（查询/替换）</a></li>
<li><a href="#compile-and-run%E7%BC%96%E8%AF%91%E5%92%8C%E8%BF%90%E8%A1%8C">Compile and Run（编译和运行）</a></li>
<li><a href="#navigation%E5%AF%BC%E8%88%AA">Navigation（导航）</a></li>
<li><a href="#%E8%B0%83%E8%AF%95">调试</a></li>
</ul>
<!-- /TOC -->
<h1 id="mac键盘符号和修饰键说明">Mac键盘符号和修饰键说明</h1>
<ul>
<li><code>⌘</code>:Command</li>
<li><code>⇧</code>:Shift</li>
<li><code>⌥</code>:Option</li>
<li><code>⌃</code>:Control</li>
<li><code>↩︎</code>:Return/Enter</li>
<li><code>⌫</code>:Delete</li>
<li><code>⌦</code>:向前删除键（Fn+Delete）</li>
<li><code>↑</code>:上箭头</li>
<li><code>↓</code>:下箭头</li>
<li><code>←</code>:左箭头</li>
<li><code>→</code>:右箭头</li>
<li><code>⇞</code>:Page Up（Fn+↑）</li>
<li><code>⇟</code>:Page Down（Fn+↓）</li>
<li><code>Home</code>:Fn + ←</li>
<li><code>End</code>:Fn + →</li>
<li><code>⇥</code>:右制表符（Tab键）</li>
<li><code>⇤</code>:左制表符（Shift+Tab）</li>
<li><code>⎋</code>:Escape (Esc)</li>
<li>一直按住<code>fn</code>可调出F1~F10</li>
</ul>
<h1 id="editing编辑">Editing（编辑）</h1>
<ul>
<li><code>⌘Z</code>:撤销操作</li>
<li><code>⌘Y</code>:删除整行</li>
<li><code>⇧F6</code>:重命名文件</li>
<li><code>⌘S</code>:保存所有</li>
<li><code>⌦</code>:删除文件（Fn+Delete）</li>
<li><code>⌘⌥L</code>:格式化代码</li>
<li><code>Home</code>:Fn + ←，跳转到行首</li>
<li><code>End</code>:Fn + →，跳转到行末</li>
<li><code>⇧↑/⇧↓</code>:向上/向下选中行</li>
<li><code>⌘D</code>: 复制当前行或选定的块</li>
<li><code>⌘/</code>:注释/取消注释与行注释</li>
<li><code>⌘⌥/</code>:注释/取消注释与块注释</li>
<li><code>⌘J</code>:插入自定义动态代码模板</li>
<li><code>⌃Space</code>:基本的代码补全（补全任何类、方法、变量）</li>
<li><code>⌃⇧Space</code>:智能代码补全（过滤器方法列表和变量的预期类型）</li>
<li><code>⇧↩</code>:开始新的一行</li>
<li><code>⌘⇧U</code>:大小写切换,光标在行内任意位置都能另起一行，且不破坏当行结构</li>
<li><code>⌘⇧↩</code>:自动结束代码，行末自动添加分号</li>
<li><code>⌘P</code>:显示方法的参数信息</li>
<li><code>⌃J</code>:快速查看文档</li>
<li><code>⇧F1</code>:查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li>
<li><code>⌘F1</code>:在错误或警告处显示具体描述信息</li>
<li><code>⌘N, ⌃↩, ⌃N</code>:生成代码（getter、setter、构造函数、hashCode/equals,toString）</li>
<li><code>⌥↑</code>:连续选中代码块</li>
<li><code>⌥↓</code>:减少当前选中的代码块</li>
<li><code>⌥↩</code>:显示意向动作和快速修复代码</li>
<li><code>⌘⇧] / ⌘⇧[</code>:选择直到代码块结束/开始</li>
<li><code>⌘+ / ⌘-</code>:展开 / 折叠代码块</li>
<li><code>⌘⇧+</code>:展开所有代码块</li>
<li><code>⌘⇧-</code>:折叠所有代码块</li>
</ul>
<h1 id="searchreplace查询替换">Search/Replace（查询/替换）</h1>
<ul>
<li><code>Double ⇧</code>:查询任何东西</li>
<li><code>⌘F</code>:文件内查找</li>
</ul>
<h1 id="compile-and-run编译和运行">Compile and Run（编译和运行）</h1>
<ul>
<li><code>⌃⇧F10</code>:Run</li>
<li><code>⌃⇧F9</code>:Debug</li>
</ul>
<h1 id="navigation导航">Navigation（导航）</h1>
<ul>
<li><code>⌘B</code>:进入光标所在的方法/变量的接口或是定义处</li>
<li><code>⌘⌥B</code>:跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li>
<li><code>⌥ Space, ⌘Y</code>:快速打开光标所在方法、类的定义</li>
<li><code>⌃⇧B</code>:跳转到类型声明处</li>
<li><code>⌘U</code>:前往当前光标所在方法的父类的方法 / 接口定义</li>
<li><code>⌃H</code>:显示当前类的层次结构</li>
<li><code>⌘⇧H</code>:显示方法层次结构</li>
<li><code>⌃⌥H</code>:显示调用层次结构</li>
</ul>
<h1 id="调试">调试</h1>
<ul>
<li><code>step over</code>:在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，<strong>程序代码越过子函数，但子函数会执行，且不进入</strong>。</li>
<li><code>step into</code>:在单步执行时，遇到子函数就进入并且继续单步执行，<strong>有的会跳到源代码里面去执行</strong>。</li>
<li><code>step into my code</code>:在单步执行时，遇到子函数就进入并且继续单步执行，<strong>不会进入到源码中</strong>。</li>
<li><code>step out</code>:假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</li>
<li><code>Resume program</code>:继续恢复程序，直接运行到下一断点处。跳过不想看的地方，直接设置下一个断点，然后<code>Resume program</code>。</li>
</ul>
]]></content>
    </entry>
</feed>